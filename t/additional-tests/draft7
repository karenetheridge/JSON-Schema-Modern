use strict;
use warnings;

# data format:
# {
#   $type => { $keyword => { schema => $schema_value, data => [ $failing, $passing ] } },
#   ...,
# }

my $data = {
  number => {
    multipleOf => { schema => 2, data => [ 1, 2 ] },
    maximum => { schema => 2, data => [ 3, 2 ] },
    exclusiveMaximum => { schema => 2, data => [ 2, 1 ] },
    minimum => { schema => 2, data => [ 1, 2 ] },
    exclusiveMinimum => { schema => 2, data => [ 2, 3 ] },
  },
  string => {
    maxLength => { schema => 2, data => [ 'hello', 'hi' ] },
    minLength => { schema => 2, data => [ 'x', 'hi' ] },
    pattern => { schema => 'hi', data => [ 'hello', 'hihi' ] },
  },
  array => {
    maxItems => { schema => 1, data => [ [1,2], [1] ] },
    minItems => { schema => 2, data => [ [1], [1,2] ] },
    uniqueItems => { schema => \1, data => [ [ 1, 1 ], [1] ] },
    items => { schema => \0, data => [ [1], [] ] },
    contains => { schema => \1, data => [ [], [1] ] },
  },
  object => {
    maxProperties => { schema => 1, data => [ {x=>1,y=>2}, { x=>1 } ] },
    minProperties => { schema => 1, data => [ {}, { x=>1 } ] },
    required => { schema => ['x'], data => [ {}, {x=>1} ] },
    dependencies => { schema => {x=>\0}, data => [ {x=>1}, {} ] },
    properties => { schema => {x=>\0}, data => [ {x=>1}, {} ] },
    patternProperties => { schema => {hi=>\0}, data => [ {hihi=>1}, {hello=>1} ] },
    additionalProperties => { schema => \0, data => [ {x=>1}, {} ] },
    propertyNames => { schema => \0, data => [ {x=>1}, {} ] },
  },
};

my @tests;

foreach my $type1 (sort keys %$data) {
  foreach my $type2 (sort keys %$data) {
    next if ($type1 cmp $type2) < 1;

    foreach my $keyword1 (sort keys %{$data->{$type1}}) {
      foreach my $keyword2 (sort keys %{$data->{$type2}}) {
        push @tests, {
          description => "$keyword1 + $keyword2",
          schema => {
            $keyword1 => $data->{$type1}{$keyword1}{schema},
            $keyword2 => $data->{$type2}{$keyword2}{schema},
          },
          tests => [
            map {
              my $keyword = $_;
              my $type = $keyword eq $keyword1 ? $type1 : $type2;
              map {
                my $valid = $_;
                +{
                  description => "$type, $keyword ".($valid?'':'in').'valid',
                  data => $data->{$type}{$keyword}{data}[$valid],
                  valid => $valid ? \1 : \0,
                }
              } 0, 1
            } $keyword1, $keyword2
          ],
        },
      }
    }
  }
}

use JSON::MaybeXS;
print JSON::MaybeXS->new(canonical => 1, pretty => 1, indent_length => 4)->encode(\@tests);
