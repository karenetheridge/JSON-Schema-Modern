#!/usr/bin/env perl
# vim: set ft=perl ts=8 sts=2 sw=2 tw=100 et :
use strict;
use warnings;

use 5.020;
no autovivification warn => qw(fetch store exists delete);
use if "$]" >= 5.022, experimental => 're_strict';
no if "$]" >= 5.031009, feature => 'indirect';
no if "$]" >= 5.033001, feature => 'multidimensional';
no if "$]" >= 5.033006, feature => 'bareword_filehandles';
use Path::Tiny;
use Mojo::UserAgent;
use Digest::MD5 'md5_hex';
use Test::File::ShareDir -share => { -dist => { 'JSON-Schema-Modern' => 'share' } };
use lib 'lib';

# ATTENTION DISTRO REPACKAGERS: do NOT use fresh copies of these files
# from their source; it is important to include the original versions
# of the files as they were packaged with this cpan distribution, or
# surprising behaviour may occur.

my %files = (
  'draft2020-12/meta/applicator.json'     => 'https://json-schema.org/draft/2020-12/meta/applicator',
  'draft2020-12/meta/content.json'        => 'https://json-schema.org/draft/2020-12/meta/content',
  'draft2020-12/meta/core.json'           => 'https://json-schema.org/draft/2020-12/meta/core',
  'draft2020-12/meta/format-annotation.json' => 'https://json-schema.org/draft/2020-12/meta/format-annotation',
  'draft2020-12/meta/format-assertion.json' => 'https://json-schema.org/draft/2020-12/meta/format-assertion',
  'draft2020-12/meta/meta-data.json'      => 'https://json-schema.org/draft/2020-12/meta/meta-data',
  'draft2020-12/meta/unevaluated.json'    => 'https://json-schema.org/draft/2020-12/meta/unevaluated',
  'draft2020-12/meta/validation.json'     => 'https://json-schema.org/draft/2020-12/meta/validation',
  'draft2020-12/output/schema.json'       => 'https://json-schema.org/draft/2020-12/output/schema',
  'draft2020-12/schema.json'              => 'https://json-schema.org/draft/2020-12/schema',

  'draft2019-09/meta/applicator.json'     => 'https://json-schema.org/draft/2019-09/meta/applicator',
  'draft2019-09/meta/content.json'        => 'https://json-schema.org/draft/2019-09/meta/content',
  'draft2019-09/meta/core.json'           => 'https://json-schema.org/draft/2019-09/meta/core',
  'draft2019-09/meta/format.json'         => 'https://json-schema.org/draft/2019-09/meta/format',
  'draft2019-09/meta/meta-data.json'      => 'https://json-schema.org/draft/2019-09/meta/meta-data',
  'draft2019-09/meta/validation.json'     => 'https://json-schema.org/draft/2019-09/meta/validation',
  'draft2019-09/output/schema.json'       => 'https://json-schema.org/draft/2019-09/output/schema',
  'draft2019-09/schema.json'              => 'https://json-schema.org/draft/2019-09/schema',

  'draft7/schema.json' => 'http://json-schema.org/draft-07/schema',
  'draft6/schema.json' => 'http://json-schema.org/draft-06/schema',
  'draft4/schema.json' => 'http://json-schema.org/draft-04/schema',

  'LICENSE' => 'https://raw.githubusercontent.com/json-schema-org/json-schema-spec/main/LICENSE',
);

my $ua = Mojo::UserAgent->new(max_redirects => 3);
my %checksums;

foreach my $target (sort keys %files) {
  my $uri = $files{$target};

  say "# fetching $uri -> share/$target" if $ENV{DEBUG};
  my $res = $ua->get($uri)->result;
  die "Failed to fetch $uri", $res->code, " ", $res->message if $res->is_error;

  $target = path('share', $target);
  $target->parent->mkpath;
  $target->spew_raw(my $content = $res->body);
  $checksums{$target} = md5_hex($content);
}

# lazy-load this to make sure we load the files we just downloaded
require JSON::Schema::Modern;

my $json_decoder = JSON::Schema::Modern::_JSON_BACKEND()->new->utf8(1);

# all files must be updated before any of them can be validated, since they depend on each other via
# the '$schema' and '$vocabulary' keywords
foreach my $target (sort keys %files) {
  $target = path('share', $target);
  next if $target->basename eq 'LICENSE';

  my $schema = $json_decoder->decode($target->slurp_raw);
  say '# validating ', $schema->{'$id'}//$schema->{id}, ' -> ', $target if $ENV{DEBUG};

  my $result = JSON::Schema::Modern::Document->validate(schema => $schema);
  die $result->dump if not $result->valid;
}

# compute checksums and record them in the test
path('t/checksums.t')->edit_raw(sub {
  m/^__DATA__$/mg;
  $_ = substr($_, 0, pos()+1).join("\n", map $_.' '.$checksums{$_}, sort keys %checksums)."\n";
});
