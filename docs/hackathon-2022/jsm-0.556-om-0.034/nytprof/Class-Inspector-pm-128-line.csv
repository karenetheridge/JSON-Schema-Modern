# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Class::Inspector;
0.000000,0,0.000000,
0.000040,2,0.000020,use 5.006;
0.000000,0,0.000000,# We don't want to use strict refs anywhere in this module, since we do a
0.000000,0,0.000000,# lot of things in here that aren't strict refs friendly.
0.000023,2,0.000012,use strict qw{vars subs};
0.000015,2,0.000007,use warnings;
0.000045,2,0.000023,use File::Spec ();
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Get information about a class and its structure
0.000001,1,0.000001,our $VERSION = '1.36'; # VERSION
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# If Unicode is available, enable it so that the
0.000000,0,0.000000,# pattern matches below match unicode method names.
0.000000,0,0.000000,# We can safely ignore any failure here.
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,local $@;
0.000004,1,0.000004,eval {
0.000000,1,0.000000,require utf8;
0.000002,1,0.000002,utf8->import;
0.000000,0,0.000000,};
0.001872,1,0.001872,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Predefine some regexs
0.000008,1,0.000008,our $RE_IDENTIFIER = qr/\A[^\W\d]\w*\z/s;
0.000002,1,0.000002,our $RE_CLASS      = qr/\A[^\W\d]\w*(?:(?:\'|::)\w+)*\z/s;
0.000000,0,0.000000,
0.000000,0,0.000000,# Are we on something Unix-like?
0.000001,1,0.000001,our $UNIX  = !! ( $File::Spec::ISA[0] eq 'File::Spec::Unix'  );
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#####################################################################
0.000000,0,0.000000,# Basic Methods
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _resolved_inc_handler {
0.000000,0,0.000000,my $class    = shift;
0.000000,0,0.000000,my $filename = $class->_inc_filename(shift) or return undef;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $inc ( @INC ) {
0.000000,0,0.000000,my $ref = ref $inc;
0.000000,0,0.000000,if($ref eq 'CODE') {
0.000000,0,0.000000,my @ret = $inc->($inc, $filename);
0.000000,0,0.000000,if(@ret == 1 && ! defined $ret[0]) {
0.000000,0,0.000000,# do nothing.
0.000000,0,0.000000,} elsif(@ret) {
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif($ref eq 'ARRAY' && ref($inc->[0]) eq 'CODE') {
0.000000,0,0.000000,my @ret = $inc->[0]->($inc, $filename);
0.000000,0,0.000000,if(@ret) {
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif($ref && eval { $inc->can('INC') }) {
0.000000,0,0.000000,my @ret = $inc->INC($filename);
0.000000,0,0.000000,if(@ret) {
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,'';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub installed {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,!! ($class->loaded_filename($_[0]) or $class->resolved_filename($_[0]) or $class->_resolved_inc_handler($_[0]));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub loaded {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $name  = $class->_class(shift) or return undef;
0.000000,0,0.000000,$class->_loaded($name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _loaded {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $name  = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Handle by far the two most common cases
0.000000,0,0.000000,# This is very fast and handles 99% of cases.
0.000000,0,0.000000,return 1 if defined ${"${name}::VERSION"};
0.000000,0,0.000000,return 1 if @{"${name}::ISA"};
0.000000,0,0.000000,
0.000000,0,0.000000,# Are there any symbol table entries other than other namespaces
0.000000,0,0.000000,foreach ( keys %{"${name}::"} ) {
0.000000,0,0.000000,next if substr($_, -2, 2) eq '::';
0.000000,0,0.000000,return 1 if defined &{"${name}::$_"};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# No functions, and it doesn't have a version, and isn't anything.
0.000000,0,0.000000,# As an absolute last resort, check for an entry in %INC
0.000000,0,0.000000,my $filename = $class->_inc_filename($name);
0.000000,0,0.000000,return 1 if defined $INC{$filename};
0.000000,0,0.000000,
0.000000,0,0.000000,'';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub filename {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $name  = $class->_class(shift) or return undef;
0.000000,0,0.000000,File::Spec->catfile( split /(?:\'|::)/, $name ) . '.pm';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub resolved_filename {
0.000000,0,0.000000,my $class     = shift;
0.000000,0,0.000000,my $filename  = $class->_inc_filename(shift) or return undef;
0.000000,0,0.000000,my @try_first = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Look through the @INC path to find the file
0.000000,0,0.000000,foreach ( @try_first, @INC ) {
0.000000,0,0.000000,my $full = "$_/$filename";
0.000000,0,0.000000,next unless -e $full;
0.000000,0,0.000000,return $UNIX ? $full : $class->_inc_to_local($full);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# File not found
0.000000,0,0.000000,'';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub loaded_filename {
0.000000,0,0.000000,my $class    = shift;
0.000000,0,0.000000,my $filename = $class->_inc_filename(shift);
0.000000,0,0.000000,$UNIX ? $INC{$filename} : $class->_inc_to_local($INC{$filename});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#####################################################################
0.000000,0,0.000000,# Sub Related Methods
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub functions {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $name  = $class->_class(shift) or return undef;
0.000000,0,0.000000,return undef unless $class->loaded( $name );
0.000000,0,0.000000,
0.000000,0,0.000000,# Get all the CODE symbol table entries
0.000000,0,0.000000,my @functions = sort grep { /$RE_IDENTIFIER/o }
0.000000,0,0.000000,grep { defined &{"${name}::$_"} }
0.000000,0,0.000000,keys %{"${name}::"};
0.000000,0,0.000000,\@functions;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub function_refs {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $name  = $class->_class(shift) or return undef;
0.000000,0,0.000000,return undef unless $class->loaded( $name );
0.000000,0,0.000000,
0.000000,0,0.000000,# Get all the CODE symbol table entries, but return
0.000000,0,0.000000,# the actual CODE refs this time.
0.000000,0,0.000000,my @functions = map { \&{"${name}::$_"} }
0.000000,0,0.000000,sort grep { /$RE_IDENTIFIER/o }
0.000000,0,0.000000,grep { defined &{"${name}::$_"} }
0.000000,0,0.000000,keys %{"${name}::"};
0.000000,0,0.000000,\@functions;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub function_exists {
0.000000,0,0.000000,my $class    = shift;
0.000000,0,0.000000,my $name     = $class->_class( shift ) or return undef;
0.000000,0,0.000000,my $function = shift or return undef;
0.000000,0,0.000000,
0.000000,0,0.000000,# Only works if the class is loaded
0.000000,0,0.000000,return undef unless $class->loaded( $name );
0.000000,0,0.000000,
0.000000,0,0.000000,# Does the GLOB exist and its CODE part exist
0.000000,0,0.000000,defined &{"${name}::$function"};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub methods {
0.000000,0,0.000000,my $class     = shift;
0.000000,0,0.000000,my $name      = $class->_class( shift ) or return undef;
0.000000,0,0.000000,my @arguments = map { lc $_ } @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Process the arguments to determine the options
0.000000,0,0.000000,my %options = ();
0.000000,0,0.000000,foreach ( @arguments ) {
0.000000,0,0.000000,if ( $_ eq 'public' ) {
0.000000,0,0.000000,# Only get public methods
0.000000,0,0.000000,return undef if $options{private};
0.000000,0,0.000000,$options{public} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif ( $_ eq 'private' ) {
0.000000,0,0.000000,# Only get private methods
0.000000,0,0.000000,return undef if $options{public};
0.000000,0,0.000000,$options{private} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif ( $_ eq 'full' ) {
0.000000,0,0.000000,# Return the full method name
0.000000,0,0.000000,return undef if $options{expanded};
0.000000,0,0.000000,$options{full} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif ( $_ eq 'expanded' ) {
0.000000,0,0.000000,# Returns class, method and function ref
0.000000,0,0.000000,return undef if $options{full};
0.000000,0,0.000000,$options{expanded} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# Unknown or unsupported options
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Only works if the class is loaded
0.000000,0,0.000000,return undef unless $class->loaded( $name );
0.000000,0,0.000000,
0.000000,0,0.000000,# Get the super path ( not including UNIVERSAL )
0.000000,0,0.000000,# Rather than using Class::ISA, we'll use an inlined version
0.000000,0,0.000000,# that implements the same basic algorithm.
0.000000,0,0.000000,my @path  = ();
0.000000,0,0.000000,my @queue = ( $name );
0.000000,0,0.000000,my %seen  = ( $name => 1 );
0.000000,0,0.000000,while ( my $cl = shift @queue ) {
0.000000,0,0.000000,push @path, $cl;
0.000000,0,0.000000,unshift @queue, grep { ! $seen{$_}++ }
0.000000,0,0.000000,map { s/^::/main::/; s/\'/::/g; $_ } ##  no critic
0.000000,0,0.000000,map { "$_" }
0.000000,0,0.000000,( @{"${cl}::ISA"} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Find and merge the function names across the entire super path.
0.000000,0,0.000000,# Sort alphabetically and return.
0.000000,0,0.000000,my %methods = ();
0.000000,0,0.000000,foreach my $namespace ( @path ) {
0.000000,0,0.000000,my @functions = grep { ! $methods{$_} }
0.000000,0,0.000000,grep { /$RE_IDENTIFIER/o }
0.000000,0,0.000000,grep { defined &{"${namespace}::$_"} }
0.000000,0,0.000000,keys %{"${namespace}::"};
0.000000,0,0.000000,foreach ( @functions ) {
0.000000,0,0.000000,$methods{$_} = $namespace;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Filter to public or private methods if needed
0.000000,0,0.000000,my @methodlist = sort keys %methods;
0.000000,0,0.000000,@methodlist = grep { ! /^\_/ } @methodlist if $options{public};
0.000000,0,0.000000,@methodlist = grep {   /^\_/ } @methodlist if $options{private};
0.000000,0,0.000000,
0.000000,0,0.000000,# Return in the correct format
0.000000,0,0.000000,@methodlist = map { "$methods{$_}::$_" } @methodlist if $options{full};
0.000000,0,0.000000,@methodlist = map {
0.000000,0,0.000000,[ "$methods{$_}::$_", $methods{$_}, $_, \&{"$methods{$_}::$_"} ]
0.000000,0,0.000000,} @methodlist if $options{expanded};
0.000000,0,0.000000,
0.000000,0,0.000000,\@methodlist;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#####################################################################
0.000000,0,0.000000,# Search Methods
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub subclasses {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $name  = $class->_class( shift ) or return undef;
0.000000,0,0.000000,
0.000000,0,0.000000,# Prepare the search queue
0.000000,0,0.000000,my @found = ();
0.000000,0,0.000000,my @queue = grep { $_ ne 'main' } $class->_subnames('');
0.000000,0,0.000000,while ( @queue ) {
0.000000,0,0.000000,my $c = shift(@queue); # c for class
0.000000,0,0.000000,if ( $class->_loaded($c) ) {
0.000000,0,0.000000,# At least one person has managed to misengineer
0.000000,0,0.000000,# a situation in which ->isa could die, even if the
0.000000,0,0.000000,# class is real. Trap these cases and just skip
0.000000,0,0.000000,# over that (bizarre) class. That would at limit
0.000000,0,0.000000,# problems with finding subclasses to only the
0.000000,0,0.000000,# modules that have broken ->isa implementation.
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,eval {
0.000000,0,0.000000,if ( $c->isa($name) ) {
0.000000,0,0.000000,# Add to the found list, but don't add the class itself
0.000000,0,0.000000,push @found, $c unless $c eq $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Add any child namespaces to the head of the queue.
0.000000,0,0.000000,# This keeps the queue length shorted, and allows us
0.000000,0,0.000000,# not to have to do another sort at the end.
0.000000,0,0.000000,unshift @queue, map { "${c}::$_" } $class->_subnames($c);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,@found ? \@found : '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _subnames {
0.000000,0,0.000000,my ($class, $name) = @_;
0.000000,0,0.000000,return sort
0.000000,0,0.000000,grep {  ## no critic
0.000000,0,0.000000,substr($_, -2, 2, '') eq '::'
0.000000,0,0.000000,and
0.000000,0,0.000000,/$RE_IDENTIFIER/o
0.000000,0,0.000000,}
0.000000,0,0.000000,keys %{"${name}::"};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#####################################################################
0.000000,0,0.000000,# Children Related Methods
0.000000,0,0.000000,
0.000000,0,0.000000,# These can go undocumented for now, until I decide if its best to
0.000000,0,0.000000,# just search the children in namespace only, or if I should do it via
0.000000,0,0.000000,# the file system.
0.000000,0,0.000000,
0.000000,0,0.000000,# Find all the loaded classes below us
0.000000,0,0.000000,sub children {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $name  = $class->_class(shift) or return ();
0.000000,0,0.000000,
0.000000,0,0.000000,# Find all the Foo:: elements in our symbol table
0.000099,2,0.000049,no strict 'refs';
0.000000,0,0.000000,map { "${name}::$_" } sort grep { s/::$// } keys %{"${name}::"};  ## no critic
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# As above, but recursively
0.000000,0,0.000000,sub recursive_children {
0.000000,0,0.000000,my $class    = shift;
0.000000,0,0.000000,my $name     = $class->_class(shift) or return ();
0.000000,0,0.000000,my @children = ( $name );
0.000000,0,0.000000,
0.000000,0,0.000000,# Do the search using a nicer, more memory efficient
0.000000,0,0.000000,# variant of actual recursion.
0.000000,0,0.000000,my $i = 0;
0.000275,2,0.000137,no strict 'refs';
0.000000,0,0.000000,while ( my $namespace = $children[$i++] ) {
0.000000,0,0.000000,push @children, map { "${namespace}::$_" }
0.000000,0,0.000000,grep { ! /^::/ } # Ignore things like ::ISA::CACHE::
0.000000,0,0.000000,grep { s/::$// }  ## no critic
0.000000,0,0.000000,keys %{"${namespace}::"};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sort @children;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#####################################################################
0.000000,0,0.000000,# Private Methods
0.000000,0,0.000000,
0.000000,0,0.000000,# Checks and expands ( if needed ) a class name
0.000000,0,0.000000,sub _class {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $name  = shift or return '';
0.000000,0,0.000000,
0.000000,0,0.000000,# Handle main shorthand
0.000000,0,0.000000,return 'main' if $name eq '::';
0.000000,0,0.000000,$name =~ s/\A::/main::/;
0.000000,0,0.000000,
0.000000,0,0.000000,# Check the class name is valid
0.000000,0,0.000000,$name =~ /$RE_CLASS/o ? $name : '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Create a INC-specific filename, which always uses '/'
0.000000,0,0.000000,# regardless of platform.
0.000000,0,0.000000,sub _inc_filename {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $name  = $class->_class(shift) or return undef;
0.000000,0,0.000000,join( '/', split /(?:\'|::)/, $name ) . '.pm';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Convert INC-specific file name to local file name
0.000000,0,0.000000,sub _inc_to_local {
0.000000,0,0.000000,# Shortcut in the Unix case
0.000000,0,0.000000,return $_[1] if $UNIX;
0.000000,0,0.000000,
0.000000,0,0.000000,# On other places, we have to deal with an unusual path that might look
0.000000,0,0.000000,# like C:/foo/bar.pm which doesn't fit ANY normal pattern.
0.000000,0,0.000000,# Putting it through splitpath/dir and back again seems to normalise
0.000000,0,0.000000,# it to a reasonable amount.
0.000000,0,0.000000,my $class              = shift;
0.000000,0,0.000000,my $inc_name           = shift or return undef;
0.000000,0,0.000000,my ($vol, $dir, $file) = File::Spec->splitpath( $inc_name );
0.000000,0,0.000000,$dir = File::Spec->catdir( File::Spec->splitdir( $dir || "" ) );
0.000000,0,0.000000,File::Spec->catpath( $vol, $dir, $file || "" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
