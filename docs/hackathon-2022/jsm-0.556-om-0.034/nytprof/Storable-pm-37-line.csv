# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,#
0.000000,0,0.000000,#  Copyright (c) 1995-2001, Raphael Manfredi
0.000000,0,0.000000,#  Copyright (c) 2002-2014 by the Perl 5 Porters
0.000000,0,0.000000,#  Copyright (c) 2015-2016 cPanel Inc
0.000000,0,0.000000,#  Copyright (c) 2017 Reini Urban
0.000000,0,0.000000,#
0.000000,0,0.000000,#  You may redistribute only under the same terms as Perl 5, as specified
0.000000,0,0.000000,#  in the README file that comes with the distribution.
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000073,1,0.000073,BEGIN { require XSLoader }
0.000001,1,0.000001,require Exporter;
0.000000,0,0.000000,package Storable;
0.000000,0,0.000000,
0.000008,1,0.000008,our @ISA = qw(Exporter);
0.000001,1,0.000001,our @EXPORT = qw(store retrieve);
0.000002,1,0.000002,our @EXPORT_OK = qw(
0.000000,0,0.000000,nstore store_fd nstore_fd fd_retrieve
0.000000,0,0.000000,freeze nfreeze thaw
0.000000,0,0.000000,dclone
0.000000,0,0.000000,retrieve_fd
0.000000,0,0.000000,lock_store lock_nstore lock_retrieve
0.000000,0,0.000000,file_magic read_magic
0.000000,0,0.000000,BLESS_OK TIE_OK FLAGS_COMPAT
0.000000,0,0.000000,stack_depth stack_depth_hash
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,our ($canonical, $forgive_me);
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000003,1,0.000003,our $VERSION = '3.26';
0.000035,1,0.000035,}
0.000000,0,0.000000,
0.000000,0,0.000000,our $recursion_limit;
0.000000,0,0.000000,our $recursion_limit_hash;
0.000000,0,0.000000,
0.000000,1,0.000000,$recursion_limit = 512
0.000000,0,0.000000,unless defined $recursion_limit;
0.000000,1,0.000000,$recursion_limit_hash = 256
0.000000,0,0.000000,unless defined $recursion_limit_hash;
0.000000,0,0.000000,
0.000086,2,0.000043,use Carp;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000001,1,0.000001,if (eval {
0.000001,1,0.000001,local $SIG{__DIE__};
0.000001,1,0.000001,local @INC = @INC;
0.000001,1,0.000001,pop @INC if $INC[-1] eq '.';
0.000085,1,0.000085,require Log::Agent;
0.000000,0,0.000000,1;
0.000000,0,0.000000,}) {
0.000000,0,0.000000,Log::Agent->import;
0.000000,0,0.000000,}
0.000000,0,0.000000,#
0.000000,0,0.000000,# Use of Log::Agent is optional. If it hasn't imported these subs then
0.000000,0,0.000000,# provide a fallback implementation.
0.000000,0,0.000000,#
0.000002,1,0.000002,unless ($Storable::{logcroak} && *{$Storable::{logcroak}}{CODE}) {
0.000000,0,0.000000,*logcroak = \&Carp::croak;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# Log::Agent's logcroak always adds a newline to the error it is
0.000000,0,0.000000,# given.  This breaks refs getting thrown.  We can just discard what
0.000000,0,0.000000,# it throws (but keep whatever logging it does) and throw the original
0.000000,0,0.000000,# args.
0.000070,2,0.000035,no warnings 'redefine';
0.000000,0,0.000000,my $logcroak = \&logcroak;
0.000000,0,0.000000,*logcroak = sub {
0.000000,0,0.000000,my @args = @_;
0.000000,0,0.000000,eval { &$logcroak };
0.000000,0,0.000000,Carp::croak(@args);
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000003,1,0.000003,unless ($Storable::{logcarp} && *{$Storable::{logcarp}}{CODE}) {
0.000000,0,0.000000,*logcarp = \&Carp::carp;
0.000000,0,0.000000,}
0.000045,1,0.000045,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# They might miss :flock in Fcntl
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000171,3,0.000057,if (eval { require Fcntl; 1 } && exists $Fcntl::EXPORT_TAGS{'flock'}) {
0.000000,0,0.000000,Fcntl->import(':flock');
0.000000,0,0.000000,} else {
0.000000,0,0.000000,eval q{
0.000000,0,0.000000,sub LOCK_SH () { 1 }
0.000000,0,0.000000,sub LOCK_EX () { 2 }
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000080,1,0.000080,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub CLONE {
0.000000,0,0.000000,# clone context under threads
0.000000,0,0.000000,Storable::init_perinterp();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub BLESS_OK     () { 2 }
0.000000,0,0.000000,sub TIE_OK       () { 4 }
0.000000,0,0.000000,sub FLAGS_COMPAT () { BLESS_OK | TIE_OK }
0.000000,0,0.000000,
0.000000,0,0.000000,# By default restricted hashes are downgraded on earlier perls.
0.000000,0,0.000000,
0.000000,1,0.000000,$Storable::flags = FLAGS_COMPAT;
0.000000,1,0.000000,$Storable::downgrade_restricted = 1;
0.000000,1,0.000000,$Storable::accept_future_minor = 1;
0.000000,0,0.000000,
0.001871,1,0.001871,BEGIN { XSLoader::load('Storable') };
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# Determine whether locking is possible, but only when needed.
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,0,0.000000,sub show_file_magic {
0.000000,0,0.000000,print <<EOM;
0.000000,0,0.000000,#
0.000000,0,0.000000,# To recognize the data files of the Perl module Storable,
0.000000,0,0.000000,# the following lines need to be added to the local magic(5) file,
0.000000,0,0.000000,# usually either /usr/share/misc/magic or /etc/magic.
0.000000,0,0.000000,#
0.000000,0,0.000000,0	string	perl-store	perl Storable(v0.6) data
0.000000,0,0.000000,>4	byte	>0	(net-order %d)
0.000000,0,0.000000,>>4	byte	&01	(network-ordered)
0.000000,0,0.000000,>>4	byte	=3	(major 1)
0.000000,0,0.000000,>>4	byte	=2	(major 1)
0.000000,0,0.000000,
0.000000,0,0.000000,0	string	pst0	perl Storable(v0.7) data
0.000000,0,0.000000,>4	byte	>0
0.000000,0,0.000000,>>4	byte	&01	(network-ordered)
0.000000,0,0.000000,>>4	byte	=5	(major 2)
0.000000,0,0.000000,>>4	byte	=4	(major 2)
0.000000,0,0.000000,>>5	byte	>0	(minor %d)
0.000000,0,0.000000,EOM
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub file_magic {
0.000000,0,0.000000,require IO::File;
0.000000,0,0.000000,
0.000000,0,0.000000,my $file = shift;
0.000000,0,0.000000,my $fh = IO::File->new;
0.000000,0,0.000000,open($fh, "<", $file) || die "Can't open '$file': $!";
0.000000,0,0.000000,binmode($fh);
0.000000,0,0.000000,defined(sysread($fh, my $buf, 32)) || die "Can't read from '$file': $!";
0.000000,0,0.000000,close($fh);
0.000000,0,0.000000,
0.000000,0,0.000000,$file = "./$file" unless $file;  # ensure TRUE value
0.000000,0,0.000000,
0.000000,0,0.000000,return read_magic($buf, $file);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub read_magic {
0.000000,0,0.000000,my($buf, $file) = @_;
0.000000,0,0.000000,my %info;
0.000000,0,0.000000,
0.000000,0,0.000000,my $buflen = length($buf);
0.000000,0,0.000000,my $magic;
0.000000,0,0.000000,if ($buf =~ s/^(pst0|perl-store)//) {
0.000000,0,0.000000,$magic = $1;
0.000000,0,0.000000,$info{file} = $file || 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return undef if $file;
0.000000,0,0.000000,$magic = "";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return undef unless length($buf);
0.000000,0,0.000000,
0.000000,0,0.000000,my $net_order;
0.000000,0,0.000000,if ($magic eq "perl-store" && ord(substr($buf, 0, 1)) > 1) {
0.000000,0,0.000000,$info{version} = -1;
0.000000,0,0.000000,$net_order = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$buf =~ s/(.)//s;
0.000000,0,0.000000,my $major = (ord $1) >> 1;
0.000000,0,0.000000,return undef if $major > 4; # sanity (assuming we never go that high)
0.000000,0,0.000000,$info{major} = $major;
0.000000,0,0.000000,$net_order = (ord $1) & 0x01;
0.000000,0,0.000000,if ($major > 1) {
0.000000,0,0.000000,return undef unless $buf =~ s/(.)//s;
0.000000,0,0.000000,my $minor = ord $1;
0.000000,0,0.000000,$info{minor} = $minor;
0.000000,0,0.000000,$info{version} = "$major.$minor";
0.000000,0,0.000000,$info{version_nv} = sprintf "%d.%03d", $major, $minor;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$info{version} = $major;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$info{version_nv} ||= $info{version};
0.000000,0,0.000000,$info{netorder} = $net_order;
0.000000,0,0.000000,
0.000000,0,0.000000,unless ($net_order) {
0.000000,0,0.000000,return undef unless $buf =~ s/(.)//s;
0.000000,0,0.000000,my $len = ord $1;
0.000000,0,0.000000,return undef unless length($buf) >= $len;
0.000000,0,0.000000,return undef unless $len == 4 || $len == 8;  # sanity
0.000000,0,0.000000,@info{qw(byteorder intsize longsize ptrsize)}
0.000000,0,0.000000,= unpack "a${len}CCC", $buf;
0.000000,0,0.000000,(substr $buf, 0, $len + 3) = '';
0.000000,0,0.000000,if ($info{version_nv} >= 2.002) {
0.000000,0,0.000000,return undef unless $buf =~ s/(.)//s;
0.000000,0,0.000000,$info{nvsize} = ord $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$info{hdrsize} = $buflen - length($buf);
0.000000,0,0.000000,
0.000000,0,0.000000,return \%info;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub BIN_VERSION_NV {
0.000000,0,0.000000,sprintf "%d.%03d", BIN_MAJOR(), BIN_MINOR();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub BIN_WRITE_VERSION_NV {
0.000000,0,0.000000,sprintf "%d.%03d", BIN_MAJOR(), BIN_WRITE_MINOR();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# store
0.000000,0,0.000000,#
0.000000,0,0.000000,# Store target object hierarchy, identified by a reference to its root.
0.000000,0,0.000000,# The stored object tree may later be retrieved to memory via retrieve.
0.000000,0,0.000000,# Returns undef if an I/O error occurred, in which case the file is
0.000000,0,0.000000,# removed.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub store {
0.000000,0,0.000000,return _store(\&pstore, @_, 0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# nstore
0.000000,0,0.000000,#
0.000000,0,0.000000,# Same as store, but in network order.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub nstore {
0.000000,0,0.000000,return _store(\&net_pstore, @_, 0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# lock_store
0.000000,0,0.000000,#
0.000000,0,0.000000,# Same as store, but flock the file first (advisory locking).
0.000000,0,0.000000,#
0.000000,0,0.000000,sub lock_store {
0.000000,0,0.000000,return _store(\&pstore, @_, 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# lock_nstore
0.000000,0,0.000000,#
0.000000,0,0.000000,# Same as nstore, but flock the file first (advisory locking).
0.000000,0,0.000000,#
0.000000,0,0.000000,sub lock_nstore {
0.000000,0,0.000000,return _store(\&net_pstore, @_, 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Internal store to file routine
0.000000,0,0.000000,sub _store {
0.000000,0,0.000000,my $xsptr = shift;
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($file, $use_locking) = @_;
0.000000,0,0.000000,logcroak "not a reference" unless ref($self);
0.000000,0,0.000000,logcroak "wrong argument number" unless @_ == 2;	# No @foo in arglist
0.000000,0,0.000000,local *FILE;
0.000000,0,0.000000,if ($use_locking) {
0.000000,0,0.000000,open(FILE, ">>", $file) || logcroak "can't write into $file: $!";
0.000000,0,0.000000,unless (CAN_FLOCK) {
0.000000,0,0.000000,logcarp
0.000000,0,0.000000,"Storable::lock_store: fcntl/flock emulation broken on $^O";
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,flock(FILE, LOCK_EX) ||
0.000000,0,0.000000,logcroak "can't get exclusive lock on $file: $!";
0.000000,0,0.000000,truncate FILE, 0;
0.000000,0,0.000000,# Unlocking will happen when FILE is closed
0.000000,0,0.000000,} else {
0.000000,0,0.000000,open(FILE, ">", $file) || logcroak "can't create $file: $!";
0.000000,0,0.000000,}
0.000000,0,0.000000,binmode FILE;	# Archaic systems...
0.000000,0,0.000000,my $da = $@;	# Don't mess if called from exception handler
0.000000,0,0.000000,my $ret;
0.000000,0,0.000000,# Call C routine nstore or pstore, depending on network order
0.000000,0,0.000000,eval { $ret = &$xsptr(*FILE, $self) };
0.000000,0,0.000000,# close will return true on success, so the or short-circuits, the ()
0.000000,0,0.000000,# expression is true, and for that case the block will only be entered
0.000000,0,0.000000,# if $@ is true (ie eval failed)
0.000000,0,0.000000,# if close fails, it returns false, $ret is altered, *that* is (also)
0.000000,0,0.000000,# false, so the () expression is false, !() is true, and the block is
0.000000,0,0.000000,# entered.
0.000000,0,0.000000,if (!(close(FILE) or undef $ret) || $@) {
0.000000,0,0.000000,unlink($file) or warn "Can't unlink $file: $!\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($@) {
0.000000,0,0.000000,$@ =~ s/\.?\n$/,/ unless ref $@;
0.000000,0,0.000000,logcroak $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,$@ = $da;
0.000000,0,0.000000,return $ret;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# store_fd
0.000000,0,0.000000,#
0.000000,0,0.000000,# Same as store, but perform on an already opened file descriptor instead.
0.000000,0,0.000000,# Returns undef if an I/O error occurred.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub store_fd {
0.000000,0,0.000000,return _store_fd(\&pstore, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# nstore_fd
0.000000,0,0.000000,#
0.000000,0,0.000000,# Same as store_fd, but in network order.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub nstore_fd {
0.000000,0,0.000000,my ($self, $file) = @_;
0.000000,0,0.000000,return _store_fd(\&net_pstore, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Internal store routine on opened file descriptor
0.000000,0,0.000000,sub _store_fd {
0.000000,0,0.000000,my $xsptr = shift;
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($file) = @_;
0.000000,0,0.000000,logcroak "not a reference" unless ref($self);
0.000000,0,0.000000,logcroak "too many arguments" unless @_ == 1;	# No @foo in arglist
0.000000,0,0.000000,my $fd = fileno($file);
0.000000,0,0.000000,logcroak "not a valid file descriptor" unless defined $fd;
0.000000,0,0.000000,my $da = $@;		# Don't mess if called from exception handler
0.000000,0,0.000000,my $ret;
0.000000,0,0.000000,# Call C routine nstore or pstore, depending on network order
0.000000,0,0.000000,eval { $ret = &$xsptr($file, $self) };
0.000000,0,0.000000,logcroak $@ if $@ =~ s/\.?\n$/,/;
0.000000,0,0.000000,local $\; print $file '';	# Autoflush the file if wanted
0.000000,0,0.000000,$@ = $da;
0.000000,0,0.000000,return $ret;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# freeze
0.000000,0,0.000000,#
0.000000,0,0.000000,# Store object and its hierarchy in memory and return a scalar
0.000000,0,0.000000,# containing the result.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub freeze {
0.000000,0,0.000000,_freeze(\&mstore, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# nfreeze
0.000000,0,0.000000,#
0.000000,0,0.000000,# Same as freeze but in network order.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub nfreeze {
0.000000,0,0.000000,_freeze(\&net_mstore, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Internal freeze routine
0.000000,0,0.000000,sub _freeze {
0.000000,0,0.000000,my $xsptr = shift;
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,logcroak "not a reference" unless ref($self);
0.000000,0,0.000000,logcroak "too many arguments" unless @_ == 0;	# No @foo in arglist
0.000000,0,0.000000,my $da = $@;	        # Don't mess if called from exception handler
0.000000,0,0.000000,my $ret;
0.000000,0,0.000000,# Call C routine mstore or net_mstore, depending on network order
0.000000,0,0.000000,eval { $ret = &$xsptr($self) };
0.000000,0,0.000000,if ($@) {
0.000000,0,0.000000,$@ =~ s/\.?\n$/,/ unless ref $@;
0.000000,0,0.000000,logcroak $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,$@ = $da;
0.000000,0,0.000000,return $ret ? $ret : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# retrieve
0.000000,0,0.000000,#
0.000000,0,0.000000,# Retrieve object hierarchy from disk, returning a reference to the root
0.000000,0,0.000000,# object of that tree.
0.000000,0,0.000000,#
0.000000,0,0.000000,# retrieve(file, flags)
0.000000,0,0.000000,# flags include by default BLESS_OK=2 | TIE_OK=4
0.000000,0,0.000000,# with flags=0 or the global $Storable::flags set to 0, no resulting object
0.000000,0,0.000000,# will be blessed nor tied.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub retrieve {
0.000000,0,0.000000,_retrieve(shift, 0, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# lock_retrieve
0.000000,0,0.000000,#
0.000000,0,0.000000,# Same as retrieve, but with advisory locking.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub lock_retrieve {
0.000000,0,0.000000,_retrieve(shift, 1, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Internal retrieve routine
0.000000,0,0.000000,sub _retrieve {
0.000000,0,0.000000,my ($file, $use_locking, $flags) = @_;
0.000000,0,0.000000,$flags = $Storable::flags unless defined $flags;
0.000000,0,0.000000,my $FILE;
0.000000,0,0.000000,open($FILE, "<", $file) || logcroak "can't open $file: $!";
0.000000,0,0.000000,binmode $FILE;			# Archaic systems...
0.000000,0,0.000000,my $self;
0.000000,0,0.000000,my $da = $@;			# Could be from exception handler
0.000000,0,0.000000,if ($use_locking) {
0.000000,0,0.000000,unless (CAN_FLOCK) {
0.000000,0,0.000000,logcarp
0.000000,0,0.000000,"Storable::lock_store: fcntl/flock emulation broken on $^O";
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,flock($FILE, LOCK_SH) || logcroak "can't get shared lock on $file: $!";
0.000000,0,0.000000,# Unlocking will happen when FILE is closed
0.000000,0,0.000000,}
0.000000,0,0.000000,eval { $self = pretrieve($FILE, $flags) };		# Call C routine
0.000000,0,0.000000,close($FILE);
0.000000,0,0.000000,if ($@) {
0.000000,0,0.000000,$@ =~ s/\.?\n$/,/ unless ref $@;
0.000000,0,0.000000,logcroak $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,$@ = $da;
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# fd_retrieve
0.000000,0,0.000000,#
0.000000,0,0.000000,# Same as retrieve, but perform from an already opened file descriptor instead.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub fd_retrieve {
0.000000,0,0.000000,my ($file, $flags) = @_;
0.000000,0,0.000000,$flags = $Storable::flags unless defined $flags;
0.000000,0,0.000000,my $fd = fileno($file);
0.000000,0,0.000000,logcroak "not a valid file descriptor" unless defined $fd;
0.000000,0,0.000000,my $self;
0.000000,0,0.000000,my $da = $@;				# Could be from exception handler
0.000000,0,0.000000,eval { $self = pretrieve($file, $flags) };	# Call C routine
0.000000,0,0.000000,if ($@) {
0.000000,0,0.000000,$@ =~ s/\.?\n$/,/ unless ref $@;
0.000000,0,0.000000,logcroak $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,$@ = $da;
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub retrieve_fd { &fd_retrieve }		# Backward compatibility
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# thaw
0.000000,0,0.000000,#
0.000000,0,0.000000,# Recreate objects in memory from an existing frozen image created
0.000000,0,0.000000,# by freeze.  If the frozen image passed is undef, return undef.
0.000000,0,0.000000,#
0.000000,0,0.000000,# thaw(frozen_obj, flags)
0.000000,0,0.000000,# flags include by default BLESS_OK=2 | TIE_OK=4
0.000000,0,0.000000,# with flags=0 or the global $Storable::flags set to 0, no resulting object
0.000000,0,0.000000,# will be blessed nor tied.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub thaw {
0.000000,0,0.000000,my ($frozen, $flags) = @_;
0.000000,0,0.000000,$flags = $Storable::flags unless defined $flags;
0.000000,0,0.000000,return undef unless defined $frozen;
0.000000,0,0.000000,my $self;
0.000000,0,0.000000,my $da = $@;			        # Could be from exception handler
0.000000,0,0.000000,eval { $self = mretrieve($frozen, $flags) };# Call C routine
0.000000,0,0.000000,if ($@) {
0.000000,0,0.000000,$@ =~ s/\.?\n$/,/ unless ref $@;
0.000000,0,0.000000,logcroak $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,$@ = $da;
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# _make_re($re, $flags)
0.000000,0,0.000000,#
0.000000,0,0.000000,# Internal function used to thaw a regular expression.
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,1,0.000000,my $re_flags;
0.000000,0,0.000000,BEGIN {
0.000002,1,0.000002,if ($] < 5.010) {
0.000000,0,0.000000,$re_flags = qr/\A[imsx]*\z/;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($] < 5.014) {
0.000000,0,0.000000,$re_flags = qr/\A[msixp]*\z/;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($] < 5.022) {
0.000000,0,0.000000,$re_flags = qr/\A[msixpdual]*\z/;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000007,1,0.000007,$re_flags = qr/\A[msixpdualn]*\z/;
0.000000,0,0.000000,}
0.000118,1,0.000118,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_re {
0.000000,0,0.000000,my ($re, $flags) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$flags =~ $re_flags
0.000000,0,0.000000,or die "regexp flags invalid";
0.000000,0,0.000000,
0.000000,0,0.000000,my $qr = eval "qr/\$re/$flags";
0.000000,0,0.000000,die $@ if $@;
0.000000,0,0.000000,
0.000000,0,0.000000,$qr;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,if ($] < 5.012) {
0.000000,0,0.000000,eval <<'EOS'
0.000000,0,0.000000,sub _regexp_pattern {
0.000000,0,0.000000,my $re = "" . shift;
0.000000,0,0.000000,$re =~ /\A\(\?([xism]*)(?:-[xism]*)?:(.*)\)\z/s
0.000000,0,0.000000,or die "Cannot parse regexp /$re/";
0.000000,0,0.000000,return ($2, $1);
0.000000,0,0.000000,}
0.000000,0,0.000000,1
0.000000,0,0.000000,EOS
0.000000,0,0.000000,or die "Cannot define _regexp_pattern: $@";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,1;
0.000000,0,0.000000,__END__
