# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000198,2,0.000099,use strict;
0.000074,2,0.000037,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Vocabulary;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Base role for JSON Schema vocabulary classes
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.556';
0.000000,0,0.000000,
0.000033,2,0.000017,use 5.020;
0.000028,2,0.000014,use Moo::Role;
0.000064,3,0.000021,use strictures 2;
0.000044,2,0.000022,use experimental qw(signatures postderef);
0.000033,2,0.000016,use if "$]" >= 5.022, experimental => 're_strict';
0.000030,2,0.000015,no if "$]" >= 5.031009, feature => 'indirect';
0.000030,2,0.000015,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000022,2,0.000011,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000051,3,0.000017,use Ref::Util 0.100 'is_plain_arrayref';
0.000026,2,0.000013,use JSON::Schema::Modern::Utilities qw(jsonp assert_keyword_type abort);
0.000019,2,0.000010,use Carp ();
0.000607,2,0.000304,use namespace::clean;
0.000000,0,0.000000,
0.000001,1,0.000001,our @CARP_NOT = qw(JSON::Schema::Modern);
0.000000,0,0.000000,
0.000002,1,0.000002,requires qw(vocabulary keywords);
0.000000,0,0.000000,
0.000006,3,0.000002,sub evaluation_order { 999 }  # override, if needed
0.000000,0,0.000000,
0.000000,0,0.000000,sub traverse ($self, $schema, $state) {
0.000000,0,0.000000,$state->{evaluator}->_traverse_subschema($schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000440,2248,0.000000,sub traverse_subschema ($self, $schema, $state) {
0.000000,0,0.000000,$state->{evaluator}->_traverse_subschema($schema->{$state->{keyword}},
0.005324,562,0.000009,+{ %$state, schema_path => $state->{schema_path}.'/'.$state->{keyword} });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000078,304,0.000000,sub traverse_array_schemas ($self, $schema, $state) {
0.000119,76,0.000002,return if not assert_keyword_type($state, $schema, 'array');
0.000087,76,0.000001,return E($state, '%s array is empty', $state->{keyword}) if not $schema->{$state->{keyword}}->@*;
0.000000,0,0.000000,
0.000016,76,0.000000,my $valid = 1;
0.000157,76,0.000002,foreach my $idx (0 .. $schema->{$state->{keyword}}->$#*) {
0.000000,0,0.000000,$valid = 0 if not $state->{evaluator}->_traverse_subschema($schema->{$state->{keyword}}[$idx],
0.001601,203,0.000008,+{ %$state, schema_path => $state->{schema_path}.'/'.$state->{keyword}.'/'.$idx });
0.000000,0,0.000000,}
0.000215,76,0.000003,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000515,1608,0.000000,sub traverse_object_schemas ($self, $schema, $state) {
0.000974,402,0.000002,return if not assert_keyword_type($state, $schema, 'object');
0.000000,0,0.000000,
0.000114,402,0.000000,my $valid = 1;
0.003310,402,0.000008,foreach my $property (sort keys $schema->{$state->{keyword}}->%*) {
0.000000,0,0.000000,$valid = 0 if not $state->{evaluator}->_traverse_subschema($schema->{$state->{keyword}}{$property},
0.015330,1349,0.000011,+{ %$state, schema_path => jsonp($state->{schema_path}, $state->{keyword}, $property) });
0.000000,0,0.000000,}
0.001228,402,0.000003,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,30,0.000000,sub traverse_property_schema ($self, $schema, $state, $property) {
0.000009,6,0.000002,return if not assert_keyword_type($state, $schema, 'object');
0.000000,0,0.000000,
0.000000,0,0.000000,$state->{evaluator}->_traverse_subschema($schema->{$state->{keyword}}{$property},
0.000052,6,0.000009,+{ %$state, schema_path => jsonp($state->{schema_path}, $state->{keyword}, $property) });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.062666,249435,0.000000,sub eval ($self, $data, $schema, $state) {
0.252289,49887,0.000005,$state->{evaluator}->_eval_subschema($data, $schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.053139,250242,0.000000,sub eval_subschema_at_uri ($self, $data, $schema, $state, $uri) {
0.103506,41707,0.000002,my $schema_info = $state->{evaluator}->_fetch_from_uri($uri);
0.013645,41707,0.000000,abort($state, 'EXCEPTION: unable to find resource %s', $uri) if not $schema_info;
0.000000,0,0.000000,
0.000000,0,0.000000,return $state->{evaluator}->_eval_subschema($data, $schema_info->{schema},
0.000000,0,0.000000,+{
0.000000,0,0.000000,$schema_info->{configs}->%*,
0.000000,0,0.000000,%$state,
0.000000,0,0.000000,traversed_schema_path => $state->{traversed_schema_path}.$state->{schema_path}
0.000000,0,0.000000,.jsonp('', $state->{keyword}, exists $state->{_schema_path_suffix}
0.000000,0,0.000000,? (is_plain_arrayref($state->{_schema_path_suffix}) ? $state->{_schema_path_suffix}->@* : $state->{_schema_path_suffix})
0.000000,0,0.000000,: ()),
0.000000,0,0.000000,initial_schema_uri => $schema_info->{canonical_uri},
0.000000,0,0.000000,document => $schema_info->{document},
0.000000,0,0.000000,document_path => $schema_info->{document_path},
0.000000,0,0.000000,spec_version => $schema_info->{specification_version},
0.000000,0,0.000000,schema_path => '',
0.000000,0,0.000000,vocabularies => $schema_info->{vocabularies}, # reference, not copy
0.887911,41707,0.000021,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,1;
0.000000,0,0.000000,
0.000028,1,0.000028,__END__
