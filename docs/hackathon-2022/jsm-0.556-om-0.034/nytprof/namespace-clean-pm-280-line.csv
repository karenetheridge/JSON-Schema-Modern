# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package namespace::clean;
0.000000,0,0.000000,
0.000050,2,0.000025,use warnings;
0.000102,2,0.000051,use strict;
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.27';
0.000012,1,0.000012,$VERSION = eval $VERSION if $VERSION =~ /_/; # numify for warning-free dev releases
0.000000,0,0.000000,
0.000000,1,0.000000,our $STORAGE_VAR = '__NAMESPACE_CLEAN_STORAGE';
0.000000,0,0.000000,
0.000882,2,0.000441,use B::Hooks::EndOfScope 'on_scope_end';
0.000000,0,0.000000,
0.000000,0,0.000000,# FIXME This is a crock of shit, needs to go away
0.000000,0,0.000000,# currently here to work around https://rt.cpan.org/Ticket/Display.html?id=74151
0.000000,0,0.000000,# kill with fire when PS::XS is *finally* fixed
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,my $provider;
0.000000,0,0.000000,
0.000003,1,0.000003,if ( "$]" < 5.008007 ) {
0.000000,0,0.000000,require Package::Stash::PP;
0.000000,0,0.000000,$provider = 'Package::Stash::PP';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000679,1,0.000679,require Package::Stash;
0.000001,1,0.000001,$provider = 'Package::Stash';
0.000000,0,0.000000,}
0.001141,1,0.001141,eval <<"EOS" or die $@;
0.000000,0,0.000000,
0.000000,0,0.000000,sub stash_for (\$) {
0.000000,0,0.000000,$provider->new(\$_[0]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,1;
0.000000,0,0.000000,
0.000000,0,0.000000,EOS
0.000033,1,0.000033,}
0.000000,0,0.000000,
0.001606,2,0.000803,use namespace::clean::_Util qw( DEBUGGER_NEEDS_CV_RENAME DEBUGGER_NEEDS_CV_PIVOT );
0.000000,0,0.000000,
0.000000,0,0.000000,# Built-in debugger CV-retrieval fixups necessary before perl 5.15.5:
0.000000,0,0.000000,# since we are deleting the glob where the subroutine was originally
0.000000,0,0.000000,# defined, the assumptions below no longer hold.
0.000000,0,0.000000,#
0.000000,0,0.000000,# In 5.8.9 ~ 5.13.5 (inclusive) the debugger assumes that a CV can
0.000000,0,0.000000,# always be found under sub_fullname($sub)
0.000000,0,0.000000,# Workaround: use sub naming to properly name the sub hidden in the package's
0.000000,0,0.000000,# deleted-stash
0.000000,0,0.000000,#
0.000000,0,0.000000,# In the rest of the range ( ... ~ 5.8.8 and 5.13.6 ~ 5.15.4 ) the debugger
0.000000,0,0.000000,# assumes the name of the glob passed to entersub can be used to find the CV
0.000000,0,0.000000,# Workaround: realias the original glob to the deleted-stash slot
0.000000,0,0.000000,#
0.000000,0,0.000000,# While the errors manifest themselves inside perl5db.pl, they are caused by
0.000000,0,0.000000,# problems inside the interpreter.  If enabled ($^P & 0x01) and existent,
0.000000,0,0.000000,# the DB::sub sub will be called by the interpreter for any sub call rather
0.000000,0,0.000000,# that call the sub directly.  It is provided the real sub to call in $DB::sub,
0.000000,0,0.000000,# but the value given has the issues described above.  We only have to enable
0.000000,0,0.000000,# the workaround if DB::sub will be used.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Can not tie constants to the current value of $^P directly,
0.000000,0,0.000000,# as the debugger can be enabled during runtime (kinda dubious)
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,0,0.000000,my $RemoveSubs = sub {
0.000015,18,0.000001,my $cleanee = shift;
0.000005,18,0.000000,my $store   = shift;
0.000045,18,0.000002,my $cleanee_stash = stash_for($cleanee);
0.000004,18,0.000000,my $deleted_stash;
0.000000,0,0.000000,
0.000000,0,0.000000,SYMBOL:
0.000088,18,0.000005,for my $f (@_) {
0.000000,0,0.000000,
0.000000,0,0.000000,# ignore already removed symbols
0.000097,281,0.000000,next SYMBOL if $store->{exclude}{ $f };
0.000000,0,0.000000,
0.001486,281,0.000005,my $sub = $cleanee_stash->get_symbol("&$f")
0.000000,0,0.000000,or next SYMBOL;
0.000000,0,0.000000,
0.000000,0,0.000000,my $need_debugger_fixup =
0.000000,0,0.000000,( DEBUGGER_NEEDS_CV_RENAME or DEBUGGER_NEEDS_CV_PIVOT )
0.000000,0,0.000000,&&
0.000000,0,0.000000,$^P & 0x01
0.000000,0,0.000000,&&
0.000000,0,0.000000,defined &DB::sub
0.000000,0,0.000000,&&
0.000066,281,0.000000,ref(my $globref = \$cleanee_stash->namespace->{$f}) eq 'GLOB'
0.000000,0,0.000000,&&
0.000000,0,0.000000,( $deleted_stash ||= stash_for("namespace::clean::deleted::$cleanee") )
0.000000,0,0.000000,;
0.000000,0,0.000000,
0.000000,0,0.000000,# convince the Perl debugger to work
0.000000,0,0.000000,# see the comment on top
0.000000,0,0.000000,if ( DEBUGGER_NEEDS_CV_RENAME and $need_debugger_fixup ) {
0.000000,0,0.000000,#
0.000000,0,0.000000,# Note - both get_subname and set_subname are only compiled when CV_RENAME
0.000000,0,0.000000,# is true ( the 5.8.9 ~ 5.12 range ). On other perls this entire block is
0.000000,0,0.000000,# constant folded away, and so are the definitions in ::_Util
0.000000,0,0.000000,#
0.000000,0,0.000000,# Do not be surprised that they are missing without DEBUGGER_NEEDS_CV_RENAME
0.000000,0,0.000000,#
0.000000,0,0.000000,namespace::clean::_Util::get_subname( $sub ) eq  ( $cleanee_stash->name . "::$f" )
0.000000,0,0.000000,and
0.000000,0,0.000000,$deleted_stash->add_symbol(
0.000000,0,0.000000,"&$f",
0.000000,0,0.000000,namespace::clean::_Util::set_subname( $deleted_stash->name . "::$f", $sub ),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( DEBUGGER_NEEDS_CV_PIVOT and $need_debugger_fixup ) {
0.000000,0,0.000000,$deleted_stash->add_symbol("&$f", $sub);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @symbols = map {
0.000730,1405,0.000001,my $name = $_ . $f;
0.004377,1124,0.000004,my $def = $cleanee_stash->get_symbol($name);
0.000186,1124,0.000000,defined($def) ? [$name, $def] : ()
0.000000,0,0.000000,} '$', '@', '%', '';
0.000000,0,0.000000,
0.001239,281,0.000004,$cleanee_stash->remove_glob($f);
0.000000,0,0.000000,
0.000000,0,0.000000,# if this perl needs no renaming trick we need to
0.000000,0,0.000000,# rename the original glob after the fact
0.000000,0,0.000000,DEBUGGER_NEEDS_CV_PIVOT
0.000000,0,0.000000,and
0.000000,0,0.000000,$need_debugger_fixup
0.000000,0,0.000000,and
0.000000,0,0.000000,*$globref = $deleted_stash->namespace->{$f};
0.000000,0,0.000000,
0.000347,281,0.000001,$cleanee_stash->add_symbol(@$_) for @symbols;
0.000000,0,0.000000,}
0.000003,1,0.000003,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub clean_subroutines {
0.000000,0,0.000000,my ($nc, $cleanee, @subs) = @_;
0.000000,0,0.000000,$RemoveSubs->($cleanee, {}, @subs);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000017,18,0.000001,my ($pragma, @args) = @_;
0.000000,0,0.000000,
0.000005,18,0.000000,my (%args, $is_explicit);
0.000000,0,0.000000,
0.000000,0,0.000000,ARG:
0.000017,18,0.000001,while (@args) {
0.000000,0,0.000000,
0.000000,0,0.000000,if ($args[0] =~ /^\-/) {
0.000000,0,0.000000,my $key = shift @args;
0.000000,0,0.000000,my $value = shift @args;
0.000000,0,0.000000,$args{ $key } = $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$is_explicit++;
0.000000,0,0.000000,last ARG;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000025,18,0.000001,my $cleanee = exists $args{ -cleanee } ? $args{ -cleanee } : scalar caller;
0.000005,18,0.000000,if ($is_explicit) {
0.000000,0,0.000000,on_scope_end {
0.000000,0,0.000000,$RemoveSubs->($cleanee, {}, @args);
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,# calling class, all current functions and our storage
0.000083,18,0.000005,my $functions = $pragma->get_functions($cleanee);
0.000049,18,0.000003,my $store     = $pragma->get_class_store($cleanee);
0.000020,18,0.000001,my $stash     = stash_for($cleanee);
0.000000,0,0.000000,
0.000000,0,0.000000,# except parameter can be array ref or single value
0.000000,0,0.000000,my %except = map {( $_ => 1 )} (
0.000000,0,0.000000,$args{ -except }
0.000000,0,0.000000,? ( ref $args{ -except } eq 'ARRAY' ? @{ $args{ -except } } : $args{ -except } )
0.000017,18,0.000001,: ()
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# register symbols for removal, if they have a CODE entry
0.000069,18,0.000004,for my $f (keys %$functions) {
0.000024,281,0.000000,next if     $except{ $f };
0.001130,281,0.000004,next unless $stash->has_symbol("&$f");
0.000198,281,0.000001,$store->{remove}{ $f } = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,on_scope_end {
0.000197,18,0.000011,$RemoveSubs->($cleanee, $store, keys %{ $store->{remove} });
0.000113,18,0.000006,};
0.000000,0,0.000000,
0.000151,18,0.000008,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unimport {
0.000000,0,0.000000,my ($pragma, %args) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# the calling class, the current functions and our storage
0.000000,0,0.000000,my $cleanee   = exists $args{ -cleanee } ? $args{ -cleanee } : scalar caller;
0.000000,0,0.000000,my $functions = $pragma->get_functions($cleanee);
0.000000,0,0.000000,my $store     = $pragma->get_class_store($cleanee);
0.000000,0,0.000000,
0.000000,0,0.000000,# register all unknown previous functions as excluded
0.000000,0,0.000000,for my $f (keys %$functions) {
0.000000,0,0.000000,next if $store->{remove}{ $f }
0.000000,0,0.000000,or $store->{exclude}{ $f };
0.000000,0,0.000000,$store->{exclude}{ $f } = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_class_store {
0.000010,18,0.000001,my ($pragma, $class) = @_;
0.000035,18,0.000002,my $stash = stash_for($class);
0.000010,18,0.000001,my $var = "%$STORAGE_VAR";
0.000279,18,0.000016,$stash->add_symbol($var, {})
0.000000,0,0.000000,unless $stash->has_symbol($var);
0.000191,18,0.000011,return $stash->get_symbol($var);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_functions {
0.000013,18,0.000001,my ($pragma, $class) = @_;
0.000000,0,0.000000,
0.000040,18,0.000002,my $stash = stash_for($class);
0.000000,0,0.000000,return {
0.002111,18,0.000117,map { $_ => $stash->get_symbol("&$_") }
0.000000,0,0.000000,$stash->list_all_symbols('CODE')
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,'Danger! Laws of Thermodynamics may not apply.'
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
