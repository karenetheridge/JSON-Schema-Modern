# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# Convert POD data to formatted text.
0.000000,0,0.000000,#
0.000000,0,0.000000,# This module converts POD to formatted text.  It replaces the old Pod::Text
0.000000,0,0.000000,# module that came with versions of Perl prior to 5.6.0 and attempts to match
0.000000,0,0.000000,# its output except for some specific circumstances where other decisions
0.000000,0,0.000000,# seemed to produce better output.  It uses Pod::Parser and is designed to be
0.000000,0,0.000000,# very easy to subclass.
0.000000,0,0.000000,#
0.000000,0,0.000000,# SPDX-License-Identifier: GPL-1.0-or-later OR Artistic-1.0-Perl
0.000000,0,0.000000,
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,# Modules and declarations
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,
0.000000,0,0.000000,package Pod::Text;
0.000000,0,0.000000,
0.000056,2,0.000028,use 5.008;
0.000032,2,0.000016,use strict;
0.000032,2,0.000016,use warnings;
0.000000,0,0.000000,
0.000030,2,0.000015,use vars qw(@ISA @EXPORT %ESCAPES $VERSION);
0.000000,0,0.000000,
0.000031,2,0.000016,use Carp qw(carp croak);
0.000039,2,0.000019,use Encode qw(encode);
0.000017,2,0.000008,use Exporter ();
0.003505,2,0.001752,use Pod::Simple ();
0.000000,0,0.000000,
0.000016,1,0.000016,@ISA = qw(Pod::Simple Exporter);
0.000000,0,0.000000,
0.000000,0,0.000000,# We have to export pod2text for backward compatibility.
0.000000,1,0.000000,@EXPORT = qw(pod2text);
0.000000,0,0.000000,
0.000001,1,0.000001,$VERSION = '4.14';
0.000000,0,0.000000,
0.000000,0,0.000000,# Ensure that $Pod::Simple::nbsp and $Pod::Simple::shy are available.  Code
0.000000,0,0.000000,# taken from Pod::Simple 3.32, but was only added in 3.30.
0.000001,1,0.000001,my ($NBSP, $SHY);
0.000036,1,0.000036,if ($Pod::Simple::VERSION ge 3.30) {
0.000001,1,0.000001,$NBSP = $Pod::Simple::nbsp;
0.000000,1,0.000000,$SHY  = $Pod::Simple::shy;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$NBSP = chr utf8::unicode_to_native(0xA0);
0.000000,0,0.000000,$SHY  = chr utf8::unicode_to_native(0xAD);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,# Initialization
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,
0.000000,0,0.000000,# This function handles code blocks.  It's registered as a callback to
0.000000,0,0.000000,# Pod::Simple and therefore doesn't work as a regular method call, but all it
0.000000,0,0.000000,# does is call output_code with the line.
0.000000,0,0.000000,sub handle_code {
0.000000,0,0.000000,my ($line, $number, $parser) = @_;
0.000000,0,0.000000,$parser->output_code ($line . "\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Initialize the object and set various Pod::Simple options that we need.
0.000000,0,0.000000,# Here, we also process any additional options passed to the constructor or
0.000000,0,0.000000,# set up defaults if none were given.  Note that all internal object keys are
0.000000,0,0.000000,# in all-caps, reserving all lower-case object keys for Pod::Simple and user
0.000000,0,0.000000,# arguments.
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $self = $class->SUPER::new;
0.000000,0,0.000000,
0.000000,0,0.000000,# Tell Pod::Simple to handle S<> by automatically inserting &nbsp;.
0.000000,0,0.000000,$self->nbsp_for_S (1);
0.000000,0,0.000000,
0.000000,0,0.000000,# Tell Pod::Simple to keep whitespace whenever possible.
0.000000,0,0.000000,if ($self->can ('preserve_whitespace')) {
0.000000,0,0.000000,$self->preserve_whitespace (1);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$self->fullstop_space_harden (1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# The =for and =begin targets that we accept.
0.000000,0,0.000000,$self->accept_targets (qw/text TEXT/);
0.000000,0,0.000000,
0.000000,0,0.000000,# Ensure that contiguous blocks of code are merged together.  Otherwise,
0.000000,0,0.000000,# some of the guesswork heuristics don't work right.
0.000000,0,0.000000,$self->merge_text (1);
0.000000,0,0.000000,
0.000000,0,0.000000,# Pod::Simple doesn't do anything useful with our arguments, but we want
0.000000,0,0.000000,# to put them in our object as hash keys and values.  This could cause
0.000000,0,0.000000,# problems if we ever clash with Pod::Simple's own internal class
0.000000,0,0.000000,# variables.
0.000000,0,0.000000,my %opts = @_;
0.000000,0,0.000000,my @opts = map { ("opt_$_", $opts{$_}) } keys %opts;
0.000000,0,0.000000,%$self = (%$self, @opts);
0.000000,0,0.000000,
0.000000,0,0.000000,# Send errors to stderr if requested.
0.000000,0,0.000000,if ($$self{opt_stderr} and not $$self{opt_errors}) {
0.000000,0,0.000000,$$self{opt_errors} = 'stderr';
0.000000,0,0.000000,}
0.000000,0,0.000000,delete $$self{opt_stderr};
0.000000,0,0.000000,
0.000000,0,0.000000,# Validate the errors parameter and act on it.
0.000000,0,0.000000,if (not defined $$self{opt_errors}) {
0.000000,0,0.000000,$$self{opt_errors} = 'pod';
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($$self{opt_errors} eq 'stderr' || $$self{opt_errors} eq 'die') {
0.000000,0,0.000000,$self->no_errata_section (1);
0.000000,0,0.000000,$self->complain_stderr (1);
0.000000,0,0.000000,if ($$self{opt_errors} eq 'die') {
0.000000,0,0.000000,$$self{complain_die} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif ($$self{opt_errors} eq 'pod') {
0.000000,0,0.000000,$self->no_errata_section (0);
0.000000,0,0.000000,$self->complain_stderr (0);
0.000000,0,0.000000,} elsif ($$self{opt_errors} eq 'none') {
0.000000,0,0.000000,$self->no_errata_section (1);
0.000000,0,0.000000,$self->no_whining (1);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak (qq(Invalid errors setting: "$$self{errors}"));
0.000000,0,0.000000,}
0.000000,0,0.000000,delete $$self{errors};
0.000000,0,0.000000,
0.000000,0,0.000000,# Initialize various things from our parameters.
0.000000,0,0.000000,$$self{opt_alt}      = 0  unless defined $$self{opt_alt};
0.000000,0,0.000000,$$self{opt_indent}   = 4  unless defined $$self{opt_indent};
0.000000,0,0.000000,$$self{opt_margin}   = 0  unless defined $$self{opt_margin};
0.000000,0,0.000000,$$self{opt_loose}    = 0  unless defined $$self{opt_loose};
0.000000,0,0.000000,$$self{opt_sentence} = 0  unless defined $$self{opt_sentence};
0.000000,0,0.000000,$$self{opt_width}    = 76 unless defined $$self{opt_width};
0.000000,0,0.000000,
0.000000,0,0.000000,# Figure out what quotes we'll be using for C<> text.
0.000000,0,0.000000,$$self{opt_quotes} ||= '"';
0.000000,0,0.000000,if ($$self{opt_quotes} eq 'none') {
0.000000,0,0.000000,$$self{LQUOTE} = $$self{RQUOTE} = '';
0.000000,0,0.000000,} elsif (length ($$self{opt_quotes}) == 1) {
0.000000,0,0.000000,$$self{LQUOTE} = $$self{RQUOTE} = $$self{opt_quotes};
0.000000,0,0.000000,} elsif (length ($$self{opt_quotes}) % 2 == 0) {
0.000000,0,0.000000,my $length = length ($$self{opt_quotes}) / 2;
0.000000,0,0.000000,$$self{LQUOTE} = substr ($$self{opt_quotes}, 0, $length);
0.000000,0,0.000000,$$self{RQUOTE} = substr ($$self{opt_quotes}, $length);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak qq(Invalid quote specification "$$self{opt_quotes}");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# If requested, do something with the non-POD text.
0.000000,0,0.000000,$self->code_handler (\&handle_code) if $$self{opt_code};
0.000000,0,0.000000,
0.000000,0,0.000000,# Return the created object.
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,# Core parsing
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,
0.000000,0,0.000000,# This is the glue that connects the code below with Pod::Simple itself.  The
0.000000,0,0.000000,# goal is to convert the event stream coming from the POD parser into method
0.000000,0,0.000000,# calls to handlers once the complete content of a tag has been seen.  Each
0.000000,0,0.000000,# paragraph or POD command will have textual content associated with it, and
0.000000,0,0.000000,# as soon as all of a paragraph or POD command has been seen, that content
0.000000,0,0.000000,# will be passed in to the corresponding method for handling that type of
0.000000,0,0.000000,# object.  The exceptions are handlers for lists, which have opening tag
0.000000,0,0.000000,# handlers and closing tag handlers that will be called right away.
0.000000,0,0.000000,#
0.000000,0,0.000000,# The internal hash key PENDING is used to store the contents of a tag until
0.000000,0,0.000000,# all of it has been seen.  It holds a stack of open tags, each one
0.000000,0,0.000000,# represented by a tuple of the attributes hash for the tag and the contents
0.000000,0,0.000000,# of the tag.
0.000000,0,0.000000,
0.000000,0,0.000000,# Add a block of text to the contents of the current node, formatting it
0.000000,0,0.000000,# according to the current formatting instructions as we do.
0.000000,0,0.000000,sub _handle_text {
0.000000,0,0.000000,my ($self, $text) = @_;
0.000000,0,0.000000,my $tag = $$self{PENDING}[-1];
0.000000,0,0.000000,$$tag[1] .= $text;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Given an element name, get the corresponding method name.
0.000000,0,0.000000,sub method_for_element {
0.000000,0,0.000000,my ($self, $element) = @_;
0.000000,0,0.000000,$element =~ tr/-/_/;
0.000000,0,0.000000,$element =~ tr/A-Z/a-z/;
0.000000,0,0.000000,$element =~ tr/_a-z0-9//cd;
0.000000,0,0.000000,return $element;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Handle the start of a new element.  If cmd_element is defined, assume that
0.000000,0,0.000000,# we need to collect the entire tree for this element before passing it to the
0.000000,0,0.000000,# element method, and create a new tree into which we'll collect blocks of
0.000000,0,0.000000,# text and nested elements.  Otherwise, if start_element is defined, call it.
0.000000,0,0.000000,sub _handle_element_start {
0.000000,0,0.000000,my ($self, $element, $attrs) = @_;
0.000000,0,0.000000,my $method = $self->method_for_element ($element);
0.000000,0,0.000000,
0.000000,0,0.000000,# If we have a command handler, we need to accumulate the contents of the
0.000000,0,0.000000,# tag before calling it.
0.000000,0,0.000000,if ($self->can ("cmd_$method")) {
0.000000,0,0.000000,push (@{ $$self{PENDING} }, [ $attrs, '' ]);
0.000000,0,0.000000,} elsif ($self->can ("start_$method")) {
0.000000,0,0.000000,my $method = 'start_' . $method;
0.000000,0,0.000000,$self->$method ($attrs, '');
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Handle the end of an element.  If we had a cmd_ method for this element,
0.000000,0,0.000000,# this is where we pass along the text that we've accumulated.  Otherwise, if
0.000000,0,0.000000,# we have an end_ method for the element, call that.
0.000000,0,0.000000,sub _handle_element_end {
0.000000,0,0.000000,my ($self, $element) = @_;
0.000000,0,0.000000,my $method = $self->method_for_element ($element);
0.000000,0,0.000000,
0.000000,0,0.000000,# If we have a command handler, pull off the pending text and pass it to
0.000000,0,0.000000,# the handler along with the saved attribute hash.
0.000000,0,0.000000,if ($self->can ("cmd_$method")) {
0.000000,0,0.000000,my $tag = pop @{ $$self{PENDING} };
0.000000,0,0.000000,my $method = 'cmd_' . $method;
0.000000,0,0.000000,my $text = $self->$method (@$tag);
0.000000,0,0.000000,if (defined $text) {
0.000000,0,0.000000,if (@{ $$self{PENDING} } > 1) {
0.000000,0,0.000000,$$self{PENDING}[-1][1] .= $text;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$self->output ($text);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif ($self->can ("end_$method")) {
0.000000,0,0.000000,my $method = 'end_' . $method;
0.000000,0,0.000000,$self->$method ();
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,# Output formatting
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,
0.000000,0,0.000000,# Wrap a line, indenting by the current left margin.  We can't use Text::Wrap
0.000000,0,0.000000,# because it plays games with tabs.  We can't use formline, even though we'd
0.000000,0,0.000000,# really like to, because it screws up non-printing characters.  So we have to
0.000000,0,0.000000,# do the wrapping ourselves.
0.000000,0,0.000000,sub wrap {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,local $_ = shift;
0.000000,0,0.000000,my $output = '';
0.000000,0,0.000000,my $spaces = ' ' x $$self{MARGIN};
0.000000,0,0.000000,my $width = $$self{opt_width} - $$self{MARGIN};
0.000000,0,0.000000,while (length > $width) {
0.000000,0,0.000000,if (s/^([^\n]{0,$width})[ \t\n]+// || s/^([^\n]{$width})//) {
0.000000,0,0.000000,$output .= $spaces . $1 . "\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$output .= $spaces . $_;
0.000000,0,0.000000,$output =~ s/\s+$/\n\n/;
0.000000,0,0.000000,return $output;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Reformat a paragraph of text for the current margin.  Takes the text to
0.000000,0,0.000000,# reformat and returns the formatted text.
0.000000,0,0.000000,sub reformat {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,local $_ = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# If we're trying to preserve two spaces after sentences, do some munging
0.000000,0,0.000000,# to support that.  Otherwise, smash all repeated whitespace.  Be careful
0.000000,0,0.000000,# not to use \s here, which in Unicode input may match non-breaking spaces
0.000000,0,0.000000,# that we don't want to smash.
0.000000,0,0.000000,if ($$self{opt_sentence}) {
0.000000,0,0.000000,s/ +$//mg;
0.000000,0,0.000000,s/\.\n/. \n/g;
0.000000,0,0.000000,s/\n/ /g;
0.000000,0,0.000000,s/   +/  /g;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,s/[ \t\n]+/ /g;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $self->wrap ($_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Output text to the output device.  Replace non-breaking spaces with spaces
0.000000,0,0.000000,# and soft hyphens with nothing, and then try to fix the output encoding if
0.000000,0,0.000000,# necessary to match the input encoding unless UTF-8 output is forced.  This
0.000000,0,0.000000,# preserves the traditional pass-through behavior of Pod::Text.
0.000000,0,0.000000,sub output {
0.000000,0,0.000000,my ($self, @text) = @_;
0.000000,0,0.000000,my $text = join ('', @text);
0.000000,0,0.000000,if ($NBSP) {
0.000000,0,0.000000,$text =~ s/$NBSP/ /g;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($SHY) {
0.000000,0,0.000000,$text =~ s/$SHY//g;
0.000000,0,0.000000,}
0.000000,0,0.000000,unless ($$self{opt_utf8}) {
0.000000,0,0.000000,my $encoding = $$self{encoding} || '';
0.000000,0,0.000000,if ($encoding && $encoding ne $$self{ENCODING}) {
0.000000,0,0.000000,$$self{ENCODING} = $encoding;
0.000000,0,0.000000,eval { binmode ($$self{output_fh}, ":encoding($encoding)") };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($$self{ENCODE}) {
0.000000,0,0.000000,print { $$self{output_fh} } encode ('UTF-8', $text);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,print { $$self{output_fh} } $text;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Output a block of code (something that isn't part of the POD text).  Called
0.000000,0,0.000000,# by preprocess_paragraph only if we were given the code option.  Exists here
0.000000,0,0.000000,# only so that it can be overridden by subclasses.
0.000000,0,0.000000,sub output_code { $_[0]->output ($_[1]) }
0.000000,0,0.000000,
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,# Document initialization
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,
0.000000,0,0.000000,# Set up various things that have to be initialized on a per-document basis.
0.000000,0,0.000000,sub start_document {
0.000000,0,0.000000,my ($self, $attrs) = @_;
0.000000,0,0.000000,if ($$attrs{contentless} && !$$self{ALWAYS_EMIT_SOMETHING}) {
0.000000,0,0.000000,$$self{CONTENTLESS} = 1;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,delete $$self{CONTENTLESS};
0.000000,0,0.000000,}
0.000000,0,0.000000,my $margin = $$self{opt_indent} + $$self{opt_margin};
0.000000,0,0.000000,
0.000000,0,0.000000,# Initialize a few per-document variables.
0.000000,0,0.000000,$$self{INDENTS} = [];       # Stack of indentations.
0.000000,0,0.000000,$$self{MARGIN}  = $margin;  # Default left margin.
0.000000,0,0.000000,$$self{PENDING} = [[]];     # Pending output.
0.000000,0,0.000000,
0.000000,0,0.000000,# We have to redo encoding handling for each document.
0.000000,0,0.000000,$$self{ENCODING} = '';
0.000000,0,0.000000,
0.000000,0,0.000000,# When UTF-8 output is set, check whether our output file handle already
0.000000,0,0.000000,# has a PerlIO encoding layer set.  If it does not, we'll need to encode
0.000000,0,0.000000,# our output before printing it (handled in the output() sub).
0.000000,0,0.000000,$$self{ENCODE} = 0;
0.000000,0,0.000000,if ($$self{opt_utf8}) {
0.000000,0,0.000000,$$self{ENCODE} = 1;
0.000000,0,0.000000,eval {
0.000000,0,0.000000,my @options = (output => 1, details => 1);
0.000000,0,0.000000,my $flag = (PerlIO::get_layers ($$self{output_fh}, @options))[-1];
0.000000,0,0.000000,if ($flag && ($flag & PerlIO::F_UTF8 ())) {
0.000000,0,0.000000,$$self{ENCODE} = 0;
0.000000,0,0.000000,$$self{ENCODING} = 'UTF-8';
0.000000,0,0.000000,}
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Handle the end of the document.  The only thing we do is handle dying on POD
0.000000,0,0.000000,# errors, since Pod::Parser currently doesn't.
0.000000,0,0.000000,sub end_document {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,if ($$self{complain_die} && $self->errors_seen) {
0.000000,0,0.000000,croak ("POD document had syntax errors");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,# Text blocks
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,
0.000000,0,0.000000,# Intended for subclasses to override, this method returns text with any
0.000000,0,0.000000,# non-printing formatting codes stripped out so that length() correctly
0.000000,0,0.000000,# returns the length of the text.  For basic Pod::Text, it does nothing.
0.000000,0,0.000000,sub strip_format {
0.000000,0,0.000000,my ($self, $string) = @_;
0.000000,0,0.000000,return $string;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This method is called whenever an =item command is complete (in other words,
0.000000,0,0.000000,# we've seen its associated paragraph or know for certain that it doesn't have
0.000000,0,0.000000,# one).  It gets the paragraph associated with the item as an argument.  If
0.000000,0,0.000000,# that argument is empty, just output the item tag; if it contains a newline,
0.000000,0,0.000000,# output the item tag followed by the newline.  Otherwise, see if there's
0.000000,0,0.000000,# enough room for us to output the item tag in the margin of the text or if we
0.000000,0,0.000000,# have to put it on a separate line.
0.000000,0,0.000000,sub item {
0.000000,0,0.000000,my ($self, $text) = @_;
0.000000,0,0.000000,my $tag = $$self{ITEM};
0.000000,0,0.000000,unless (defined $tag) {
0.000000,0,0.000000,carp "Item called without tag";
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,undef $$self{ITEM};
0.000000,0,0.000000,
0.000000,0,0.000000,# Calculate the indentation and margin.  $fits is set to true if the tag
0.000000,0,0.000000,# will fit into the margin of the paragraph given our indentation level.
0.000000,0,0.000000,my $indent = $$self{INDENTS}[-1];
0.000000,0,0.000000,$indent = $$self{opt_indent} unless defined $indent;
0.000000,0,0.000000,my $margin = ' ' x $$self{opt_margin};
0.000000,0,0.000000,my $tag_length = length ($self->strip_format ($tag));
0.000000,0,0.000000,my $fits = ($$self{MARGIN} - $indent >= $tag_length + 1);
0.000000,0,0.000000,
0.000000,0,0.000000,# If the tag doesn't fit, or if we have no associated text, print out the
0.000000,0,0.000000,# tag separately.  Otherwise, put the tag in the margin of the paragraph.
0.000000,0,0.000000,if (!$text || $text =~ /^\s+$/ || !$fits) {
0.000000,0,0.000000,my $realindent = $$self{MARGIN};
0.000000,0,0.000000,$$self{MARGIN} = $indent;
0.000000,0,0.000000,my $output = $self->reformat ($tag);
0.000000,0,0.000000,$output =~ s/^$margin /$margin:/ if ($$self{opt_alt} && $indent > 0);
0.000000,0,0.000000,$output =~ s/\n*$/\n/;
0.000000,0,0.000000,
0.000000,0,0.000000,# If the text is just whitespace, we have an empty item paragraph;
0.000000,0,0.000000,# this can result from =over/=item/=back without any intermixed
0.000000,0,0.000000,# paragraphs.  Insert some whitespace to keep the =item from merging
0.000000,0,0.000000,# into the next paragraph.
0.000000,0,0.000000,$output .= "\n" if $text && $text =~ /^\s*$/;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->output ($output);
0.000000,0,0.000000,$$self{MARGIN} = $realindent;
0.000000,0,0.000000,$self->output ($self->reformat ($text)) if ($text && $text =~ /\S/);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,my $space = ' ' x $indent;
0.000000,0,0.000000,$space =~ s/^$margin /$margin:/ if $$self{opt_alt};
0.000000,0,0.000000,$text = $self->reformat ($text);
0.000000,0,0.000000,$text =~ s/^$margin /$margin:/ if ($$self{opt_alt} && $indent > 0);
0.000000,0,0.000000,my $tagspace = ' ' x $tag_length;
0.000000,0,0.000000,$text =~ s/^($space)$tagspace/$1$tag/ or warn "Bizarre space in item";
0.000000,0,0.000000,$self->output ($text);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Handle a basic block of text.  The only tricky thing here is that if there
0.000000,0,0.000000,# is a pending item tag, we need to format this as an item paragraph.
0.000000,0,0.000000,sub cmd_para {
0.000000,0,0.000000,my ($self, $attrs, $text) = @_;
0.000000,0,0.000000,$text =~ s/\s+$/\n/;
0.000000,0,0.000000,if (defined $$self{ITEM}) {
0.000000,0,0.000000,$self->item ($text . "\n");
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$self->output ($self->reformat ($text . "\n"));
0.000000,0,0.000000,}
0.000000,0,0.000000,return '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Handle a verbatim paragraph.  Just print it out, but indent it according to
0.000000,0,0.000000,# our margin.
0.000000,0,0.000000,sub cmd_verbatim {
0.000000,0,0.000000,my ($self, $attrs, $text) = @_;
0.000000,0,0.000000,$self->item if defined $$self{ITEM};
0.000000,0,0.000000,return if $text =~ /^\s*$/;
0.000000,0,0.000000,$text =~ s/^(\n*)([ \t]*\S+)/$1 . (' ' x $$self{MARGIN}) . $2/gme;
0.000000,0,0.000000,$text =~ s/\s*$/\n\n/;
0.000000,0,0.000000,$self->output ($text);
0.000000,0,0.000000,return '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Handle literal text (produced by =for and similar constructs).  Just output
0.000000,0,0.000000,# it with the minimum of changes.
0.000000,0,0.000000,sub cmd_data {
0.000000,0,0.000000,my ($self, $attrs, $text) = @_;
0.000000,0,0.000000,$text =~ s/^\n+//;
0.000000,0,0.000000,$text =~ s/\n{0,2}$/\n/;
0.000000,0,0.000000,$self->output ($text);
0.000000,0,0.000000,return '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,# Headings
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,
0.000000,0,0.000000,# The common code for handling all headers.  Takes the header text, the
0.000000,0,0.000000,# indentation, and the surrounding marker for the alt formatting method.
0.000000,0,0.000000,sub heading {
0.000000,0,0.000000,my ($self, $text, $indent, $marker) = @_;
0.000000,0,0.000000,$self->item ("\n\n") if defined $$self{ITEM};
0.000000,0,0.000000,$text =~ s/\s+$//;
0.000000,0,0.000000,if ($$self{opt_alt}) {
0.000000,0,0.000000,my $closemark = reverse (split (//, $marker));
0.000000,0,0.000000,my $margin = ' ' x $$self{opt_margin};
0.000000,0,0.000000,$self->output ("\n" . "$margin$marker $text $closemark" . "\n\n");
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$text .= "\n" if $$self{opt_loose};
0.000000,0,0.000000,my $margin = ' ' x ($$self{opt_margin} + $indent);
0.000000,0,0.000000,$self->output ($margin . $text . "\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,return '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# First level heading.
0.000000,0,0.000000,sub cmd_head1 {
0.000000,0,0.000000,my ($self, $attrs, $text) = @_;
0.000000,0,0.000000,$self->heading ($text, 0, '====');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Second level heading.
0.000000,0,0.000000,sub cmd_head2 {
0.000000,0,0.000000,my ($self, $attrs, $text) = @_;
0.000000,0,0.000000,$self->heading ($text, $$self{opt_indent} / 2, '==  ');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Third level heading.
0.000000,0,0.000000,sub cmd_head3 {
0.000000,0,0.000000,my ($self, $attrs, $text) = @_;
0.000000,0,0.000000,$self->heading ($text, $$self{opt_indent} * 2 / 3 + 0.5, '=   ');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Fourth level heading.
0.000000,0,0.000000,sub cmd_head4 {
0.000000,0,0.000000,my ($self, $attrs, $text) = @_;
0.000000,0,0.000000,$self->heading ($text, $$self{opt_indent} * 3 / 4 + 0.5, '-   ');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,# List handling
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,
0.000000,0,0.000000,# Handle the beginning of an =over block.  Takes the type of the block as the
0.000000,0,0.000000,# first argument, and then the attr hash.  This is called by the handlers for
0.000000,0,0.000000,# the four different types of lists (bullet, number, text, and block).
0.000000,0,0.000000,sub over_common_start {
0.000000,0,0.000000,my ($self, $attrs) = @_;
0.000000,0,0.000000,$self->item ("\n\n") if defined $$self{ITEM};
0.000000,0,0.000000,
0.000000,0,0.000000,# Find the indentation level.
0.000000,0,0.000000,my $indent = $$attrs{indent};
0.000000,0,0.000000,unless (defined ($indent) && $indent =~ /^\s*[-+]?\d{1,4}\s*$/) {
0.000000,0,0.000000,$indent = $$self{opt_indent};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Add this to our stack of indents and increase our current margin.
0.000000,0,0.000000,push (@{ $$self{INDENTS} }, $$self{MARGIN});
0.000000,0,0.000000,$$self{MARGIN} += ($indent + 0);
0.000000,0,0.000000,return '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# End an =over block.  Takes no options other than the class pointer.  Output
0.000000,0,0.000000,# any pending items and then pop one level of indentation.
0.000000,0,0.000000,sub over_common_end {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,$self->item ("\n\n") if defined $$self{ITEM};
0.000000,0,0.000000,$$self{MARGIN} = pop @{ $$self{INDENTS} };
0.000000,0,0.000000,return '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Dispatch the start and end calls as appropriate.
0.000000,0,0.000000,sub start_over_bullet { $_[0]->over_common_start ($_[1]) }
0.000000,0,0.000000,sub start_over_number { $_[0]->over_common_start ($_[1]) }
0.000000,0,0.000000,sub start_over_text   { $_[0]->over_common_start ($_[1]) }
0.000000,0,0.000000,sub start_over_block  { $_[0]->over_common_start ($_[1]) }
0.000000,0,0.000000,sub end_over_bullet { $_[0]->over_common_end }
0.000000,0,0.000000,sub end_over_number { $_[0]->over_common_end }
0.000000,0,0.000000,sub end_over_text   { $_[0]->over_common_end }
0.000000,0,0.000000,sub end_over_block  { $_[0]->over_common_end }
0.000000,0,0.000000,
0.000000,0,0.000000,# The common handler for all item commands.  Takes the type of the item, the
0.000000,0,0.000000,# attributes, and then the text of the item.
0.000000,0,0.000000,sub item_common {
0.000000,0,0.000000,my ($self, $type, $attrs, $text) = @_;
0.000000,0,0.000000,$self->item if defined $$self{ITEM};
0.000000,0,0.000000,
0.000000,0,0.000000,# Clean up the text.  We want to end up with two variables, one ($text)
0.000000,0,0.000000,# which contains any body text after taking out the item portion, and
0.000000,0,0.000000,# another ($item) which contains the actual item text.  Note the use of
0.000000,0,0.000000,# the internal Pod::Simple attribute here; that's a potential land mine.
0.000000,0,0.000000,$text =~ s/\s+$//;
0.000000,0,0.000000,my ($item, $index);
0.000000,0,0.000000,if ($type eq 'bullet') {
0.000000,0,0.000000,$item = '*';
0.000000,0,0.000000,} elsif ($type eq 'number') {
0.000000,0,0.000000,$item = $$attrs{'~orig_content'};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$item = $text;
0.000000,0,0.000000,$item =~ s/\s*\n\s*/ /g;
0.000000,0,0.000000,$text = '';
0.000000,0,0.000000,}
0.000000,0,0.000000,$$self{ITEM} = $item;
0.000000,0,0.000000,
0.000000,0,0.000000,# If body text for this item was included, go ahead and output that now.
0.000000,0,0.000000,if ($text) {
0.000000,0,0.000000,$text =~ s/\s*$/\n/;
0.000000,0,0.000000,$self->item ($text);
0.000000,0,0.000000,}
0.000000,0,0.000000,return '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Dispatch the item commands to the appropriate place.
0.000000,0,0.000000,sub cmd_item_bullet { my $self = shift; $self->item_common ('bullet', @_) }
0.000000,0,0.000000,sub cmd_item_number { my $self = shift; $self->item_common ('number', @_) }
0.000000,0,0.000000,sub cmd_item_text   { my $self = shift; $self->item_common ('text',   @_) }
0.000000,0,0.000000,sub cmd_item_block  { my $self = shift; $self->item_common ('block',  @_) }
0.000000,0,0.000000,
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,# Formatting codes
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,
0.000000,0,0.000000,# The simple ones.
0.000000,0,0.000000,sub cmd_b { return $_[0]{alt} ? "``$_[2]''" : $_[2] }
0.000000,0,0.000000,sub cmd_f { return $_[0]{alt} ? "\"$_[2]\"" : $_[2] }
0.000000,0,0.000000,sub cmd_i { return '*' . $_[2] . '*' }
0.000000,0,0.000000,sub cmd_x { return '' }
0.000000,0,0.000000,
0.000000,0,0.000000,# Apply a whole bunch of messy heuristics to not quote things that don't
0.000000,0,0.000000,# benefit from being quoted.  These originally come from Barrie Slaymaker and
0.000000,0,0.000000,# largely duplicate code in Pod::Man.
0.000000,0,0.000000,sub cmd_c {
0.000000,0,0.000000,my ($self, $attrs, $text) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# A regex that matches the portion of a variable reference that's the
0.000000,0,0.000000,# array or hash index, separated out just because we want to use it in
0.000000,0,0.000000,# several places in the following regex.
0.000000,0,0.000000,my $index = '(?: \[.*\] | \{.*\} )?';
0.000000,0,0.000000,
0.000000,0,0.000000,# Check for things that we don't want to quote, and if we find any of
0.000000,0,0.000000,# them, return the string with just a font change and no quoting.
0.000000,0,0.000000,$text =~ m{
0.000000,0,0.000000,^\s*
0.000000,0,0.000000,(?:
0.000000,0,0.000000,( [\'\`\"] ) .* \1                             # already quoted
0.000000,0,0.000000,| \` .* \'                                       # `quoted'
0.000000,0,0.000000,| \$+ [\#^]? \S $index                           # special ($^Foo, $")
0.000000,0,0.000000,| [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
0.000000,0,0.000000,| [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
0.000000,0,0.000000,| [+-]? ( \d[\d.]* | \.\d+ ) (?: [eE][+-]?\d+ )? # a number
0.000000,0,0.000000,| 0x [a-fA-F\d]+                                 # a hex constant
0.000000,0,0.000000,)
0.000000,0,0.000000,\s*\z
0.000000,0,0.000000,}xo && return $text;
0.000000,0,0.000000,
0.000000,0,0.000000,# If we didn't return, go ahead and quote the text.
0.000000,0,0.000000,return $$self{opt_alt}
0.000000,0,0.000000,? "``$text''"
0.000000,0,0.000000,: "$$self{LQUOTE}$text$$self{RQUOTE}";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Links reduce to the text that we're given, wrapped in angle brackets if it's
0.000000,0,0.000000,# a URL.
0.000000,0,0.000000,sub cmd_l {
0.000000,0,0.000000,my ($self, $attrs, $text) = @_;
0.000000,0,0.000000,if ($$attrs{type} eq 'url') {
0.000000,0,0.000000,if (not defined($$attrs{to}) or $$attrs{to} eq $text) {
0.000000,0,0.000000,return "<$text>";
0.000000,0,0.000000,} elsif ($$self{opt_nourls}) {
0.000000,0,0.000000,return $text;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return "$text <$$attrs{to}>";
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return $text;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,# Backwards compatibility
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,
0.000000,0,0.000000,# The old Pod::Text module did everything in a pod2text() function.  This
0.000000,0,0.000000,# tries to provide the same interface for legacy applications.
0.000000,0,0.000000,sub pod2text {
0.000000,0,0.000000,my @args;
0.000000,0,0.000000,
0.000000,0,0.000000,# This is really ugly; I hate doing option parsing in the middle of a
0.000000,0,0.000000,# module.  But the old Pod::Text module supported passing flags to its
0.000000,0,0.000000,# entry function, so handle -a and -<number>.
0.000000,0,0.000000,while ($_[0] =~ /^-/) {
0.000000,0,0.000000,my $flag = shift;
0.000000,0,0.000000,if    ($flag eq '-a')       { push (@args, alt => 1)    }
0.000000,0,0.000000,elsif ($flag =~ /^-(\d+)$/) { push (@args, width => $1) }
0.000000,0,0.000000,else {
0.000000,0,0.000000,unshift (@_, $flag);
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Now that we know what arguments we're using, create the parser.
0.000000,0,0.000000,my $parser = Pod::Text->new (@args);
0.000000,0,0.000000,
0.000000,0,0.000000,# If two arguments were given, the second argument is going to be a file
0.000000,0,0.000000,# handle.  That means we want to call parse_from_filehandle(), which means
0.000000,0,0.000000,# we need to turn the first argument into a file handle.  Magic open will
0.000000,0,0.000000,# handle the <&STDIN case automagically.
0.000000,0,0.000000,if (defined $_[1]) {
0.000000,0,0.000000,my @fhs = @_;
0.000000,0,0.000000,local *IN;
0.000000,0,0.000000,unless (open (IN, $fhs[0])) {
0.000000,0,0.000000,croak ("Can't open $fhs[0] for reading: $!\n");
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,$fhs[0] = \*IN;
0.000000,0,0.000000,$parser->output_fh ($fhs[1]);
0.000000,0,0.000000,my $retval = $parser->parse_file ($fhs[0]);
0.000000,0,0.000000,my $fh = $parser->output_fh ();
0.000000,0,0.000000,close $fh;
0.000000,0,0.000000,return $retval;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$parser->output_fh (\*STDOUT);
0.000000,0,0.000000,return $parser->parse_file (@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Reset the underlying Pod::Simple object between calls to parse_from_file so
0.000000,0,0.000000,# that the same object can be reused to convert multiple pages.
0.000000,0,0.000000,sub parse_from_file {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->reinit;
0.000000,0,0.000000,
0.000000,0,0.000000,# Fake the old cutting option to Pod::Parser.  This fiddles with internal
0.000000,0,0.000000,# Pod::Simple state and is quite ugly; we need a better approach.
0.000000,0,0.000000,if (ref ($_[0]) eq 'HASH') {
0.000000,0,0.000000,my $opts = shift @_;
0.000000,0,0.000000,if (defined ($$opts{-cutting}) && !$$opts{-cutting}) {
0.000000,0,0.000000,$$self{in_pod} = 1;
0.000000,0,0.000000,$$self{last_was_blank} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Do the work.
0.000000,0,0.000000,my $retval = $self->Pod::Simple::parse_from_file (@_);
0.000000,0,0.000000,
0.000000,0,0.000000,# Flush output, since Pod::Simple doesn't do this.  Ideally we should also
0.000000,0,0.000000,# close the file descriptor if we had to open one, but we can't easily
0.000000,0,0.000000,# figure this out.
0.000000,0,0.000000,my $fh = $self->output_fh ();
0.000000,0,0.000000,my $oldfh = select $fh;
0.000000,0,0.000000,my $oldflush = $|;
0.000000,0,0.000000,$| = 1;
0.000000,0,0.000000,print $fh '';
0.000000,0,0.000000,$| = $oldflush;
0.000000,0,0.000000,select $oldfh;
0.000000,0,0.000000,return $retval;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Pod::Simple failed to provide this backward compatibility function, so
0.000000,0,0.000000,# implement it ourselves.  File handles are one of the inputs that
0.000000,0,0.000000,# parse_from_file supports.
0.000000,0,0.000000,sub parse_from_filehandle {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->parse_from_file (@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Pod::Simple's parse_file doesn't set output_fh.  Wrap the call and do so
0.000000,0,0.000000,# ourself unless it was already set by the caller, since our documentation has
0.000000,0,0.000000,# always said that this should work.
0.000000,0,0.000000,sub parse_file {
0.000000,0,0.000000,my ($self, $in) = @_;
0.000000,0,0.000000,unless (defined $$self{output_fh}) {
0.000000,0,0.000000,$self->output_fh (\*STDOUT);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $self->SUPER::parse_file ($in);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Do the same for parse_lines, just to be polite.  Pod::Simple's man page
0.000000,0,0.000000,# implies that the caller is responsible for setting this, but I don't see any
0.000000,0,0.000000,# reason not to set a default.
0.000000,0,0.000000,sub parse_lines {
0.000000,0,0.000000,my ($self, @lines) = @_;
0.000000,0,0.000000,unless (defined $$self{output_fh}) {
0.000000,0,0.000000,$self->output_fh (\*STDOUT);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $self->SUPER::parse_lines (@lines);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Likewise for parse_string_document.
0.000000,0,0.000000,sub parse_string_document {
0.000000,0,0.000000,my ($self, $doc) = @_;
0.000000,0,0.000000,unless (defined $$self{output_fh}) {
0.000000,0,0.000000,$self->output_fh (\*STDOUT);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $self->SUPER::parse_string_document ($doc);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,# Module return value and documentation
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,
0.000008,1,0.000008,1;
0.000000,0,0.000000,__END__
