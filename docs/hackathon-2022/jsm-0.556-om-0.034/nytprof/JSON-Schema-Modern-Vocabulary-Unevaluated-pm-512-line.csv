# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000030,2,0.000015,use strict;
0.000037,2,0.000018,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Vocabulary::Unevaluated;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Implementation of the JSON Schema Unevaluated vocabulary
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.556';
0.000000,0,0.000000,
0.000032,2,0.000016,use 5.020;
0.000026,2,0.000013,use Moo;
0.000039,3,0.000013,use strictures 2;
0.000038,2,0.000019,use experimental qw(signatures postderef);
0.000023,2,0.000012,use if "$]" >= 5.022, experimental => 're_strict';
0.000022,2,0.000011,no if "$]" >= 5.031009, feature => 'indirect';
0.000021,2,0.000011,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000019,2,0.000010,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000035,3,0.000012,use List::Util 1.45 qw(any max);
0.000016,2,0.000008,use JSON::Schema::Modern::Utilities qw(is_type jsonp local_annotations E A abort true);
0.001214,2,0.000607,use namespace::clean;
0.000000,0,0.000000,
0.000002,1,0.000002,with 'JSON::Schema::Modern::Vocabulary';
0.000000,0,0.000000,
0.000000,0,0.000000,sub vocabulary {
0.000003,1,0.000003,'https://json-schema.org/draft/2020-12/vocab/unevaluated' => 'draft2020-12';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,2,0.000003,sub evaluation_order { 7 }
0.000000,0,0.000000,
0.000000,0,0.000000,# This vocabulary should be evaluated after the Applicator vocabulary.
0.000001,6,0.000000,sub keywords ($self, $spec_version) {
0.000019,2,0.000010,die 'Unevaluated not implemented in '.$spec_version if $spec_version =~ /^draft[467]$/;
0.000008,2,0.000004,qw(unevaluatedItems unevaluatedProperties);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_unevaluatedItems ($self, $schema, $state) {
0.000000,0,0.000000,my $valid = $self->traverse_subschema($schema, $state);
0.000000,0,0.000000,
0.000000,0,0.000000,# remember that annotations need to be collected in order to evaluate this keyword
0.000000,0,0.000000,$state->{configs}{collect_annotations} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_unevaluatedItems ($self, $data, $schema, $state) {
0.000000,0,0.000000,abort($state, 'EXCEPTION: "unevaluatedItems" keyword present, but annotation collection is disabled')
0.000000,0,0.000000,if not $state->{collect_annotations};
0.000000,0,0.000000,
0.000000,0,0.000000,abort($state, 'EXCEPTION: "unevaluatedItems" keyword present, but short_circuit is enabled: results unreliable')
0.000000,0,0.000000,if $state->{short_circuit};
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if not is_type('array', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,my @annotations = local_annotations($state);
0.000000,0,0.000000,
0.000000,0,0.000000,# a relevant keyword already produced a 'true' annotation at this location
0.000000,0,0.000000,my @boolean_annotation_keywords =
0.000000,0,0.000000,$state->{spec_version} eq 'draft2019-09' ? qw(items additionalItems unevaluatedItems)
0.000000,0,0.000000,: qw(prefixItems items contains unevaluatedItems);
0.000000,0,0.000000,my %bools; @bools{@boolean_annotation_keywords} = (1)x@boolean_annotation_keywords;
0.000000,0,0.000000,return 1
0.000000,0,0.000000,if any { $bools{$_->keyword} && is_type('boolean', $_->annotation) && $_->annotation }
0.000000,0,0.000000,@annotations;
0.000000,0,0.000000,
0.000000,0,0.000000,# otherwise, evaluate at every instance item greater than the max of all 'prefixItems'/numeric
0.000000,0,0.000000,# 'items' annotations that isn't in a 'contains' annotation
0.000000,0,0.000000,my $max_index_annotation_keyword = $state->{spec_version} eq 'draft2019-09' ? 'items' : 'prefixItems';
0.000000,0,0.000000,my $last_index = max(-1, grep is_type('integer', $_),
0.000000,0,0.000000,map +($_->keyword eq $max_index_annotation_keyword ? $_->annotation : ()), @annotations);
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if $last_index == $data->$#*;
0.000000,0,0.000000,
0.000000,0,0.000000,my @contains_annotation_indexes = $state->{spec_version} eq 'draft2019-09' ? ()
0.000000,0,0.000000,: map +($_->keyword eq 'contains' ? $_->annotation->@* : ()), @annotations;
0.000000,0,0.000000,
0.000000,0,0.000000,my $valid = 1;
0.000000,0,0.000000,foreach my $idx ($last_index+1 .. $data->$#*) {
0.000000,0,0.000000,next if any { $idx == $_ } @contains_annotation_indexes;
0.000000,0,0.000000,if (is_type('boolean', $schema->{unevaluatedItems})) {
0.000000,0,0.000000,next if $schema->{unevaluatedItems};
0.000000,0,0.000000,$valid = E({ %$state, data_path => $state->{data_path}.'/'.$idx },
0.000000,0,0.000000,'additional item not permitted')
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($self->eval($data->[$idx], $schema->{unevaluatedItems},
0.000000,0,0.000000,+{ %$state, data_path => $state->{data_path}.'/'.$idx,
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/unevaluatedItems' })) {
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,A($state, true);
0.000000,0,0.000000,return E($state, 'subschema is not valid against all additional items') if not $valid;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000160,624,0.000000,sub _traverse_keyword_unevaluatedProperties ($self, $schema, $state) {
0.000752,156,0.000005,my $valid = $self->traverse_subschema($schema, $state);
0.000000,0,0.000000,
0.000000,0,0.000000,# remember that annotations need to be collected in order to evaluate this keyword
0.000206,156,0.000001,$state->{configs}{collect_annotations} = 1;
0.000000,0,0.000000,
0.000385,156,0.000002,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.004425,18735,0.000000,sub _eval_keyword_unevaluatedProperties ($self, $data, $schema, $state) {
0.000000,0,0.000000,abort($state, 'EXCEPTION: "unevaluatedProperties" keyword present, but annotation collection is disabled')
0.001641,3747,0.000000,if not $state->{collect_annotations};
0.000000,0,0.000000,
0.000000,0,0.000000,abort($state, 'EXCEPTION: "unevaluatedProperties" keyword present, but short_circuit is enabled: results unreliable')
0.001754,3747,0.000000,if $state->{short_circuit};
0.000000,0,0.000000,
0.005318,3747,0.000001,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,my @evaluated_properties = map {
0.021162,12745,0.000002,my $keyword = $_->keyword;
0.019235,8998,0.000002,(grep $keyword eq $_, qw(properties additionalProperties patternProperties unevaluatedProperties))
0.000000,0,0.000000,? $_->annotation->@* : ();
0.000000,0,0.000000,} local_annotations($state);
0.000000,0,0.000000,
0.000798,3747,0.000000,my $valid = 1;
0.000695,3747,0.000000,my @properties;
0.021981,3747,0.000006,foreach my $property (sort keys %$data) {
0.051751,54233,0.000001,next if any { $_ eq $property } @evaluated_properties;
0.000000,0,0.000000,push @properties, $property;
0.000000,0,0.000000,
0.000000,0,0.000000,if (is_type('boolean', $schema->{unevaluatedProperties})) {
0.000000,0,0.000000,next if $schema->{unevaluatedProperties};
0.000000,0,0.000000,$valid = E({ %$state, data_path => jsonp($state->{data_path}, $property) },
0.000000,0,0.000000,'additional property not permitted');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($self->eval($data->{$property}, $schema->{unevaluatedProperties},
0.000000,0,0.000000,+{ %$state, data_path => jsonp($state->{data_path}, $property),
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/unevaluatedProperties' })) {
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.004561,3747,0.000001,A($state, \@properties);
0.000927,3747,0.000000,return E($state, 'not all additional properties are valid') if not $valid;
0.011381,3747,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,1;
0.000000,0,0.000000,
0.000033,1,0.000033,__END__
