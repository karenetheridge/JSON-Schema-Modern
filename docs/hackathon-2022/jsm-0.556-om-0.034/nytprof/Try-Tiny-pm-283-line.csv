# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Try::Tiny; # git description: v0.30-11-g1b81d0a
0.000050,2,0.000025,use 5.006;
0.000000,0,0.000000,# ABSTRACT: Minimal try/catch with proper preservation of $@
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.31';
0.000000,0,0.000000,
0.000019,2,0.000010,use strict;
0.000017,2,0.000008,use warnings;
0.000000,0,0.000000,
0.000044,3,0.000015,use Exporter 5.57 'import';
0.000001,1,0.000001,our @EXPORT = our @EXPORT_OK = qw(try catch finally);
0.000000,0,0.000000,
0.000166,2,0.000083,use Carp;
0.000000,1,0.000000,$Carp::Internal{+__PACKAGE__}++;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000001,1,0.000001,my $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname;
0.000000,1,0.000000,my $sn = $INC{'Sub/Name.pm'} && eval { Sub::Name->VERSION(0.08) };
0.000000,1,0.000000,unless ($su || $sn) {
0.000000,0,0.000000,$su = eval { require Sub::Util; } && defined &Sub::Util::set_subname;
0.000000,0,0.000000,unless ($su) {
0.000000,0,0.000000,$sn = eval { require Sub::Name; Sub::Name->VERSION(0.08) };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,*_subname = $su ? \&Sub::Util::set_subname
0.000000,0,0.000000,: $sn ? \&Sub::Name::subname
0.000001,1,0.000001,: sub { $_[1] };
0.000007,1,0.000007,*_HAS_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
0.000278,1,0.000278,}
0.000000,0,0.000000,
0.000000,1,0.000000,my %_finally_guards;
0.000000,0,0.000000,
0.000000,0,0.000000,# Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
0.000000,0,0.000000,# Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
0.000000,0,0.000000,# context & not a scalar one
0.000000,0,0.000000,
0.000000,0,0.000000,sub try (&;@) {
0.000002,2,0.000001,my ( $try, @code_refs ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# we need to save this here, the eval block will be in scalar context due
0.000000,0,0.000000,# to $failed
0.000001,2,0.000000,my $wantarray = wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,# work around perl bug by explicitly initializing these, due to the likelyhood
0.000000,0,0.000000,# this will be used in global destruction (perl rt#119311)
0.000000,2,0.000000,my ( $catch, @finally ) = ();
0.000000,0,0.000000,
0.000000,0,0.000000,# find labeled blocks in the argument list.
0.000000,0,0.000000,# catch and finally tag the blocks by blessing a scalar reference to them.
0.000000,2,0.000000,foreach my $code_ref (@code_refs) {
0.000000,0,0.000000,
0.000002,2,0.000001,if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
0.000002,2,0.000001,croak 'A try() may not be followed by multiple catch() blocks'
0.000000,0,0.000000,if $catch;
0.000000,2,0.000000,$catch = ${$code_ref};
0.000000,0,0.000000,} elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
0.000000,0,0.000000,push @finally, ${$code_ref};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak(
0.000000,0,0.000000,'try() encountered an unexpected argument ('
0.000000,0,0.000000,. ( defined $code_ref ? $code_ref : 'undef' )
0.000000,0,0.000000,. ') - perhaps a missing semi-colon before or'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
0.000000,0,0.000000,# not perfect, but we could provide a list of additional errors for
0.000000,0,0.000000,# $catch->();
0.000000,0,0.000000,
0.000000,0,0.000000,# name the blocks if we have Sub::Name installed
0.000037,2,0.000018,_subname(caller().'::try {...} ' => $try)
0.000000,0,0.000000,if _HAS_SUBNAME;
0.000000,0,0.000000,
0.000000,0,0.000000,# set up scope guards to invoke the finally blocks at the end.
0.000000,0,0.000000,# this should really be a function scope lexical variable instead of
0.000000,0,0.000000,# file scope + local but that causes issues with perls < 5.20 due to
0.000000,0,0.000000,# perl rt#119311
0.000000,0,0.000000,local $_finally_guards{guards} = [
0.000004,2,0.000002,map Try::Tiny::ScopeGuard->_new($_),
0.000000,0,0.000000,@finally
0.000000,0,0.000000,];
0.000000,0,0.000000,
0.000000,0,0.000000,# save the value of $@ so we can set $@ back to it in the beginning of the eval
0.000000,0,0.000000,# and restore $@ after the eval finishes
0.000001,2,0.000000,my $prev_error = $@;
0.000000,0,0.000000,
0.000001,2,0.000000,my ( @ret, $error );
0.000000,0,0.000000,
0.000000,0,0.000000,# failed will be true if the eval dies, because 1 will not be returned
0.000000,0,0.000000,# from the eval body
0.000002,2,0.000001,my $failed = not eval {
0.000001,2,0.000000,$@ = $prev_error;
0.000000,0,0.000000,
0.000000,0,0.000000,# evaluate the try block in the correct context
0.000005,2,0.000002,if ( $wantarray ) {
0.000000,0,0.000000,@ret = $try->();
0.000000,0,0.000000,} elsif ( defined $wantarray ) {
0.000000,0,0.000000,$ret[0] = $try->();
0.000000,0,0.000000,} else {
0.000003,2,0.000002,$try->();
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,2,0.000000,return 1; # properly set $failed to false
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,# preserve the current error and reset the original value of $@
0.000001,2,0.000000,$error = $@;
0.000000,2,0.000000,$@ = $prev_error;
0.000000,0,0.000000,
0.000000,0,0.000000,# at this point $failed contains a true value if the eval died, even if some
0.000000,0,0.000000,# destructor overwrote $@ as the eval was unwinding.
0.000000,2,0.000000,if ( $failed ) {
0.000000,0,0.000000,# pass $error to the finally blocks
0.000000,0,0.000000,push @$_, $error for @{$_finally_guards{guards}};
0.000000,0,0.000000,
0.000000,0,0.000000,# if we got an error, invoke the catch block.
0.000000,0,0.000000,if ( $catch ) {
0.000000,0,0.000000,# This works like given($error), but is backwards compatible and
0.000000,0,0.000000,# sets $_ in the dynamic scope for the body of C<$catch>
0.000000,0,0.000000,for ($error) {
0.000000,0,0.000000,return $catch->($error);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# in case when() was used without an explicit return, the C<for>
0.000000,0,0.000000,# loop will be aborted and there's no useful return value
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# no failure, $@ is back to what it was, everything is fine
0.000012,2,0.000006,return $wantarray ? @ret : $ret[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub catch (&;@) {
0.000000,2,0.000000,my ( $block, @rest ) = @_;
0.000000,0,0.000000,
0.000001,2,0.000000,croak 'Useless bare catch()' unless wantarray;
0.000000,0,0.000000,
0.000025,2,0.000012,_subname(caller().'::catch {...} ' => $block)
0.000000,0,0.000000,if _HAS_SUBNAME;
0.000000,0,0.000000,return (
0.000014,2,0.000007,bless(\$block, 'Try::Tiny::Catch'),
0.000000,0,0.000000,@rest,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub finally (&;@) {
0.000000,0,0.000000,my ( $block, @rest ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,croak 'Useless bare finally()' unless wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,_subname(caller().'::finally {...} ' => $block)
0.000000,0,0.000000,if _HAS_SUBNAME;
0.000000,0,0.000000,return (
0.000000,0,0.000000,bless(\$block, 'Try::Tiny::Finally'),
0.000000,0,0.000000,@rest,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,package # hide from PAUSE
0.000000,0,0.000000,Try::Tiny::ScopeGuard;
0.000000,0,0.000000,
0.000156,2,0.000078,use constant UNSTABLE_DOLLARAT => ("$]" < '5.013002') ? 1 : 0;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _new {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,bless [ @_ ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub DESTROY {
0.000000,0,0.000000,my ($code, @args) = @{ $_[0] };
0.000000,0,0.000000,
0.000000,0,0.000000,local $@ if UNSTABLE_DOLLARAT;
0.000000,0,0.000000,eval {
0.000000,0,0.000000,$code->(@args);
0.000000,0,0.000000,1;
0.000000,0,0.000000,} or do {
0.000000,0,0.000000,warn
0.000000,0,0.000000,"Execution of finally() block $code resulted in an exception, which "
0.000000,0,0.000000,. '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
0.000000,0,0.000000,. 'Your program will continue as if this event never took place. '
0.000000,0,0.000000,. "Original exception text follows:\n\n"
0.000000,0,0.000000,. (defined $@ ? $@ : '$@ left undefined...')
0.000000,0,0.000000,. "\n"
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,__PACKAGE__
0.000000,0,0.000000,__END__
0.000004,1,0.000004,
