# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Data::Perl::Role::Collection::Array;
0.000002,1,0.000002,$Data::Perl::Role::Collection::Array::VERSION = '0.002011';
0.000000,0,0.000000,# ABSTRACT: Wrapping class for Perl's built in array structure.
0.000000,0,0.000000,
0.000027,3,0.000009,use strictures 1;
0.000000,0,0.000000,
0.000021,2,0.000011,use Role::Tiny;
0.000016,2,0.000008,use List::Util;
0.000025,2,0.000013,use List::MoreUtils;
0.000073,2,0.000036,use Scalar::Util qw/blessed/;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my $cl = CORE::shift; bless([ @_ ], $cl)
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# find the package name if possible else default to __PACKAGE__
0.000000,0,0.000000,#sub _blessed { blessed($_[0]) || __PACKAGE__ }
0.000000,0,0.000000,
0.000034,17,0.000002,sub count { CORE::scalar @{$_[0]} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_empty { CORE::scalar @{$_[0]} ? 0 : 1 }
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.001422,3,0.000474,no warnings 'once';
0.000000,0,0.000000,sub all { @{$_[0]} }
0.000000,0,0.000000,
0.000003,1,0.000003,*elements = *all;
0.000001,1,0.000001,*flatten = *all;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get { $_[0]->[ $_[1] ] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub pop { CORE::pop @{$_[0]} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub push { CORE::push @{$_[0]}, @_[1..$#_] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub shift { CORE::shift @{$_[0]} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub unshift { CORE::unshift @{$_[0]}, @_[1..$#_] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub clear { @{$_[0]} = () }
0.000000,0,0.000000,
0.000000,0,0.000000,sub first { &List::Util::first($_[1], @{$_[0]}) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub first_index { &List::MoreUtils::first_index($_[1], @{$_[0]}) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub reduce { List::Util::reduce { $_[1]->($a, $b) } @{$_[0]} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub set { $_[0]->[ $_[1] ] = $_[2] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub accessor {
0.000000,0,0.000000,if (@_ == 2) {
0.000000,0,0.000000,$_[0]->[$_[1]];
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (@_ > 2) {
0.000000,0,0.000000,$_[0]->[$_[1]] = $_[2];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub natatime {
0.000000,0,0.000000,my $iter = List::MoreUtils::natatime($_[1], @{$_[0]});
0.000000,0,0.000000,
0.000000,0,0.000000,if ($_[2]) {
0.000000,0,0.000000,while (my @vals = $iter->()) {
0.000000,0,0.000000,$_[2]->(@vals);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$iter;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub shallow_clone { blessed($_[0]) ? bless([@{$_[0]}], ref $_[0]) : [@{$_[0]}] }
0.000000,0,0.000000,
0.000000,0,0.000000,# Data::Collection methods that return a Data::Perl::Collection::Array object
0.000000,0,0.000000,#sub members {
0.000000,0,0.000000,#  my ($self) = @_;
0.000000,0,0.000000,#  qw/map grep member_count sort reverse print any all one none join/;
0.000000,0,0.000000,#}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub map {
0.000000,0,0.000000,my ($self, $cb) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @res = CORE::map { $cb->($_) } @$self;
0.000000,0,0.000000,
0.000000,0,0.000000,blessed($self) ? blessed($self)->new(@res) : @res;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub grep {
0.000000,0,0.000000,my ($self, $cb) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @res = CORE::grep { $cb->($_) } @$self;
0.000000,0,0.000000,
0.000000,0,0.000000,blessed($self) ? blessed($self)->new(@res) : @res;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sort {
0.000000,0,0.000000,my ($self, $cb) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @res = $cb ? CORE::sort { $cb->($a, $b) } @$self : CORE::sort @$self;
0.000000,0,0.000000,
0.000000,0,0.000000,blessed($self) ? blessed($self)->new(@res) : @res;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub reverse {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @res = CORE::reverse @$self;
0.000000,0,0.000000,
0.000000,0,0.000000,blessed($self) ? blessed($self)->new(@res) : @res;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sort_in_place {
0.000000,0,0.000000,@{$_[0]} = ($_[1] ? sort { $_[1]->($a, $b) } @{$_[0]} : sort @{$_[0]});
0.000000,0,0.000000,$_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub splice {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @res = CORE::splice @{$_[0]}, $_[1], $_[2], @_[3..$#_];
0.000000,0,0.000000,
0.000000,0,0.000000,blessed($self) ? blessed($self)->new(@res) : @res;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub shuffle {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @res = List::Util::shuffle(@$self);
0.000000,0,0.000000,
0.000000,0,0.000000,blessed($self) ? blessed($self)->new(@res) : @res;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub uniq {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @res = List::MoreUtils::uniq(@$self);
0.000000,0,0.000000,
0.000000,0,0.000000,blessed($self) ? blessed($self)->new(@res) : @res;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub delete {
0.000000,0,0.000000,my ($self, $idx) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($res) = CORE::splice(@$self, $idx, 1);
0.000000,0,0.000000,
0.000000,0,0.000000,$res;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub insert {
0.000000,0,0.000000,my ($self, $idx, $el) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($res) = CORE::splice(@$self, $idx, 0, $el);
0.000000,0,0.000000,
0.000000,0,0.000000,$res;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub flatten_deep {
0.000000,0,0.000000,my ($self, $depth) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,_flatten_deep(@$self, $depth);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _flatten_deep {
0.000000,0,0.000000,my @array = @_;
0.000000,0,0.000000,my $depth = CORE::pop @array;
0.000000,0,0.000000,--$depth if (defined($depth));
0.000000,0,0.000000,
0.000000,0,0.000000,my @elements = CORE::map {
0.000000,0,0.000000,(ref eq 'ARRAY')
0.000000,0,0.000000,? (defined($depth) && $depth == -1) ? $_ : _flatten_deep( @$_, $depth )
0.000000,0,0.000000,: $_
0.000000,0,0.000000,} @array;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub join {
0.000000,0,0.000000,my ($self, $with) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,CORE::join((defined $with ? $with : ','), @$self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub print {
0.000000,0,0.000000,my ($self, $fh, $arg) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,print { $fh || *STDOUT } CORE::join((defined $arg ? $arg : ','), @$self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub head {
0.000000,0,0.000000,my ($self, $count) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$count = $self->count if $count > $self->count;
0.000000,0,0.000000,$count = $self->count - -$count if $count < 0;
0.000000,0,0.000000,
0.000000,0,0.000000,my @res = ($self->elements)[0 .. $count - 1];
0.000000,0,0.000000,
0.000000,0,0.000000,blessed($self) ? blessed($self)->new(@res) : @res;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub tail {
0.000000,0,0.000000,my ($self, $count) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$count = $self->count if $count > $self->count;
0.000000,0,0.000000,$count = $self->count - -$count if $count < 0;
0.000000,0,0.000000,my $start = $self->count - $count;
0.000000,0,0.000000,
0.000000,0,0.000000,my @res = ($self->elements)[$start .. $self->count - 1];
0.000000,0,0.000000,
0.000000,0,0.000000,blessed($self) ? blessed($self)->new(@res) : @res;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000013,1,0.000013,1;
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=encoding UTF-8
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,Data::Perl::Role::Collection::Array - Wrapping class for Perl's built in array structure.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 VERSION
0.000000,0,0.000000,
0.000000,0,0.000000,version 0.002011
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use Data::Perl qw/array/;
0.000000,0,0.000000,
0.000000,0,0.000000,my $array = array(1, 2, 3);
0.000000,0,0.000000,
0.000000,0,0.000000,$array->push(5);
0.000000,0,0.000000,
0.000000,0,0.000000,$array->grep(sub { $_ > 2 })->map(sub { $_ ** 2 })->elements; # (3, 5);
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,This class provides a wrapper and methods for interacting with an array.
0.000000,0,0.000000,All methods that return a list do so via a Data::Perl::Collection::Array object.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 PROVIDED METHODS
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<new($value, $value, ....)>
0.000000,0,0.000000,
0.000000,0,0.000000,Constructs a new Data::Perl::Collection::Array object initialized with passed
0.000000,0,0.000000,in values, and returns it.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<count>
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the number of elements in the array.
0.000000,0,0.000000,
0.000000,0,0.000000,$stuff = Data::Perl::Collection::Array->new(qw/foo bar baz boo/);
0.000000,0,0.000000,
0.000000,0,0.000000,print $stuff->count; # prints 4
0.000000,0,0.000000,
0.000000,0,0.000000,This method does not accept any arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<is_empty>
0.000000,0,0.000000,
0.000000,0,0.000000,Returns a boolean value that is true when the array has no elements.
0.000000,0,0.000000,
0.000000,0,0.000000,$stuff->is_empty ? die "No options!\n" : print "Good boy.\n";
0.000000,0,0.000000,
0.000000,0,0.000000,This method does not accept any arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<elements/all>
0.000000,0,0.000000,
0.000000,0,0.000000,Returns all of the elements of the array as an array (not an array reference).
0.000000,0,0.000000,
0.000000,0,0.000000,my @options = $stuff->elements;
0.000000,0,0.000000,print "@options\n";    # prints "foo bar baz boo"
0.000000,0,0.000000,
0.000000,0,0.000000,This method does not accept any arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<get($index)>
0.000000,0,0.000000,
0.000000,0,0.000000,Returns an element of the array by its index. You can also use negative index
0.000000,0,0.000000,numbers, just as with Perl's core array handling.
0.000000,0,0.000000,
0.000000,0,0.000000,my $option = $stuff->get(1);
0.000000,0,0.000000,print "$option\n";    # prints "bar"
0.000000,0,0.000000,
0.000000,0,0.000000,If the specified element does not exist, this will return C<undef>.
0.000000,0,0.000000,
0.000000,0,0.000000,This method accepts just one argument.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<pop>
0.000000,0,0.000000,
0.000000,0,0.000000,Just like Perl's builtin C<pop>.
0.000000,0,0.000000,
0.000000,0,0.000000,This method does not accept any arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<push($value1, $value2, value3 ...)>
0.000000,0,0.000000,
0.000000,0,0.000000,Just like Perl's builtin C<push>. Returns the number of elements in the new
0.000000,0,0.000000,array.
0.000000,0,0.000000,
0.000000,0,0.000000,This method accepts any number of arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<shift>
0.000000,0,0.000000,
0.000000,0,0.000000,Just like Perl's builtin C<shift>.
0.000000,0,0.000000,
0.000000,0,0.000000,This method does not accept any arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<unshift($value1, $value2, value3 ...)>
0.000000,0,0.000000,
0.000000,0,0.000000,Just like Perl's builtin C<unshift>. Returns the number of elements in the new
0.000000,0,0.000000,array.
0.000000,0,0.000000,
0.000000,0,0.000000,This method accepts any number of arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<splice($offset, $length, @values)>
0.000000,0,0.000000,
0.000000,0,0.000000,Just like Perl's builtin C<splice>. In scalar context, this returns the last
0.000000,0,0.000000,element removed, or C<undef> if no elements were removed. In list context, this
0.000000,0,0.000000,returns all the elements removed from the array, wrapped in a Collection::Array
0.000000,0,0.000000,object.
0.000000,0,0.000000,
0.000000,0,0.000000,This method requires at least one argument.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<first( sub { ... } )>
0.000000,0,0.000000,
0.000000,0,0.000000,This method returns the first matching item in the array, just like
0.000000,0,0.000000,L<List::Util>'s C<first> function. The matching is done with a subroutine
0.000000,0,0.000000,reference you pass to this method. The subroutine will be called against each
0.000000,0,0.000000,element in the array until one matches or all elements have been checked.
0.000000,0,0.000000,
0.000000,0,0.000000,my $found = $stuff->find_option( sub {/^b/} );
0.000000,0,0.000000,print "$found\n";    # prints "bar"
0.000000,0,0.000000,
0.000000,0,0.000000,This method requires a single argument.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<first_index( sub { ... } )>
0.000000,0,0.000000,
0.000000,0,0.000000,This method returns the index of the first matching item in the array, just
0.000000,0,0.000000,like L<List::MoreUtils>'s C<first_index> function. The matching is done with a
0.000000,0,0.000000,subroutine reference you pass to this method. The subroutine will be called
0.000000,0,0.000000,against each element in the array until one matches or all elements have been
0.000000,0,0.000000,checked.
0.000000,0,0.000000,
0.000000,0,0.000000,This method requires a single argument.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<grep( sub { ... } )>
0.000000,0,0.000000,
0.000000,0,0.000000,This method returns every element matching a given criteria, just like Perl's
0.000000,0,0.000000,core C<grep> function. This method requires a subroutine which implements the
0.000000,0,0.000000,matching logic. The returned list is provided as a Collection::Array object.
0.000000,0,0.000000,
0.000000,0,0.000000,my @found = $stuff->grep( sub {/^b/} );
0.000000,0,0.000000,print "@found\n";    # prints "bar baz boo"
0.000000,0,0.000000,
0.000000,0,0.000000,This method requires a single argument.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<map( sub { ... } )>
0.000000,0,0.000000,
0.000000,0,0.000000,This method transforms every element in the array and returns a new array, just
0.000000,0,0.000000,like Perl's core C<map> function. This method requires a subroutine which
0.000000,0,0.000000,implements the transformation. The returned list is provided as
0.000000,0,0.000000,a Collection::Array object.
0.000000,0,0.000000,
0.000000,0,0.000000,my @mod_options = $stuff->map( sub { $_ . "-tag" } );
0.000000,0,0.000000,print "@mod_options\n";    # prints "foo-tag bar-tag baz-tag boo-tag"
0.000000,0,0.000000,
0.000000,0,0.000000,This method requires a single argument.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<reduce( sub { ... } )>
0.000000,0,0.000000,
0.000000,0,0.000000,This method turns an array into a single value, by passing a function the
0.000000,0,0.000000,value so far and the next value in the array, just like L<List::Util>'s
0.000000,0,0.000000,C<reduce> function. The reducing is done with a subroutine reference you pass
0.000000,0,0.000000,to this method.
0.000000,0,0.000000,
0.000000,0,0.000000,my $found = $stuff->reduce( sub { $_[0] . $_[1] } );
0.000000,0,0.000000,print "$found\n";    # prints "foobarbazboo"
0.000000,0,0.000000,
0.000000,0,0.000000,This method requires a single argument.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<sort>
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<sort( sub { ... } )>
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the elements of the array in sorted order.
0.000000,0,0.000000,
0.000000,0,0.000000,You can provide an optional subroutine reference to sort with (as you can with
0.000000,0,0.000000,Perl's core C<sort> function). However, instead of using C<$a> and C<$b> in
0.000000,0,0.000000,this subroutine, you will need to use C<$_[0]> and C<$_[1]>. The returned list
0.000000,0,0.000000,is provided as a Collection::Array object.
0.000000,0,0.000000,
0.000000,0,0.000000,# ascending ASCIIbetical
0.000000,0,0.000000,my @sorted = $stuff->sort();
0.000000,0,0.000000,
0.000000,0,0.000000,# Descending alphabetical order
0.000000,0,0.000000,my @sorted_options = $stuff->sort( sub { lc $_[1] cmp lc $_[0] } );
0.000000,0,0.000000,print "@sorted_options\n";    # prints "foo boo baz bar"
0.000000,0,0.000000,
0.000000,0,0.000000,This method accepts a single argument.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<sort_in_place>
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<sort_in_place( sub { ... } )>
0.000000,0,0.000000,
0.000000,0,0.000000,Sorts the array I<in place>, modifying the value of the attribute.
0.000000,0,0.000000,
0.000000,0,0.000000,You can provide an optional subroutine reference to sort with (as you can with
0.000000,0,0.000000,Perl's core C<sort> function). However, instead of using C<$a> and C<$b>, you
0.000000,0,0.000000,will need to use C<$_[0]> and C<$_[1]> instead. The returned list is provided
0.000000,0,0.000000,as a Collection::Array object.
0.000000,0,0.000000,
0.000000,0,0.000000,This method accepts a single argument.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<reverse>
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the elements of the array in reversed order. The returned list is
0.000000,0,0.000000,provided as a Collection::Array object.
0.000000,0,0.000000,
0.000000,0,0.000000,This method does not accept any arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<shuffle>
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the elements of the array in random order, like C<shuffle> from
0.000000,0,0.000000,L<List::Util>. The returned list is provided as a Collection::Array object.
0.000000,0,0.000000,
0.000000,0,0.000000,This method does not accept any arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<uniq>
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the array with all duplicate elements removed, like C<uniq> from
0.000000,0,0.000000,L<List::MoreUtils>. The returned list is provided as a Collection::Array object.
0.000000,0,0.000000,
0.000000,0,0.000000,This method does not accept any arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<head($count)>
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the first C<$count> elements of the array. If C<$count> is greater
0.000000,0,0.000000,than the number of elements in the array, the array (without spurious C<undef>s)
0.000000,0,0.000000,is returned. Negative C<$count> means "all but the last C<$count> elements". The
0.000000,0,0.000000,returned list is provided as a Collection::Array object.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<tail($count)>
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the last C<$count> elements of the array. If C<$count> is greater
0.000000,0,0.000000,than the number of elements in the array, the array (without spurious C<undef>s)
0.000000,0,0.000000,is returned. Negative C<$count> means "all but the first C<$count> elements". The
0.000000,0,0.000000,returned list is provided as a Collection::Array object.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<join($str)>
0.000000,0,0.000000,
0.000000,0,0.000000,Joins every element of the array using the separator given as argument, just
0.000000,0,0.000000,like Perl's core C<join> function.
0.000000,0,0.000000,
0.000000,0,0.000000,my $joined = $stuff->join(':');
0.000000,0,0.000000,print "$joined\n";    # prints "foo:bar:baz:boo"
0.000000,0,0.000000,
0.000000,0,0.000000,This method requires a single argument.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<print($handle, $str)>
0.000000,0,0.000000,
0.000000,0,0.000000,Prints the output of join($str) to $handle. $handle defaults to STDOUT, and
0.000000,0,0.000000,join $str defaults to join()'s default of ','.
0.000000,0,0.000000,
0.000000,0,0.000000,$joined = $stuff->print(*STDERR, ';'); # prints foo;bar;baz to STDERR
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<set($index, $value)>
0.000000,0,0.000000,
0.000000,0,0.000000,Given an index and a value, sets the specified array element's value.
0.000000,0,0.000000,
0.000000,0,0.000000,This method returns the value at C<$index> after the set.
0.000000,0,0.000000,
0.000000,0,0.000000,This method requires two arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<delete($index)>
0.000000,0,0.000000,
0.000000,0,0.000000,Removes the element at the given index from the array.
0.000000,0,0.000000,
0.000000,0,0.000000,This method returns the deleted value, either as an array or scalar as
0.000000,0,0.000000,dependent on splice context semantics. Note that if no value exists, it will
0.000000,0,0.000000,
0.000000,0,0.000000,return C<undef>.
0.000000,0,0.000000,
0.000000,0,0.000000,This method requires one argument.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<insert($index, $value)>
0.000000,0,0.000000,
0.000000,0,0.000000,Inserts a new element into the array at the given index.
0.000000,0,0.000000,
0.000000,0,0.000000,This method returns the new value at C<$index>, either as an array or scalar as
0.000000,0,0.000000,dependent on splice context semantics.
0.000000,0,0.000000,
0.000000,0,0.000000,This method requires two arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<clear>
0.000000,0,0.000000,
0.000000,0,0.000000,Empties the entire array, like C<@array = ()>.
0.000000,0,0.000000,
0.000000,0,0.000000,This method does not define a return value.
0.000000,0,0.000000,
0.000000,0,0.000000,This method does not accept any arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<accessor($index)>
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<accessor($index, $value)>
0.000000,0,0.000000,
0.000000,0,0.000000,This method provides a get/set accessor for the array, based on array indexes.
0.000000,0,0.000000,If passed one argument, it returns the value at the specified index.  If
0.000000,0,0.000000,passed two arguments, it sets the value of the specified index.
0.000000,0,0.000000,
0.000000,0,0.000000,When called as a setter, this method returns the new value at C<$index>.
0.000000,0,0.000000,
0.000000,0,0.000000,This method accepts one or two arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<natatime($n)>
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<natatime($n, $code)>
0.000000,0,0.000000,
0.000000,0,0.000000,This method returns an iterator which, on each call, returns C<$n> more items
0.000000,0,0.000000,from the array, in order, like C<natatime> from L<List::MoreUtils>. A coderef
0.000000,0,0.000000,can optionally be provided; it will be called on each group of C<$n> elements
0.000000,0,0.000000,in the array.
0.000000,0,0.000000,
0.000000,0,0.000000,This method accepts one or two arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<shallow_clone>
0.000000,0,0.000000,
0.000000,0,0.000000,This method returns a shallow clone of the array reference.  The return value
0.000000,0,0.000000,is a reference to a new array with the same elements.  It is I<shallow>
0.000000,0,0.000000,because any elements that were references in the original will be the I<same>
0.000000,0,0.000000,references in the clone.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<flatten>
0.000000,0,0.000000,
0.000000,0,0.000000,This method returns a list of elements in the array.  This method is an alias
0.000000,0,0.000000,to the I<elements> method.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<flatten_deep($level)>
0.000000,0,0.000000,
0.000000,0,0.000000,This method returns a flattened list of elements in the array. Will flatten
0.000000,0,0.000000,arrays contained within the root array recursively - depth is controlled by the
0.000000,0,0.000000,optional $level parameter.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * L<Data::Perl>
0.000000,0,0.000000,
0.000000,0,0.000000,=item * L<MooX::HandlesVia>
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHOR
0.000000,0,0.000000,
0.000000,0,0.000000,Matthew Phillips <mattp@cpan.org>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT AND LICENSE
0.000000,0,0.000000,
0.000000,0,0.000000,This software is copyright (c) 2020 by Matthew Phillips <mattp@cpan.org>.
0.000000,0,0.000000,
0.000000,0,0.000000,This is free software; you can redistribute it and/or modify it under
0.000000,0,0.000000,the same terms as the Perl 5 programming language system itself.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
