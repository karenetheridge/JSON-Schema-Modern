# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000011,1,0.000011,require 5;
0.000000,0,0.000000,package Pod::Simple;
0.000036,2,0.000018,use strict;
0.000047,2,0.000024,use Carp ();
0.000021,1,0.000021,BEGIN           { *DEBUG = sub () {0} unless defined &DEBUG }
0.000032,2,0.000016,use integer;
0.000326,3,0.000109,use Pod::Escapes 1.04 ();
0.000250,2,0.000125,use Pod::Simple::LinkSection ();
0.000017,2,0.000008,use Pod::Simple::BlackBox ();
0.000291,2,0.000146,use Pod::Simple::TiedOutFH;
0.000000,0,0.000000,#use utf8;
0.000000,0,0.000000,
0.000000,1,0.000000,use vars qw(
0.000000,0,0.000000,$VERSION @ISA
0.000000,0,0.000000,@Known_formatting_codes  @Known_directives
0.000000,0,0.000000,%Known_formatting_codes  %Known_directives
0.000000,0,0.000000,$NL
0.000181,1,0.000181,);
0.000000,0,0.000000,
0.000011,1,0.000011,@ISA = ('Pod::Simple::BlackBox');
0.000000,1,0.000000,$VERSION = '3.43';
0.000000,0,0.000000,
0.000002,1,0.000002,@Known_formatting_codes = qw(I B C L E F S X Z); 
0.000006,1,0.000006,%Known_formatting_codes = map(($_=>1), @Known_formatting_codes);
0.000001,1,0.000001,@Known_directives       = qw(head1 head2 head3 head4 head5 head6 item over back); 
0.000005,1,0.000005,%Known_directives       = map(($_=>'Plain'), @Known_directives);
0.000002,1,0.000002,$NL = $/ unless defined $NL;
0.000000,0,0.000000,
0.000000,0,0.000000,#-----------------------------------------------------------------------------
0.000000,0,0.000000,# Set up some constants:
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000001,1,0.000001,if(defined &ASCII)    { }
0.000000,0,0.000000,elsif(chr(65) eq 'A') { *ASCII = sub () {1}  }
0.000000,0,0.000000,else                  { *ASCII = sub () {''} }
0.000000,0,0.000000,
0.000001,1,0.000001,unless(defined &MANY_LINES) { *MANY_LINES = sub () {20} }
0.000000,0,0.000000,DEBUG > 4 and print STDERR "MANY_LINES is ", MANY_LINES(), "\n";
0.000028,1,0.000028,unless(MANY_LINES() >= 1) {
0.000000,0,0.000000,die "MANY_LINES is too small (", MANY_LINES(), ")!\nAborting";
0.000000,0,0.000000,}
0.000002,1,0.000002,if(defined &UNICODE) { }
0.000000,0,0.000000,elsif($] >= 5.008)   { *UNICODE = sub() {1}  }
0.000000,0,0.000000,else                 { *UNICODE = sub() {''} }
0.000245,1,0.000245,}
0.000000,0,0.000000,if(DEBUG > 2) {
0.000000,0,0.000000,print STDERR "# We are ", ASCII ? '' : 'not ', "in ASCII-land\n";
0.000000,0,0.000000,print STDERR "# We are under a Unicode-safe Perl.\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# The NO BREAK SPACE and SOFT HYHPEN are used in several submodules.
0.000005,1,0.000005,if ($] ge 5.007_003) {  # On sufficiently modern Perls we can handle any
0.000000,0,0.000000,# character set
0.000000,1,0.000000,$Pod::Simple::nbsp = chr utf8::unicode_to_native(0xA0);
0.000001,1,0.000001,$Pod::Simple::shy  = chr utf8::unicode_to_native(0xAD);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (Pod::Simple::ASCII) {  # Hard code ASCII early Perl
0.000000,0,0.000000,$Pod::Simple::nbsp = "\xA0";
0.000000,0,0.000000,$Pod::Simple::shy  = "\xAD";
0.000000,0,0.000000,}
0.000000,0,0.000000,else { # EBCDIC on early Perl.  We know what the values are for the code
0.000000,0,0.000000,# pages supported then.
0.000000,0,0.000000,$Pod::Simple::nbsp = "\x41";
0.000000,0,0.000000,$Pod::Simple::shy  = "\xCA";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Design note:
0.000000,0,0.000000,# This is a parser for Pod.  It is not a parser for the set of Pod-like
0.000000,0,0.000000,#  languages which happens to contain Pod -- it is just for Pod, plus possibly
0.000000,0,0.000000,#  some extensions.
0.000000,0,0.000000,
0.000000,0,0.000000,# @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @
0.000000,0,0.000000,#@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000004,1,0.000004,__PACKAGE__->_accessorize(
0.000000,0,0.000000,'_output_is_for_JustPod', # For use only by Pod::Simple::JustPod,
0.000000,0,0.000000,# If non-zero, don't expand Z<> E<> S<> L<>,
0.000000,0,0.000000,# and count how many brackets in format codes
0.000000,0,0.000000,'nbsp_for_S',        # Whether to map S<...>'s to \xA0 characters
0.000000,0,0.000000,'source_filename',   # Filename of the source, for use in warnings
0.000000,0,0.000000,'source_dead',       # Whether to consider this parser's source dead
0.000000,0,0.000000,
0.000000,0,0.000000,'output_fh',         # The filehandle we're writing to, if applicable.
0.000000,0,0.000000,# Used only in some derived classes.
0.000000,0,0.000000,
0.000000,0,0.000000,'hide_line_numbers', # For some dumping subclasses: whether to pointedly
0.000000,0,0.000000,# suppress the start_line attribute
0.000000,0,0.000000,
0.000000,0,0.000000,'line_count',        # the current line number
0.000000,0,0.000000,'pod_para_count',    # count of pod paragraphs seen so far
0.000000,0,0.000000,
0.000000,0,0.000000,'no_whining',        # whether to suppress whining
0.000000,0,0.000000,'no_errata_section', # whether to suppress the errata section
0.000000,0,0.000000,'complain_stderr',   # whether to complain to stderr
0.000000,0,0.000000,
0.000000,0,0.000000,'doc_has_started',   # whether we've fired the open-Document event yet
0.000000,0,0.000000,
0.000000,0,0.000000,'bare_output',       # For some subclasses: whether to prepend
0.000000,0,0.000000,#  header-code and postpend footer-code
0.000000,0,0.000000,
0.000000,0,0.000000,'keep_encoding_directive',  # whether to emit =encoding
0.000000,0,0.000000,'nix_X_codes',       # whether to ignore X<...> codes
0.000000,0,0.000000,'merge_text',        # whether to avoid breaking a single piece of
0.000000,0,0.000000,#  text up into several events
0.000000,0,0.000000,
0.000000,0,0.000000,'preserve_whitespace', # whether to try to keep whitespace as-is
0.000000,0,0.000000,'strip_verbatim_indent', # What indent to strip from verbatim
0.000000,0,0.000000,'expand_verbatim_tabs',  # 0: preserve tabs in verbatim blocks
0.000000,0,0.000000,# n: expand tabs to stops every n columns
0.000000,0,0.000000,
0.000000,0,0.000000,'parse_characters',  # Whether parser should expect chars rather than octets
0.000000,0,0.000000,
0.000000,0,0.000000,'content_seen',      # whether we've seen any real Pod content
0.000000,0,0.000000,'errors_seen',       # TODO: document.  whether we've seen any errors (fatal or not)
0.000000,0,0.000000,
0.000000,0,0.000000,'codes_in_verbatim', # for PseudoPod extensions
0.000000,0,0.000000,
0.000000,0,0.000000,'code_handler',      # coderef to call when a code (non-pod) line is seen
0.000000,0,0.000000,'cut_handler',       # ... when a =cut line is seen
0.000000,0,0.000000,'pod_handler',       # ... when a =pod line is seen
0.000000,0,0.000000,'whiteline_handler', # ... when a line with only whitespace is seen
0.000000,0,0.000000,#Called like:
0.000000,0,0.000000,# $code_handler->($line, $self->{'line_count'}, $self) if $code_handler;
0.000000,0,0.000000,#  $cut_handler->($line, $self->{'line_count'}, $self) if $cut_handler;
0.000000,0,0.000000,#  $pod_handler->($line, $self->{'line_count'}, $self) if $pod_handler;
0.000000,0,0.000000,#   $wl_handler->($line, $self->{'line_count'}, $self) if $wl_handler;
0.000000,0,0.000000,'parse_empty_lists', # whether to acknowledge empty =over/=back blocks
0.000000,0,0.000000,'raw_mode',          # to report entire raw lines instead of Pod elements
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub any_errata_seen {  # good for using as an exit() value...
0.000000,0,0.000000,return shift->{'errors_seen'} || 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub errata_seen {
0.000000,0,0.000000,return shift->{'all_errata'} || {};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Returns the encoding only if it was recognized as being handled and set
0.000000,0,0.000000,sub detected_encoding {
0.000000,0,0.000000,return shift->{'detected_encoding'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub encoding {
0.000000,0,0.000000,my $this = shift;
0.000000,0,0.000000,return $this->{'encoding'} unless @_;  # GET.
0.000000,0,0.000000,
0.000000,0,0.000000,$this->_handle_encoding_line("=encoding $_[0]");
0.000000,0,0.000000,if ($this->{'_processed_encoding'}) {
0.000000,0,0.000000,delete $this->{'_processed_encoding'};
0.000000,0,0.000000,if(! $this->{'encoding_command_statuses'} ) {
0.000000,0,0.000000,DEBUG > 2 and print STDERR " CRAZY ERROR: encoding wasn't really handled?!\n";
0.000000,0,0.000000,} elsif( $this->{'encoding_command_statuses'}[-1] ) {
0.000000,0,0.000000,$this->scream( "=encoding $_[0]",
0.000000,0,0.000000,sprintf "Couldn't do %s: %s",
0.000000,0,0.000000,$this->{'encoding_command_reqs'  }[-1],
0.000000,0,0.000000,$this->{'encoding_command_statuses'}[-1],
0.000000,0,0.000000,);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 2 and print STDERR " (encoding successfully handled.)\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,return $this->{'encoding'};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,# Pull in some functions that, for some reason, I expect to see here too:
0.000000,0,0.000000,BEGIN {
0.000001,1,0.000001,*pretty        = \&Pod::Simple::BlackBox::pretty;
0.000000,1,0.000000,*stringify_lol = \&Pod::Simple::BlackBox::stringify_lol;
0.000002,1,0.000002,*my_qr         = \&Pod::Simple::BlackBox::my_qr;
0.005916,1,0.005916,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub version_report {
0.000000,0,0.000000,my $class = ref($_[0]) || $_[0];
0.000000,0,0.000000,if($class eq __PACKAGE__) {
0.000000,0,0.000000,return "$class $VERSION";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,my $v = $class->VERSION;
0.000000,0,0.000000,return "$class $v (" . __PACKAGE__ . " $VERSION)";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,#sub curr_open { # read-only list accessor
0.000000,0,0.000000,#  return @{ $_[0]{'curr_open'} || return() };
0.000000,0,0.000000,#}
0.000000,0,0.000000,#sub _curr_open_listref { $_[0]{'curr_open'} ||= [] }
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub output_string {
0.000000,0,0.000000,# Works by faking out output_fh.  Simplifies our code.
0.000000,0,0.000000,#
0.000000,0,0.000000,my $this = shift;
0.000000,0,0.000000,return $this->{'output_string'} unless @_;  # GET.
0.000000,0,0.000000,
0.000000,0,0.000000,my $x = (defined($_[0]) and ref($_[0])) ? $_[0] : \( $_[0] );
0.000000,0,0.000000,$$x = '' unless defined $$x;
0.000000,0,0.000000,DEBUG > 4 and print STDERR "# Output string set to $x ($$x)\n";
0.000000,0,0.000000,$this->{'output_fh'} = Pod::Simple::TiedOutFH->handle_on($_[0]);
0.000000,0,0.000000,return
0.000000,0,0.000000,$this->{'output_string'} = $_[0];
0.000000,0,0.000000,#${ ${ $this->{'output_fh'} } };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub abandon_output_string { $_[0]->abandon_output_fh; delete $_[0]{'output_string'} }
0.000000,0,0.000000,sub abandon_output_fh     { $_[0]->output_fh(undef) }
0.000000,0,0.000000,# These don't delete the string or close the FH -- they just delete our
0.000000,0,0.000000,#  references to it/them.
0.000000,0,0.000000,# TODO: document these
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,# takes no parameters
0.000000,0,0.000000,my $class = ref($_[0]) || $_[0];
0.000000,0,0.000000,#Carp::croak(__PACKAGE__ . " is a virtual base class -- see perldoc "
0.000000,0,0.000000,#  . __PACKAGE__ );
0.000000,0,0.000000,my $obj = bless {
0.000000,0,0.000000,'accept_codes'      => { map( ($_=>$_), @Known_formatting_codes ) },
0.000000,0,0.000000,'accept_directives' => { %Known_directives },
0.000000,0,0.000000,'accept_targets'    => {},
0.000000,0,0.000000,}, $class;
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->expand_verbatim_tabs(8);
0.000000,0,0.000000,return $obj;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: an option for whether to interpolate E<...>'s, or just resolve to codes.
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub _handle_element_start {     # OVERRIDE IN DERIVED CLASS
0.000000,0,0.000000,my($self, $element_name, $attr_hash_r) = @_;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _handle_element_end {       # OVERRIDE IN DERIVED CLASS
0.000000,0,0.000000,my($self, $element_name) = @_;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _handle_text          {     # OVERRIDE IN DERIVED CLASS
0.000000,0,0.000000,my($self, $text) = @_;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,#
0.000000,0,0.000000,# And now directives (not targets)
0.000000,0,0.000000,
0.000000,0,0.000000,sub accept_directive_as_verbatim  { shift->_accept_directives('Verbatim', @_) }
0.000000,0,0.000000,sub accept_directive_as_data      { shift->_accept_directives('Data',     @_) }
0.000000,0,0.000000,sub accept_directive_as_processed { shift->_accept_directives('Plain',    @_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _accept_directives {
0.000000,0,0.000000,my($this, $type) = splice @_,0,2;
0.000000,0,0.000000,foreach my $d (@_) {
0.000000,0,0.000000,next unless defined $d and length $d;
0.000000,0,0.000000,Carp::croak "\"$d\" isn't a valid directive name"
0.000000,0,0.000000,unless $d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;
0.000000,0,0.000000,Carp::croak "\"$d\" is already a reserved Pod directive name"
0.000000,0,0.000000,if exists $Known_directives{$d};
0.000000,0,0.000000,$this->{'accept_directives'}{$d} = $type;
0.000000,0,0.000000,DEBUG > 2 and print STDERR "Learning to accept \"=$d\" as directive of type $type\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,DEBUG > 6 and print STDERR "$this\'s accept_directives : ",
0.000000,0,0.000000,pretty($this->{'accept_directives'}), "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,return sort keys %{ $this->{'accept_directives'} } if wantarray;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#--------------------------------------------------------------------------
0.000000,0,0.000000,# TODO: document these:
0.000000,0,0.000000,
0.000000,0,0.000000,sub unaccept_directive { shift->unaccept_directives(@_) };
0.000000,0,0.000000,
0.000000,0,0.000000,sub unaccept_directives {
0.000000,0,0.000000,my $this = shift;
0.000000,0,0.000000,foreach my $d (@_) {
0.000000,0,0.000000,next unless defined $d and length $d;
0.000000,0,0.000000,Carp::croak "\"$d\" isn't a valid directive name"
0.000000,0,0.000000,unless $d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;
0.000000,0,0.000000,Carp::croak "But you must accept \"$d\" directives -- it's a builtin!"
0.000000,0,0.000000,if exists $Known_directives{$d};
0.000000,0,0.000000,delete $this->{'accept_directives'}{$d};
0.000000,0,0.000000,DEBUG > 2 and print STDERR "OK, won't accept \"=$d\" as directive.\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,return sort keys %{ $this->{'accept_directives'} } if wantarray;
0.000000,0,0.000000,return
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,#
0.000000,0,0.000000,# And now targets (not directives)
0.000000,0,0.000000,
0.000000,0,0.000000,sub accept_target         { shift->accept_targets(@_)         } # alias
0.000000,0,0.000000,sub accept_target_as_text { shift->accept_targets_as_text(@_) } # alias
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub accept_targets         { shift->_accept_targets('1', @_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub accept_targets_as_text { shift->_accept_targets('force_resolve', @_) }
0.000000,0,0.000000,# forces them to be processed, even when there's no ":".
0.000000,0,0.000000,
0.000000,0,0.000000,sub _accept_targets {
0.000000,0,0.000000,my($this, $type) = splice @_,0,2;
0.000000,0,0.000000,foreach my $t (@_) {
0.000000,0,0.000000,next unless defined $t and length $t;
0.000000,0,0.000000,# TODO: enforce some limitations on what a target name can be?
0.000000,0,0.000000,$this->{'accept_targets'}{$t} = $type;
0.000000,0,0.000000,DEBUG > 2 and print STDERR "Learning to accept \"$t\" as target of type $type\n";
0.000000,0,0.000000,}    
0.000000,0,0.000000,return sort keys %{ $this->{'accept_targets'} } if wantarray;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#--------------------------------------------------------------------------
0.000000,0,0.000000,sub unaccept_target         { shift->unaccept_targets(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub unaccept_targets {
0.000000,0,0.000000,my $this = shift;
0.000000,0,0.000000,foreach my $t (@_) {
0.000000,0,0.000000,next unless defined $t and length $t;
0.000000,0,0.000000,# TODO: enforce some limitations on what a target name can be?
0.000000,0,0.000000,delete $this->{'accept_targets'}{$t};
0.000000,0,0.000000,DEBUG > 2 and print STDERR "OK, won't accept \"$t\" as target.\n";
0.000000,0,0.000000,}    
0.000000,0,0.000000,return sort keys %{ $this->{'accept_targets'} } if wantarray;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,#
0.000000,0,0.000000,# And now codes (not targets or directives)
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX Probably it is an error that the digit '9' is excluded from these re's.
0.000000,0,0.000000,# Broken for early Perls on EBCDIC
0.000003,1,0.000003,my $xml_name_re = my_qr('[^-.0-8:A-Z_a-z[:^ascii:]]', '9');
0.000000,1,0.000000,$xml_name_re = qr/[\x00-\x2C\x2F\x39\x3B-\x40\x5B-\x5E\x60\x7B-\x7F]/
0.000000,0,0.000000,unless $xml_name_re;
0.000000,0,0.000000,
0.000000,0,0.000000,sub accept_code { shift->accept_codes(@_) } # alias
0.000000,0,0.000000,
0.000000,0,0.000000,sub accept_codes {  # Add some codes
0.000000,0,0.000000,my $this = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $new_code (@_) {
0.000000,0,0.000000,next unless defined $new_code and length $new_code;
0.000000,0,0.000000,# A good-enough check that it's good as an XML Name symbol:
0.000000,0,0.000000,Carp::croak "\"$new_code\" isn't a valid element name"
0.000000,0,0.000000,if $new_code =~ $xml_name_re
0.000000,0,0.000000,# Characters under 0x80 that aren't legal in an XML Name.
0.000000,0,0.000000,or $new_code =~ m/^[-\.0-9]/s
0.000000,0,0.000000,or $new_code =~ m/:[-\.0-9]/s;
0.000000,0,0.000000,# The legal under-0x80 Name characters that
0.000000,0,0.000000,#  an XML Name still can't start with.
0.000000,0,0.000000,
0.000000,0,0.000000,$this->{'accept_codes'}{$new_code} = $new_code;
0.000000,0,0.000000,
0.000000,0,0.000000,# Yes, map to itself -- just so that when we
0.000000,0,0.000000,#  see "=extend W [whatever] thatelementname", we say that W maps
0.000000,0,0.000000,#  to whatever $this->{accept_codes}{thatelementname} is,
0.000000,0,0.000000,#  i.e., "thatelementname".  Then when we go re-mapping,
0.000000,0,0.000000,#  a "W" in the treelet turns into "thatelementname".  We only
0.000000,0,0.000000,#  remap once.
0.000000,0,0.000000,# If we say we accept "W", then a "W" in the treelet simply turns
0.000000,0,0.000000,#  into "W".
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#--------------------------------------------------------------------------
0.000000,0,0.000000,sub unaccept_code { shift->unaccept_codes(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub unaccept_codes { # remove some codes
0.000000,0,0.000000,my $this = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $new_code (@_) {
0.000000,0,0.000000,next unless defined $new_code and length $new_code;
0.000000,0,0.000000,# A good-enough check that it's good as an XML Name symbol:
0.000000,0,0.000000,Carp::croak "\"$new_code\" isn't a valid element name"
0.000000,0,0.000000,if $new_code =~ $xml_name_re
0.000000,0,0.000000,# Characters under 0x80 that aren't legal in an XML Name.
0.000000,0,0.000000,or $new_code =~ m/^[-\.0-9]/s
0.000000,0,0.000000,or $new_code =~ m/:[-\.0-9]/s;
0.000000,0,0.000000,# The legal under-0x80 Name characters that
0.000000,0,0.000000,#  an XML Name still can't start with.
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak "But you must accept \"$new_code\" codes -- it's a builtin!"
0.000000,0,0.000000,if grep $new_code eq $_, @Known_formatting_codes;
0.000000,0,0.000000,
0.000000,0,0.000000,delete $this->{'accept_codes'}{$new_code};
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 2 and print STDERR "OK, won't accept the code $new_code<...>.\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_string_document {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my @lines;
0.000000,0,0.000000,foreach my $line_group (@_) {
0.000000,0,0.000000,next unless defined $line_group and length $line_group;
0.000000,0,0.000000,pos($line_group) = 0;
0.000000,0,0.000000,while($line_group =~
0.000000,0,0.000000,m/([^\n\r]*)(\r?\n?)/g # supports \r, \n ,\r\n
0.000000,0,0.000000,#m/([^\n\r]*)((?:\r?\n)?)/g
0.000000,0,0.000000,) {
0.000000,0,0.000000,#print(">> $1\n"),
0.000000,0,0.000000,$self->parse_lines($1)
0.000000,0,0.000000,if length($1) or length($2)
0.000000,0,0.000000,or pos($line_group) != length($line_group);
0.000000,0,0.000000,# I.e., unless it's a zero-length "empty line" at the very
0.000000,0,0.000000,#  end of "foo\nbar\n" (i.e., between the \n and the EOS).
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->parse_lines(undef); # to signal EOF
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _init_fh_source {
0.000000,0,0.000000,my($self, $source) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,#DEBUG > 1 and print STDERR "Declaring $source as :raw for starters\n";
0.000000,0,0.000000,#$self->_apply_binmode($source, ':raw');
0.000000,0,0.000000,#binmode($source, ":raw");
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_file {
0.000000,0,0.000000,my($self, $source) = (@_);
0.000000,0,0.000000,
0.000000,0,0.000000,if(!defined $source) {
0.000000,0,0.000000,Carp::croak("Can't use empty-string as a source for parse_file");
0.000000,0,0.000000,} elsif(ref(\$source) eq 'GLOB') {
0.000000,0,0.000000,$self->{'source_filename'} = '' . ($source);
0.000000,0,0.000000,} elsif(ref $source) {
0.000000,0,0.000000,$self->{'source_filename'} = '' . ($source);
0.000000,0,0.000000,} elsif(!length $source) {
0.000000,0,0.000000,Carp::croak("Can't use empty-string as a source for parse_file");
0.000000,0,0.000000,} else {
0.000000,0,0.000000,{
0.000000,0,0.000000,local *PODSOURCE;
0.000000,0,0.000000,open(PODSOURCE, "<$source") || Carp::croak("Can't open $source: $!");
0.000000,0,0.000000,$self->{'source_filename'} = $source;
0.000000,0,0.000000,$source = *PODSOURCE{IO};
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_init_fh_source($source);
0.000000,0,0.000000,}
0.000000,0,0.000000,# By here, $source is a FH.
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{'source_fh'} = $source;
0.000000,0,0.000000,
0.000000,0,0.000000,my($i, @lines);
0.000000,0,0.000000,until( $self->{'source_dead'} ) {
0.000000,0,0.000000,splice @lines;
0.000000,0,0.000000,
0.000000,0,0.000000,for($i = MANY_LINES; $i--;) {  # read those many lines at a time
0.000000,0,0.000000,local $/ = $NL;
0.000000,0,0.000000,push @lines, scalar(<$source>);  # readline
0.000000,0,0.000000,last unless defined $lines[-1];
0.000000,0,0.000000,# but pass thru the undef, which will set source_dead to true
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $at_eof = ! $lines[-1]; # keep track of the undef
0.000000,0,0.000000,pop @lines if $at_eof; # silence warnings
0.000000,0,0.000000,
0.000000,0,0.000000,# be eol agnostic
0.000000,0,0.000000,s/\r\n?/\n/g for @lines;
0.000000,0,0.000000,
0.000000,0,0.000000,# make sure there are only one line elements for parse_lines
0.000000,0,0.000000,@lines = split(/(?<=\n)/, join('', @lines));
0.000000,0,0.000000,
0.000000,0,0.000000,# push the undef back after popping it to set source_dead to true
0.000000,0,0.000000,push @lines, undef if $at_eof;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->parse_lines(@lines);
0.000000,0,0.000000,}
0.000000,0,0.000000,delete($self->{'source_fh'}); # so it can be GC'd
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_from_file {
0.000000,0,0.000000,# An emulation of Pod::Parser's interface, for the sake of Perldoc.
0.000000,0,0.000000,# Basically just a wrapper around parse_file.
0.000000,0,0.000000,
0.000000,0,0.000000,my($self, $source, $to) = @_;
0.000000,0,0.000000,$self = $self->new unless ref($self); # so we tolerate being a class method
0.000000,0,0.000000,
0.000000,0,0.000000,if(!defined $source)             { $source = *STDIN{IO}
0.000000,0,0.000000,} elsif(ref(\$source) eq 'GLOB') { # stet
0.000000,0,0.000000,} elsif(ref($source)           ) { # stet
0.000000,0,0.000000,} elsif(!length $source
0.000000,0,0.000000,or $source eq '-' or $source =~ m/^<&(?:STDIN|0)$/i
0.000000,0,0.000000,) { 
0.000000,0,0.000000,$source = *STDIN{IO};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(!defined $to) {             $self->output_fh( *STDOUT{IO}   );
0.000000,0,0.000000,} elsif(ref(\$to) eq 'GLOB') { $self->output_fh( $to );
0.000000,0,0.000000,} elsif(ref($to)) {            $self->output_fh( $to );
0.000000,0,0.000000,} elsif(!length $to
0.000000,0,0.000000,or $to eq '-' or $to =~ m/^>&?(?:STDOUT|1)$/i
0.000000,0,0.000000,) {
0.000000,0,0.000000,$self->output_fh( *STDOUT{IO} );
0.000000,0,0.000000,} elsif($to =~ m/^>&(?:STDERR|2)$/i) {
0.000000,0,0.000000,$self->output_fh( *STDERR{IO} );
0.000000,0,0.000000,} else {
0.000000,0,0.000000,require Symbol;
0.000000,0,0.000000,my $out_fh = Symbol::gensym();
0.000000,0,0.000000,DEBUG and print STDERR "Write-opening to $to\n";
0.000000,0,0.000000,open($out_fh, ">$to")  or  Carp::croak "Can't write-open $to: $!";
0.000000,0,0.000000,binmode($out_fh)
0.000000,0,0.000000,if $self->can('write_with_binmode') and $self->write_with_binmode;
0.000000,0,0.000000,$self->output_fh($out_fh);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->parse_file($source);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#-----------------------------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,sub whine {
0.000000,0,0.000000,#my($self,$line,$complaint) = @_;
0.000000,0,0.000000,my $self = shift(@_);
0.000000,0,0.000000,++$self->{'errors_seen'};
0.000000,0,0.000000,if($self->{'no_whining'}) {
0.000000,0,0.000000,DEBUG > 9 and print STDERR "Discarding complaint (at line $_[0]) $_[1]\n because no_whining is on.\n";
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,push @{$self->{'all_errata'}{$_[0]}}, $_[1];
0.000000,0,0.000000,return $self->_complain_warn(@_) if $self->{'complain_stderr'};
0.000000,0,0.000000,return $self->_complain_errata(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub scream {    # like whine, but not suppressible
0.000000,0,0.000000,#my($self,$line,$complaint) = @_;
0.000000,0,0.000000,my $self = shift(@_);
0.000000,0,0.000000,++$self->{'errors_seen'};
0.000000,0,0.000000,push @{$self->{'all_errata'}{$_[0]}}, $_[1];
0.000000,0,0.000000,return $self->_complain_warn(@_) if $self->{'complain_stderr'};
0.000000,0,0.000000,return $self->_complain_errata(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _complain_warn {
0.000000,0,0.000000,my($self,$line,$complaint) = @_;
0.000000,0,0.000000,return printf STDERR "%s around line %s: %s\n",
0.000000,0,0.000000,$self->{'source_filename'} || 'Pod input', $line, $complaint;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _complain_errata {
0.000000,0,0.000000,my($self,$line,$complaint) = @_;
0.000000,0,0.000000,if( $self->{'no_errata_section'} ) {
0.000000,0,0.000000,DEBUG > 9 and print STDERR "Discarding erratum (at line $line) $complaint\n because no_errata_section is on.\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 9 and print STDERR "Queuing erratum (at line $line) $complaint\n";
0.000000,0,0.000000,push @{$self->{'errata'}{$line}}, $complaint
0.000000,0,0.000000,# for a report to be generated later!
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub _get_initial_item_type {
0.000000,0,0.000000,# A hack-wrapper here for when you have like "=over\n\n=item 456\n\n"
0.000000,0,0.000000,my($self, $para) = @_;
0.000000,0,0.000000,return $para->[1]{'~type'}  if $para->[1]{'~type'};
0.000000,0,0.000000,
0.000000,0,0.000000,return $para->[1]{'~type'} = 'text'
0.000000,0,0.000000,if join("\n", @{$para}[2 .. $#$para]) =~ m/^\s*(\d+)\.?\s*$/s and $1 ne '1';
0.000000,0,0.000000,# Else fall thru to the general case:
0.000000,0,0.000000,return $self->_get_item_type($para);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _get_item_type {       # mutates the item!!
0.000000,0,0.000000,my($self, $para) = @_;
0.000000,0,0.000000,return $para->[1]{'~type'} if $para->[1]{'~type'};
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# Otherwise we haven't yet been to this node.  Maybe alter it...
0.000000,0,0.000000,
0.000000,0,0.000000,my $content = join "\n", @{$para}[2 .. $#$para];
0.000000,0,0.000000,
0.000000,0,0.000000,if($content =~ m/^\s*\*\s*$/s or $content =~ m/^\s*$/s) {
0.000000,0,0.000000,# Like: "=item *", "=item   *   ", "=item"
0.000000,0,0.000000,splice @$para, 2; # so it ends up just being ['=item', { attrhash } ]
0.000000,0,0.000000,$para->[1]{'~orig_content'} = $content;
0.000000,0,0.000000,return $para->[1]{'~type'} = 'bullet';
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($content =~ m/^\s*\*\s+(.+)/s) {  # tolerance
0.000000,0,0.000000,
0.000000,0,0.000000,# Like: "=item * Foo bar baz";
0.000000,0,0.000000,$para->[1]{'~orig_content'}      = $content;
0.000000,0,0.000000,$para->[1]{'~_freaky_para_hack'} = $1;
0.000000,0,0.000000,DEBUG > 2 and print STDERR " Tolerating $$para[2] as =item *\\n\\n$1\n";
0.000000,0,0.000000,splice @$para, 2; # so it ends up just being ['=item', { attrhash } ]
0.000000,0,0.000000,return $para->[1]{'~type'} = 'bullet';
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($content =~ m/^\s*(\d+)\.?\s*$/s) {
0.000000,0,0.000000,# Like: "=item 1.", "=item    123412"
0.000000,0,0.000000,
0.000000,0,0.000000,$para->[1]{'~orig_content'} = $content;
0.000000,0,0.000000,$para->[1]{'number'} = $1;  # Yes, stores the number there!
0.000000,0,0.000000,
0.000000,0,0.000000,splice @$para, 2; # so it ends up just being ['=item', { attrhash } ]
0.000000,0,0.000000,return $para->[1]{'~type'} = 'number';
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# It's anything else.
0.000000,0,0.000000,return $para->[1]{'~type'} = 'text';
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#-----------------------------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_treelet {
0.000000,0,0.000000,my $self = shift;  # and ($para, $start_line)
0.000000,0,0.000000,my $treelet;
0.000000,0,0.000000,if(!@_) {
0.000000,0,0.000000,return [''];
0.000000,0,0.000000,} if(ref $_[0] and ref $_[0][0] and $_[0][0][0] eq '~Top') {
0.000000,0,0.000000,# Hack so we can pass in fake-o pre-cooked paragraphs:
0.000000,0,0.000000,#  just have the first line be a reference to a ['~Top', {}, ...]
0.000000,0,0.000000,# We use this feechure in gen_errata and stuff.
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and print STDERR "Applying precooked treelet hack to $_[0][0]\n";
0.000000,0,0.000000,$treelet = $_[0][0];
0.000000,0,0.000000,splice @$treelet, 0, 2;  # lop the top off
0.000000,0,0.000000,return $treelet;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$treelet = $self->_treelet_from_formatting_codes(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if( ! $self->{'_output_is_for_JustPod'}   # Retain these as-is for pod output
0.000000,0,0.000000,&& $self->_remap_sequences($treelet) )
0.000000,0,0.000000,{
0.000000,0,0.000000,$self->_treat_Zs($treelet);  # Might as well nix these first
0.000000,0,0.000000,$self->_treat_Ls($treelet);  # L has to precede E and S
0.000000,0,0.000000,$self->_treat_Es($treelet);
0.000000,0,0.000000,$self->_treat_Ss($treelet);  # S has to come after E
0.000000,0,0.000000,$self->_wrap_up($treelet); # Nix X's and merge texties
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG and print STDERR "Formatless treelet gets fast-tracked.\n";
0.000000,0,0.000000,# Very common case!
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,splice @$treelet, 0, 2;  # lop the top off
0.000000,0,0.000000,
0.000000,0,0.000000,return $treelet;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
0.000000,0,0.000000,
0.000000,0,0.000000,sub _wrap_up {
0.000000,0,0.000000,my($self, @stack) = @_;
0.000000,0,0.000000,my $nixx  = $self->{'nix_X_codes'};
0.000000,0,0.000000,my $merge = $self->{'merge_text' };
0.000000,0,0.000000,return unless $nixx or $merge;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 2 and print STDERR "\nStarting _wrap_up traversal.\n",
0.000000,0,0.000000,$merge ? (" Merge mode on\n") : (),
0.000000,0,0.000000,$nixx  ? (" Nix-X mode on\n") : (),
0.000000,0,0.000000,;    
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,my($i, $treelet);
0.000000,0,0.000000,while($treelet = shift @stack) {
0.000000,0,0.000000,DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";
0.000000,0,0.000000,for($i = 2; $i < @$treelet; ++$i) { # iterate over children
0.000000,0,0.000000,DEBUG > 3 and print STDERR " Considering child at $i ", pretty($treelet->[$i]), "\n";
0.000000,0,0.000000,if($nixx and ref $treelet->[$i] and $treelet->[$i][0] eq 'X') {
0.000000,0,0.000000,DEBUG > 3 and print STDERR "   Nixing X node at $i\n";
0.000000,0,0.000000,splice(@$treelet, $i, 1); # just nix this node (and its descendants)
0.000000,0,0.000000,# no need to back-update the counter just yet
0.000000,0,0.000000,redo;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($merge and $i != 2 and  # non-initial
0.000000,0,0.000000,!ref $treelet->[$i] and !ref $treelet->[$i - 1]
0.000000,0,0.000000,) {
0.000000,0,0.000000,DEBUG > 3 and print STDERR "   Merging ", $i-1,
0.000000,0,0.000000,":[$treelet->[$i-1]] and $i\:[$treelet->[$i]]\n";
0.000000,0,0.000000,$treelet->[$i-1] .= ( splice(@$treelet, $i, 1) )[0];
0.000000,0,0.000000,DEBUG > 4 and print STDERR "    Now: ", $i-1, ":[$treelet->[$i-1]]\n";
0.000000,0,0.000000,--$i;
0.000000,0,0.000000,next; 
0.000000,0,0.000000,# since we just pulled the possibly last node out from under
0.000000,0,0.000000,#  ourselves, we can't just redo()
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif( ref $treelet->[$i] ) {
0.000000,0,0.000000,DEBUG > 4 and print STDERR "  Enqueuing ", pretty($treelet->[$i]), " for traversal.\n";
0.000000,0,0.000000,push @stack, $treelet->[$i];
0.000000,0,0.000000,
0.000000,0,0.000000,if($treelet->[$i][0] eq 'L') {
0.000000,0,0.000000,my $thing;
0.000000,0,0.000000,foreach my $attrname ('section', 'to') {        
0.000000,0,0.000000,if(defined($thing = $treelet->[$i][1]{$attrname}) and ref $thing) {
0.000000,0,0.000000,unshift @stack, $thing;
0.000000,0,0.000000,DEBUG > 4 and print STDERR "  +Enqueuing ",
0.000000,0,0.000000,pretty( $treelet->[$i][1]{$attrname} ),
0.000000,0,0.000000," as an attribute value to tweak.\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,DEBUG > 2 and print STDERR "End of _wrap_up traversal.\n\n";
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
0.000000,0,0.000000,
0.000000,0,0.000000,sub _remap_sequences {
0.000000,0,0.000000,my($self,@stack) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if(@stack == 1 and @{ $stack[0] } == 3 and !ref $stack[0][2]) {
0.000000,0,0.000000,# VERY common case: abort it.
0.000000,0,0.000000,DEBUG and print STDERR "Skipping _remap_sequences: formatless treelet.\n";
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $map = ($self->{'accept_codes'} || die "NO accept_codes in $self?!?");
0.000000,0,0.000000,
0.000000,0,0.000000,my $start_line = $stack[0][1]{'start_line'};
0.000000,0,0.000000,DEBUG > 2 and printf
0.000000,0,0.000000,"\nAbout to start _remap_sequences on treelet from line %s.\n",
0.000000,0,0.000000,$start_line || '[?]'
0.000000,0,0.000000,;
0.000000,0,0.000000,DEBUG > 3 and print STDERR " Map: ",
0.000000,0,0.000000,join('; ', map "$_=" . (
0.000000,0,0.000000,ref($map->{$_}) ? join(",", @{$map->{$_}}) : $map->{$_}
0.000000,0,0.000000,),
0.000000,0,0.000000,sort keys %$map ),
0.000000,0,0.000000,("B~C~E~F~I~L~S~X~Z" eq join '~', sort keys %$map)
0.000000,0,0.000000,? "  (all normal)\n" : "\n"
0.000000,0,0.000000,;
0.000000,0,0.000000,
0.000000,0,0.000000,# A recursive algorithm implemented iteratively!  Whee!
0.000000,0,0.000000,
0.000000,0,0.000000,my($is, $was, $i, $treelet); # scratch
0.000000,0,0.000000,while($treelet = shift @stack) {
0.000000,0,0.000000,DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";
0.000000,0,0.000000,for($i = 2; $i < @$treelet; ++$i) { # iterate over children
0.000000,0,0.000000,next unless ref $treelet->[$i];  # text nodes are uninteresting
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 4 and print STDERR "  Noting child $i : $treelet->[$i][0]<...>\n";
0.000000,0,0.000000,
0.000000,0,0.000000,$is = $treelet->[$i][0] = $map->{ $was = $treelet->[$i][0] };
0.000000,0,0.000000,if( DEBUG > 3 ) {
0.000000,0,0.000000,if(!defined $is) {
0.000000,0,0.000000,print STDERR "   Code $was<> is UNKNOWN!\n";
0.000000,0,0.000000,} elsif($is eq $was) {
0.000000,0,0.000000,DEBUG > 4 and print STDERR "   Code $was<> stays the same.\n";
0.000000,0,0.000000,} else  {
0.000000,0,0.000000,print STDERR "   Code $was<> maps to ",
0.000000,0,0.000000,ref($is)
0.000000,0,0.000000,? ( "tags ", map("$_<", @$is), '...', map('>', @$is), "\n" )
0.000000,0,0.000000,: "tag $is<...>.\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(!defined $is) {
0.000000,0,0.000000,$self->whine($start_line, "Deleting unknown formatting code $was<>");
0.000000,0,0.000000,$is = $treelet->[$i][0] = '1';  # But saving the children!
0.000000,0,0.000000,# I could also insert a leading "$was<" and tailing ">" as
0.000000,0,0.000000,# children of this node, but something about that seems icky.
0.000000,0,0.000000,}
0.000000,0,0.000000,if(ref $is) {
0.000000,0,0.000000,my @dynasty = @$is;
0.000000,0,0.000000,DEBUG > 4 and print STDERR "    Renaming $was node to $dynasty[-1]\n";
0.000000,0,0.000000,$treelet->[$i][0] = pop @dynasty;
0.000000,0,0.000000,my $nugget;
0.000000,0,0.000000,while(@dynasty) {
0.000000,0,0.000000,DEBUG > 4 and printf
0.000000,0,0.000000,"    Grafting a new %s node between %s and %s\n",
0.000000,0,0.000000,$dynasty[-1], $treelet->[0], $treelet->[$i][0], 
0.000000,0,0.000000,;
0.000000,0,0.000000,
0.000000,0,0.000000,#$nugget = ;
0.000000,0,0.000000,splice @$treelet, $i, 1, [pop(@dynasty), {}, $treelet->[$i]];
0.000000,0,0.000000,# relace node with a new parent
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif($is eq '0') {
0.000000,0,0.000000,splice(@$treelet, $i, 1); # just nix this node (and its descendants)
0.000000,0,0.000000,--$i;  # back-update the counter
0.000000,0,0.000000,} elsif($is eq '1') {
0.000000,0,0.000000,splice(@$treelet, $i, 1 # replace this node with its children!
0.000000,0,0.000000,=> splice @{ $treelet->[$i] },2
0.000000,0,0.000000,# (not catching its first two (non-child) items)
0.000000,0,0.000000,);
0.000000,0,0.000000,--$i;  # back up for new stuff
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# otherwise it's unremarkable
0.000000,0,0.000000,unshift @stack, $treelet->[$i];  # just recurse
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 2 and print STDERR "End of _remap_sequences traversal.\n\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if(@_ == 2 and @{ $_[1] } == 3 and !ref $_[1][2]) {
0.000000,0,0.000000,DEBUG and print STDERR "Noting that the treelet is now formatless.\n";
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_extend {
0.000000,0,0.000000,
0.000000,0,0.000000,# "Go to an extreme, move back to a more comfortable place"
0.000000,0,0.000000,#  -- /Oblique Strategies/,  Brian Eno and Peter Schmidt
0.000000,0,0.000000,
0.000000,0,0.000000,my($self, $para) = @_;
0.000000,0,0.000000,my $content = join ' ', splice @$para, 2;
0.000000,0,0.000000,$content =~ s/^\s+//s;
0.000000,0,0.000000,$content =~ s/\s+$//s;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 2 and print STDERR "Ogling extensor: =extend $content\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if($content =~
0.000000,0,0.000000,m/^
0.000000,0,0.000000,(\S+)         # 1 : new item
0.000000,0,0.000000,\s+
0.000000,0,0.000000,(\S+)         # 2 : fallback(s)
0.000000,0,0.000000,(?:\s+(\S+))? # 3 : element name(s)
0.000000,0,0.000000,\s*
0.000000,0,0.000000,$
0.000000,0,0.000000,/xs
0.000000,0,0.000000,) {
0.000000,0,0.000000,my $new_letter = $1;
0.000000,0,0.000000,my $fallbacks_one = $2;
0.000000,0,0.000000,my $elements_one;
0.000000,0,0.000000,$elements_one = defined($3) ? $3 : $1;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 2 and print STDERR "Extensor has good syntax.\n";
0.000000,0,0.000000,
0.000000,0,0.000000,unless($new_letter =~ m/^[A-Z]$/s or $new_letter) {
0.000000,0,0.000000,DEBUG > 2 and print STDERR " $new_letter isn't a valid thing to entend.\n";
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"You can extend only formatting codes A-Z, not like \"$new_letter\""
0.000000,0,0.000000,);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(grep $new_letter eq $_, @Known_formatting_codes) {
0.000000,0,0.000000,DEBUG > 2 and print STDERR " $new_letter isn't a good thing to extend, because known.\n";
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"You can't extend an established code like \"$new_letter\""
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,#TODO: or allow if last bit is same?
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless($fallbacks_one =~ m/^[A-Z](,[A-Z])*$/s  # like "B", "M,I", etc.
0.000000,0,0.000000,or $fallbacks_one eq '0' or $fallbacks_one eq '1'
0.000000,0,0.000000,) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Format for second =extend parameter must be like"
0.000000,0,0.000000,. " M or 1 or 0 or M,N or M,N,O but you have it like "
0.000000,0,0.000000,. $fallbacks_one
0.000000,0,0.000000,);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless($elements_one =~ m/^[^ ,]+(,[^ ,]+)*$/s) { # like "B", "M,I", etc.
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Format for third =extend parameter: like foo or bar,Baz,qu:ux but not like "
0.000000,0,0.000000,. $elements_one
0.000000,0,0.000000,);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @fallbacks  = split ',', $fallbacks_one,  -1;
0.000000,0,0.000000,my @elements   = split ',', $elements_one, -1;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $f (@fallbacks) {
0.000000,0,0.000000,next if exists $Known_formatting_codes{$f} or $f eq '0' or $f eq '1';
0.000000,0,0.000000,DEBUG > 2 and print STDERR "  Can't fall back on unknown code $f\n";
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Can't use unknown formatting code '$f' as a fallback for '$new_letter'"
0.000000,0,0.000000,);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 3 and printf STDERR "Extensor: Fallbacks <%s> Elements <%s>.\n",
0.000000,0,0.000000,@fallbacks, @elements;
0.000000,0,0.000000,
0.000000,0,0.000000,my $canonical_form;
0.000000,0,0.000000,foreach my $e (@elements) {
0.000000,0,0.000000,if(exists $self->{'accept_codes'}{$e}) {
0.000000,0,0.000000,DEBUG > 1 and print STDERR " Mapping '$new_letter' to known extension '$e'\n";
0.000000,0,0.000000,$canonical_form = $e;
0.000000,0,0.000000,last; # first acceptable elementname wins!
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 1 and print STDERR " Can't map '$new_letter' to unknown extension '$e'\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,if( defined $canonical_form ) {
0.000000,0,0.000000,# We found a good N => elementname mapping
0.000000,0,0.000000,$self->{'accept_codes'}{$new_letter} = $canonical_form;
0.000000,0,0.000000,DEBUG > 2 and print
0.000000,0,0.000000,"Extensor maps $new_letter => known element $canonical_form.\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# We have to use the fallback(s), which might be '0', or '1'.
0.000000,0,0.000000,$self->{'accept_codes'}{$new_letter}
0.000000,0,0.000000,= (@fallbacks == 1) ? $fallbacks[0] : \@fallbacks;
0.000000,0,0.000000,DEBUG > 2 and print
0.000000,0,0.000000,"Extensor maps $new_letter => fallbacks @fallbacks.\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 2 and print STDERR "Extensor has bad syntax.\n";
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Unknown =extend syntax: $content"
0.000000,0,0.000000,)
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
0.000000,0,0.000000,
0.000000,0,0.000000,sub _treat_Zs {  # Nix Z<...>'s
0.000000,0,0.000000,my($self,@stack) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my($i, $treelet);
0.000000,0,0.000000,my $start_line = $stack[0][1]{'start_line'};
0.000000,0,0.000000,
0.000000,0,0.000000,# A recursive algorithm implemented iteratively!  Whee!
0.000000,0,0.000000,
0.000000,0,0.000000,while($treelet = shift @stack) {
0.000000,0,0.000000,for($i = 2; $i < @$treelet; ++$i) { # iterate over children
0.000000,0,0.000000,next unless ref $treelet->[$i];  # text nodes are uninteresting
0.000000,0,0.000000,unless($treelet->[$i][0] eq 'Z') {
0.000000,0,0.000000,unshift @stack, $treelet->[$i]; # recurse
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Nixing Z node @{$treelet->[$i]}\n";
0.000000,0,0.000000,
0.000000,0,0.000000,# bitch UNLESS it's empty
0.000000,0,0.000000,unless(  @{$treelet->[$i]} == 2
0.000000,0,0.000000,or (@{$treelet->[$i]} == 3 and $treelet->[$i][2] eq '')
0.000000,0,0.000000,) {
0.000000,0,0.000000,$self->whine( $start_line, "A non-empty Z<>" );
0.000000,0,0.000000,}      # but kill it anyway
0.000000,0,0.000000,
0.000000,0,0.000000,splice(@$treelet, $i, 1); # thereby just nix this node.
0.000000,0,0.000000,--$i;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
0.000000,0,0.000000,
0.000000,0,0.000000,# Quoting perlpodspec:
0.000000,0,0.000000,
0.000000,0,0.000000,# In parsing an L<...> code, Pod parsers must distinguish at least four
0.000000,0,0.000000,# attributes:
0.000000,0,0.000000,
0.000000,0,0.000000,############# Not used.  Expressed via the element children plus
0.000000,0,0.000000,#############  the value of the "content-implicit" flag.
0.000000,0,0.000000,# First:
0.000000,0,0.000000,# The link-text. If there is none, this must be undef. (E.g., in "L<Perl
0.000000,0,0.000000,# Functions|perlfunc>", the link-text is "Perl Functions". In
0.000000,0,0.000000,# "L<Time::HiRes>" and even "L<|Time::HiRes>", there is no link text. Note
0.000000,0,0.000000,# that link text may contain formatting.)
0.000000,0,0.000000,# 
0.000000,0,0.000000,
0.000000,0,0.000000,############# The element children
0.000000,0,0.000000,# Second:
0.000000,0,0.000000,# The possibly inferred link-text -- i.e., if there was no real link text,
0.000000,0,0.000000,# then this is the text that we'll infer in its place. (E.g., for
0.000000,0,0.000000,# "L<Getopt::Std>", the inferred link text is "Getopt::Std".)
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,0,0.000000,############# The "to" attribute (which might be text, or a treelet)
0.000000,0,0.000000,# Third:
0.000000,0,0.000000,# The name or URL, or undef if none. (E.g., in "L<Perl
0.000000,0,0.000000,# Functions|perlfunc>", the name -- also sometimes called the page -- is
0.000000,0,0.000000,# "perlfunc". In "L</CAVEATS>", the name is undef.)
0.000000,0,0.000000,# 
0.000000,0,0.000000,
0.000000,0,0.000000,############# The "section" attribute (which might be next, or a treelet)
0.000000,0,0.000000,# Fourth:
0.000000,0,0.000000,# The section (AKA "item" in older perlpods), or undef if none. E.g., in
0.000000,0,0.000000,# Getopt::Std/DESCRIPTION, "DESCRIPTION" is the section. (Note that this
0.000000,0,0.000000,# is not the same as a manpage section like the "5" in "man 5 crontab".
0.000000,0,0.000000,# "Section Foo" in the Pod sense means the part of the text that's
0.000000,0,0.000000,# introduced by the heading or item whose text is "Foo".)
0.000000,0,0.000000,# 
0.000000,0,0.000000,# Pod parsers may also note additional attributes including:
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,0,0.000000,############# The "type" attribute.
0.000000,0,0.000000,# Fifth:
0.000000,0,0.000000,# A flag for whether item 3 (if present) is a URL (like
0.000000,0,0.000000,# "http://lists.perl.org" is), in which case there should be no section
0.000000,0,0.000000,# attribute; a Pod name (like "perldoc" and "Getopt::Std" are); or
0.000000,0,0.000000,# possibly a man page name (like "crontab(5)" is).
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,0,0.000000,############# The "raw" attribute that is already there.
0.000000,0,0.000000,# Sixth:
0.000000,0,0.000000,# The raw original L<...> content, before text is split on "|", "/", etc,
0.000000,0,0.000000,# and before E<...> codes are expanded.
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# For L<...> codes without a "name|" part, only E<...> and Z<> codes may
0.000000,0,0.000000,# occur -- no other formatting codes. That is, authors should not use
0.000000,0,0.000000,# "L<B<Foo::Bar>>".
0.000000,0,0.000000,#
0.000000,0,0.000000,# Note, however, that formatting codes and Z<>'s can occur in any and all
0.000000,0,0.000000,# parts of an L<...> (i.e., in name, section, text, and url).
0.000000,0,0.000000,
0.000000,0,0.000000,sub _treat_Ls {  # Process our dear dear friends, the L<...> sequences
0.000000,0,0.000000,
0.000000,0,0.000000,# L<name>
0.000000,0,0.000000,# L<name/"sec"> or L<name/sec>
0.000000,0,0.000000,# L</"sec"> or L</sec> or L<"sec">
0.000000,0,0.000000,# L<text|name>
0.000000,0,0.000000,# L<text|name/"sec"> or L<text|name/sec>
0.000000,0,0.000000,# L<text|/"sec"> or L<text|/sec> or L<text|"sec">
0.000000,0,0.000000,# L<scheme:...>
0.000000,0,0.000000,# L<text|scheme:...>
0.000000,0,0.000000,
0.000000,0,0.000000,my($self,@stack) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my($i, $treelet);
0.000000,0,0.000000,my $start_line = $stack[0][1]{'start_line'};
0.000000,0,0.000000,
0.000000,0,0.000000,# A recursive algorithm implemented iteratively!  Whee!
0.000000,0,0.000000,
0.000000,0,0.000000,while($treelet = shift @stack) {
0.000000,0,0.000000,for(my $i = 2; $i < @$treelet; ++$i) {
0.000000,0,0.000000,# iterate over children of current tree node
0.000000,0,0.000000,next unless ref $treelet->[$i];  # text nodes are uninteresting
0.000000,0,0.000000,unless($treelet->[$i][0] eq 'L') {
0.000000,0,0.000000,unshift @stack, $treelet->[$i]; # recurse
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# By here, $treelet->[$i] is definitely an L node
0.000000,0,0.000000,my $ell = $treelet->[$i];
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Ogling L node " . pretty($ell) . "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,# bitch if it's empty or is just '/'
0.000000,0,0.000000,if (@{$ell} == 3 and $ell->[2] =~ m!\A\s*/\s*\z!) {
0.000000,0,0.000000,$self->whine( $start_line, "L<> contains only '/'" );
0.000000,0,0.000000,$treelet->[$i] = 'L</>';  # just make it a text node
0.000000,0,0.000000,next;  # and move on
0.000000,0,0.000000,}
0.000000,0,0.000000,if(  @{$ell} == 2
0.000000,0,0.000000,or (@{$ell} == 3 and $ell->[2] eq '')
0.000000,0,0.000000,) {
0.000000,0,0.000000,$self->whine( $start_line, "An empty L<>" );
0.000000,0,0.000000,$treelet->[$i] = 'L<>';  # just make it a text node
0.000000,0,0.000000,next;  # and move on
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if( (! ref $ell->[2]  && $ell->[2] =~ /\A\s/)
0.000000,0,0.000000,||(! ref $ell->[-1] && $ell->[-1] =~ /\s\z/)
0.000000,0,0.000000,) {
0.000000,0,0.000000,$self->whine( $start_line, "L<> starts or ends with whitespace" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Catch URLs:
0.000000,0,0.000000,
0.000000,0,0.000000,# there are a number of possible cases:
0.000000,0,0.000000,# 1) text node containing url: http://foo.com
0.000000,0,0.000000,#   -> [ 'http://foo.com' ]
0.000000,0,0.000000,# 2) text node containing url and text: foo|http://foo.com
0.000000,0,0.000000,#   -> [ 'foo|http://foo.com' ]
0.000000,0,0.000000,# 3) text node containing url start: mailto:xE<at>foo.com
0.000000,0,0.000000,#   -> [ 'mailto:x', [ E ... ], 'foo.com' ]
0.000000,0,0.000000,# 4) text node containing url start and text: foo|mailto:xE<at>foo.com
0.000000,0,0.000000,#   -> [ 'foo|mailto:x', [ E ... ], 'foo.com' ]
0.000000,0,0.000000,# 5) other nodes containing text and url start: OE<39>Malley|http://foo.com
0.000000,0,0.000000,#   -> [ 'O', [ E ... ], 'Malley', '|http://foo.com' ]
0.000000,0,0.000000,# ... etc.
0.000000,0,0.000000,
0.000000,0,0.000000,# anything before the url is part of the text.
0.000000,0,0.000000,# anything after it is part of the url.
0.000000,0,0.000000,# the url text node itself may contain parts of both.
0.000000,0,0.000000,
0.000000,0,0.000000,if (my ($url_index, $text_part, $url_part) =
0.000000,0,0.000000,# grep is no good here; we want to bail out immediately so that we can
0.000000,0,0.000000,# use $1, $2, etc. without having to do the match twice.
0.000000,0,0.000000,sub {
0.000000,0,0.000000,for (2..$#$ell) {
0.000000,0,0.000000,next if ref $ell->[$_];
0.000000,0,0.000000,next unless $ell->[$_] =~ m/^(?:([^|]*)\|)?(\w+:[^:\s]\S*)$/s;
0.000000,0,0.000000,return ($_, $1, $2);
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}->()
0.000000,0,0.000000,) {
0.000000,0,0.000000,$ell->[1]{'type'} = 'url';
0.000000,0,0.000000,
0.000000,0,0.000000,my @text = @{$ell}[2..$url_index-1];
0.000000,0,0.000000,push @text, $text_part if defined $text_part;
0.000000,0,0.000000,
0.000000,0,0.000000,my @url  = @{$ell}[$url_index+1..$#$ell];
0.000000,0,0.000000,unshift @url, $url_part;
0.000000,0,0.000000,
0.000000,0,0.000000,unless (@text) {
0.000000,0,0.000000,$ell->[1]{'content-implicit'} = 'yes';
0.000000,0,0.000000,@text = @url;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$ell->[1]{to} = Pod::Simple::LinkSection->new(
0.000000,0,0.000000,@url == 1
0.000000,0,0.000000,? $url[0]
0.000000,0,0.000000,: [ '', {}, @url ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,splice @$ell, 2, $#$ell, @text;
0.000000,0,0.000000,
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Catch some very simple and/or common cases
0.000000,0,0.000000,if(@{$ell} == 3 and ! ref $ell->[2]) {
0.000000,0,0.000000,my $it = $ell->[2];
0.000000,0,0.000000,if($it =~ m{^[^/|]+[(][-a-zA-Z0-9]+[)]$}s) { # man sections
0.000000,0,0.000000,# Hopefully neither too broad nor too restrictive a RE
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Catching \"$it\" as manpage link.\n";
0.000000,0,0.000000,$ell->[1]{'type'} = 'man';
0.000000,0,0.000000,# This's the only place where man links can get made.
0.000000,0,0.000000,$ell->[1]{'content-implicit'} = 'yes';
0.000000,0,0.000000,$ell->[1]{'to'  } =
0.000000,0,0.000000,Pod::Simple::LinkSection->new( $it ); # treelet!
0.000000,0,0.000000,
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,if($it =~ m/^[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+(\:\:[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+)*$/s) {
0.000000,0,0.000000,# Extremely forgiving idea of what constitutes a bare
0.000000,0,0.000000,#  modulename link like L<Foo::Bar> or even L<Thing::1.0::Docs::Tralala>
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Catching \"$it\" as ho-hum L<Modulename> link.\n";
0.000000,0,0.000000,$ell->[1]{'type'} = 'pod';
0.000000,0,0.000000,$ell->[1]{'content-implicit'} = 'yes';
0.000000,0,0.000000,$ell->[1]{'to'  } =
0.000000,0,0.000000,Pod::Simple::LinkSection->new( $it ); # treelet!
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,# else fall thru...
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# ...Uhoh, here's the real L<...> parsing stuff...
0.000000,0,0.000000,# "With the ill behavior, with the ill behavior, with the ill behavior..."
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Running a real parse on this non-trivial L\n";
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,my $link_text; # set to an arrayref if found
0.000000,0,0.000000,my @ell_content = @$ell;
0.000000,0,0.000000,splice @ell_content,0,2; # Knock off the 'L' and {} bits
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 3 and print STDERR " Ell content to start: ",
0.000000,0,0.000000,pretty(@ell_content), "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# Look for the "|" -- only in CHILDREN (not all underlings!)
0.000000,0,0.000000,# Like L<I like the strictness|strict>
0.000000,0,0.000000,DEBUG > 3 and
0.000000,0,0.000000,print STDERR "  Peering at L content for a '|' ...\n";
0.000000,0,0.000000,for(my $j = 0; $j < @ell_content; ++$j) {
0.000000,0,0.000000,next if ref $ell_content[$j];
0.000000,0,0.000000,DEBUG > 3 and
0.000000,0,0.000000,print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '|'.\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if($ell_content[$j] =~ m/^([^\|]*)\|(.*)$/s) {
0.000000,0,0.000000,my @link_text = ($1);   # might be 0-length
0.000000,0,0.000000,$ell_content[$j] = $2;  # might be 0-length
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 3 and
0.000000,0,0.000000,print STDERR "     FOUND a '|' in it.  Splitting into [$1] + [$2]\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if ($link_text[0] =~ m{[|/]}) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$start_line,
0.000000,0,0.000000,"alternative text '$link_text[0]' contains non-escaped | or /"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unshift @link_text, splice @ell_content, 0, $j;
0.000000,0,0.000000,# leaving only things at J and after
0.000000,0,0.000000,@ell_content =  grep ref($_)||length($_), @ell_content ;
0.000000,0,0.000000,$link_text   = [grep ref($_)||length($_), @link_text  ];
0.000000,0,0.000000,DEBUG > 3 and printf
0.000000,0,0.000000,"  So link text is %s\n  and remaining ell content is %s\n",
0.000000,0,0.000000,pretty($link_text), pretty(@ell_content);
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# Now look for the "/" -- only in CHILDREN (not all underlings!)
0.000000,0,0.000000,# And afterward, anything left in @ell_content will be the raw name
0.000000,0,0.000000,# Like L<Foo::Bar/Object Methods>
0.000000,0,0.000000,my $section_name;  # set to arrayref if found
0.000000,0,0.000000,DEBUG > 3 and print STDERR "  Peering at L-content for a '/' ...\n";
0.000000,0,0.000000,for(my $j = 0; $j < @ell_content; ++$j) {
0.000000,0,0.000000,next if ref $ell_content[$j];
0.000000,0,0.000000,DEBUG > 3 and
0.000000,0,0.000000,print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '/'.\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if($ell_content[$j] =~ m/^([^\/]*)\/(.*)$/s) {
0.000000,0,0.000000,my @section_name = ($2); # might be 0-length
0.000000,0,0.000000,$ell_content[$j] =  $1;  # might be 0-length
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 3 and
0.000000,0,0.000000,print STDERR "     FOUND a '/' in it.",
0.000000,0,0.000000,"  Splitting to page [...$1] + section [$2...]\n";
0.000000,0,0.000000,
0.000000,0,0.000000,push @section_name, splice @ell_content, 1+$j;
0.000000,0,0.000000,# leaving only things before and including J
0.000000,0,0.000000,
0.000000,0,0.000000,@ell_content  = grep ref($_)||length($_), @ell_content  ;
0.000000,0,0.000000,@section_name = grep ref($_)||length($_), @section_name ;
0.000000,0,0.000000,
0.000000,0,0.000000,# Turn L<.../"foo"> into L<.../foo>
0.000000,0,0.000000,if(@section_name
0.000000,0,0.000000,and !ref($section_name[0]) and !ref($section_name[-1])
0.000000,0,0.000000,and $section_name[ 0] =~ m/^\"/s
0.000000,0,0.000000,and $section_name[-1] =~ m/\"$/s
0.000000,0,0.000000,and !( # catch weird degenerate case of L<"> !
0.000000,0,0.000000,@section_name == 1 and $section_name[0] eq '"'
0.000000,0,0.000000,)
0.000000,0,0.000000,) {
0.000000,0,0.000000,$section_name[ 0] =~ s/^\"//s;
0.000000,0,0.000000,$section_name[-1] =~ s/\"$//s;
0.000000,0,0.000000,DEBUG > 3 and
0.000000,0,0.000000,print STDERR "     Quotes removed: ", pretty(@section_name), "\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 3 and
0.000000,0,0.000000,print STDERR "     No need to remove quotes in ", pretty(@section_name), "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$section_name = \@section_name;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Turn L<"Foo Bar"> into L</Foo Bar>
0.000000,0,0.000000,if(!$section_name and @ell_content
0.000000,0,0.000000,and !ref($ell_content[0]) and !ref($ell_content[-1])
0.000000,0,0.000000,and $ell_content[ 0] =~ m/^\"/s
0.000000,0,0.000000,and $ell_content[-1] =~ m/\"$/s
0.000000,0,0.000000,and !( # catch weird degenerate case of L<"> !
0.000000,0,0.000000,@ell_content == 1 and $ell_content[0] eq '"'
0.000000,0,0.000000,)
0.000000,0,0.000000,) {
0.000000,0,0.000000,$section_name = [splice @ell_content];
0.000000,0,0.000000,$section_name->[ 0] =~ s/^\"//s;
0.000000,0,0.000000,$section_name->[-1] =~ s/\"$//s;
0.000000,0,0.000000,$ell->[1]{'~tolerated'} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Turn L<Foo Bar> into L</Foo Bar>.
0.000000,0,0.000000,if(!$section_name and !$link_text and @ell_content
0.000000,0,0.000000,and grep !ref($_) && m/ /s, @ell_content
0.000000,0,0.000000,) {
0.000000,0,0.000000,$section_name = [splice @ell_content];
0.000000,0,0.000000,$ell->[1]{'~deprecated'} = 1;
0.000000,0,0.000000,# That's support for the now-deprecated syntax.
0.000000,0,0.000000,# Note that it deliberately won't work on L<...|Foo Bar>
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# Now make up the link_text
0.000000,0,0.000000,# L<Foo>     -> L<Foo|Foo>
0.000000,0,0.000000,# L</Bar>    -> L<"Bar"|Bar>
0.000000,0,0.000000,# L<Foo/Bar> -> L<"Bar" in Foo/Foo>
0.000000,0,0.000000,unless($link_text) {
0.000000,0,0.000000,$ell->[1]{'content-implicit'} = 'yes';
0.000000,0,0.000000,$link_text = [];
0.000000,0,0.000000,push @$link_text, '"', @$section_name, '"' if $section_name;
0.000000,0,0.000000,
0.000000,0,0.000000,if(@ell_content) {
0.000000,0,0.000000,$link_text->[-1] .= ' in ' if $section_name;
0.000000,0,0.000000,push @$link_text, @ell_content;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# And the E resolver will have to deal with all our treeletty things:
0.000000,0,0.000000,
0.000000,0,0.000000,if(@ell_content == 1 and !ref($ell_content[0])
0.000000,0,0.000000,and $ell_content[0] =~ m{^[^/]+[(][-a-zA-Z0-9]+[)]$}s
0.000000,0,0.000000,) {
0.000000,0,0.000000,$ell->[1]{'type'}    = 'man';
0.000000,0,0.000000,DEBUG > 3 and print STDERR "Considering this ($ell_content[0]) a man link.\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$ell->[1]{'type'}    = 'pod';
0.000000,0,0.000000,DEBUG > 3 and print STDERR "Considering this a pod link (not man or url).\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if( defined $section_name ) {
0.000000,0,0.000000,$ell->[1]{'section'} = Pod::Simple::LinkSection->new(
0.000000,0,0.000000,['', {}, @$section_name]
0.000000,0,0.000000,);
0.000000,0,0.000000,DEBUG > 3 and print STDERR "L-section content: ", pretty($ell->[1]{'section'}), "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if( @ell_content ) {
0.000000,0,0.000000,$ell->[1]{'to'} = Pod::Simple::LinkSection->new(
0.000000,0,0.000000,['', {}, @ell_content]
0.000000,0,0.000000,);
0.000000,0,0.000000,DEBUG > 3 and print STDERR "L-to content: ", pretty($ell->[1]{'to'}), "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# And update children to be the link-text:
0.000000,0,0.000000,@$ell = (@$ell[0,1], defined($link_text) ? splice(@$link_text) : '');
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 2 and print STDERR "End of L-parsing for this node " . pretty($treelet->[$i]) . "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,unshift @stack, $treelet->[$i]; # might as well recurse
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
0.000000,0,0.000000,
0.000000,0,0.000000,sub _treat_Es {
0.000000,0,0.000000,my($self,@stack) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my($i, $treelet, $content, $replacer, $charnum);
0.000000,0,0.000000,my $start_line = $stack[0][1]{'start_line'};
0.000000,0,0.000000,
0.000000,0,0.000000,# A recursive algorithm implemented iteratively!  Whee!
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# Has frightening side effects on L nodes' attributes.
0.000000,0,0.000000,
0.000000,0,0.000000,#my @ells_to_tweak;
0.000000,0,0.000000,
0.000000,0,0.000000,while($treelet = shift @stack) {
0.000000,0,0.000000,for(my $i = 2; $i < @$treelet; ++$i) { # iterate over children
0.000000,0,0.000000,next unless ref $treelet->[$i];  # text nodes are uninteresting
0.000000,0,0.000000,if($treelet->[$i][0] eq 'L') {
0.000000,0,0.000000,# SPECIAL STUFF for semi-processed L<>'s
0.000000,0,0.000000,
0.000000,0,0.000000,my $thing;
0.000000,0,0.000000,foreach my $attrname ('section', 'to') {        
0.000000,0,0.000000,if(defined($thing = $treelet->[$i][1]{$attrname}) and ref $thing) {
0.000000,0,0.000000,unshift @stack, $thing;
0.000000,0,0.000000,DEBUG > 2 and print STDERR "  Enqueuing ",
0.000000,0,0.000000,pretty( $treelet->[$i][1]{$attrname} ),
0.000000,0,0.000000," as an attribute value to tweak.\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unshift @stack, $treelet->[$i]; # recurse
0.000000,0,0.000000,next;
0.000000,0,0.000000,} elsif($treelet->[$i][0] ne 'E') {
0.000000,0,0.000000,unshift @stack, $treelet->[$i]; # recurse
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Ogling E node ", pretty($treelet->[$i]), "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,# bitch if it's empty
0.000000,0,0.000000,if(  @{$treelet->[$i]} == 2
0.000000,0,0.000000,or (@{$treelet->[$i]} == 3 and $treelet->[$i][2] eq '')
0.000000,0,0.000000,) {
0.000000,0,0.000000,$self->whine( $start_line, "An empty E<>" );
0.000000,0,0.000000,$treelet->[$i] = 'E<>'; # splice in a literal
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# bitch if content is weird
0.000000,0,0.000000,unless(@{$treelet->[$i]} == 3 and !ref($content = $treelet->[$i][2])) {
0.000000,0,0.000000,$self->whine( $start_line, "An E<...> surrounding strange content" );
0.000000,0,0.000000,$replacer = $treelet->[$i]; # scratch
0.000000,0,0.000000,splice(@$treelet, $i, 1,   # fake out a literal
0.000000,0,0.000000,'E<',
0.000000,0,0.000000,splice(@$replacer,2), # promote its content
0.000000,0,0.000000,'>'
0.000000,0,0.000000,);
0.000000,0,0.000000,# Don't need to do --$i, as the 'E<' we just added isn't interesting.
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Ogling E<$content>\n";
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX E<>'s contents *should* be a valid char in the scope of the current
0.000000,0,0.000000,# =encoding directive. Defaults to iso-8859-1, I believe. Fix this in the
0.000000,0,0.000000,# future sometime.
0.000000,0,0.000000,
0.000000,0,0.000000,$charnum  = Pod::Escapes::e2charnum($content);
0.000000,0,0.000000,DEBUG > 1 and print STDERR " Considering E<$content> with char ",
0.000000,0,0.000000,defined($charnum) ? $charnum : "undef", ".\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if(!defined( $charnum )) {
0.000000,0,0.000000,DEBUG > 1 and print STDERR "I don't know how to deal with E<$content>.\n";
0.000000,0,0.000000,$self->whine( $start_line, "Unknown E content in E<$content>" );
0.000000,0,0.000000,$replacer = "E<$content>"; # better than nothing
0.000000,0,0.000000,} elsif($charnum >= 255 and !UNICODE) {
0.000000,0,0.000000,$replacer = ASCII ? "\xA4" : "?";
0.000000,0,0.000000,DEBUG > 1 and print STDERR "This Perl version can't handle ",
0.000000,0,0.000000,"E<$content> (chr $charnum), so replacing with $replacer\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$replacer = Pod::Escapes::e2char($content);
0.000000,0,0.000000,DEBUG > 1 and print STDERR " Replacing E<$content> with $replacer\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,splice(@$treelet, $i, 1, $replacer); # no need to back up $i, tho
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
0.000000,0,0.000000,
0.000000,0,0.000000,sub _treat_Ss {
0.000000,0,0.000000,my($self,$treelet) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,_change_S_to_nbsp($treelet,0) if $self->{'nbsp_for_S'};
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: or a change_nbsp_to_S
0.000000,0,0.000000,#  Normalizing nbsp's to S is harder: for each text node, make S content
0.000000,0,0.000000,#  out of anything matching m/([^ \xA0]*(?:\xA0+[^ \xA0]*)+)/
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _change_S_to_nbsp { #  a recursive function
0.000000,0,0.000000,# Sanely assumes that the top node in the excursion won't be an S node.
0.000000,0,0.000000,my($treelet, $in_s) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $is_s = ('S' eq $treelet->[0]);
0.000000,0,0.000000,$in_s ||= $is_s; # So in_s is on either by this being an S element,
0.000000,0,0.000000,#  or by an ancestor being an S element.
0.000000,0,0.000000,
0.000000,0,0.000000,for(my $i = 2; $i < @$treelet; ++$i) {
0.000000,0,0.000000,if(ref $treelet->[$i]) {
0.000000,0,0.000000,if( _change_S_to_nbsp( $treelet->[$i], $in_s ) ) {
0.000000,0,0.000000,my $to_pull_up = $treelet->[$i];
0.000000,0,0.000000,splice @$to_pull_up,0,2;   # ...leaving just its content
0.000000,0,0.000000,splice @$treelet, $i, 1, @$to_pull_up;  # Pull up content
0.000000,0,0.000000,$i +=  @$to_pull_up - 1;   # Make $i skip the pulled-up stuff
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$treelet->[$i] =~ s/\s/$Pod::Simple::nbsp/g if $in_s;
0.000000,0,0.000000,
0.000000,0,0.000000,# Note that if you apply nbsp_for_S to text, and so turn
0.000000,0,0.000000,# "foo S<bar baz> quux" into "foo bar&#160;faz quux", you
0.000000,0,0.000000,# end up with something that fails to say "and don't hyphenate
0.000000,0,0.000000,# any part of 'bar baz'".  However, hyphenation is such a vexing
0.000000,0,0.000000,# problem anyway, that most Pod renderers just don't render it
0.000000,0,0.000000,# at all.  But if you do want to implement hyphenation, I guess
0.000000,0,0.000000,# that you'd better have nbsp_for_S off.
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $is_s;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#-----------------------------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,sub _accessorize {  # A simple-minded method-maker
0.000153,2,0.000077,no strict 'refs';
0.000002,1,0.000002,foreach my $attrname (@_) {
0.000099,30,0.000003,next if $attrname =~ m/::/; # a hack
0.000000,0,0.000000,*{caller() . '::' . $attrname} = sub {
0.000636,2,0.000318,use strict;
0.000000,0,0.000000,$Carp::CarpLevel = 1,  Carp::croak(
0.000000,0,0.000000,"Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)"
0.000000,0,0.000000,) unless (@_ == 1 or @_ == 2) and ref $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,(@_ == 1) ?  $_[0]->{$attrname}
0.000000,0,0.000000,: ($_[0]->{$attrname} = $_[1]);
0.000074,29,0.000003,};
0.000000,0,0.000000,}
0.000000,0,0.000000,# Ya know, they say accessories make the ensemble!
0.000003,1,0.000003,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
0.000000,0,0.000000,# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
0.000000,0,0.000000,#=============================================================================
0.000000,0,0.000000,
0.000000,0,0.000000,sub filter {
0.000000,0,0.000000,my($class, $source) = @_;
0.000000,0,0.000000,my $new = $class->new;
0.000000,0,0.000000,$new->output_fh(*STDOUT{IO});
0.000000,0,0.000000,
0.000000,0,0.000000,if(ref($source || '') eq 'SCALAR') {
0.000000,0,0.000000,$new->parse_string_document( $$source );
0.000000,0,0.000000,} elsif(ref($source)) {  # it's a file handle
0.000000,0,0.000000,$new->parse_file($source);
0.000000,0,0.000000,} else {  # it's a filename
0.000000,0,0.000000,$new->parse_file($source);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#-----------------------------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,sub _out {
0.000000,0,0.000000,# For use in testing: Class->_out($source)
0.000000,0,0.000000,#  returns the transformation of $source
0.000000,0,0.000000,
0.000000,0,0.000000,my $class = shift(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,my $mutor = shift(@_) if @_ and ref($_[0] || '') eq 'CODE';
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and print STDERR "\n\n", '#' x 76,
0.000000,0,0.000000,"\nAbout to parse source: {{\n$_[0]\n}}\n\n";
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,my $parser = ref $class && $class->isa(__PACKAGE__) ? $class : $class->new;
0.000000,0,0.000000,$parser->hide_line_numbers(1);
0.000000,0,0.000000,
0.000000,0,0.000000,my $out = '';
0.000000,0,0.000000,$parser->output_string( \$out );
0.000000,0,0.000000,DEBUG and print STDERR " _out to ", \$out, "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,$mutor->($parser) if $mutor;
0.000000,0,0.000000,
0.000000,0,0.000000,$parser->parse_string_document( $_[0] );
0.000000,0,0.000000,# use Data::Dumper; print STDERR Dumper($parser), "\n";
0.000000,0,0.000000,return $out;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _duo {
0.000000,0,0.000000,# For use in testing: Class->_duo($source1, $source2)
0.000000,0,0.000000,#  returns the parse trees of $source1 and $source2.
0.000000,0,0.000000,# Good in things like: &ok( Class->duo(... , ...) );
0.000000,0,0.000000,
0.000000,0,0.000000,my $class = shift(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak "But $class->_duo is useful only in list context!"
0.000000,0,0.000000,unless wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,my $mutor = shift(@_) if @_ and ref($_[0] || '') eq 'CODE';
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak "But $class->_duo takes two parameters, not: @_"
0.000000,0,0.000000,unless @_ == 2;
0.000000,0,0.000000,
0.000000,0,0.000000,my(@out);
0.000000,0,0.000000,
0.000000,0,0.000000,while( @_ ) {
0.000000,0,0.000000,my $parser = $class->new;
0.000000,0,0.000000,
0.000000,0,0.000000,push @out, '';
0.000000,0,0.000000,$parser->output_string( \( $out[-1] ) );
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and print STDERR " _duo out to ", $parser->output_string(),
0.000000,0,0.000000," = $parser->{'output_string'}\n";
0.000000,0,0.000000,
0.000000,0,0.000000,$parser->hide_line_numbers(1);
0.000000,0,0.000000,$mutor->($parser) if $mutor;
0.000000,0,0.000000,$parser->parse_string_document( shift( @_ ) );
0.000000,0,0.000000,# use Data::Dumper; print STDERR Dumper($parser), "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return @out;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#-----------------------------------------------------------------------------
0.000013,1,0.000013,1;
0.000000,0,0.000000,__END__
