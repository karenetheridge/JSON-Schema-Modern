# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package POSIX;
0.000021,2,0.000011,use strict;
0.000055,2,0.000028,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,our ($AUTOLOAD, %SIGRT);
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '2.03';
0.000000,0,0.000000,
0.000001,1,0.000001,require XSLoader;
0.000000,0,0.000000,
0.000000,1,0.000000,use Fcntl qw(FD_CLOEXEC F_DUPFD F_GETFD F_GETFL F_GETLK F_RDLCK F_SETFD
0.000000,0,0.000000,F_SETFL F_SETLK F_SETLKW F_UNLCK F_WRLCK O_ACCMODE O_APPEND
0.000000,0,0.000000,O_CREAT O_EXCL O_NOCTTY O_NONBLOCK O_RDONLY O_RDWR O_TRUNC
0.000000,0,0.000000,O_WRONLY SEEK_CUR SEEK_END SEEK_SET
0.000000,0,0.000000,S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG
0.000000,0,0.000000,S_IRGRP S_IROTH S_IRUSR S_IRWXG S_IRWXO S_IRWXU S_ISGID S_ISUID
0.000655,1,0.000655,S_IWGRP S_IWOTH S_IWUSR S_IXGRP S_IXOTH S_IXUSR);
0.000000,0,0.000000,
0.000000,1,0.000000,my $loaded;
0.000000,0,0.000000,
0.000000,0,0.000000,sub croak { require Carp;  goto &Carp::croak }
0.000000,0,0.000000,sub usage { croak "Usage: POSIX::$_[0]" }
0.000000,0,0.000000,
0.001547,1,0.001547,XSLoader::load();
0.000000,0,0.000000,
0.000034,1,0.000034,my %replacement = (
0.000000,0,0.000000,L_tmpnam    => undef,
0.000000,0,0.000000,atexit      => 'END {}',
0.000000,0,0.000000,atof        => undef,
0.000000,0,0.000000,atoi        => undef,
0.000000,0,0.000000,atol        => undef,
0.000000,0,0.000000,bsearch     => \'not supplied',
0.000000,0,0.000000,calloc      => undef,
0.000000,0,0.000000,clearerr    => 'IO::Handle::clearerr',
0.000000,0,0.000000,div         => '/, % and int',
0.000000,0,0.000000,execl       => undef,
0.000000,0,0.000000,execle      => undef,
0.000000,0,0.000000,execlp      => undef,
0.000000,0,0.000000,execv       => undef,
0.000000,0,0.000000,execve      => undef,
0.000000,0,0.000000,execvp      => undef,
0.000000,0,0.000000,fclose      => 'IO::Handle::close',
0.000000,0,0.000000,fdopen      => 'IO::Handle::new_from_fd',
0.000000,0,0.000000,feof        => 'IO::Handle::eof',
0.000000,0,0.000000,ferror      => 'IO::Handle::error',
0.000000,0,0.000000,fflush      => 'IO::Handle::flush',
0.000000,0,0.000000,fgetc       => 'IO::Handle::getc',
0.000000,0,0.000000,fgetpos     => 'IO::Seekable::getpos',
0.000000,0,0.000000,fgets       => 'IO::Handle::gets',
0.000000,0,0.000000,fileno      => 'IO::Handle::fileno',
0.000000,0,0.000000,fopen       => 'IO::File::open',
0.000000,0,0.000000,fprintf     => 'printf',
0.000000,0,0.000000,fputc       => 'print',
0.000000,0,0.000000,fputs       => 'print',
0.000000,0,0.000000,fread       => 'read',
0.000000,0,0.000000,free        => undef,
0.000000,0,0.000000,freopen     => 'open',
0.000000,0,0.000000,fscanf      => '<> and regular expressions',
0.000000,0,0.000000,fseek       => 'IO::Seekable::seek',
0.000000,0,0.000000,fsetpos     => 'IO::Seekable::setpos',
0.000000,0,0.000000,fsync       => 'IO::Handle::sync',
0.000000,0,0.000000,ftell       => 'IO::Seekable::tell',
0.000000,0,0.000000,fwrite      => 'print',
0.000000,0,0.000000,labs        => 'abs',
0.000000,0,0.000000,ldiv        => '/, % and int',
0.000000,0,0.000000,longjmp     => 'die',
0.000000,0,0.000000,malloc      => undef,
0.000000,0,0.000000,memchr      => 'index()',
0.000000,0,0.000000,memcmp      => 'eq',
0.000000,0,0.000000,memcpy      => '=',
0.000000,0,0.000000,memmove     => '=',
0.000000,0,0.000000,memset      => 'x',
0.000000,0,0.000000,offsetof    => undef,
0.000000,0,0.000000,putc        => 'print',
0.000000,0,0.000000,putchar     => 'print',
0.000000,0,0.000000,puts        => 'print',
0.000000,0,0.000000,qsort       => 'sort',
0.000000,0,0.000000,rand        => \'non-portable, use Perl\'s rand instead',
0.000000,0,0.000000,realloc     => undef,
0.000000,0,0.000000,scanf       => '<> and regular expressions',
0.000000,0,0.000000,setbuf      => 'IO::Handle::setbuf',
0.000000,0,0.000000,setjmp      => 'eval {}',
0.000000,0,0.000000,setvbuf     => 'IO::Handle::setvbuf',
0.000000,0,0.000000,siglongjmp  => 'die',
0.000000,0,0.000000,sigsetjmp   => 'eval {}',
0.000000,0,0.000000,srand       => \'not supplied; refer to Perl\'s srand documentation',
0.000000,0,0.000000,sscanf      => 'regular expressions',
0.000000,0,0.000000,strcat      => '.=',
0.000000,0,0.000000,strchr      => 'index()',
0.000000,0,0.000000,strcmp      => 'eq',
0.000000,0,0.000000,strcpy      => '=',
0.000000,0,0.000000,strcspn     => 'regular expressions',
0.000000,0,0.000000,strlen      => 'length',
0.000000,0,0.000000,strncat     => '.=',
0.000000,0,0.000000,strncmp     => 'eq',
0.000000,0,0.000000,strncpy     => '=',
0.000000,0,0.000000,strpbrk     => undef,
0.000000,0,0.000000,strrchr     => 'rindex()',
0.000000,0,0.000000,strspn      => undef,
0.000000,0,0.000000,strtok      => undef,
0.000000,0,0.000000,tmpfile     => 'IO::File::new_tmpfile',
0.000000,0,0.000000,tmpnam      => 'use File::Temp',
0.000000,0,0.000000,ungetc      => 'IO::Handle::ungetc',
0.000000,0,0.000000,vfprintf    => undef,
0.000000,0,0.000000,vprintf     => undef,
0.000000,0,0.000000,vsprintf    => undef,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000024,1,0.000024,my %reimpl = (
0.000000,0,0.000000,abs       => 'x => CORE::abs($_[0])',
0.000000,0,0.000000,alarm     => 'seconds => CORE::alarm($_[0])',
0.000000,0,0.000000,assert    => 'expr => croak "Assertion failed" if !$_[0]',
0.000000,0,0.000000,atan2     => 'x, y => CORE::atan2($_[0], $_[1])',
0.000000,0,0.000000,chdir     => 'directory => CORE::chdir($_[0])',
0.000000,0,0.000000,chmod     => 'mode, filename => CORE::chmod($_[0], $_[1])',
0.000000,0,0.000000,chown     => 'uid, gid, filename => CORE::chown($_[0], $_[1], $_[2])',
0.000000,0,0.000000,closedir  => 'dirhandle => CORE::closedir($_[0])',
0.000000,0,0.000000,cos       => 'x => CORE::cos($_[0])',
0.000000,0,0.000000,creat     => 'filename, mode => &open($_[0], &O_WRONLY | &O_CREAT | &O_TRUNC, $_[1])',
0.000000,0,0.000000,errno     => '$! + 0',
0.000000,0,0.000000,exit      => 'status => CORE::exit($_[0])',
0.000000,0,0.000000,exp       => 'x => CORE::exp($_[0])',
0.000000,0,0.000000,fabs      => 'x => CORE::abs($_[0])',
0.000000,0,0.000000,fcntl     => 'filehandle, cmd, arg => CORE::fcntl($_[0], $_[1], $_[2])',
0.000000,0,0.000000,fork      => 'CORE::fork',
0.000000,0,0.000000,fstat     => 'fd => CORE::open my $dup, "<&", $_[0]; CORE::stat($dup)', # Gross.
0.000000,0,0.000000,getc      => 'handle => CORE::getc($_[0])',
0.000000,0,0.000000,getchar   => 'CORE::getc(STDIN)',
0.000000,0,0.000000,getegid   => '$) + 0',
0.000000,0,0.000000,getenv    => 'name => $ENV{$_[0]}',
0.000000,0,0.000000,geteuid   => '$> + 0',
0.000000,0,0.000000,getgid    => '$( + 0',
0.000000,0,0.000000,getgrgid  => 'gid => CORE::getgrgid($_[0])',
0.000000,0,0.000000,getgrnam  => 'name => CORE::getgrnam($_[0])',
0.000000,0,0.000000,getgroups => 'my %seen; grep !$seen{$_}++, split " ", $)',
0.000000,0,0.000000,getlogin  => 'CORE::getlogin()',
0.000000,0,0.000000,getpgrp   => 'CORE::getpgrp',
0.000000,0,0.000000,getpid    => '$$',
0.000000,0,0.000000,getppid   => 'CORE::getppid',
0.000000,0,0.000000,getpwnam  => 'name => CORE::getpwnam($_[0])',
0.000000,0,0.000000,getpwuid  => 'uid => CORE::getpwuid($_[0])',
0.000000,0,0.000000,gets      => 'scalar <STDIN>',
0.000000,0,0.000000,getuid    => '$<',
0.000000,0,0.000000,gmtime    => 'time => CORE::gmtime($_[0])',
0.000000,0,0.000000,isatty    => 'filehandle => -t $_[0]',
0.000000,0,0.000000,kill      => 'pid, sig => CORE::kill $_[1], $_[0]',
0.000000,0,0.000000,link      => 'oldfilename, newfilename => CORE::link($_[0], $_[1])',
0.000000,0,0.000000,localtime => 'time => CORE::localtime($_[0])',
0.000000,0,0.000000,log       => 'x => CORE::log($_[0])',
0.000000,0,0.000000,mkdir     => 'directoryname, mode => CORE::mkdir($_[0], $_[1])',
0.000000,0,0.000000,opendir   => 'directory => my $dh; CORE::opendir($dh, $_[0]) ? $dh : undef',
0.000000,0,0.000000,pow       => 'x, exponent => $_[0] ** $_[1]',
0.000000,0,0.000000,raise     => 'sig => CORE::kill $_[0], $$;	# Is this good enough',
0.000000,0,0.000000,readdir   => 'dirhandle => CORE::readdir($_[0])',
0.000000,0,0.000000,remove    => 'filename => (-d $_[0]) ? CORE::rmdir($_[0]) : CORE::unlink($_[0])',
0.000000,0,0.000000,rename    => 'oldfilename, newfilename => CORE::rename($_[0], $_[1])',
0.000000,0,0.000000,rewind    => 'filehandle => CORE::seek($_[0],0,0)',
0.000000,0,0.000000,rewinddir => 'dirhandle => CORE::rewinddir($_[0])',
0.000000,0,0.000000,rmdir     => 'directoryname => CORE::rmdir($_[0])',
0.000000,0,0.000000,sin       => 'x => CORE::sin($_[0])',
0.000000,0,0.000000,sqrt      => 'x => CORE::sqrt($_[0])',
0.000000,0,0.000000,stat      => 'filename => CORE::stat($_[0])',
0.000000,0,0.000000,strerror  => 'errno => BEGIN { local $!; require locale; locale->import} my $e = $_[0] + 0; local $!; $! = $e; "$!"',
0.000000,0,0.000000,strstr    => 'big, little => CORE::index($_[0], $_[1])',
0.000000,0,0.000000,system    => 'command => CORE::system($_[0])',
0.000000,0,0.000000,time      => 'CORE::time',
0.000000,0,0.000000,umask     => 'mask => CORE::umask($_[0])',
0.000000,0,0.000000,unlink    => 'filename => CORE::unlink($_[0])',
0.000000,0,0.000000,utime     => 'filename, atime, mtime => CORE::utime($_[1], $_[2], $_[0])',
0.000000,0,0.000000,wait      => 'CORE::wait()',
0.000000,0,0.000000,waitpid   => 'pid, options => CORE::waitpid($_[0], $_[1])',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000001,1,0.000001,my $pkg = shift;
0.000000,0,0.000000,
0.000002,1,0.000002,load_imports() unless $loaded++;
0.000000,0,0.000000,
0.000000,0,0.000000,# Rewrite legacy foo_h form to new :foo_h form
0.000015,1,0.000015,s/^(?=\w+_h$)/:/ for my @list = @_;
0.000000,0,0.000000,
0.000009,1,0.000009,my @unimpl = sort grep { exists $replacement{$_} } @list;
0.000001,1,0.000001,if (@unimpl) {
0.000000,0,0.000000,for my $u (@unimpl) {
0.000000,0,0.000000,warn "Unimplemented: POSIX::$u(): ", unimplemented_message($u);
0.000000,0,0.000000,}
0.000000,0,0.000000,croak(sprintf("Unimplemented: %s",
0.000000,0,0.000000,join(" ", map { "POSIX::$_()" } @unimpl)));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,local $Exporter::ExportLevel = 1;
0.000008,1,0.000008,Exporter::import($pkg,@list);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000653,1,0.000653,eval join ';', map "sub $_", keys %replacement, keys %reimpl;
0.000000,0,0.000000,
0.000000,0,0.000000,sub unimplemented_message {
0.000000,0,0.000000,my $func = shift;
0.000000,0,0.000000,my $how = $replacement{$func};
0.000000,0,0.000000,return "C-specific, stopped" unless defined $how;
0.000000,0,0.000000,return "$$how" if ref $how;
0.000000,0,0.000000,return "$how instead" if $how =~ /^use /;
0.000000,0,0.000000,return "Use method $how() instead" if $how =~ /::/;
0.000000,0,0.000000,return "C-specific: use $how instead";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub AUTOLOAD {
0.000000,0,0.000000,my ($func) = ($AUTOLOAD =~ /.*::(.*)/);
0.000000,0,0.000000,
0.000000,0,0.000000,die "POSIX.xs has failed to load\n" if $func eq 'constant';
0.000000,0,0.000000,
0.000000,0,0.000000,if (my $code = $reimpl{$func}) {
0.000000,0,0.000000,my ($num, $arg) = (0, '');
0.000000,0,0.000000,if ($code =~ s/^(.*?) *=> *//) {
0.000000,0,0.000000,$arg = $1;
0.000000,0,0.000000,$num = 1 + $arg =~ tr/,//;
0.000000,0,0.000000,}
0.000000,0,0.000000,# no warnings to be consistent with the old implementation, where each
0.000000,0,0.000000,# function was in its own little AutoSplit world:
0.000000,0,0.000000,eval qq{ sub $func {
0.000000,0,0.000000,no warnings;
0.000000,0,0.000000,usage "$func($arg)" if \@_ != $num;
0.000000,0,0.000000,$code
0.000000,0,0.000000,} };
0.001502,2,0.000751,no strict;
0.000000,0,0.000000,goto &$AUTOLOAD;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (exists $replacement{$func}) {
0.000000,0,0.000000,croak "Unimplemented: POSIX::$func(): ", unimplemented_message($func);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,constant($func);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub perror {
0.000000,0,0.000000,print STDERR "@_: " if @_;
0.000000,0,0.000000,print STDERR $!,"\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub printf {
0.000000,0,0.000000,usage "printf(pattern, args...)" if @_ < 1;
0.000000,0,0.000000,CORE::printf STDOUT @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sprintf {
0.000000,0,0.000000,usage "sprintf(pattern, args...)" if @_ == 0;
0.000000,0,0.000000,CORE::sprintf(shift,@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub load_imports {
0.000045,1,0.000045,my %default_export_tags = ( # cf. exports policy below
0.000000,0,0.000000,
0.000000,0,0.000000,assert_h =>	[qw(assert NDEBUG)],
0.000000,0,0.000000,
0.000000,0,0.000000,ctype_h =>	        [],
0.000000,0,0.000000,
0.000000,0,0.000000,dirent_h =>	[],
0.000000,0,0.000000,
0.000000,0,0.000000,errno_h =>	[qw(E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN
0.000000,0,0.000000,EALREADY EBADF EBADMSG EBUSY ECANCELED ECHILD ECONNABORTED
0.000000,0,0.000000,ECONNREFUSED ECONNRESET EDEADLK EDESTADDRREQ EDOM EDQUOT EEXIST
0.000000,0,0.000000,EFAULT EFBIG EHOSTDOWN EHOSTUNREACH EIDRM EILSEQ EINPROGRESS
0.000000,0,0.000000,EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK EMSGSIZE
0.000000,0,0.000000,ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS
0.000000,0,0.000000,ENODATA ENODEV ENOENT ENOEXEC ENOLCK ENOLINK ENOMEM ENOMSG
0.000000,0,0.000000,ENOPROTOOPT ENOSPC ENOSR ENOSTR ENOSYS ENOTBLK ENOTCONN ENOTDIR
0.000000,0,0.000000,ENOTEMPTY ENOTRECOVERABLE ENOTSOCK ENOTSUP ENOTTY ENXIO
0.000000,0,0.000000,EOPNOTSUPP EOTHER EOVERFLOW EOWNERDEAD EPERM EPFNOSUPPORT EPIPE
0.000000,0,0.000000,EPROCLIM EPROTO EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE
0.000000,0,0.000000,ERESTART EROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE
0.000000,0,0.000000,ETIME ETIMEDOUT ETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV
0.000000,0,0.000000,errno)],
0.000000,0,0.000000,
0.000000,0,0.000000,fcntl_h =>	[qw(FD_CLOEXEC F_DUPFD F_GETFD F_GETFL F_GETLK F_RDLCK
0.000000,0,0.000000,F_SETFD F_SETFL F_SETLK F_SETLKW F_UNLCK F_WRLCK
0.000000,0,0.000000,O_ACCMODE O_APPEND O_CREAT O_EXCL O_NOCTTY O_NONBLOCK
0.000000,0,0.000000,O_RDONLY O_RDWR O_TRUNC O_WRONLY
0.000000,0,0.000000,creat
0.000000,0,0.000000,SEEK_CUR SEEK_END SEEK_SET
0.000000,0,0.000000,S_IRGRP S_IROTH S_IRUSR S_IRWXG S_IRWXO S_IRWXU
0.000000,0,0.000000,S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISGID S_ISREG S_ISUID
0.000000,0,0.000000,S_IWGRP S_IWOTH S_IWUSR)],
0.000000,0,0.000000,
0.000000,0,0.000000,float_h =>	[qw(DBL_DIG DBL_EPSILON DBL_MANT_DIG
0.000000,0,0.000000,DBL_MAX DBL_MAX_10_EXP DBL_MAX_EXP
0.000000,0,0.000000,DBL_MIN DBL_MIN_10_EXP DBL_MIN_EXP
0.000000,0,0.000000,FLT_DIG FLT_EPSILON FLT_MANT_DIG
0.000000,0,0.000000,FLT_MAX FLT_MAX_10_EXP FLT_MAX_EXP
0.000000,0,0.000000,FLT_MIN FLT_MIN_10_EXP FLT_MIN_EXP
0.000000,0,0.000000,FLT_RADIX FLT_ROUNDS
0.000000,0,0.000000,LDBL_DIG LDBL_EPSILON LDBL_MANT_DIG
0.000000,0,0.000000,LDBL_MAX LDBL_MAX_10_EXP LDBL_MAX_EXP
0.000000,0,0.000000,LDBL_MIN LDBL_MIN_10_EXP LDBL_MIN_EXP)],
0.000000,0,0.000000,
0.000000,0,0.000000,grp_h =>	[],
0.000000,0,0.000000,
0.000000,0,0.000000,limits_h =>	[qw( ARG_MAX CHAR_BIT CHAR_MAX CHAR_MIN CHILD_MAX
0.000000,0,0.000000,INT_MAX INT_MIN LINK_MAX LONG_MAX LONG_MIN MAX_CANON
0.000000,0,0.000000,MAX_INPUT MB_LEN_MAX NAME_MAX NGROUPS_MAX OPEN_MAX
0.000000,0,0.000000,PATH_MAX PIPE_BUF SCHAR_MAX SCHAR_MIN SHRT_MAX SHRT_MIN
0.000000,0,0.000000,SSIZE_MAX STREAM_MAX TZNAME_MAX UCHAR_MAX UINT_MAX
0.000000,0,0.000000,ULONG_MAX USHRT_MAX _POSIX_ARG_MAX _POSIX_CHILD_MAX
0.000000,0,0.000000,_POSIX_LINK_MAX _POSIX_MAX_CANON _POSIX_MAX_INPUT
0.000000,0,0.000000,_POSIX_NAME_MAX _POSIX_NGROUPS_MAX _POSIX_OPEN_MAX
0.000000,0,0.000000,_POSIX_PATH_MAX _POSIX_PIPE_BUF _POSIX_SSIZE_MAX
0.000000,0,0.000000,_POSIX_STREAM_MAX _POSIX_TZNAME_MAX)],
0.000000,0,0.000000,
0.000000,0,0.000000,locale_h =>	[qw(LC_ALL LC_COLLATE LC_CTYPE LC_MESSAGES
0.000000,0,0.000000,LC_MONETARY LC_NUMERIC LC_TIME LC_IDENTIFICATION
0.000000,0,0.000000,LC_MEASUREMENT LC_PAPER LC_TELEPHONE LC_ADDRESS
0.000000,0,0.000000,LC_SYNTAX LC_TOD NULL
0.000000,0,0.000000,localeconv setlocale)],
0.000000,0,0.000000,
0.000000,0,0.000000,math_h =>   [qw(FP_ILOGB0 FP_ILOGBNAN FP_INFINITE FP_NAN FP_NORMAL
0.000000,0,0.000000,FP_SUBNORMAL FP_ZERO
0.000000,0,0.000000,M_1_PI M_2_PI M_2_SQRTPI M_E M_LN10 M_LN2 M_LOG10E M_LOG2E
0.000000,0,0.000000,M_PI M_PI_2 M_PI_4 M_SQRT1_2 M_SQRT2
0.000000,0,0.000000,HUGE_VAL INFINITY NAN
0.000000,0,0.000000,acos asin atan ceil cosh fabs floor fmod
0.000000,0,0.000000,frexp ldexp log10 modf pow sinh tan tanh)],
0.000000,0,0.000000,
0.000000,0,0.000000,pwd_h =>	[],
0.000000,0,0.000000,
0.000000,0,0.000000,setjmp_h =>	[qw(longjmp setjmp siglongjmp sigsetjmp)],
0.000000,0,0.000000,
0.000000,0,0.000000,signal_h =>	[qw(SA_NOCLDSTOP SA_NOCLDWAIT SA_NODEFER SA_ONSTACK
0.000000,0,0.000000,SA_RESETHAND SA_RESTART SA_SIGINFO SIGABRT SIGALRM
0.000000,0,0.000000,SIGCHLD SIGCONT SIGFPE SIGHUP SIGILL SIGINT SIGKILL
0.000000,0,0.000000,SIGPIPE %SIGRT SIGRTMIN SIGRTMAX SIGQUIT SIGSEGV SIGSTOP
0.000000,0,0.000000,SIGTERM SIGTSTP SIGTTIN SIGTTOU SIGUSR1 SIGUSR2 SIGBUS
0.000000,0,0.000000,SIGPOLL SIGPROF SIGSYS SIGTRAP SIGURG SIGVTALRM SIGXCPU SIGXFSZ
0.000000,0,0.000000,SIG_BLOCK SIG_DFL SIG_ERR SIG_IGN SIG_SETMASK SIG_UNBLOCK
0.000000,0,0.000000,raise sigaction signal sigpending sigprocmask sigsuspend)],
0.000000,0,0.000000,
0.000000,0,0.000000,stdarg_h =>	[],
0.000000,0,0.000000,
0.000000,0,0.000000,stddef_h =>	[qw(NULL offsetof)],
0.000000,0,0.000000,
0.000000,0,0.000000,stdio_h =>	[qw(BUFSIZ EOF FILENAME_MAX L_ctermid L_cuserid
0.000000,0,0.000000,NULL SEEK_CUR SEEK_END SEEK_SET
0.000000,0,0.000000,STREAM_MAX TMP_MAX stderr stdin stdout
0.000000,0,0.000000,clearerr fclose fdopen feof ferror fflush fgetc fgetpos
0.000000,0,0.000000,fgets fopen fprintf fputc fputs fread freopen
0.000000,0,0.000000,fscanf fseek fsetpos ftell fwrite getchar gets
0.000000,0,0.000000,perror putc putchar puts remove rewind
0.000000,0,0.000000,scanf setbuf setvbuf sscanf tmpfile tmpnam
0.000000,0,0.000000,ungetc vfprintf vprintf vsprintf)],
0.000000,0,0.000000,
0.000000,0,0.000000,stdlib_h =>	[qw(EXIT_FAILURE EXIT_SUCCESS MB_CUR_MAX NULL RAND_MAX
0.000000,0,0.000000,abort atexit atof atoi atol bsearch calloc div
0.000000,0,0.000000,free getenv labs ldiv malloc mblen mbstowcs mbtowc
0.000000,0,0.000000,qsort realloc strtod strtol strtoul wcstombs wctomb)],
0.000000,0,0.000000,
0.000000,0,0.000000,string_h =>	[qw(NULL memchr memcmp memcpy memmove memset strcat
0.000000,0,0.000000,strchr strcmp strcoll strcpy strcspn strerror strlen
0.000000,0,0.000000,strncat strncmp strncpy strpbrk strrchr strspn strstr
0.000000,0,0.000000,strtok strxfrm)],
0.000000,0,0.000000,
0.000000,0,0.000000,sys_stat_h => [qw(S_IRGRP S_IROTH S_IRUSR S_IRWXG S_IRWXO S_IRWXU
0.000000,0,0.000000,S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISGID S_ISREG
0.000000,0,0.000000,S_ISUID S_IWGRP S_IWOTH S_IWUSR S_IXGRP S_IXOTH S_IXUSR
0.000000,0,0.000000,fstat mkfifo)],
0.000000,0,0.000000,
0.000000,0,0.000000,sys_times_h => [],
0.000000,0,0.000000,
0.000000,0,0.000000,sys_types_h => [],
0.000000,0,0.000000,
0.000000,0,0.000000,sys_utsname_h => [qw(uname)],
0.000000,0,0.000000,
0.000000,0,0.000000,sys_wait_h => [qw(WEXITSTATUS WIFEXITED WIFSIGNALED WIFSTOPPED
0.000000,0,0.000000,WNOHANG WSTOPSIG WTERMSIG WUNTRACED)],
0.000000,0,0.000000,
0.000000,0,0.000000,termios_h => [qw( B0 B110 B1200 B134 B150 B1800 B19200 B200 B2400
0.000000,0,0.000000,B300 B38400 B4800 B50 B600 B75 B9600 BRKINT CLOCAL
0.000000,0,0.000000,CREAD CS5 CS6 CS7 CS8 CSIZE CSTOPB ECHO ECHOE ECHOK
0.000000,0,0.000000,ECHONL HUPCL ICANON ICRNL IEXTEN IGNBRK IGNCR IGNPAR
0.000000,0,0.000000,INLCR INPCK ISIG ISTRIP IXOFF IXON NCCS NOFLSH OPOST
0.000000,0,0.000000,PARENB PARMRK PARODD TCIFLUSH TCIOFF TCIOFLUSH TCION
0.000000,0,0.000000,TCOFLUSH TCOOFF TCOON TCSADRAIN TCSAFLUSH TCSANOW
0.000000,0,0.000000,TOSTOP VEOF VEOL VERASE VINTR VKILL VMIN VQUIT VSTART
0.000000,0,0.000000,VSTOP VSUSP VTIME
0.000000,0,0.000000,cfgetispeed cfgetospeed cfsetispeed cfsetospeed tcdrain
0.000000,0,0.000000,tcflow tcflush tcgetattr tcsendbreak tcsetattr )],
0.000000,0,0.000000,
0.000000,0,0.000000,time_h =>	[qw(CLK_TCK CLOCKS_PER_SEC NULL asctime clock ctime
0.000000,0,0.000000,difftime mktime strftime tzset tzname)],
0.000000,0,0.000000,
0.000000,0,0.000000,unistd_h =>	[qw(F_OK NULL R_OK SEEK_CUR SEEK_END SEEK_SET
0.000000,0,0.000000,STDERR_FILENO STDIN_FILENO STDOUT_FILENO W_OK X_OK
0.000000,0,0.000000,_PC_CHOWN_RESTRICTED _PC_LINK_MAX _PC_MAX_CANON
0.000000,0,0.000000,_PC_MAX_INPUT _PC_NAME_MAX _PC_NO_TRUNC _PC_PATH_MAX
0.000000,0,0.000000,_PC_PIPE_BUF _PC_VDISABLE _POSIX_CHOWN_RESTRICTED
0.000000,0,0.000000,_POSIX_JOB_CONTROL _POSIX_NO_TRUNC _POSIX_SAVED_IDS
0.000000,0,0.000000,_POSIX_VDISABLE _POSIX_VERSION _SC_ARG_MAX
0.000000,0,0.000000,_SC_CHILD_MAX _SC_CLK_TCK _SC_JOB_CONTROL
0.000000,0,0.000000,_SC_NGROUPS_MAX _SC_OPEN_MAX _SC_PAGESIZE _SC_SAVED_IDS
0.000000,0,0.000000,_SC_STREAM_MAX _SC_TZNAME_MAX _SC_VERSION
0.000000,0,0.000000,_exit access ctermid cuserid
0.000000,0,0.000000,dup2 dup execl execle execlp execv execve execvp
0.000000,0,0.000000,fpathconf fsync getcwd getegid geteuid getgid getgroups
0.000000,0,0.000000,getpid getuid isatty lseek pathconf pause setgid setpgid
0.000000,0,0.000000,setsid setuid sysconf tcgetpgrp tcsetpgrp ttyname)],
0.000000,0,0.000000,
0.000000,0,0.000000,utime_h =>	[],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000002,1,0.000002,if ($^O eq 'MSWin32') {
0.000000,0,0.000000,$default_export_tags{winsock_h} = [qw(
0.000000,0,0.000000,WSAEINTR WSAEBADF WSAEACCES WSAEFAULT WSAEINVAL WSAEMFILE WSAEWOULDBLOCK
0.000000,0,0.000000,WSAEINPROGRESS WSAEALREADY WSAENOTSOCK WSAEDESTADDRREQ WSAEMSGSIZE
0.000000,0,0.000000,WSAEPROTOTYPE WSAENOPROTOOPT WSAEPROTONOSUPPORT WSAESOCKTNOSUPPORT
0.000000,0,0.000000,WSAEOPNOTSUPP WSAEPFNOSUPPORT WSAEAFNOSUPPORT WSAEADDRINUSE
0.000000,0,0.000000,WSAEADDRNOTAVAIL WSAENETDOWN WSAENETUNREACH WSAENETRESET WSAECONNABORTED
0.000000,0,0.000000,WSAECONNRESET WSAENOBUFS WSAEISCONN WSAENOTCONN WSAESHUTDOWN
0.000000,0,0.000000,WSAETOOMANYREFS WSAETIMEDOUT WSAECONNREFUSED WSAELOOP WSAENAMETOOLONG
0.000000,0,0.000000,WSAEHOSTDOWN WSAEHOSTUNREACH WSAENOTEMPTY WSAEPROCLIM WSAEUSERS
0.000000,0,0.000000,WSAEDQUOT WSAESTALE WSAEREMOTE WSAEDISCON WSAENOMORE WSAECANCELLED
0.000000,0,0.000000,WSAEINVALIDPROCTABLE WSAEINVALIDPROVIDER WSAEPROVIDERFAILEDINIT
0.000000,0,0.000000,WSAEREFUSED)];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %other_export_tags = ( # cf. exports policy below
0.000000,0,0.000000,fenv_h => [qw(
0.000000,0,0.000000,FE_DOWNWARD FE_TONEAREST FE_TOWARDZERO FE_UPWARD fegetround fesetround
0.000000,0,0.000000,)],
0.000000,0,0.000000,
0.000000,0,0.000000,math_h_c99 => [ @{$default_export_tags{math_h}}, qw(
0.000000,0,0.000000,Inf NaN acosh asinh atanh cbrt copysign erf erfc exp2 expm1 fdim fma
0.000000,0,0.000000,fmax fmin fpclassify hypot ilogb isfinite isgreater isgreaterequal
0.000000,0,0.000000,isinf isless islessequal islessgreater isnan isnormal isunordered j0 j1
0.000000,0,0.000000,jn lgamma log1p log2 logb lrint lround nan nearbyint nextafter nexttoward
0.000000,0,0.000000,remainder remquo rint round scalbn signbit tgamma trunc y0 y1 yn
0.000000,0,0.000000,)],
0.000000,0,0.000000,
0.000000,0,0.000000,netdb_h => [qw(EAI_AGAIN    EAI_BADFLAGS EAI_FAIL
0.000000,0,0.000000,EAI_FAMILY   EAI_MEMORY   EAI_NONAME
0.000000,0,0.000000,EAI_OVERFLOW EAI_SERVICE  EAI_SOCKTYPE
0.000000,0,0.000000,EAI_SYSTEM)],
0.000000,0,0.000000,
0.000022,1,0.000022,stdlib_h_c99 => [ @{$default_export_tags{stdlib_h}}, 'strtold' ],
0.000000,0,0.000000,
0.000000,0,0.000000,sys_resource_h => [qw(PRIO_PROCESS PRIO_PGRP PRIO_USER)],
0.000000,0,0.000000,
0.000000,0,0.000000,sys_socket_h => [qw(
0.000000,0,0.000000,MSG_CTRUNC MSG_DONTROUTE MSG_EOR MSG_OOB MSG_PEEK MSG_TRUNC MSG_WAITALL
0.000000,0,0.000000,)],
0.000000,0,0.000000,
0.000000,0,0.000000,nan_payload => [ qw(getpayload setpayload setpayloadsig issignaling) ],
0.000000,0,0.000000,
0.000000,0,0.000000,signal_h_si_code => [qw(
0.000000,0,0.000000,ILL_ILLOPC ILL_ILLOPN ILL_ILLADR ILL_ILLTRP ILL_PRVOPC ILL_PRVREG
0.000000,0,0.000000,ILL_COPROC ILL_BADSTK
0.000000,0,0.000000,FPE_INTDIV FPE_INTOVF FPE_FLTDIV FPE_FLTOVF FPE_FLTUND
0.000000,0,0.000000,FPE_FLTRES FPE_FLTINV FPE_FLTSUB
0.000000,0,0.000000,SEGV_MAPERR SEGV_ACCERR
0.000000,0,0.000000,BUS_ADRALN BUS_ADRERR BUS_OBJERR
0.000000,0,0.000000,TRAP_BRKPT TRAP_TRACE
0.000000,0,0.000000,CLD_EXITED CLD_KILLED CLD_DUMPED CLD_TRAPPED CLD_STOPPED CLD_CONTINUED
0.000000,0,0.000000,POLL_IN POLL_OUT POLL_MSG POLL_ERR POLL_PRI POLL_HUP
0.000000,0,0.000000,SI_USER SI_QUEUE SI_TIMER SI_ASYNCIO SI_MESGQ
0.000000,0,0.000000,)],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# exports policy:
0.000000,0,0.000000,# - new functions may not be added to @EXPORT, only to @EXPORT_OK
0.000000,0,0.000000,# - new SHOUTYCONSTANTS are OK to add to @EXPORT
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,# De-duplicate the export list: 
0.000001,2,0.000000,my ( %export, %export_ok );
0.000180,1,0.000180,@export   {map {@$_} values %default_export_tags} = ();
0.000050,1,0.000050,@export_ok{map {@$_} values   %other_export_tags} = ();
0.000000,0,0.000000,# Doing the de-dup with a temporary hash has the advantage that the SVs in
0.000000,0,0.000000,# @EXPORT are actually shared hash key scalars, which will save some memory.
0.000035,1,0.000035,our @EXPORT = keys %export;
0.000000,0,0.000000,
0.000000,0,0.000000,# you do not want to add symbols to the following list. add a new tag instead
0.000000,0,0.000000,our @EXPORT_OK = (qw(close lchown nice open pipe read sleep times write
0.000000,0,0.000000,printf sprintf),
0.000070,1,0.000070,grep {!exists $export{$_}} keys %reimpl, keys %replacement, keys %export_ok);
0.000000,0,0.000000,
0.000043,1,0.000043,our %EXPORT_TAGS = ( %default_export_tags, %other_export_tags );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,require Exporter;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,package POSIX::SigAction;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new { bless {HANDLER => $_[1], MASK => $_[2], FLAGS => $_[3] || 0, SAFE => 0}, $_[0] }
0.000000,0,0.000000,sub handler { $_[0]->{HANDLER} = $_[1] if @_ > 1; $_[0]->{HANDLER} };
0.000000,0,0.000000,sub mask    { $_[0]->{MASK}    = $_[1] if @_ > 1; $_[0]->{MASK} };
0.000000,0,0.000000,sub flags   { $_[0]->{FLAGS}   = $_[1] if @_ > 1; $_[0]->{FLAGS} };
0.000000,0,0.000000,sub safe    { $_[0]->{SAFE}    = $_[1] if @_ > 1; $_[0]->{SAFE} };
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,1,0.000000,package POSIX::SigSet;
0.000000,0,0.000000,# This package is here entirely to make sure that POSIX::SigSet is seen by the
0.000000,0,0.000000,# PAUSE indexer, so that it will always be clearly indexed in core.  This is to
0.000000,0,0.000000,# prevent the accidental case where a third-party distribution can accidentally
0.000000,0,0.000000,# claim the POSIX::SigSet package, as occurred in 2011-12. -- rjbs, 2011-12-30
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,package POSIX::SigRt;
0.000000,0,0.000000,
0.000002,1,0.000002,require Tie::Hash;
0.000000,0,0.000000,
0.000012,1,0.000012,our @ISA = 'Tie::StdHash';
0.000000,0,0.000000,
0.000000,0,0.000000,our ($_SIGRTMIN, $_SIGRTMAX, $_sigrtn);
0.000000,0,0.000000,
0.000001,1,0.000001,our $SIGACTION_FLAGS = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _init {
0.000000,0,0.000000,$_SIGRTMIN = &POSIX::SIGRTMIN;
0.000000,0,0.000000,$_SIGRTMAX = &POSIX::SIGRTMAX;
0.000000,0,0.000000,$_sigrtn   = $_SIGRTMAX - $_SIGRTMIN;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak {
0.000000,0,0.000000,&_init unless defined $_sigrtn;
0.000000,0,0.000000,die "POSIX::SigRt not available" unless defined $_sigrtn && $_sigrtn > 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _getsig {
0.000000,0,0.000000,&_croak;
0.000000,0,0.000000,my $rtsig = $_[0];
0.000000,0,0.000000,# Allow (SIGRT)?MIN( + n)?, a common idiom when doing these things in C.
0.000000,0,0.000000,$rtsig = $_SIGRTMIN + ($1 || 0)
0.000000,0,0.000000,if $rtsig =~ /^(?:(?:SIG)?RT)?MIN(\s*\+\s*(\d+))?$/;
0.000000,0,0.000000,return $rtsig;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _exist {
0.000000,0,0.000000,my $rtsig = _getsig($_[1]);
0.000000,0,0.000000,my $ok    = $rtsig >= $_SIGRTMIN && $rtsig <= $_SIGRTMAX;
0.000000,0,0.000000,($rtsig, $ok);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _check {
0.000000,0,0.000000,my ($rtsig, $ok) = &_exist;
0.000000,0,0.000000,die "No POSIX::SigRt signal $_[1] (valid range SIGRTMIN..SIGRTMAX, or $_SIGRTMIN..$_SIGRTMAX)"
0.000000,0,0.000000,unless $ok;
0.000000,0,0.000000,return $rtsig;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my ($rtsig, $handler, $flags) = @_;
0.000000,0,0.000000,my $sigset = POSIX::SigSet->new($rtsig);
0.000000,0,0.000000,my $sigact = POSIX::SigAction->new($handler, $sigset, $flags);
0.000000,0,0.000000,POSIX::sigaction($rtsig, $sigact);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub EXISTS { &_exist }
0.000000,0,0.000000,sub FETCH  { my $rtsig = &_check;
0.000000,0,0.000000,my $oa = POSIX::SigAction->new();
0.000000,0,0.000000,POSIX::sigaction($rtsig, undef, $oa);
0.000000,0,0.000000,return $oa->{HANDLER} }
0.000000,0,0.000000,sub STORE  { my $rtsig = &_check; new($rtsig, $_[2], $SIGACTION_FLAGS) }
0.000000,0,0.000000,sub DELETE { delete $SIG{ &_check } }
0.000000,0,0.000000,sub CLEAR  { &_exist; delete @SIG{ &POSIX::SIGRTMIN .. &POSIX::SIGRTMAX } }
0.000000,0,0.000000,sub SCALAR { &_croak; $_sigrtn + 1 }
0.000000,0,0.000000,
0.000053,1,0.000053,tie %POSIX::SIGRT, 'POSIX::SigRt';
0.000000,0,0.000000,# and the expression on the line above is true, so we return true.
