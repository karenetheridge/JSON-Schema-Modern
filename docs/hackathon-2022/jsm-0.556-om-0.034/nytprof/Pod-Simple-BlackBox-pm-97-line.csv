# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Pod::Simple::BlackBox;
0.000000,0,0.000000,#
0.000000,0,0.000000,# "What's in the box?"  "Pain."
0.000000,0,0.000000,#
0.000000,0,0.000000,###########################################################################
0.000000,0,0.000000,#
0.000000,0,0.000000,# This is where all the scary things happen: parsing lines into
0.000000,0,0.000000,#  paragraphs; and then into directives, verbatims, and then also
0.000000,0,0.000000,#  turning formatting sequences into treelets.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Are you really sure you want to read this code?
0.000000,0,0.000000,#
0.000000,0,0.000000,#-----------------------------------------------------------------------------
0.000000,0,0.000000,#
0.000000,0,0.000000,# The basic work of this module Pod::Simple::BlackBox is doing the dirty work
0.000000,0,0.000000,# of parsing Pod into treelets (generally one per non-verbatim paragraph), and
0.000000,0,0.000000,# to call the proper callbacks on the treelets.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Every node in a treelet is a ['name', {attrhash}, ...children...]
0.000000,0,0.000000,
0.000027,2,0.000013,use integer; # vroom!
0.000020,2,0.000010,use strict;
0.000017,2,0.000008,use Carp ();
0.000134,2,0.000067,use vars qw($VERSION );
0.000001,1,0.000001,$VERSION = '3.43';
0.000000,0,0.000000,#use constant DEBUG => 7;
0.000000,0,0.000000,
0.000000,0,0.000000,sub my_qr ($$) {
0.000000,0,0.000000,
0.000000,0,0.000000,# $1 is a pattern to compile and return.  Older perls compile any
0.000000,0,0.000000,# syntactically valid property, even if it isn't legal.  To cope with
0.000000,0,0.000000,# this, return an empty string unless the compiled pattern also
0.000000,0,0.000000,# successfully matches $2, which the caller furnishes.
0.000000,0,0.000000,
0.000007,9,0.000001,my ($input_re, $should_match) = @_;
0.000000,0,0.000000,# XXX could have a third parameter $shouldnt_match for extra safety
0.000000,0,0.000000,
0.000021,9,0.000002,my $use_utf8 = ($] le 5.006002) ? 'use utf8;' : "";
0.000000,0,0.000000,
0.000493,9,0.000055,my $re = eval "no warnings; $use_utf8 qr/$input_re/";
0.000000,0,0.000000,#print STDERR  __LINE__, ": $input_re: $@\n" if $@;
0.000002,9,0.000000,return "" if $@;
0.000000,0,0.000000,
0.000477,9,0.000053,my $matches = eval "no warnings; $use_utf8 '$should_match' =~ /$re/";
0.000000,0,0.000000,#print STDERR  __LINE__, ": $input_re: $@\n" if $@;
0.000001,9,0.000000,return "" if $@;
0.000000,0,0.000000,
0.000000,0,0.000000,#print STDERR  __LINE__, ": SUCCESS: $re\n" if $matches;
0.000021,9,0.000002,return $re if $matches;
0.000000,0,0.000000,
0.000000,0,0.000000,#print STDERR  __LINE__, ": $re: didn't match\n";
0.000000,0,0.000000,return "";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000001,1,0.000001,require Pod::Simple;
0.000005,1,0.000005,*DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG
0.000071,1,0.000071,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Matches a character iff the character will have a different meaning
0.000000,0,0.000000,# if we choose CP1252 vs UTF-8 if there is no =encoding line.
0.000000,0,0.000000,# This is broken for early Perls on non-ASCII platforms.
0.000004,1,0.000004,my $non_ascii_re = my_qr('[[:^ascii:]]', "\xB6");
0.000000,1,0.000000,$non_ascii_re = qr/[\x80-\xFF]/ unless $non_ascii_re;
0.000000,0,0.000000,
0.000000,0,0.000000,# Use patterns understandable by Perl 5.6, if possible
0.000720,4,0.000180,my $cs_re = do { no warnings; my_qr('\p{IsCs}', "\x{D800}") };
0.000000,1,0.000000,my $cn_re = my_qr('\p{IsCn}', "\x{09E4}");  # <reserved> code point unlikely
0.000000,0,0.000000,# to get assigned
0.000002,1,0.000002,my $rare_blocks_re = my_qr('[\p{InIPAExtensions}\p{InSpacingModifierLetters}]',
0.000000,0,0.000000,"\x{250}");
0.000000,1,0.000000,$rare_blocks_re = my_qr('[\x{0250}-\x{02FF}]', "\x{250}") unless $rare_blocks_re;
0.000000,0,0.000000,
0.000034,1,0.000034,my $script_run_re = eval 'no warnings "experimental::script_run";
0.000000,0,0.000000,qr/(*script_run: ^ .* $ )/x';
0.000000,1,0.000000,my $latin_re = my_qr('[\p{IsLatin}\p{IsInherited}\p{IsCommon}]', "\x{100}");
0.000001,1,0.000001,unless ($latin_re) {
0.000000,0,0.000000,# This was machine generated to be the ranges of the union of the above
0.000000,0,0.000000,# three properties, with things that were undefined by Unicode 4.1 filling
0.000000,0,0.000000,# gaps.  That is the version in use when Perl advanced enough to
0.000000,0,0.000000,# successfully compile and execute the above pattern.
0.000000,0,0.000000,$latin_re = my_qr('[\x00-\x{02E9}\x{02EC}-\x{0374}\x{037E}\x{0385}\x{0387}\x{0485}\x{0486}\x{0589}\x{060C}\x{061B}\x{061F}\x{0640}\x{064B}-\x{0655}\x{0670}\x{06DD}\x{0951}-\x{0954}\x{0964}\x{0965}\x{0E3F}\x{10FB}\x{16EB}-\x{16ED}\x{1735}\x{1736}\x{1802}\x{1803}\x{1805}\x{1D00}-\x{1D25}\x{1D2C}-\x{1D5C}\x{1D62}-\x{1D65}\x{1D6B}-\x{1D77}\x{1D79}-\x{1DBE}\x{1DC0}-\x{1EF9}\x{2000}-\x{2125}\x{2127}-\x{27FF}\x{2900}-\x{2B13}\x{2E00}-\x{2E1D}\x{2FF0}-\x{3004}\x{3006}\x{3008}-\x{3020}\x{302A}-\x{302D}\x{3030}-\x{3037}\x{303C}-\x{303F}\x{3099}-\x{309C}\x{30A0}\x{30FB}\x{30FC}\x{3190}-\x{319F}\x{31C0}-\x{31CF}\x{3220}-\x{325F}\x{327F}-\x{32CF}\x{3358}-\x{33FF}\x{4DC0}-\x{4DFF}\x{A700}-\x{A716}\x{FB00}-\x{FB06}\x{FD3E}\x{FD3F}\x{FE00}-\x{FE6B}\x{FEFF}-\x{FF65}\x{FF70}\x{FF9E}\x{FF9F}\x{FFE0}-\x{FFFD}\x{10100}-\x{1013F}\x{1D000}-\x{1D1DD}\x{1D300}-\x{1D7FF}]', "\x{100}");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,my $every_char_is_latin_re = my_qr("^(?:$latin_re)*\\z", "A");
0.000000,0,0.000000,
0.000000,0,0.000000,# Latin script code points not in the first release of Unicode
0.000001,1,0.000001,my $later_latin_re = my_qr('[^\P{IsLatin}\p{IsAge=1.1}]', "\x{1F6}");
0.000000,0,0.000000,
0.000000,0,0.000000,# If this perl doesn't have the Deprecated property, there's only one code
0.000000,0,0.000000,# point in it that we need be concerned with.
0.000000,1,0.000000,my $deprecated_re = my_qr('\p{IsDeprecated}', "\x{149}");
0.000000,1,0.000000,$deprecated_re = qr/\x{149}/ unless $deprecated_re;
0.000000,0,0.000000,
0.000000,1,0.000000,my $utf8_bom;
0.000001,1,0.000001,if (($] ge 5.007_003)) {
0.000000,1,0.000000,$utf8_bom = "\x{FEFF}";
0.000005,1,0.000005,utf8::encode($utf8_bom);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$utf8_bom = "\xEF\xBB\xBF";   # No EBCDIC BOM detection for early Perls.
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This is used so that the 'content_seen' method doesn't return true on a
0.000000,0,0.000000,# file that just happens to have a line that matches /^=[a-zA-z]/.  Only if
0.000000,0,0.000000,# there is a valid =foo line will we return that content was seen.
0.000000,1,0.000000,my $seen_legal_directive = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_line { shift->parse_lines(@_) } # alias
0.000000,0,0.000000,
0.000000,0,0.000000,# - - -  Turn back now!  Run away!  - - -
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_lines {             # Usage: $parser->parse_lines(@lines)
0.000000,0,0.000000,# an undef means end-of-stream
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $code_handler = $self->{'code_handler'};
0.000000,0,0.000000,my $cut_handler  = $self->{'cut_handler'};
0.000000,0,0.000000,my $wl_handler   = $self->{'whiteline_handler'};
0.000000,0,0.000000,$self->{'line_count'} ||= 0;
0.000000,0,0.000000,
0.000000,0,0.000000,my $scratch;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 4 and
0.000000,0,0.000000,print STDERR "# Parsing starting at line ", $self->{'line_count'}, ".\n";
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 5 and
0.000000,0,0.000000,print STDERR "#  About to parse lines: ",
0.000000,0,0.000000,join(' ', map defined($_) ? "[$_]" : "EOF", @_), "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,my $paras = ($self->{'paras'} ||= []);
0.000000,0,0.000000,# paragraph buffer.  Because we need to defer processing of =over
0.000000,0,0.000000,# directives and verbatim paragraphs.  We call _ponder_paragraph_buffer
0.000000,0,0.000000,# to process this.
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{'pod_para_count'} ||= 0;
0.000000,0,0.000000,
0.000000,0,0.000000,# An attempt to match the pod portions of a line.  This is not fool proof,
0.000000,0,0.000000,# but is good enough to serve as part of the heuristic for guessing the pod
0.000000,0,0.000000,# encoding if not specified.
0.000000,0,0.000000,my $codes = join '', grep { / ^ [A-Za-z] $/x } sort keys %{$self->{accept_codes}};
0.000000,0,0.000000,my $pod_chars_re = qr/ ^ = [A-Za-z]+ | [\Q$codes\E] < /x;
0.000000,0,0.000000,
0.000000,0,0.000000,my $line;
0.000000,0,0.000000,foreach my $source_line (@_) {
0.000000,0,0.000000,if( $self->{'source_dead'} ) {
0.000000,0,0.000000,DEBUG > 4 and print STDERR "# Source is dead.\n";
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless( defined $source_line ) {
0.000000,0,0.000000,DEBUG > 4 and print STDERR "# Undef-line seen.\n";
0.000000,0,0.000000,
0.000000,0,0.000000,push @$paras, ['~end', {'start_line' => $self->{'line_count'}}];
0.000000,0,0.000000,push @$paras, $paras->[-1], $paras->[-1];
0.000000,0,0.000000,# So that it definitely fills the buffer.
0.000000,0,0.000000,$self->{'source_dead'} = 1;
0.000000,0,0.000000,$self->_ponder_paragraph_buffer;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,if( $self->{'line_count'}++ ) {
0.000000,0,0.000000,($line = $source_line) =~ tr/\n\r//d;
0.000000,0,0.000000,# If we don't have two vars, we'll end up with that there
0.000000,0,0.000000,# tr/// modding the (potentially read-only) original source line!
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 2 and print STDERR "First line: [$source_line]\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if( ($line = $source_line) =~ s/^$utf8_bom//s ) {
0.000000,0,0.000000,DEBUG and print STDERR "UTF-8 BOM seen.  Faking a '=encoding utf8'.\n";
0.000000,0,0.000000,$self->_handle_encoding_line( "=encoding utf8" );
0.000000,0,0.000000,delete $self->{'_processed_encoding'};
0.000000,0,0.000000,$line =~ tr/\n\r//d;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif( $line =~ s/^\xFE\xFF//s ) {
0.000000,0,0.000000,DEBUG and print STDERR "Big-endian UTF-16 BOM seen.  Aborting parsing.\n";
0.000000,0,0.000000,$self->scream(
0.000000,0,0.000000,$self->{'line_count'},
0.000000,0,0.000000,"UTF16-BE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet."
0.000000,0,0.000000,);
0.000000,0,0.000000,splice @_;
0.000000,0,0.000000,push @_, undef;
0.000000,0,0.000000,next;
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: implement somehow?
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif( $line =~ s/^\xFF\xFE//s ) {
0.000000,0,0.000000,DEBUG and print STDERR "Little-endian UTF-16 BOM seen.  Aborting parsing.\n";
0.000000,0,0.000000,$self->scream(
0.000000,0,0.000000,$self->{'line_count'},
0.000000,0,0.000000,"UTF16-LE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet."
0.000000,0,0.000000,);
0.000000,0,0.000000,splice @_;
0.000000,0,0.000000,push @_, undef;
0.000000,0,0.000000,next;
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: implement somehow?
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 2 and print STDERR "First line is BOM-less.\n";
0.000000,0,0.000000,($line = $source_line) =~ tr/\n\r//d;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(!$self->{'parse_characters'} && !$self->{'encoding'}
0.000000,0,0.000000,&& ($self->{'in_pod'} || $line =~ /^=/s)
0.000000,0,0.000000,&& $line =~ /$non_ascii_re/
0.000000,0,0.000000,) {
0.000000,0,0.000000,
0.000000,0,0.000000,my $encoding;
0.000000,0,0.000000,
0.000000,0,0.000000,# No =encoding line, and we are at the first pod line in the input that
0.000000,0,0.000000,# contains a non-ascii byte, that is, one whose meaning varies depending
0.000000,0,0.000000,# on whether the file is encoded in UTF-8 or CP1252, which are the two
0.000000,0,0.000000,# possibilities permitted by the pod spec.  (ASCII is assumed if the
0.000000,0,0.000000,# file only contains ASCII bytes.)  In order to process this line, we
0.000000,0,0.000000,# need to figure out what encoding we will use for the file.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Strictly speaking ISO 8859-1 (Latin 1) refers to the code points
0.000000,0,0.000000,# 160-255, but it is used here, as it often colloquially is, to refer to
0.000000,0,0.000000,# the complete set of code points 0-255, including ASCII (0-127), the C1
0.000000,0,0.000000,# controls (128-159), and strict Latin 1 (160-255).
0.000000,0,0.000000,#
0.000000,0,0.000000,# CP1252 is effectively a superset of Latin 1, because it differs only
0.000000,0,0.000000,# from colloquial 8859-1 in the C1 controls, which are very unlikely to
0.000000,0,0.000000,# actually be present in 8859-1 files, so can be used for other purposes
0.000000,0,0.000000,# without conflict.  CP 1252 uses most of them for graphic characters.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Note that all ASCII-range bytes represent their corresponding code
0.000000,0,0.000000,# points in both CP1252 and UTF-8.  In ASCII platform UTF-8, all other
0.000000,0,0.000000,# code points require multiple (non-ASCII) bytes to represent.  (A
0.000000,0,0.000000,# separate paragraph for EBCDIC is below.)  The multi-byte
0.000000,0,0.000000,# representation is quite structured.  If we find an isolated byte that
0.000000,0,0.000000,# would require multiple bytes to represent in UTF-8, we know that the
0.000000,0,0.000000,# encoding is not UTF-8.  If we find a sequence of bytes that violates
0.000000,0,0.000000,# the UTF-8 structure, we also can presume the encoding isn't UTF-8, and
0.000000,0,0.000000,# hence must be 1252.
0.000000,0,0.000000,#
0.000000,0,0.000000,# But there are ambiguous cases where we could guess wrong.  If so, the
0.000000,0,0.000000,# user will end up having to supply an =encoding line.  We use all
0.000000,0,0.000000,# readily available information to improve our chances of guessing
0.000000,0,0.000000,# right.  The odds of something not being UTF-8, but still passing a
0.000000,0,0.000000,# UTF-8 validity test go down very rapidly with increasing length of the
0.000000,0,0.000000,# sequence.  Therefore we look at all non-ascii sequences on the line.
0.000000,0,0.000000,# If any of the sequences can't be UTF-8, we quit there and choose
0.000000,0,0.000000,# CP1252.  If all could be UTF-8, we see if any of the code points
0.000000,0,0.000000,# represented are unlikely to be in pod.  If so, we guess CP1252.  If
0.000000,0,0.000000,# not, we check if the line is all in the same script; if not guess
0.000000,0,0.000000,# CP1252; otherwise UTF-8.  For perls that don't have convenient script
0.000000,0,0.000000,# run testing, see if there is both Latin and non-Latin.  If so, CP1252,
0.000000,0,0.000000,# otherwise UTF-8.
0.000000,0,0.000000,#
0.000000,0,0.000000,# On EBCDIC platforms, the situation is somewhat different.  In
0.000000,0,0.000000,# UTF-EBCDIC, not only do ASCII-range bytes represent their code points,
0.000000,0,0.000000,# but so do the bytes that are for the C1 controls.  Recall that these
0.000000,0,0.000000,# correspond to the unused portion of 8859-1 that 1252 mostly takes
0.000000,0,0.000000,# over.  That means that there are fewer code points that are
0.000000,0,0.000000,# represented by multi-bytes.  But, note that the these controls are
0.000000,0,0.000000,# very unlikely to be in pod text.  So if we encounter one of them, it
0.000000,0,0.000000,# means that it is quite likely CP1252 and not UTF-8.  The net result is
0.000000,0,0.000000,# the same code below is used for both platforms.
0.000000,0,0.000000,#
0.000000,0,0.000000,# XXX probably if the line has E<foo> that evaluates to illegal CP1252,
0.000000,0,0.000000,# then it is UTF-8.  But we haven't processed E<> yet.
0.000000,0,0.000000,
0.000000,0,0.000000,goto set_1252 if $] lt 5.006_000;    # No UTF-8 on very early perls
0.000000,0,0.000000,
0.000000,0,0.000000,my $copy;
0.000000,0,0.000000,
0.000069,2,0.000034,no warnings 'utf8';
0.000000,0,0.000000,
0.000000,0,0.000000,if ($] ge 5.007_003) {
0.000000,0,0.000000,$copy = $line;
0.000000,0,0.000000,
0.000000,0,0.000000,# On perls that have this function, we can use it to easily see if the
0.000000,0,0.000000,# sequence is valid UTF-8 or not; if valid it turns on the UTF-8 flag
0.000000,0,0.000000,# needed below for script run detection
0.000000,0,0.000000,goto set_1252 if ! utf8::decode($copy);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (ord("A") != 65) {  # Early EBCDIC, assume UTF-8.  What's a windows
0.000000,0,0.000000,# code page doing here anyway?
0.000000,0,0.000000,goto set_utf8;
0.000000,0,0.000000,}
0.000000,0,0.000000,else { # ASCII, no decode(): do it ourselves using the fundamental
0.000000,0,0.000000,# characteristics of UTF-8
0.007029,2,0.003515,use if $] le 5.006002, 'utf8';
0.000000,0,0.000000,
0.000000,0,0.000000,my $char_ord;
0.000000,0,0.000000,my $needed;         # How many continuation bytes to gobble up
0.000000,0,0.000000,
0.000000,0,0.000000,# Initialize the translated line with a dummy character that will be
0.000000,0,0.000000,# deleted after everything else is done.  This dummy makes sure that
0.000000,0,0.000000,# $copy will be in UTF-8.  Doing it now avoids the bugs in early perls
0.000000,0,0.000000,# with upgrading in the middle
0.000000,0,0.000000,$copy = chr(0x100);
0.000000,0,0.000000,
0.000000,0,0.000000,# Parse through the line
0.000000,0,0.000000,for (my $i = 0; $i < length $line; $i++) {
0.000000,0,0.000000,my $byte = substr($line, $i, 1);
0.000000,0,0.000000,
0.000000,0,0.000000,# ASCII bytes are trivially dealt with
0.000000,0,0.000000,if ($byte !~ $non_ascii_re) {
0.000000,0,0.000000,$copy .= $byte;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $b_ord = ord $byte;
0.000000,0,0.000000,
0.000000,0,0.000000,# Now figure out what this code point would be if the input is
0.000000,0,0.000000,# actually in UTF-8.  If, in the process, we discover that it isn't
0.000000,0,0.000000,# well-formed UTF-8, we guess CP1252.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Start the process.  If it is UTF-8, we are at the first, start
0.000000,0,0.000000,# byte, of a multi-byte sequence.  We look at this byte to figure
0.000000,0,0.000000,# out how many continuation bytes are needed, and to initialize the
0.000000,0,0.000000,# code point accumulator with the data from this byte.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Normally the minimum continuation byte is 0x80, but in certain
0.000000,0,0.000000,# instances the minimum is a higher number.  So the code below
0.000000,0,0.000000,# overrides this for those instances.
0.000000,0,0.000000,my $min_cont = 0x80;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($b_ord < 0xC2) { #  A start byte < C2 is malformed
0.000000,0,0.000000,goto set_1252;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($b_ord <= 0xDF) {
0.000000,0,0.000000,$needed = 1;
0.000000,0,0.000000,$char_ord = $b_ord & 0x1F;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($b_ord <= 0xEF) {
0.000000,0,0.000000,$min_cont = 0xA0 if $b_ord == 0xE0;
0.000000,0,0.000000,$needed = 2;
0.000000,0,0.000000,$char_ord = $b_ord & (0x1F >> 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($b_ord <= 0xF4) {
0.000000,0,0.000000,$min_cont = 0x90 if $b_ord == 0xF0;
0.000000,0,0.000000,$needed = 3;
0.000000,0,0.000000,$char_ord = $b_ord & (0x1F >> 2);
0.000000,0,0.000000,}
0.000000,0,0.000000,else { # F4 is the highest start byte for legal Unicode; higher is
0.000000,0,0.000000,# unlikely to be in pod.
0.000000,0,0.000000,goto set_1252;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# ? not enough continuation bytes available
0.000000,0,0.000000,goto set_1252 if $i + $needed >= length $line;
0.000000,0,0.000000,
0.000000,0,0.000000,# Accumulate the ordinal of the character from the remaining
0.000000,0,0.000000,# (continuation) bytes.
0.000000,0,0.000000,while ($needed-- > 0) {
0.000000,0,0.000000,my $cont = substr($line, ++$i, 1);
0.000000,0,0.000000,$b_ord = ord $cont;
0.000000,0,0.000000,goto set_1252 if $b_ord < $min_cont || $b_ord > 0xBF;
0.000000,0,0.000000,
0.000000,0,0.000000,# In all cases, any next continuation bytes all have the same
0.000000,0,0.000000,# minimum legal value
0.000000,0,0.000000,$min_cont = 0x80;
0.000000,0,0.000000,
0.000000,0,0.000000,# Accumulate this byte's contribution to the code point
0.000000,0,0.000000,$char_ord <<= 6;
0.000000,0,0.000000,$char_ord |= ($b_ord & 0x3F);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, the sequence that formed this code point was valid UTF-8,
0.000000,0,0.000000,# so add the completed character to the output
0.000000,0,0.000000,$copy .= chr $char_ord;
0.000000,0,0.000000,} # End of loop through line
0.000000,0,0.000000,
0.000000,0,0.000000,# Delete the dummy first character
0.000000,0,0.000000,$copy = substr($copy, 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, $copy is legal UTF-8.
0.000000,0,0.000000,
0.000000,0,0.000000,# If it can't be legal CP1252, no need to look further.  (These bytes
0.000000,0,0.000000,# aren't valid in CP1252.)  This test could have been placed higher in
0.000000,0,0.000000,# the code, but it seemed wrong to set the encoding to UTF-8 without
0.000000,0,0.000000,# making sure that the very first instance is well-formed.  But what if
0.000000,0,0.000000,# it isn't legal CP1252 either?  We have to choose one or the other, and
0.000000,0,0.000000,# It seems safer to favor the single-byte encoding over the multi-byte.
0.000000,0,0.000000,goto set_utf8 if ord("A") == 65 && $line =~ /[\x81\x8D\x8F\x90\x9D]/;
0.000000,0,0.000000,
0.000000,0,0.000000,# The C1 controls are not likely to appear in pod
0.000000,0,0.000000,goto set_1252 if ord("A") == 65 && $copy =~ /[\x80-\x9F]/;
0.000000,0,0.000000,
0.000000,0,0.000000,# Nor are surrogates nor unassigned, nor deprecated.
0.000000,0,0.000000,DEBUG > 8 and print STDERR __LINE__, ": $copy: surrogate\n" if $copy =~ $cs_re;
0.000000,0,0.000000,goto set_1252 if $cs_re && $copy =~ $cs_re;
0.000000,0,0.000000,DEBUG > 8 and print STDERR __LINE__, ": $copy: unassigned\n" if $cn_re && $copy =~ $cn_re;
0.000000,0,0.000000,goto set_1252 if $cn_re && $copy =~ $cn_re;
0.000000,0,0.000000,DEBUG > 8 and print STDERR __LINE__, ": $copy: deprecated\n" if $copy =~ $deprecated_re;
0.000000,0,0.000000,goto set_1252 if $copy =~ $deprecated_re;
0.000000,0,0.000000,
0.000000,0,0.000000,# Nor are rare code points.  But this is hard to determine.  khw
0.000000,0,0.000000,# believes that IPA characters and the modifier letters are unlikely to
0.000000,0,0.000000,# be in pod (and certainly very unlikely to be the in the first line in
0.000000,0,0.000000,# the pod containing non-ASCII)
0.000000,0,0.000000,DEBUG > 8 and print STDERR __LINE__, ": $copy: rare\n" if $copy =~ $rare_blocks_re;
0.000000,0,0.000000,goto set_1252 if $rare_blocks_re && $copy =~ $rare_blocks_re;
0.000000,0,0.000000,
0.000000,0,0.000000,# The first Unicode version included essentially every Latin character
0.000000,0,0.000000,# in modern usage.  So, a Latin character not in the first release will
0.000000,0,0.000000,# unlikely be in pod.
0.000000,0,0.000000,DEBUG > 8 and print STDERR __LINE__, ": $copy: later_latin\n" if $later_latin_re && $copy =~ $later_latin_re;
0.000000,0,0.000000,goto set_1252 if $later_latin_re && $copy =~ $later_latin_re;
0.000000,0,0.000000,
0.000000,0,0.000000,# On perls that handle script runs, if the UTF-8 interpretation yields
0.000000,0,0.000000,# a single script, we guess UTF-8, otherwise just having a mixture of
0.000000,0,0.000000,# scripts is suspicious, so guess CP1252.  We first strip off, as best
0.000000,0,0.000000,# we can, the ASCII characters that look like they are pod directives,
0.000000,0,0.000000,# as these would always show as mixed with non-Latin text.
0.000000,0,0.000000,$copy =~ s/$pod_chars_re//g;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($script_run_re) {
0.000000,0,0.000000,goto set_utf8 if $copy =~ $script_run_re;
0.000000,0,0.000000,DEBUG > 8 and print STDERR __LINE__, ":  not script run\n";
0.000000,0,0.000000,goto set_1252;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Even without script runs, but on recent enough perls and Unicodes, we
0.000000,0,0.000000,# can check if there is a mixture of both Latin and non-Latin.  Again,
0.000000,0,0.000000,# having a mixture of scripts is suspicious, so assume CP1252
0.000000,0,0.000000,
0.000000,0,0.000000,# If it's all non-Latin, there is no CP1252, as that is Latin
0.000000,0,0.000000,# characters and punct, etc.
0.000000,0,0.000000,DEBUG > 8 and print STDERR __LINE__, ": $copy: not latin\n" if $copy !~ $latin_re;
0.000000,0,0.000000,goto set_utf8 if $copy !~ $latin_re;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 8 and print STDERR __LINE__, ": $copy: all latin\n" if $copy =~ $every_char_is_latin_re;
0.000000,0,0.000000,goto set_utf8 if $copy =~ $every_char_is_latin_re;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 8 and print STDERR __LINE__, ": $copy: mixed\n";
0.000000,0,0.000000,
0.000000,0,0.000000,set_1252:
0.000000,0,0.000000,DEBUG > 9 and print STDERR __LINE__, ": $copy: is 1252\n";
0.000000,0,0.000000,$encoding = 'CP1252';
0.000000,0,0.000000,goto done_set;
0.000000,0,0.000000,
0.000000,0,0.000000,set_utf8:
0.000000,0,0.000000,DEBUG > 9 and print STDERR __LINE__, ": $copy: is UTF-8\n";
0.000000,0,0.000000,$encoding = 'UTF-8';
0.000000,0,0.000000,
0.000000,0,0.000000,done_set:
0.000000,0,0.000000,$self->_handle_encoding_line( "=encoding $encoding" );
0.000000,0,0.000000,delete $self->{'_processed_encoding'};
0.000000,0,0.000000,$self->{'_transcoder'} && $self->{'_transcoder'}->($line);
0.000000,0,0.000000,
0.000000,0,0.000000,my ($word) = $line =~ /(\S*$non_ascii_re\S*)/;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$self->{'line_count'},
0.000000,0,0.000000,"Non-ASCII character seen before =encoding in '$word'. Assuming $encoding"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 5 and print STDERR "# Parsing line: [$line]\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if(!$self->{'in_pod'}) {
0.000000,0,0.000000,if($line =~ m/^=([a-zA-Z][a-zA-Z0-9]*)(?:\s|$)/s) {
0.000000,0,0.000000,if($1 eq 'cut') {
0.000000,0,0.000000,$self->scream(
0.000000,0,0.000000,$self->{'line_count'},
0.000000,0,0.000000,"=cut found outside a pod block.  Skipping to next block."
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,## Before there were errata sections in the world, it was
0.000000,0,0.000000,## least-pessimal to abort processing the file.  But now we can
0.000000,0,0.000000,## just barrel on thru (but still not start a pod block).
0.000000,0,0.000000,#splice @_;
0.000000,0,0.000000,#push @_, undef;
0.000000,0,0.000000,
0.000000,0,0.000000,next;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$self->{'in_pod'} = $self->{'start_of_pod_block'}
0.000000,0,0.000000,= $self->{'last_was_blank'}     = 1;
0.000000,0,0.000000,# And fall thru to the pod-mode block further down
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 5 and print STDERR "# It's a code-line.\n";
0.000000,0,0.000000,$code_handler->(map $_, $line, $self->{'line_count'}, $self)
0.000000,0,0.000000,if $code_handler;
0.000000,0,0.000000,# Note: this may cause code to be processed out of order relative
0.000000,0,0.000000,#  to pods, but in order relative to cuts.
0.000000,0,0.000000,
0.000000,0,0.000000,# Note also that we haven't yet applied the transcoding to $line
0.000000,0,0.000000,#  by time we call $code_handler!
0.000000,0,0.000000,
0.000000,0,0.000000,if( $line =~ m/^#\s*line\s+(\d+)\s*(?:\s"([^"]+)")?\s*$/ ) {
0.000000,0,0.000000,# That RE is from perlsyn, section "Plain Old Comments (Not!)",
0.000000,0,0.000000,#$fname = $2 if defined $2;
0.000000,0,0.000000,#DEBUG > 1 and defined $2 and print STDERR "# Setting fname to \"$fname\"\n";
0.000000,0,0.000000,DEBUG > 1 and print STDERR "# Setting nextline to $1\n";
0.000000,0,0.000000,$self->{'line_count'} = $1 - 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
0.000000,0,0.000000,# Else we're in pod mode:
0.000000,0,0.000000,
0.000000,0,0.000000,# Apply any necessary transcoding:
0.000000,0,0.000000,$self->{'_transcoder'} && $self->{'_transcoder'}->($line);
0.000000,0,0.000000,
0.000000,0,0.000000,# HERE WE CATCH =encoding EARLY!
0.000000,0,0.000000,if( $line =~ m/^=encoding\s+\S+\s*$/s ) {
0.000000,0,0.000000,next if $self->parse_characters;   # Ignore this line
0.000000,0,0.000000,$line = $self->_handle_encoding_line( $line );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if($line =~ m/^=cut/s) {
0.000000,0,0.000000,# here ends the pod block, and therefore the previous pod para
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Noting =cut at line ${$self}{'line_count'}\n";
0.000000,0,0.000000,$self->{'in_pod'} = 0;
0.000000,0,0.000000,# ++$self->{'pod_para_count'};
0.000000,0,0.000000,$self->_ponder_paragraph_buffer();
0.000000,0,0.000000,# by now it's safe to consider the previous paragraph as done.
0.000000,0,0.000000,DEBUG > 6 and print STDERR "Processing any cut handler, line ${$self}{'line_count'}\n";
0.000000,0,0.000000,$cut_handler->(map $_, $line, $self->{'line_count'}, $self)
0.000000,0,0.000000,if $cut_handler;
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: add to docs: Note: this may cause cuts to be processed out
0.000000,0,0.000000,#  of order relative to pods, but in order relative to code.
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($line =~ m/^(\s*)$/s) {  # it's a blank line
0.000000,0,0.000000,if (defined $1 and $1 =~ /[^\S\r\n]/) { # it's a white line
0.000000,0,0.000000,$wl_handler->(map $_, $line, $self->{'line_count'}, $self)
0.000000,0,0.000000,if $wl_handler;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(!$self->{'start_of_pod_block'} and @$paras and $paras->[-1][0] eq '~Verbatim') {
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Saving blank line at line ${$self}{'line_count'}\n";
0.000000,0,0.000000,push @{$paras->[-1]}, $line;
0.000000,0,0.000000,}  # otherwise it's not interesting
0.000000,0,0.000000,
0.000000,0,0.000000,if(!$self->{'start_of_pod_block'} and !$self->{'last_was_blank'}) {
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Noting para ends with blank line at ${$self}{'line_count'}\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{'last_was_blank'} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($self->{'last_was_blank'}) {  # A non-blank line starting a new para...
0.000000,0,0.000000,
0.000000,0,0.000000,if($line =~ m/^(=[a-zA-Z][a-zA-Z0-9]*)(\s+|$)(.*)/s) {
0.000000,0,0.000000,# THIS IS THE ONE PLACE WHERE WE CONSTRUCT NEW DIRECTIVE OBJECTS
0.000000,0,0.000000,my $new = [$1, {'start_line' => $self->{'line_count'}}, $3];
0.000000,0,0.000000,$new->[1]{'~orig_spacer'} = $2 if $2 && $2 ne " ";
0.000000,0,0.000000,# Note that in "=head1 foo", the WS is lost.
0.000000,0,0.000000,# Example: ['=head1', {'start_line' => 123}, ' foo']
0.000000,0,0.000000,
0.000000,0,0.000000,++$self->{'pod_para_count'};
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_ponder_paragraph_buffer();
0.000000,0,0.000000,# by now it's safe to consider the previous paragraph as done.
0.000000,0,0.000000,
0.000000,0,0.000000,push @$paras, $new; # the new incipient paragraph
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Starting new ${$paras}[-1][0] para at line ${$self}{'line_count'}\n";
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($line =~ m/^\s/s) {
0.000000,0,0.000000,
0.000000,0,0.000000,if(!$self->{'start_of_pod_block'} and @$paras and $paras->[-1][0] eq '~Verbatim') {
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Resuming verbatim para at line ${$self}{'line_count'}\n";
0.000000,0,0.000000,push @{$paras->[-1]}, $line;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,++$self->{'pod_para_count'};
0.000000,0,0.000000,$self->_ponder_paragraph_buffer();
0.000000,0,0.000000,# by now it's safe to consider the previous paragraph as done.
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Starting verbatim para at line ${$self}{'line_count'}\n";
0.000000,0,0.000000,push @$paras, ['~Verbatim', {'start_line' => $self->{'line_count'}}, $line];
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,++$self->{'pod_para_count'};
0.000000,0,0.000000,$self->_ponder_paragraph_buffer();
0.000000,0,0.000000,# by now it's safe to consider the previous paragraph as done.
0.000000,0,0.000000,push @$paras, ['~Para',  {'start_line' => $self->{'line_count'}}, $line];
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Starting plain para at line ${$self}{'line_count'}\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->{'last_was_blank'} = $self->{'start_of_pod_block'} = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# It's a non-blank line /continuing/ the current para
0.000000,0,0.000000,if(@$paras) {
0.000000,0,0.000000,DEBUG > 2 and print STDERR "Line ${$self}{'line_count'} continues current paragraph\n";
0.000000,0,0.000000,push @{$paras->[-1]}, $line;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# Unexpected case!
0.000000,0,0.000000,die "Continuing a paragraph but \@\$paras is empty?";
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->{'last_was_blank'} = $self->{'start_of_pod_block'} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} # ends the big while loop
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 1 and print STDERR (pretty(@$paras), "\n");
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub _handle_encoding_line {
0.000000,0,0.000000,my($self, $line) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return if $self->parse_characters;
0.000000,0,0.000000,
0.000000,0,0.000000,# The point of this routine is to set $self->{'_transcoder'} as indicated.
0.000000,0,0.000000,
0.000000,0,0.000000,return $line unless $line =~ m/^=encoding\s+(\S+)\s*$/s;
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Found an encoding line \"=encoding $1\"\n";
0.000000,0,0.000000,
0.000000,0,0.000000,my $e    = $1;
0.000000,0,0.000000,my $orig = $e;
0.000000,0,0.000000,push @{ $self->{'encoding_command_reqs'} }, "=encoding $orig";
0.000000,0,0.000000,
0.000000,0,0.000000,my $enc_error;
0.000000,0,0.000000,
0.000000,0,0.000000,# Cf.   perldoc Encode   and   perldoc Encode::Supported
0.000000,0,0.000000,
0.000000,0,0.000000,require Pod::Simple::Transcode;
0.000000,0,0.000000,
0.000000,0,0.000000,if( $self->{'encoding'} ) {
0.000000,0,0.000000,my $norm_current = $self->{'encoding'};
0.000000,0,0.000000,my $norm_e = $e;
0.000000,0,0.000000,foreach my $that ($norm_current, $norm_e) {
0.000000,0,0.000000,$that =  lc($that);
0.000000,0,0.000000,$that =~ s/[-_]//g;
0.000000,0,0.000000,}
0.000000,0,0.000000,if($norm_current eq $norm_e) {
0.000000,0,0.000000,DEBUG > 1 and print STDERR "The '=encoding $orig' line is ",
0.000000,0,0.000000,"redundant.  ($norm_current eq $norm_e).  Ignoring.\n";
0.000000,0,0.000000,$enc_error = '';
0.000000,0,0.000000,# But that doesn't necessarily mean that the earlier one went okay
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$enc_error = "Encoding is already set to " . $self->{'encoding'};
0.000000,0,0.000000,DEBUG > 1 and print STDERR $enc_error;
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif (
0.000000,0,0.000000,# OK, let's turn on the encoding
0.000000,0,0.000000,do {
0.000000,0,0.000000,DEBUG > 1 and print STDERR " Setting encoding to $e\n";
0.000000,0,0.000000,$self->{'encoding'} = $e;
0.000000,0,0.000000,1;
0.000000,0,0.000000,}
0.000000,0,0.000000,and $e eq 'HACKRAW'
0.000000,0,0.000000,) {
0.000000,0,0.000000,DEBUG and print STDERR " Putting in HACKRAW (no-op) encoding mode.\n";
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif( Pod::Simple::Transcode::->encoding_is_available($e) ) {
0.000000,0,0.000000,
0.000000,0,0.000000,die($enc_error = "WHAT? _transcoder is already set?!")
0.000000,0,0.000000,if $self->{'_transcoder'};   # should never happen
0.000000,0,0.000000,require Pod::Simple::Transcode;
0.000000,0,0.000000,$self->{'_transcoder'} = Pod::Simple::Transcode::->make_transcoder($e);
0.000000,0,0.000000,eval {
0.000000,0,0.000000,my @x = ('', "abc", "123");
0.000000,0,0.000000,$self->{'_transcoder'}->(@x);
0.000000,0,0.000000,};
0.000000,0,0.000000,$@ && die( $enc_error =
0.000000,0,0.000000,"Really unexpected error setting up encoding $e: $@\nAborting"
0.000000,0,0.000000,);
0.000000,0,0.000000,$self->{'detected_encoding'} = $e;
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,my @supported = Pod::Simple::Transcode::->all_encodings;
0.000000,0,0.000000,
0.000000,0,0.000000,# Note unsupported, and complain
0.000000,0,0.000000,DEBUG and print STDERR " Encoding [$e] is unsupported.",
0.000000,0,0.000000,"\nSupporteds: @supported\n";
0.000000,0,0.000000,my $suggestion = '';
0.000000,0,0.000000,
0.000000,0,0.000000,# Look for a near match:
0.000000,0,0.000000,my $norm = lc($e);
0.000000,0,0.000000,$norm =~ tr[-_][]d;
0.000000,0,0.000000,my $n;
0.000000,0,0.000000,foreach my $enc (@supported) {
0.000000,0,0.000000,$n = lc($enc);
0.000000,0,0.000000,$n =~ tr[-_][]d;
0.000000,0,0.000000,next unless $n eq $norm;
0.000000,0,0.000000,$suggestion = "  (Maybe \"$e\" should be \"$enc\"?)";
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $encmodver = Pod::Simple::Transcode::->encmodver;
0.000000,0,0.000000,$enc_error = join '' =>
0.000000,0,0.000000,"This document probably does not appear as it should, because its ",
0.000000,0,0.000000,"\"=encoding $e\" line calls for an unsupported encoding.",
0.000000,0,0.000000,$suggestion, "  [$encmodver\'s supported encodings are: @supported]"
0.000000,0,0.000000,;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->scream( $self->{'line_count'}, $enc_error );
0.000000,0,0.000000,}
0.000000,0,0.000000,push @{ $self->{'encoding_command_statuses'} }, $enc_error;
0.000000,0,0.000000,if (defined($self->{'_processed_encoding'})) {
0.000000,0,0.000000,# Double declaration.
0.000000,0,0.000000,$self->scream( $self->{'line_count'}, 'Cannot have multiple =encoding directives');
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->{'_processed_encoding'} = $orig;
0.000000,0,0.000000,
0.000000,0,0.000000,return $line;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0.000000,0,0.000000,
0.000000,0,0.000000,sub _handle_encoding_second_level {
0.000000,0,0.000000,# By time this is called, the encoding (if well formed) will already
0.000000,0,0.000000,#  have been acted on.
0.000000,0,0.000000,my($self, $para) = @_;
0.000000,0,0.000000,my @x = @$para;
0.000000,0,0.000000,my $content = join ' ', splice @x, 2;
0.000000,0,0.000000,$content =~ s/^\s+//s;
0.000000,0,0.000000,$content =~ s/\s+$//s;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 2 and print STDERR "Ogling encoding directive: =encoding $content\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined($self->{'_processed_encoding'})) {
0.000000,0,0.000000,#if($content ne $self->{'_processed_encoding'}) {
0.000000,0,0.000000,#  Could it happen?
0.000000,0,0.000000,#}
0.000000,0,0.000000,delete $self->{'_processed_encoding'};
0.000000,0,0.000000,# It's already been handled.  Check for errors.
0.000000,0,0.000000,if(! $self->{'encoding_command_statuses'} ) {
0.000000,0,0.000000,DEBUG > 2 and print STDERR " CRAZY ERROR: It wasn't really handled?!\n";
0.000000,0,0.000000,} elsif( $self->{'encoding_command_statuses'}[-1] ) {
0.000000,0,0.000000,$self->whine( $para->[1]{'start_line'},
0.000000,0,0.000000,sprintf "Couldn't do %s: %s",
0.000000,0,0.000000,$self->{'encoding_command_reqs'  }[-1],
0.000000,0,0.000000,$self->{'encoding_command_statuses'}[-1],
0.000000,0,0.000000,);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 2 and print STDERR " (Yup, it was successfully handled already.)\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# Otherwise it's a syntax error
0.000000,0,0.000000,$self->whine( $para->[1]{'start_line'},
0.000000,0,0.000000,"Invalid =encoding syntax: $content"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,1,0.000000,my $m = -321;   # magic line number
0.000000,0,0.000000,
0.000000,0,0.000000,sub _gen_errata {
0.000000,0,0.000000,my $self = $_[0];
0.000000,0,0.000000,# Return 0 or more fake-o paragraphs explaining the accumulated
0.000000,0,0.000000,#  errors on this document.
0.000000,0,0.000000,
0.000000,0,0.000000,return() unless $self->{'errata'} and keys %{$self->{'errata'}};
0.000000,0,0.000000,
0.000000,0,0.000000,my @out;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $line (sort {$a <=> $b} keys %{$self->{'errata'}}) {
0.000000,0,0.000000,push @out,
0.000000,0,0.000000,['=item', {'start_line' => $m}, "Around line $line:"],
0.000000,0,0.000000,map( ['~Para', {'start_line' => $m, '~cooked' => 1},
0.000000,0,0.000000,#['~Top', {'start_line' => $m},
0.000000,0,0.000000,$_
0.000000,0,0.000000,#]
0.000000,0,0.000000,],
0.000000,0,0.000000,@{$self->{'errata'}{$line}}
0.000000,0,0.000000,)
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: report of unknown entities? unrenderable characters?
0.000000,0,0.000000,
0.000000,0,0.000000,unshift @out,
0.000000,0,0.000000,['=head1', {'start_line' => $m, 'errata' => 1}, 'POD ERRORS'],
0.000000,0,0.000000,['~Para', {'start_line' => $m, '~cooked' => 1, 'errata' => 1},
0.000000,0,0.000000,"Hey! ",
0.000000,0,0.000000,['B', {},
0.000000,0,0.000000,'The above document had some coding errors, which are explained below:'
0.000000,0,0.000000,]
0.000000,0,0.000000,],
0.000000,0,0.000000,['=over',  {'start_line' => $m, 'errata' => 1}, ''],
0.000000,0,0.000000,;
0.000000,0,0.000000,
0.000000,0,0.000000,push @out,
0.000000,0,0.000000,['=back',  {'start_line' => $m, 'errata' => 1}, ''],
0.000000,0,0.000000,;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and print STDERR "\n<<\n", pretty(\@out), "\n>>\n\n";
0.000000,0,0.000000,
0.000000,0,0.000000,return @out;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,##
0.000000,0,0.000000,##  stop reading now stop reading now stop reading now stop reading now stop
0.000000,0,0.000000,##
0.000000,0,0.000000,##                         HERE IT BECOMES REALLY SCARY
0.000000,0,0.000000,##
0.000000,0,0.000000,##  stop reading now stop reading now stop reading now stop reading now stop
0.000000,0,0.000000,##
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,
0.000000,1,0.000000,sub _ponder_paragraph_buffer {
0.000000,0,0.000000,
0.000000,0,0.000000,# Para-token types as found in the buffer.
0.000000,0,0.000000,#   ~Verbatim, ~Para, ~end, =head1..4, =for, =begin, =end,
0.000000,0,0.000000,#   =over, =back, =item
0.000000,0,0.000000,#   and the null =pod (to be complained about if over one line)
0.000000,0,0.000000,#
0.000000,0,0.000000,# "~data" paragraphs are something we generate at this level, depending on
0.000000,0,0.000000,# a currently open =over region
0.000000,0,0.000000,
0.000000,0,0.000000,# Events fired:  Begin and end for:
0.000000,0,0.000000,#                   directivename (like head1 .. head4), item, extend,
0.000000,0,0.000000,#                   for (from =begin...=end, =for),
0.000000,0,0.000000,#                   over-bullet, over-number, over-text, over-block,
0.000000,0,0.000000,#                   item-bullet, item-number, item-text,
0.000000,0,0.000000,#                   Document,
0.000000,0,0.000000,#                   Data, Para, Verbatim
0.000000,0,0.000000,#                   B, C, longdirname (TODO -- wha?), etc. for all directives
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,0,0.000000,my $self = $_[0];
0.000000,0,0.000000,my $paras;
0.000000,0,0.000000,return unless @{$paras = $self->{'paras'}};
0.000000,0,0.000000,my $curr_open = ($self->{'curr_open'} ||= []);
0.000000,0,0.000000,
0.000000,0,0.000000,my $scratch;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 10 and print STDERR "# Paragraph buffer: <<", pretty($paras), ">>\n";
0.000000,0,0.000000,
0.000000,0,0.000000,# We have something in our buffer.  So apparently the document has started.
0.000000,0,0.000000,unless($self->{'doc_has_started'}) {
0.000000,0,0.000000,$self->{'doc_has_started'} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $starting_contentless;
0.000000,0,0.000000,$starting_contentless =
0.000000,0,0.000000,(
0.000000,0,0.000000,!@$curr_open
0.000000,0,0.000000,and @$paras and ! grep $_->[0] ne '~end', @$paras
0.000000,0,0.000000,# i.e., if the paras is all ~ends
0.000000,0,0.000000,)
0.000000,0,0.000000,;
0.000000,0,0.000000,DEBUG and print STDERR "# Starting ",
0.000000,0,0.000000,$starting_contentless ? 'contentless' : 'contentful',
0.000000,0,0.000000," document\n"
0.000000,0,0.000000,;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_handle_element_start(
0.000000,0,0.000000,($scratch = 'Document'),
0.000000,0,0.000000,{
0.000000,0,0.000000,'start_line' => $paras->[0][1]{'start_line'},
0.000000,0,0.000000,$starting_contentless ? ( 'contentless' => 1 ) : (),
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my($para, $para_type);
0.000000,0,0.000000,while(@$paras) {
0.000000,0,0.000000,
0.000000,0,0.000000,# If a directive, assume it's legal; subtract below if found not to be
0.000000,0,0.000000,$seen_legal_directive++ if $paras->[0][0] =~ /^=/;
0.000000,0,0.000000,
0.000000,0,0.000000,last if      @$paras == 1
0.000000,0,0.000000,and (    $paras->[0][0] eq '=over'
0.000000,0,0.000000,or  $paras->[0][0] eq '=item'
0.000000,0,0.000000,or ($paras->[0][0] eq '~Verbatim' and $self->{'in_pod'}));
0.000000,0,0.000000,# Those're the three kinds of paragraphs that require lookahead.
0.000000,0,0.000000,#   Actually, an "=item Foo" inside an <over type=text> region
0.000000,0,0.000000,#   and any =item inside an <over type=block> region (rare)
0.000000,0,0.000000,#   don't require any lookahead, but all others (bullets
0.000000,0,0.000000,#   and numbers) do.
0.000000,0,0.000000,# The verbatim is different from the other two, because those might be
0.000000,0,0.000000,# like:
0.000000,0,0.000000,#
0.000000,0,0.000000,#   =item
0.000000,0,0.000000,#   ...
0.000000,0,0.000000,#   =cut
0.000000,0,0.000000,#   ...
0.000000,0,0.000000,#   =item
0.000000,0,0.000000,#
0.000000,0,0.000000,# The =cut here finishes the paragraph but doesn't terminate the =over
0.000000,0,0.000000,# they should be in. (khw apologizes that he didn't comment at the time
0.000000,0,0.000000,# why the 'in_pod' works, and no longer remembers why, and doesn't think
0.000000,0,0.000000,# it is currently worth the effort to re-figure it out.)
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: whinge about many kinds of directives in non-resolving =for regions?
0.000000,0,0.000000,# TODO: many?  like what?  =head1 etc?
0.000000,0,0.000000,
0.000000,0,0.000000,$para = shift @$paras;
0.000000,0,0.000000,$para_type = $para->[0];
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Pondering a $para_type paragraph, given the stack: (",
0.000000,0,0.000000,$self->_dump_curr_open(), ")\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if($para_type eq '=for') {
0.000000,0,0.000000,next if $self->_ponder_for($para,$curr_open,$paras);
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($para_type eq '=begin') {
0.000000,0,0.000000,next if $self->_ponder_begin($para,$curr_open,$paras);
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($para_type eq '=end') {
0.000000,0,0.000000,next if $self->_ponder_end($para,$curr_open,$paras);
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($para_type eq '~end') { # The virtual end-document signal
0.000000,0,0.000000,next if $self->_ponder_doc_end($para,$curr_open,$paras);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
0.000000,0,0.000000,#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
0.000000,0,0.000000,if(grep $_->[1]{'~ignore'}, @$curr_open) {
0.000000,0,0.000000,DEBUG > 1 and
0.000000,0,0.000000,print STDERR "Skipping $para_type paragraph because in ignore mode.\n";
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
0.000000,0,0.000000,# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
0.000000,0,0.000000,
0.000000,0,0.000000,if($para_type eq '=pod') {
0.000000,0,0.000000,$self->_ponder_pod($para,$curr_open,$paras);
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($para_type eq '=over') {
0.000000,0,0.000000,next if $self->_ponder_over($para,$curr_open,$paras);
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($para_type eq '=back') {
0.000000,0,0.000000,next if $self->_ponder_back($para,$curr_open,$paras);
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,
0.000000,0,0.000000,# All non-magical codes!!!
0.000000,0,0.000000,
0.000000,0,0.000000,# Here we start using $para_type for our own twisted purposes, to
0.000000,0,0.000000,#  mean how it should get treated, not as what the element name
0.000000,0,0.000000,#  should be.
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Pondering non-magical $para_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,my $i;
0.000000,0,0.000000,
0.000000,0,0.000000,# Enforce some =headN discipline
0.000000,0,0.000000,if($para_type =~ m/^=head\d$/s
0.000000,0,0.000000,and ! $self->{'accept_heads_anywhere'}
0.000000,0,0.000000,and @$curr_open
0.000000,0,0.000000,and $curr_open->[-1][0] eq '=over'
0.000000,0,0.000000,) {
0.000000,0,0.000000,DEBUG > 2 and print STDERR "'=$para_type' inside an '=over'!\n";
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"You forgot a '=back' before '$para_type'"
0.000000,0,0.000000,);
0.000000,0,0.000000,unshift @$paras, ['=back', {}, ''], $para;   # close the =over
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,if($para_type eq '=item') {
0.000000,0,0.000000,
0.000000,0,0.000000,my $over;
0.000000,0,0.000000,unless(@$curr_open and
0.000000,0,0.000000,$over = (grep { $_->[0] eq '=over' } @$curr_open)[-1]) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"'=item' outside of any '=over'"
0.000000,0,0.000000,);
0.000000,0,0.000000,unshift @$paras,
0.000000,0,0.000000,['=over', {'start_line' => $para->[1]{'start_line'}}, ''],
0.000000,0,0.000000,$para
0.000000,0,0.000000,;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,my $over_type = $over->[1]{'~type'};
0.000000,0,0.000000,
0.000000,0,0.000000,if(!$over_type) {
0.000000,0,0.000000,# Shouldn't happen1
0.000000,0,0.000000,die "Typeless over in stack, starting at line "
0.000000,0,0.000000,. $over->[1]{'start_line'};
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'block') {
0.000000,0,0.000000,unless($curr_open->[-1][1]{'~bitched_about'}) {
0.000000,0,0.000000,$curr_open->[-1][1]{'~bitched_about'} = 1;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$curr_open->[-1][1]{'start_line'},
0.000000,0,0.000000,"You can't have =items (as at line "
0.000000,0,0.000000,. $para->[1]{'start_line'}
0.000000,0,0.000000,. ") unless the first thing after the =over is an =item"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,# Just turn it into a paragraph and reconsider it
0.000000,0,0.000000,$para->[0] = '~Para';
0.000000,0,0.000000,unshift @$paras, $para;
0.000000,0,0.000000,next;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'text') {
0.000000,0,0.000000,my $item_type = $self->_get_item_type($para);
0.000000,0,0.000000,# That kills the content of the item if it's a number or bullet.
0.000000,0,0.000000,DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if($item_type eq 'text') {
0.000000,0,0.000000,# Nothing special needs doing for 'text'
0.000000,0,0.000000,} elsif($item_type eq 'number' or $item_type eq 'bullet') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected text after =item, not a $item_type"
0.000000,0,0.000000,);
0.000000,0,0.000000,# Undo our clobbering:
0.000000,0,0.000000,push @$para, $para->[1]{'~orig_content'};
0.000000,0,0.000000,delete $para->[1]{'number'};
0.000000,0,0.000000,# Only a PROPER item-number element is allowed
0.000000,0,0.000000,#  to have a number attribute.
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "Unhandled item type $item_type"; # should never happen
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# =item-text thingies don't need any assimilation, it seems.
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'number') {
0.000000,0,0.000000,my $item_type = $self->_get_item_type($para);
0.000000,0,0.000000,# That kills the content of the item if it's a number or bullet.
0.000000,0,0.000000,DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,my $expected_value = ++ $curr_open->[-1][1]{'~counter'};
0.000000,0,0.000000,
0.000000,0,0.000000,if($item_type eq 'bullet') {
0.000000,0,0.000000,# Hm, it's not numeric.  Correct for this.
0.000000,0,0.000000,$para->[1]{'number'} = $expected_value;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item $expected_value'"
0.000000,0,0.000000,);
0.000000,0,0.000000,push @$para, $para->[1]{'~orig_content'};
0.000000,0,0.000000,# restore the bullet, blocking the assimilation of next para
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($item_type eq 'text') {
0.000000,0,0.000000,# Hm, it's not numeric.  Correct for this.
0.000000,0,0.000000,$para->[1]{'number'} = $expected_value;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item $expected_value'"
0.000000,0,0.000000,);
0.000000,0,0.000000,# Text content will still be there and will block next ~Para
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($item_type ne 'number') {
0.000000,0,0.000000,die "Unknown item type $item_type"; # should never happen
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($expected_value == $para->[1]{'number'}) {
0.000000,0,0.000000,DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n";
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 1 and print STDERR " Numeric item has ", $para->[1]{'number'},
0.000000,0,0.000000," instead of the expected value of $expected_value\n";
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"You have '=item " . $para->[1]{'number'} .
0.000000,0,0.000000,"' instead of the expected '=item $expected_value'"
0.000000,0,0.000000,);
0.000000,0,0.000000,$para->[1]{'number'} = $expected_value;  # correcting!!
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(@$para == 2) {
0.000000,0,0.000000,# For the cases where we /didn't/ push to @$para
0.000000,0,0.000000,if($paras->[0][0] eq '~Para') {
0.000000,0,0.000000,DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
0.000000,0,0.000000,push @$para, splice @{shift @$paras},2;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
0.000000,0,0.000000,push @$para, '';  # Just so it's not contentless
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'bullet') {
0.000000,0,0.000000,my $item_type = $self->_get_item_type($para);
0.000000,0,0.000000,# That kills the content of the item if it's a number or bullet.
0.000000,0,0.000000,DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if($item_type eq 'bullet') {
0.000000,0,0.000000,# as expected!
0.000000,0,0.000000,
0.000000,0,0.000000,if( $para->[1]{'~_freaky_para_hack'} ) {
0.000000,0,0.000000,DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";
0.000000,0,0.000000,push @$para, $para->[1]{'~_freaky_para_hack'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($item_type eq 'number') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item *'"
0.000000,0,0.000000,);
0.000000,0,0.000000,push @$para, $para->[1]{'~orig_content'};
0.000000,0,0.000000,# and block assimilation of the next paragraph
0.000000,0,0.000000,delete $para->[1]{'number'};
0.000000,0,0.000000,# Only a PROPER item-number element is allowed
0.000000,0,0.000000,#  to have a number attribute.
0.000000,0,0.000000,} elsif($item_type eq 'text') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item *'"
0.000000,0,0.000000,);
0.000000,0,0.000000,# But doesn't need processing.  But it'll block assimilation
0.000000,0,0.000000,#  of the next para.
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "Unhandled item type $item_type"; # should never happen
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(@$para == 2) {
0.000000,0,0.000000,# For the cases where we /didn't/ push to @$para
0.000000,0,0.000000,if($paras->[0][0] eq '~Para') {
0.000000,0,0.000000,DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
0.000000,0,0.000000,push @$para, splice @{shift @$paras},2;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
0.000000,0,0.000000,push @$para, '';  # Just so it's not contentless
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "Unhandled =over type \"$over_type\"?";
0.000000,0,0.000000,# Shouldn't happen!
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$para_type = 'Plain';
0.000000,0,0.000000,$para->[0] .= '-' . $over_type;
0.000000,0,0.000000,# Whew.  Now fall thru and process it.
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($para_type eq '=extend') {
0.000000,0,0.000000,# Well, might as well implement it here.
0.000000,0,0.000000,$self->_ponder_extend($para);
0.000000,0,0.000000,next;  # and skip
0.000000,0,0.000000,} elsif($para_type eq '=encoding') {
0.000000,0,0.000000,# Not actually acted on here, but we catch errors here.
0.000000,0,0.000000,$self->_handle_encoding_second_level($para);
0.000000,0,0.000000,next unless $self->keep_encoding_directive;
0.000000,0,0.000000,$para_type = 'Plain';
0.000000,0,0.000000,} elsif($para_type eq '~Verbatim') {
0.000000,0,0.000000,$para->[0] = 'Verbatim';
0.000000,0,0.000000,$para_type = '?Verbatim';
0.000000,0,0.000000,} elsif($para_type eq '~Para') {
0.000000,0,0.000000,$para->[0] = 'Para';
0.000000,0,0.000000,$para_type = '?Plain';
0.000000,0,0.000000,} elsif($para_type eq 'Data') {
0.000000,0,0.000000,$para->[0] = 'Data';
0.000000,0,0.000000,$para_type = '?Data';
0.000000,0,0.000000,} elsif( $para_type =~ s/^=//s
0.000000,0,0.000000,and defined( $para_type = $self->{'accept_directives'}{$para_type} )
0.000000,0,0.000000,) {
0.000000,0,0.000000,DEBUG > 1 and print STDERR " Pondering known directive ${$para}[0] as $para_type\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# An unknown directive!
0.000000,0,0.000000,$seen_legal_directive--;
0.000000,0,0.000000,DEBUG > 1 and printf STDERR "Unhandled directive %s (Handled: %s)\n",
0.000000,0,0.000000,$para->[0], join(' ', sort keys %{$self->{'accept_directives'}} )
0.000000,0,0.000000,;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Unknown directive: $para->[0]"
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# And maybe treat it as text instead of just letting it go?
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if($para_type =~ s/^\?//s) {
0.000000,0,0.000000,if(! @$curr_open) {  # usual case
0.000000,0,0.000000,DEBUG and print STDERR "Treating $para_type paragraph as such because stack is empty.\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,my @fors = grep $_->[0] eq '=for', @$curr_open;
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Containing fors: ",
0.000000,0,0.000000,join(',', map $_->[1]{'target'}, @fors), "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if(! @fors) {
0.000000,0,0.000000,DEBUG and print STDERR "Treating $para_type paragraph as such because stack has no =for's\n";
0.000000,0,0.000000,
0.000000,0,0.000000,#} elsif(grep $_->[1]{'~resolve'}, @fors) {
0.000000,0,0.000000,#} elsif(not grep !$_->[1]{'~resolve'}, @fors) {
0.000000,0,0.000000,} elsif( $fors[-1][1]{'~resolve'} ) {
0.000000,0,0.000000,# Look to the immediately containing for
0.000000,0,0.000000,
0.000000,0,0.000000,if($para_type eq 'Data') {
0.000000,0,0.000000,DEBUG and print STDERR "Treating Data paragraph as Plain/Verbatim because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";
0.000000,0,0.000000,$para->[0] = 'Para';
0.000000,0,0.000000,$para_type = 'Plain';
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG and print STDERR "Treating $para_type paragraph as such because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG and print STDERR "Treating $para_type paragraph as Data because the containing =for ($fors[-1][1]{'target'}) is a non-resolver\n";
0.000000,0,0.000000,$para->[0] = $para_type = 'Data';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0.000000,0,0.000000,if($para_type eq 'Plain') {
0.000000,0,0.000000,$self->_ponder_Plain($para);
0.000000,0,0.000000,} elsif($para_type eq 'Verbatim') {
0.000000,0,0.000000,$self->_ponder_Verbatim($para);
0.000000,0,0.000000,} elsif($para_type eq 'Data') {
0.000000,0,0.000000,$self->_ponder_Data($para);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "\$para type is $para_type -- how did that happen?";
0.000000,0,0.000000,# Shouldn't happen.
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0.000000,0,0.000000,$para->[0] =~ s/^[~=]//s;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and print STDERR "\n", pretty($para), "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,# traverse the treelet (which might well be just one string scalar)
0.000000,0,0.000000,$self->{'content_seen'} ||= 1 if   $seen_legal_directive
0.000000,0,0.000000,&& ! $self->{'~tried_gen_errata'};
0.000000,0,0.000000,$self->_traverse_treelet_bit(@$para);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################################################
0.000000,0,0.000000,# The sub-ponderers...
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_for {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Fake it out as a begin/end
0.000000,0,0.000000,my $target;
0.000000,0,0.000000,
0.000000,0,0.000000,if(grep $_->[1]{'~ignore'}, @$curr_open) {
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Ignoring ignorable =for\n";
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for(my $i = 2; $i < @$para; ++$i) {
0.000000,0,0.000000,if($para->[$i] =~ s/^\s*(\S+)\s*//s) {
0.000000,0,0.000000,$target = $1;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,unless(defined $target) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=for without a target?"
0.000000,0,0.000000,);
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,DEBUG > 1 and
0.000000,0,0.000000,print STDERR "Faking out a =for $target as a =begin $target / =end $target\n";
0.000000,0,0.000000,
0.000000,0,0.000000,$para->[0] = 'Data';
0.000000,0,0.000000,
0.000000,0,0.000000,unshift @$paras,
0.000000,0,0.000000,['=begin',
0.000000,0,0.000000,{'start_line' => $para->[1]{'start_line'}, '~really' => '=for'},
0.000000,0,0.000000,$target,
0.000000,0,0.000000,],
0.000000,0,0.000000,$para,
0.000000,0,0.000000,['=end',
0.000000,0,0.000000,{'start_line' => $para->[1]{'start_line'}, '~really' => '=for'},
0.000000,0,0.000000,$target,
0.000000,0,0.000000,],
0.000000,0,0.000000,;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_begin {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,my $content = join ' ', splice @$para, 2;
0.000000,0,0.000000,$content =~ s/^\s+//s;
0.000000,0,0.000000,$content =~ s/\s+$//s;
0.000000,0,0.000000,unless(length($content)) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=begin without a target?"
0.000000,0,0.000000,);
0.000000,0,0.000000,DEBUG and print STDERR "Ignoring targetless =begin\n";
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my ($target, $title) = $content =~ m/^(\S+)\s*(.*)$/;
0.000000,0,0.000000,$para->[1]{'title'} = $title if ($title);
0.000000,0,0.000000,$para->[1]{'target'} = $target;  # without any ':'
0.000000,0,0.000000,$content = $target; # strip off the title
0.000000,0,0.000000,
0.000000,0,0.000000,$content =~ s/^:!/!:/s;
0.000000,0,0.000000,my $neg;  # whether this is a negation-match
0.000000,0,0.000000,$neg = 1        if $content =~ s/^!//s;
0.000000,0,0.000000,my $to_resolve;  # whether to process formatting codes
0.000000,0,0.000000,$to_resolve = 1 if $content =~ s/^://s;
0.000000,0,0.000000,
0.000000,0,0.000000,my $dont_ignore; # whether this target matches us
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $target_name (
0.000000,0,0.000000,split(',', $content, -1),
0.000000,0,0.000000,$neg ? () : '*'
0.000000,0,0.000000,) {
0.000000,0,0.000000,DEBUG > 2 and
0.000000,0,0.000000,print STDERR " Considering whether =begin $content matches $target_name\n";
0.000000,0,0.000000,next unless $self->{'accept_targets'}{$target_name};
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 2 and
0.000000,0,0.000000,print STDERR "  It DOES match the acceptable target $target_name!\n";
0.000000,0,0.000000,$to_resolve = 1
0.000000,0,0.000000,if $self->{'accept_targets'}{$target_name} eq 'force_resolve';
0.000000,0,0.000000,$dont_ignore = 1;
0.000000,0,0.000000,$para->[1]{'target_matching'} = $target_name;
0.000000,0,0.000000,last; # stop looking at other target names
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if($neg) {
0.000000,0,0.000000,if( $dont_ignore ) {
0.000000,0,0.000000,$dont_ignore = '';
0.000000,0,0.000000,delete $para->[1]{'target_matching'};
0.000000,0,0.000000,DEBUG > 2 and print STDERR " But the leading ! means that this is a NON-match!\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$dont_ignore = 1;
0.000000,0,0.000000,$para->[1]{'target_matching'} = '!';
0.000000,0,0.000000,DEBUG > 2 and print STDERR " But the leading ! means that this IS a match!\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$para->[0] = '=for';  # Just what we happen to call these, internally
0.000000,0,0.000000,$para->[1]{'~really'} ||= '=begin';
0.000000,0,0.000000,$para->[1]{'~ignore'}   = (! $dont_ignore) || 0;
0.000000,0,0.000000,$para->[1]{'~resolve'}  = $to_resolve || 0;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 1 and print STDERR " Making note to ", $dont_ignore ? 'not ' : '',
0.000000,0,0.000000,"ignore contents of this region\n";
0.000000,0,0.000000,DEBUG > 1 and $dont_ignore and print STDERR " Making note to treat contents as ",
0.000000,0,0.000000,($to_resolve ? 'verbatim/plain' : 'data'), " paragraphs\n";
0.000000,0,0.000000,DEBUG > 1 and print STDERR " (Stack now: ", $self->_dump_curr_open(), ")\n";
0.000000,0,0.000000,
0.000000,0,0.000000,push @$curr_open, $para;
0.000000,0,0.000000,if(!$dont_ignore or scalar grep $_->[1]{'~ignore'}, @$curr_open) {
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Ignoring ignorable =begin\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$self->{'content_seen'} ||= 1 unless $self->{'~tried_gen_errata'};
0.000000,0,0.000000,$self->_handle_element_start((my $scratch='for'), $para->[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_end {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,my $content = join ' ', splice @$para, 2;
0.000000,0,0.000000,$content =~ s/^\s+//s;
0.000000,0,0.000000,$content =~ s/\s+$//s;
0.000000,0,0.000000,DEBUG and print STDERR "Ogling '=end $content' directive\n";
0.000000,0,0.000000,
0.000000,0,0.000000,unless(length($content)) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"'=end' without a target?" . (
0.000000,0,0.000000,( @$curr_open and $curr_open->[-1][0] eq '=for' )
0.000000,0,0.000000,? ( " (Should be \"=end " . $curr_open->[-1][1]{'target'} . '")' )
0.000000,0,0.000000,: ''
0.000000,0,0.000000,)
0.000000,0,0.000000,);
0.000000,0,0.000000,DEBUG and print STDERR "Ignoring targetless =end\n";
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless($content =~ m/^\S+$/) {  # i.e., unless it's one word
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"'=end $content' is invalid.  (Stack: "
0.000000,0,0.000000,. $self->_dump_curr_open() . ')'
0.000000,0,0.000000,);
0.000000,0,0.000000,DEBUG and print STDERR "Ignoring mistargetted =end $content\n";
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless(@$curr_open and $curr_open->[-1][0] eq '=for') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=end $content without matching =begin.  (Stack: "
0.000000,0,0.000000,. $self->_dump_curr_open() . ')'
0.000000,0,0.000000,);
0.000000,0,0.000000,DEBUG and print STDERR "Ignoring mistargetted =end $content\n";
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless($content eq $curr_open->[-1][1]{'target'}) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=end $content doesn't match =begin "
0.000000,0,0.000000,. $curr_open->[-1][1]{'target'}
0.000000,0,0.000000,. ".  (Stack: "
0.000000,0,0.000000,. $self->_dump_curr_open() . ')'
0.000000,0,0.000000,);
0.000000,0,0.000000,DEBUG and print STDERR "Ignoring mistargetted =end $content at line $para->[1]{'start_line'}\n";
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Else it's okay to close...
0.000000,0,0.000000,if(grep $_->[1]{'~ignore'}, @$curr_open) {
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Not firing any event for this =end $content because in an ignored region\n";
0.000000,0,0.000000,# And that may be because of this to-be-closed =for region, or some
0.000000,0,0.000000,#  other one, but it doesn't matter.
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$curr_open->[-1][1]{'start_line'} = $para->[1]{'start_line'};
0.000000,0,0.000000,# what's that for?
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{'content_seen'} ||= 1 unless $self->{'~tried_gen_errata'};
0.000000,0,0.000000,$self->_handle_element_end( my $scratch = 'for', $para->[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Popping $curr_open->[-1][0] $curr_open->[-1][1]{'target'} because of =end $content\n";
0.000000,0,0.000000,pop @$curr_open;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_doc_end {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,if(@$curr_open) { # Deal with things left open
0.000000,0,0.000000,DEBUG and print STDERR "Stack is nonempty at end-document: (",
0.000000,0,0.000000,$self->_dump_curr_open(), ")\n";
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 9 and print STDERR "Stack: ", pretty($curr_open), "\n";
0.000000,0,0.000000,unshift @$paras, $self->_closers_for_all_curr_open;
0.000000,0,0.000000,# Make sure there is exactly one ~end in the parastack, at the end:
0.000000,0,0.000000,@$paras = grep $_->[0] ne '~end', @$paras;
0.000000,0,0.000000,push @$paras, $para, $para;
0.000000,0,0.000000,# We need two -- once for the next cycle where we
0.000000,0,0.000000,#  generate errata, and then another to be at the end
0.000000,0,0.000000,#  when that loop back around to process the errata.
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG and print STDERR "Okay, stack is empty now.\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Try generating errata section, if applicable
0.000000,0,0.000000,unless($self->{'~tried_gen_errata'}) {
0.000000,0,0.000000,$self->{'~tried_gen_errata'} = 1;
0.000000,0,0.000000,my @extras = $self->_gen_errata();
0.000000,0,0.000000,if(@extras) {
0.000000,0,0.000000,unshift @$paras, @extras;
0.000000,0,0.000000,DEBUG and print STDERR "Generated errata... relooping...\n";
0.000000,0,0.000000,return 1;  # I.e., loop around again to process these fake-o paragraphs
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,splice @$paras; # Well, that's that for this paragraph buffer.
0.000000,0,0.000000,DEBUG and print STDERR "Throwing end-document event.\n";
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_handle_element_end( my $scratch = 'Document' );
0.000000,0,0.000000,return 1; # Hasta la byebye
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_pod {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=pod directives shouldn't be over one line long!  Ignoring all "
0.000000,0,0.000000,. (@$para - 2) . " lines of content"
0.000000,0,0.000000,) if @$para > 3;
0.000000,0,0.000000,
0.000000,0,0.000000,# Content ignored unless 'pod_handler' is set
0.000000,0,0.000000,if (my $pod_handler = $self->{'pod_handler'}) {
0.000000,0,0.000000,my ($line_num, $line) = map $_, $para->[1]{'start_line'}, $para->[2];
0.000000,0,0.000000,$line = $line eq '' ? "=pod" : "=pod $line"; # imitate cut_handler output
0.000000,0,0.000000,$pod_handler->($line, $line_num, $self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# The surrounding methods set content_seen, so let us remain consistent.
0.000000,0,0.000000,# I do not know why it was not here before -- should it not be here?
0.000000,0,0.000000,# $self->{'content_seen'} ||= 1 unless $self->{'~tried_gen_errata'};
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_over {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,return 1 unless @$paras;
0.000000,0,0.000000,my $list_type;
0.000000,0,0.000000,
0.000000,0,0.000000,if($paras->[0][0] eq '=item') { # most common case
0.000000,0,0.000000,$list_type = $self->_get_initial_item_type($paras->[0]);
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($paras->[0][0] eq '=back') {
0.000000,0,0.000000,# Ignore empty lists by default
0.000000,0,0.000000,if ($self->{'parse_empty_lists'}) {
0.000000,0,0.000000,$list_type = 'empty';
0.000000,0,0.000000,} else {
0.000000,0,0.000000,shift @$paras;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif($paras->[0][0] eq '~end') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=over is the last thing in the document?!"
0.000000,0,0.000000,);
0.000000,0,0.000000,return 1; # But feh, ignore it.
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$list_type = 'block';
0.000000,0,0.000000,}
0.000000,0,0.000000,$para->[1]{'~type'} = $list_type;
0.000000,0,0.000000,push @$curr_open, $para;
0.000000,0,0.000000,# yes, we reuse the paragraph as a stack item
0.000000,0,0.000000,
0.000000,0,0.000000,my $content = join ' ', splice @$para, 2;
0.000000,0,0.000000,$para->[1]{'~orig_content'} = $content;
0.000000,0,0.000000,my $overness;
0.000000,0,0.000000,if($content =~ m/^\s*$/s) {
0.000000,0,0.000000,$para->[1]{'indent'} = 4;
0.000000,0,0.000000,} elsif($content =~ m/^\s*((?:\d*\.)?\d+)\s*$/s) {
0.005348,2,0.002674,no integer;
0.000000,0,0.000000,$para->[1]{'indent'} = $1;
0.000000,0,0.000000,if($1 == 0) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Can't have a 0 in =over $content"
0.000000,0,0.000000,);
0.000000,0,0.000000,$para->[1]{'indent'} = 4;
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=over should be: '=over' or '=over positive_number'"
0.000000,0,0.000000,);
0.000000,0,0.000000,$para->[1]{'indent'} = 4;
0.000000,0,0.000000,}
0.000000,0,0.000000,DEBUG > 1 and print STDERR "=over found of type $list_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{'content_seen'} ||= 1 unless $self->{'~tried_gen_errata'};
0.000000,0,0.000000,$self->_handle_element_start((my $scratch = 'over-' . $list_type), $para->[1]);
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_back {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,# TODO: fire off </item-number> or </item-bullet> or </item-text> ??
0.000000,0,0.000000,
0.000000,0,0.000000,my $content = join ' ', splice @$para, 2;
0.000000,0,0.000000,if($content =~ m/\S/) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=back doesn't take any parameters, but you said =back $content"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(@$curr_open and $curr_open->[-1][0] eq '=over') {
0.000000,0,0.000000,DEBUG > 1 and print STDERR "=back happily closes matching =over\n";
0.000000,0,0.000000,# Expected case: we're closing the most recently opened thing
0.000000,0,0.000000,#my $over = pop @$curr_open;
0.000000,0,0.000000,$self->{'content_seen'} ||= 1 unless $self->{'~tried_gen_errata'};
0.000000,0,0.000000,$self->_handle_element_end( my $scratch =
0.000000,0,0.000000,'over-' . ( (pop @$curr_open)->[1]{'~type'} ), $para->[1]
0.000000,0,0.000000,);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 1 and print STDERR "=back found without a matching =over.  Stack: (",
0.000000,0,0.000000,join(', ', map $_->[0], @$curr_open), ").\n";
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,'=back without =over'
0.000000,0,0.000000,);
0.000000,0,0.000000,return 1; # and ignore it
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_item {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,my $over;
0.000000,0,0.000000,unless(@$curr_open and
0.000000,0,0.000000,$over = (grep { $_->[0] eq '=over' } @$curr_open)[-1]) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"'=item' outside of any '=over'"
0.000000,0,0.000000,);
0.000000,0,0.000000,unshift @$paras,
0.000000,0,0.000000,['=over', {'start_line' => $para->[1]{'start_line'}}, ''],
0.000000,0,0.000000,$para
0.000000,0,0.000000,;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,my $over_type = $over->[1]{'~type'};
0.000000,0,0.000000,
0.000000,0,0.000000,if(!$over_type) {
0.000000,0,0.000000,# Shouldn't happen1
0.000000,0,0.000000,die "Typeless over in stack, starting at line "
0.000000,0,0.000000,. $over->[1]{'start_line'};
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'block') {
0.000000,0,0.000000,unless($curr_open->[-1][1]{'~bitched_about'}) {
0.000000,0,0.000000,$curr_open->[-1][1]{'~bitched_about'} = 1;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$curr_open->[-1][1]{'start_line'},
0.000000,0,0.000000,"You can't have =items (as at line "
0.000000,0,0.000000,. $para->[1]{'start_line'}
0.000000,0,0.000000,. ") unless the first thing after the =over is an =item"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,# Just turn it into a paragraph and reconsider it
0.000000,0,0.000000,$para->[0] = '~Para';
0.000000,0,0.000000,unshift @$paras, $para;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'text') {
0.000000,0,0.000000,my $item_type = $self->_get_item_type($para);
0.000000,0,0.000000,# That kills the content of the item if it's a number or bullet.
0.000000,0,0.000000,DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if($item_type eq 'text') {
0.000000,0,0.000000,# Nothing special needs doing for 'text'
0.000000,0,0.000000,} elsif($item_type eq 'number' or $item_type eq 'bullet') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected text after =item, not a $item_type"
0.000000,0,0.000000,);
0.000000,0,0.000000,# Undo our clobbering:
0.000000,0,0.000000,push @$para, $para->[1]{'~orig_content'};
0.000000,0,0.000000,delete $para->[1]{'number'};
0.000000,0,0.000000,# Only a PROPER item-number element is allowed
0.000000,0,0.000000,#  to have a number attribute.
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "Unhandled item type $item_type"; # should never happen
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# =item-text thingies don't need any assimilation, it seems.
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'number') {
0.000000,0,0.000000,my $item_type = $self->_get_item_type($para);
0.000000,0,0.000000,# That kills the content of the item if it's a number or bullet.
0.000000,0,0.000000,DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,my $expected_value = ++ $curr_open->[-1][1]{'~counter'};
0.000000,0,0.000000,
0.000000,0,0.000000,if($item_type eq 'bullet') {
0.000000,0,0.000000,# Hm, it's not numeric.  Correct for this.
0.000000,0,0.000000,$para->[1]{'number'} = $expected_value;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item $expected_value'"
0.000000,0,0.000000,);
0.000000,0,0.000000,push @$para, $para->[1]{'~orig_content'};
0.000000,0,0.000000,# restore the bullet, blocking the assimilation of next para
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($item_type eq 'text') {
0.000000,0,0.000000,# Hm, it's not numeric.  Correct for this.
0.000000,0,0.000000,$para->[1]{'number'} = $expected_value;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item $expected_value'"
0.000000,0,0.000000,);
0.000000,0,0.000000,# Text content will still be there and will block next ~Para
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($item_type ne 'number') {
0.000000,0,0.000000,die "Unknown item type $item_type"; # should never happen
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($expected_value == $para->[1]{'number'}) {
0.000000,0,0.000000,DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n";
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 1 and print STDERR " Numeric item has ", $para->[1]{'number'},
0.000000,0,0.000000," instead of the expected value of $expected_value\n";
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"You have '=item " . $para->[1]{'number'} .
0.000000,0,0.000000,"' instead of the expected '=item $expected_value'"
0.000000,0,0.000000,);
0.000000,0,0.000000,$para->[1]{'number'} = $expected_value;  # correcting!!
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(@$para == 2) {
0.000000,0,0.000000,# For the cases where we /didn't/ push to @$para
0.000000,0,0.000000,if($paras->[0][0] eq '~Para') {
0.000000,0,0.000000,DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
0.000000,0,0.000000,push @$para, splice @{shift @$paras},2;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
0.000000,0,0.000000,push @$para, '';  # Just so it's not contentless
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'bullet') {
0.000000,0,0.000000,my $item_type = $self->_get_item_type($para);
0.000000,0,0.000000,# That kills the content of the item if it's a number or bullet.
0.000000,0,0.000000,DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if($item_type eq 'bullet') {
0.000000,0,0.000000,# as expected!
0.000000,0,0.000000,
0.000000,0,0.000000,if( $para->[1]{'~_freaky_para_hack'} ) {
0.000000,0,0.000000,DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";
0.000000,0,0.000000,push @$para, $para->[1]{'~_freaky_para_hack'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($item_type eq 'number') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item *'"
0.000000,0,0.000000,);
0.000000,0,0.000000,push @$para, $para->[1]{'~orig_content'};
0.000000,0,0.000000,# and block assimilation of the next paragraph
0.000000,0,0.000000,delete $para->[1]{'number'};
0.000000,0,0.000000,# Only a PROPER item-number element is allowed
0.000000,0,0.000000,#  to have a number attribute.
0.000000,0,0.000000,} elsif($item_type eq 'text') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item *'"
0.000000,0,0.000000,);
0.000000,0,0.000000,# But doesn't need processing.  But it'll block assimilation
0.000000,0,0.000000,#  of the next para.
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "Unhandled item type $item_type"; # should never happen
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(@$para == 2) {
0.000000,0,0.000000,# For the cases where we /didn't/ push to @$para
0.000000,0,0.000000,if($paras->[0][0] eq '~Para') {
0.000000,0,0.000000,DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
0.000000,0,0.000000,push @$para, splice @{shift @$paras},2;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
0.000000,0,0.000000,push @$para, '';  # Just so it's not contentless
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "Unhandled =over type \"$over_type\"?";
0.000000,0,0.000000,# Shouldn't happen!
0.000000,0,0.000000,}
0.000000,0,0.000000,$para->[0] .= '-' . $over_type;
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_Plain {
0.000000,0,0.000000,my ($self,$para) = @_;
0.000000,0,0.000000,DEBUG and print STDERR " giving plain treatment...\n";
0.000000,0,0.000000,unless( @$para == 2 or ( @$para == 3 and $para->[2] eq '' )
0.000000,0,0.000000,or $para->[1]{'~cooked'}
0.000000,0,0.000000,) {
0.000000,0,0.000000,push @$para,
0.000000,0,0.000000,@{$self->_make_treelet(
0.000000,0,0.000000,join("\n", splice(@$para, 2)),
0.000000,0,0.000000,$para->[1]{'start_line'}
0.000000,0,0.000000,)};
0.000000,0,0.000000,}
0.000000,0,0.000000,# Empty paragraphs don't need a treelet for any reason I can see.
0.000000,0,0.000000,# And precooked paragraphs already have a treelet.
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_Verbatim {
0.000000,0,0.000000,my ($self,$para) = @_;
0.000000,0,0.000000,DEBUG and print STDERR " giving verbatim treatment...\n";
0.000000,0,0.000000,
0.000000,0,0.000000,$para->[1]{'xml:space'} = 'preserve';
0.000000,0,0.000000,
0.000000,0,0.000000,unless ($self->{'_output_is_for_JustPod'}) {
0.000000,0,0.000000,# Fix illegal settings for expand_verbatim_tabs()
0.000000,0,0.000000,# This is because this module doesn't do input error checking, but khw
0.000000,0,0.000000,# doesn't want to add yet another instance of that.
0.000000,0,0.000000,$self->expand_verbatim_tabs(8)
0.000000,0,0.000000,if ! defined $self->expand_verbatim_tabs()
0.000000,0,0.000000,||   $self->expand_verbatim_tabs() =~ /\D/;
0.000000,0,0.000000,
0.000000,0,0.000000,my $indent = $self->strip_verbatim_indent;
0.000000,0,0.000000,if ($indent && ref $indent eq 'CODE') {
0.000000,0,0.000000,my @shifted = (shift @{$para}, shift @{$para});
0.000000,0,0.000000,$indent = $indent->($para);
0.000000,0,0.000000,unshift @{$para}, @shifted;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for(my $i = 2; $i < @$para; $i++) {
0.000000,0,0.000000,foreach my $line ($para->[$i]) { # just for aliasing
0.000000,0,0.000000,# Strip indentation.
0.000000,0,0.000000,$line =~ s/^\Q$indent// if $indent;
0.000000,0,0.000000,next unless $self->expand_verbatim_tabs;
0.000000,0,0.000000,
0.000000,0,0.000000,# This is commented out because of github issue #85, and the
0.000000,0,0.000000,# current maintainers don't know why it was there in the first
0.000000,0,0.000000,# place.
0.000000,0,0.000000,#&& !($self->{accept_codes} && $self->{accept_codes}{VerbatimFormatted});
0.000000,0,0.000000,while( $line =~
0.000000,0,0.000000,# Sort of adapted from Text::Tabs.
0.000000,0,0.000000,s/^([^\t]*)(\t+)/$1.(" " x ((length($2)
0.000000,0,0.000000,* $self->expand_verbatim_tabs)
0.000000,0,0.000000,-(length($1)&7)))/e
0.000000,0,0.000000,) {}
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: whinge about (or otherwise treat) unindented or overlong lines
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Now the VerbatimFormatted hoodoo...
0.000000,0,0.000000,if( $self->{'accept_codes'} and
0.000000,0,0.000000,$self->{'accept_codes'}{'VerbatimFormatted'}
0.000000,0,0.000000,) {
0.000000,0,0.000000,while(@$para > 3 and $para->[-1] !~ m/\S/) { pop @$para }
0.000000,0,0.000000,# Kill any number of terminal newlines
0.000000,0,0.000000,$self->_verbatim_format($para);
0.000000,0,0.000000,} elsif ($self->{'codes_in_verbatim'}) {
0.000000,0,0.000000,push @$para,
0.000000,0,0.000000,@{$self->_make_treelet(
0.000000,0,0.000000,join("\n", splice(@$para, 2)),
0.000000,0,0.000000,$para->[1]{'start_line'}, $para->[1]{'xml:space'}
0.000000,0,0.000000,)};
0.000000,0,0.000000,$para->[-1] =~ s/\n+$//s; # Kill any number of terminal newlines
0.000000,0,0.000000,} else {
0.000000,0,0.000000,push @$para, join "\n", splice(@$para, 2) if @$para > 3;
0.000000,0,0.000000,$para->[-1] =~ s/\n+$//s; # Kill any number of terminal newlines
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_Data {
0.000000,0,0.000000,my ($self,$para) = @_;
0.000000,0,0.000000,DEBUG and print STDERR " giving data treatment...\n";
0.000000,0,0.000000,$para->[1]{'xml:space'} = 'preserve';
0.000000,0,0.000000,push @$para, join "\n", splice(@$para, 2) if @$para > 3;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################################################
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_treelet_bit {  # for use only by the routine above
0.000000,0,0.000000,my($self, $name) = splice @_,0,2;
0.000000,0,0.000000,
0.000000,0,0.000000,my $scratch;
0.000000,0,0.000000,$self->_handle_element_start(($scratch=$name), shift @_);
0.000000,0,0.000000,
0.000000,0,0.000000,while (@_) {
0.000000,0,0.000000,my $x = shift;
0.000000,0,0.000000,if (ref($x)) {
0.000000,0,0.000000,&_traverse_treelet_bit($self, @$x);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$x .= shift while @_ && !ref($_[0]);
0.000000,0,0.000000,$self->_handle_text($x);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_handle_element_end($scratch=$name);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub _closers_for_all_curr_open {
0.000000,0,0.000000,my $self = $_[0];
0.000000,0,0.000000,my @closers;
0.000000,0,0.000000,foreach my $still_open (@{  $self->{'curr_open'} || return  }) {
0.000000,0,0.000000,my @copy = @$still_open;
0.000000,0,0.000000,$copy[1] = {%{ $copy[1] }};
0.000000,0,0.000000,#$copy[1]{'start_line'} = -1;
0.000000,0,0.000000,if($copy[0] eq '=for') {
0.000000,0,0.000000,$copy[0] = '=end';
0.000000,0,0.000000,} elsif($copy[0] eq '=over') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$still_open->[1]{start_line} ,
0.000000,0,0.000000,"=over without closing =back"
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$copy[0] = '=back';
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "I don't know how to auto-close an open $copy[0] region";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless( @copy > 2 ) {
0.000000,0,0.000000,push @copy, $copy[1]{'target'};
0.000000,0,0.000000,$copy[-1] = '' unless defined $copy[-1];
0.000000,0,0.000000,# since =over's don't have targets
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$copy[1]{'fake-closer'} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and print STDERR "Queuing up fake-o event: ", pretty(\@copy), "\n";
0.000000,0,0.000000,unshift @closers, \@copy;
0.000000,0,0.000000,}
0.000000,0,0.000000,return @closers;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#--------------------------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,sub _verbatim_format {
0.000000,0,0.000000,my($it, $p) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $formatting;
0.000000,0,0.000000,
0.000000,0,0.000000,for(my $i = 2; $i < @$p; $i++) { # work backwards over the lines
0.000000,0,0.000000,DEBUG and print STDERR "_verbatim_format appends a newline to $i: $p->[$i]\n";
0.000000,0,0.000000,$p->[$i] .= "\n";
0.000000,0,0.000000,# Unlike with simple Verbatim blocks, we don't end up just doing
0.000000,0,0.000000,# a join("\n", ...) on the contents, so we have to append a
0.000000,0,0.000000,# newline to every line, and then nix the last one later.
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if( DEBUG > 4 ) {
0.000000,0,0.000000,print STDERR "<<\n";
0.000000,0,0.000000,for(my $i = $#$p; $i >= 2; $i--) { # work backwards over the lines
0.000000,0,0.000000,print STDERR "_verbatim_format $i: $p->[$i]";
0.000000,0,0.000000,}
0.000000,0,0.000000,print STDERR ">>\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for(my $i = $#$p; $i > 2; $i--) {
0.000000,0,0.000000,# work backwards over the lines, except the first (#2)
0.000000,0,0.000000,
0.000000,0,0.000000,#next unless $p->[$i]   =~ m{^#:([ \^\/\%]*)\n?$}s
0.000000,0,0.000000,#        and $p->[$i-1] !~ m{^#:[ \^\/\%]*\n?$}s;
0.000000,0,0.000000,# look at a formatty line preceding a nonformatty one
0.000000,0,0.000000,DEBUG > 5 and print STDERR "Scrutinizing line $i: $$p[$i]\n";
0.000000,0,0.000000,if($p->[$i]   =~ m{^#:([ \^\/\%]*)\n?$}s) {
0.000000,0,0.000000,DEBUG > 5 and print STDERR "  It's a formatty line.  ",
0.000000,0,0.000000,"Peeking at previous line ", $i-1, ": $$p[$i-1]: \n";
0.000000,0,0.000000,
0.000000,0,0.000000,if( $p->[$i-1] =~ m{^#:[ \^\/\%]*\n?$}s ) {
0.000000,0,0.000000,DEBUG > 5 and print STDERR "  Previous line is formatty!  Skipping this one.\n";
0.000000,0,0.000000,next;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 5 and print STDERR "  Previous line is non-formatty!  Yay!\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 5 and print STDERR "  It's not a formatty line.  Ignoring\n";
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# A formatty line has to have #: in the first two columns, and uses
0.000000,0,0.000000,# "^" to mean bold, "/" to mean underline, and "%" to mean bold italic.
0.000000,0,0.000000,# Example:
0.000000,0,0.000000,#   What do you want?  i like pie. [or whatever]
0.000000,0,0.000000,# #:^^^^^^^^^^^^^^^^^              /////////////
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 4 and print STDERR "_verbatim_format considers:\n<$p->[$i-1]>\n<$p->[$i]>\n";
0.000000,0,0.000000,
0.000000,0,0.000000,$formatting = '  ' . $1;
0.000000,0,0.000000,$formatting =~ s/\s+$//s; # nix trailing whitespace
0.000000,0,0.000000,unless(length $formatting and $p->[$i-1] =~ m/\S/) { # no-op
0.000000,0,0.000000,splice @$p,$i,1; # remove this line
0.000000,0,0.000000,$i--; # don't consider next line
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if( length($formatting) >= length($p->[$i-1]) ) {
0.000000,0,0.000000,$formatting = substr($formatting, 0, length($p->[$i-1]) - 1) . ' ';
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$formatting .= ' ' x (length($p->[$i-1]) - length($formatting));
0.000000,0,0.000000,}
0.000000,0,0.000000,# Make $formatting and the previous line be exactly the same length,
0.000000,0,0.000000,# with $formatting having a " " as the last character.
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 4 and print STDERR "Formatting <$formatting>    on <", $p->[$i-1], ">\n";
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,my @new_line;
0.000000,0,0.000000,while( $formatting =~ m{\G(( +)|(\^+)|(\/+)|(\%+))}g ) {
0.000000,0,0.000000,#print STDERR "Format matches $1\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if($2) {
0.000000,0,0.000000,#print STDERR "SKIPPING <$2>\n";
0.000000,0,0.000000,push @new_line,
0.000000,0,0.000000,substr($p->[$i-1], pos($formatting)-length($1), length($1));
0.000000,0,0.000000,} else {
0.000000,0,0.000000,#print STDERR "SNARING $+\n";
0.000000,0,0.000000,push @new_line, [
0.000000,0,0.000000,(
0.000000,0,0.000000,$3 ? 'VerbatimB'  :
0.000000,0,0.000000,$4 ? 'VerbatimI'  :
0.000000,0,0.000000,$5 ? 'VerbatimBI' : die("Should never get called")
0.000000,0,0.000000,), {},
0.000000,0,0.000000,substr($p->[$i-1], pos($formatting)-length($1), length($1))
0.000000,0,0.000000,];
0.000000,0,0.000000,#print STDERR "Formatting <$new_line[-1][-1]> as $new_line[-1][0]\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my @nixed =
0.000000,0,0.000000,splice @$p, $i-1, 2, @new_line; # replace myself and the next line
0.000000,0,0.000000,DEBUG > 10 and print STDERR "Nixed count: ", scalar(@nixed), "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 6 and print STDERR "New version of the above line is these tokens (",
0.000000,0,0.000000,scalar(@new_line), "):",
0.000000,0,0.000000,map( ref($_)?"<@$_> ":"<$_>", @new_line ), "\n";
0.000000,0,0.000000,$i--; # So the next line we scrutinize is the line before the one
0.000000,0,0.000000,#  that we just went and formatted
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$p->[0] = 'VerbatimFormatted';
0.000000,0,0.000000,
0.000000,0,0.000000,# Collapse adjacent text nodes, just for kicks.
0.000000,0,0.000000,for( my $i = 2; $i > $#$p; $i++ ) { # work forwards over the tokens except for the last
0.000000,0,0.000000,if( !ref($p->[$i]) and !ref($p->[$i + 1]) ) {
0.000000,0,0.000000,DEBUG > 5 and print STDERR "_verbatim_format merges {$p->[$i]} and {$p->[$i+1]}\n";
0.000000,0,0.000000,$p->[$i] .= splice @$p, $i+1, 1; # merge
0.000000,0,0.000000,--$i;  # and back up
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Now look for the last text token, and remove the terminal newline
0.000000,0,0.000000,for( my $i = $#$p; $i >= 2; $i-- ) {
0.000000,0,0.000000,# work backwards over the tokens, even the first
0.000000,0,0.000000,if( !ref($p->[$i]) ) {
0.000000,0,0.000000,if($p->[$i] =~ s/\n$//s) {
0.000000,0,0.000000,DEBUG > 5 and print STDERR "_verbatim_format killed the terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]}\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 5 and print STDERR
0.000000,0,0.000000,"No terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]} !?\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,last; # we only want the next one
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _treelet_from_formatting_codes {
0.000000,0,0.000000,# Given a paragraph, returns a treelet.  Full of scary tokenizing code.
0.000000,0,0.000000,#  Like [ '~Top', {'start_line' => $start_line},
0.000000,0,0.000000,#            "I like ",
0.000000,0,0.000000,#            [ 'B', {}, "pie" ],
0.000000,0,0.000000,#            "!"
0.000000,0,0.000000,#       ]
0.000000,0,0.000000,# This illustrates the general format of a treelet.  It is an array:
0.000000,0,0.000000,#     [0]       is a scalar indicating its type.  In the example above, the
0.000000,0,0.000000,#               types are '~Top' and 'B'
0.000000,0,0.000000,#     [1]       is a hash of various flags about it, possibly empty
0.000000,0,0.000000,#     [2] - [N] are an ordered list of the subcomponents of the treelet.
0.000000,0,0.000000,#               Scalars are literal text, refs are sub-treelets, to
0.000000,0,0.000000,#               arbitrary levels.  Stringifying a treelet will recursively
0.000000,0,0.000000,#               stringify the sub-treelets, concatentating everything
0.000000,0,0.000000,#               together to form the exact text of the treelet.
0.000000,0,0.000000,
0.000000,0,0.000000,my($self, $para, $start_line, $preserve_space) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $treelet = ['~Top', {'start_line' => $start_line},];
0.000000,0,0.000000,
0.000000,0,0.000000,unless ($preserve_space || $self->{'preserve_whitespace'}) {
0.000000,0,0.000000,$para =~ s/\s+/ /g; # collapse and trim all whitespace first.
0.000000,0,0.000000,$para =~ s/ $//;
0.000000,0,0.000000,$para =~ s/^ //;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Only apparent problem the above code is that N<<  >> turns into
0.000000,0,0.000000,# N<< >>.  But then, word wrapping does that too!  So don't do that!
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# As a Start-code is encountered, the number of opening bracket '<'
0.000000,0,0.000000,# characters minus 1 is pushed onto @stack (so 0 means a single bracket,
0.000000,0,0.000000,# etc).  When closing brackets are found in the text, at least this number
0.000000,0,0.000000,# (plus the 1) will be required to mean the Start-code is terminated.  When
0.000000,0,0.000000,# those are found, @stack is popped.
0.000000,0,0.000000,my @stack;
0.000000,0,0.000000,
0.000000,0,0.000000,my @lineage = ($treelet);
0.000000,0,0.000000,my $raw = ''; # raw content of L<> fcode before splitting/processing
0.000000,0,0.000000,# XXX 'raw' is not 100% accurate: all surrounding whitespace is condensed
0.000000,0,0.000000,# into just 1 ' '. Is this the regex's doing or 'raw's?  Answer is it's
0.000000,0,0.000000,# the 'collapse and trim all whitespace first' lines just above.
0.000000,0,0.000000,my $inL = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 4 and print STDERR "Paragraph:\n$para\n\n";
0.000000,0,0.000000,
0.000000,0,0.000000,# Here begins our frightening tokenizer RE.  The following regex matches
0.000000,0,0.000000,# text in four main parts:
0.000000,0,0.000000,#
0.000000,0,0.000000,#  * Start-codes.  The first alternative matches C< or C<<, the latter
0.000000,0,0.000000,#    followed by some whitespace.  $1 will hold the entire start code
0.000000,0,0.000000,#    (including any space following a multiple-angle-bracket delimiter),
0.000000,0,0.000000,#    and $2 will hold only the additional brackets past the first in a
0.000000,0,0.000000,#    multiple-bracket delimiter.  length($2) + 1 will be the number of
0.000000,0,0.000000,#    closing brackets we have to find.
0.000000,0,0.000000,#
0.000000,0,0.000000,#  * Closing brackets.  Match some amount of whitespace followed by
0.000000,0,0.000000,#    multiple close brackets.  The logic to see if this closes anything
0.000000,0,0.000000,#    is down below.  Note that in order to parse C<<  >> correctly, we
0.000000,0,0.000000,#    have to use look-behind (?<=\s\s), since the match of the starting
0.000000,0,0.000000,#    code will have consumed the whitespace.
0.000000,0,0.000000,#
0.000000,0,0.000000,#  * A single closing bracket, to close a simple code like C<>.
0.000000,0,0.000000,#
0.000000,0,0.000000,#  * Something that isn't a start or end code.  We have to be careful
0.000000,0,0.000000,#    about accepting whitespace, since perlpodspec says that any whitespace
0.000000,0,0.000000,#    before a multiple-bracket closing delimiter should be ignored.
0.000000,0,0.000000,#
0.000000,0,0.000000,while($para =~
0.000000,0,0.000000,m/\G
0.000000,0,0.000000,(?:
0.000000,0,0.000000,# Match starting codes, including the whitespace following a
0.000000,0,0.000000,# multiple-delimiter start code.  $1 gets the whole start code and
0.000000,0,0.000000,# $2 gets all but one of the <s in the multiple-bracket case.
0.000000,0,0.000000,([A-Z]<(?:(<+)\s+)?)
0.000000,0,0.000000,|
0.000000,0,0.000000,# Match multiple-bracket end codes.  $3 gets the whitespace that
0.000000,0,0.000000,# should be discarded before an end bracket but kept in other cases
0.000000,0,0.000000,# and $4 gets the end brackets themselves.  ($3 can be empty if the
0.000000,0,0.000000,# construct is empty, like C<<  >>, and all the white-space has been
0.000000,0,0.000000,# gobbled up already, considered to be space after the opening
0.000000,0,0.000000,# bracket.  In this case we use look-behind to verify that there are
0.000000,0,0.000000,# at least 2 spaces in a row before the ">".)
0.000000,0,0.000000,(\s+|(?<=\s\s))(>{2,})
0.000000,0,0.000000,|
0.000000,0,0.000000,(\s?>)          # $5: simple end-codes
0.000000,0,0.000000,|
0.000000,0,0.000000,(               # $6: stuff containing no start-codes or end-codes
0.000000,0,0.000000,(?:
0.000000,0,0.000000,[^A-Z\s>]
0.000000,0,0.000000,|
0.000000,0,0.000000,(?:
0.000000,0,0.000000,[A-Z](?!<)
0.000000,0,0.000000,)
0.000000,0,0.000000,|
0.000000,0,0.000000,# whitespace is ok, but we don't want to eat the whitespace before
0.000000,0,0.000000,# a multiple-bracket end code.
0.000000,0,0.000000,# NOTE: we may still have problems with e.g. S<<    >>
0.000000,0,0.000000,(?:
0.000000,0,0.000000,\s(?!\s*>{2,})
0.000000,0,0.000000,)
0.000000,0,0.000000,)+
0.000000,0,0.000000,)
0.000000,0,0.000000,)
0.000000,0,0.000000,/xgo
0.000000,0,0.000000,) {
0.000000,0,0.000000,DEBUG > 4 and print STDERR "\nParagraphic tokenstack = (@stack)\n";
0.000000,0,0.000000,if(defined $1) {
0.000000,0,0.000000,my $bracket_count;    # How many '<<<' in a row this has.  Needed for
0.000000,0,0.000000,# Pod::Simple::JustPod
0.000000,0,0.000000,if(defined $2) {
0.000000,0,0.000000,DEBUG > 3 and print STDERR "Found complex start-text code \"$1\"\n";
0.000000,0,0.000000,$bracket_count = length($2) + 1;
0.000000,0,0.000000,push @stack, $bracket_count; # length of the necessary complex
0.000000,0,0.000000,# end-code string
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 3 and print STDERR "Found simple start-text code \"$1\"\n";
0.000000,0,0.000000,push @stack, 0;  # signal that we're looking for simple
0.000000,0,0.000000,$bracket_count = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $code = substr($1,0,1);
0.000000,0,0.000000,if ('L' eq $code) {
0.000000,0,0.000000,if ($inL) {
0.000000,0,0.000000,$raw .= $1;
0.000000,0,0.000000,$self->scream( $start_line,
0.000000,0,0.000000,'Nested L<> are illegal.  Pretending inner one is '
0.000000,0,0.000000,. 'X<...> so can continue looking for other errors.');
0.000000,0,0.000000,$code = "X";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$raw = ""; # reset raw content accumulator
0.000000,0,0.000000,$inL = @stack;
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$raw .= $1 if $inL;
0.000000,0,0.000000,}
0.000000,0,0.000000,push @lineage, [ $code, {}, ];  # new node object
0.000000,0,0.000000,
0.000000,0,0.000000,# Tell Pod::Simple::JustPod how many brackets there were, but to save
0.000000,0,0.000000,# space, not in the most usual case of there was just 1.  It can be
0.000000,0,0.000000,# inferred by the absence of this element.  Similarly, if there is more
0.000000,0,0.000000,# than one bracket, extract the white space between the final bracket
0.000000,0,0.000000,# and the real beginning of the interior.  Save that if it isn't just a
0.000000,0,0.000000,# single space
0.000000,0,0.000000,if ($self->{'_output_is_for_JustPod'} && $bracket_count > 1) {
0.000000,0,0.000000,$lineage[-1][1]{'~bracket_count'} = $bracket_count;
0.000000,0,0.000000,my $lspacer = substr($1, 1 + $bracket_count);
0.000000,0,0.000000,$lineage[-1][1]{'~lspacer'} = $lspacer if $lspacer ne " ";
0.000000,0,0.000000,}
0.000000,0,0.000000,push @{ $lineage[-2] }, $lineage[-1];
0.000000,0,0.000000,} elsif(defined $4) {
0.000000,0,0.000000,DEBUG > 3 and print STDERR "Found apparent complex end-text code \"$3$4\"\n";
0.000000,0,0.000000,# This is where it gets messy...
0.000000,0,0.000000,if(! @stack) {
0.000000,0,0.000000,# We saw " >>>>" but needed nothing.  This is ALL just stuff then.
0.000000,0,0.000000,DEBUG > 4 and print STDERR " But it's really just stuff.\n";
0.000000,0,0.000000,push @{ $lineage[-1] }, $3, $4;
0.000000,0,0.000000,next;
0.000000,0,0.000000,} elsif(!$stack[-1]) {
0.000000,0,0.000000,# We saw " >>>>" but needed only ">".  Back pos up.
0.000000,0,0.000000,DEBUG > 4 and print STDERR " And that's more than we needed to close simple.\n";
0.000000,0,0.000000,push @{ $lineage[-1] }, $3; # That was a for-real space, too.
0.000000,0,0.000000,pos($para) = pos($para) - length($4) + 1;
0.000000,0,0.000000,} elsif($stack[-1] == length($4)) {
0.000000,0,0.000000,# We found " >>>>", and it was exactly what we needed.  Commonest case.
0.000000,0,0.000000,DEBUG > 4 and print STDERR " And that's exactly what we needed to close complex.\n";
0.000000,0,0.000000,} elsif($stack[-1] < length($4)) {
0.000000,0,0.000000,# We saw " >>>>" but needed only " >>".  Back pos up.
0.000000,0,0.000000,DEBUG > 4 and print STDERR " And that's more than we needed to close complex.\n";
0.000000,0,0.000000,pos($para) = pos($para) - length($4) + $stack[-1];
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# We saw " >>>>" but needed " >>>>>>".  So this is all just stuff!
0.000000,0,0.000000,DEBUG > 4 and print STDERR " But it's really just stuff, because we needed more.\n";
0.000000,0,0.000000,push @{ $lineage[-1] }, $3, $4;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,#print STDERR "\nHOOBOY ", scalar(@{$lineage[-1]}), "!!!\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if ($3 ne " " && $self->{'_output_is_for_JustPod'}) {
0.000000,0,0.000000,if ($3 ne "") {
0.000000,0,0.000000,$lineage[-1][1]{'~rspacer'} = $3;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($lineage[-1][1]{'~lspacer'} eq "  ") {
0.000000,0,0.000000,
0.000000,0,0.000000,# Here we had something like C<<  >> which was a false positive
0.000000,0,0.000000,delete $lineage[-1][1]{'~lspacer'};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$lineage[-1][1]{'~rspacer'}
0.000000,0,0.000000,= substr($lineage[-1][1]{'~lspacer'}, -1, 1);
0.000000,0,0.000000,chop $lineage[-1][1]{'~lspacer'};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @{ $lineage[-1] }, '' if 2 == @{ $lineage[-1] };
0.000000,0,0.000000,# Keep the element from being childless
0.000000,0,0.000000,
0.000000,0,0.000000,if ($inL == @stack) {
0.000000,0,0.000000,$lineage[-1][1]{'raw'} = $raw;
0.000000,0,0.000000,$inL = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,pop @stack;
0.000000,0,0.000000,pop @lineage;
0.000000,0,0.000000,
0.000000,0,0.000000,$raw .= $3.$4 if $inL;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif(defined $5) {
0.000000,0,0.000000,DEBUG > 3 and print STDERR "Found apparent simple end-text code \"$5\"\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if(@stack and ! $stack[-1]) {
0.000000,0,0.000000,# We're indeed expecting a simple end-code
0.000000,0,0.000000,DEBUG > 4 and print STDERR " It's indeed an end-code.\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if(length($5) == 2) { # There was a space there: " >"
0.000000,0,0.000000,push @{ $lineage[-1] }, ' ';
0.000000,0,0.000000,} elsif( 2 == @{ $lineage[-1] } ) { # Closing a childless element
0.000000,0,0.000000,push @{ $lineage[-1] }, ''; # keep it from being really childless
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($inL == @stack) {
0.000000,0,0.000000,$lineage[-1][1]{'raw'} = $raw;
0.000000,0,0.000000,$inL = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,pop @stack;
0.000000,0,0.000000,pop @lineage;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 4 and print STDERR " It's just stuff.\n";
0.000000,0,0.000000,push @{ $lineage[-1] }, $5;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$raw .= $5 if $inL;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif(defined $6) {
0.000000,0,0.000000,DEBUG > 3 and print STDERR "Found stuff \"$6\"\n";
0.000000,0,0.000000,push @{ $lineage[-1] }, $6;
0.000000,0,0.000000,$raw .= $6 if $inL;
0.000000,0,0.000000,# XXX does not capture multiplace whitespaces -- 'raw' ends up with
0.000000,0,0.000000,#     at most 1 leading/trailing whitespace, why not all of it?
0.000000,0,0.000000,#     Answer, because we deliberately trimmed it above
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# should never ever ever ever happen
0.000000,0,0.000000,DEBUG and print STDERR "AYYAYAAAAA at line ", __LINE__, "\n";
0.000000,0,0.000000,die "SPORK 512512!";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(@stack) { # Uhoh, some sequences weren't closed.
0.000000,0,0.000000,my $x= "...";
0.000000,0,0.000000,while(@stack) {
0.000000,0,0.000000,push @{ $lineage[-1] }, '' if 2 == @{ $lineage[-1] };
0.000000,0,0.000000,# Hmmmmm!
0.000000,0,0.000000,
0.000000,0,0.000000,my $code         = (pop @lineage)->[0];
0.000000,0,0.000000,my $ender_length =  pop @stack;
0.000000,0,0.000000,if($ender_length) {
0.000000,0,0.000000,--$ender_length;
0.000000,0,0.000000,$x = $code . ("<" x $ender_length) . " $x " . (">" x $ender_length);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$x = $code . "<$x>";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,DEBUG > 1 and print STDERR "Unterminated $x sequence\n";
0.000000,0,0.000000,$self->whine($start_line,
0.000000,0,0.000000,"Unterminated $x sequence",
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $treelet;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub text_content_of_treelet {  # method: $parser->text_content_of_treelet($lol)
0.000000,0,0.000000,return stringify_lol($_[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub stringify_lol {  # function: stringify_lol($lol)
0.000000,0,0.000000,my $string_form = '';
0.000000,0,0.000000,_stringify_lol( $_[0] => \$string_form );
0.000000,0,0.000000,return $string_form;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _stringify_lol {  # the real recursor
0.000000,0,0.000000,my($lol, $to) = @_;
0.000000,0,0.000000,for(my $i = 2; $i < @$lol; ++$i) {
0.000000,0,0.000000,if( ref($lol->[$i] || '') and UNIVERSAL::isa($lol->[$i], 'ARRAY') ) {
0.000000,0,0.000000,_stringify_lol( $lol->[$i], $to);  # recurse!
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$$to .= $lol->[$i];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub _dump_curr_open { # return a string representation of the stack
0.000000,0,0.000000,my $curr_open = $_[0]{'curr_open'};
0.000000,0,0.000000,
0.000000,0,0.000000,return '[empty]' unless @$curr_open;
0.000000,0,0.000000,return join '; ',
0.000000,0,0.000000,map {;
0.000000,0,0.000000,($_->[0] eq '=for')
0.000000,0,0.000000,? ( ($_->[1]{'~really'} || '=over')
0.000000,0,0.000000,. ' ' . $_->[1]{'target'})
0.000000,0,0.000000,: $_->[0]
0.000000,0,0.000000,}
0.000000,0,0.000000,@$curr_open
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################################################
0.000006,1,0.000006,my %pretty_form = (
0.000000,0,0.000000,"\a" => '\a', # ding!
0.000000,0,0.000000,"\b" => '\b', # BS
0.000000,0,0.000000,"\e" => '\e', # ESC
0.000000,0,0.000000,"\f" => '\f', # FF
0.000000,0,0.000000,"\t" => '\t', # tab
0.000000,0,0.000000,"\cm" => '\cm',
0.000000,0,0.000000,"\cj" => '\cj',
0.000000,0,0.000000,"\n" => '\n', # probably overrides one of either \cm or \cj
0.000000,0,0.000000,'"' => '\"',
0.000000,0,0.000000,'\\' => '\\\\',
0.000000,0,0.000000,'$' => '\\$',
0.000000,0,0.000000,'@' => '\\@',
0.000000,0,0.000000,'%' => '\\%',
0.000000,0,0.000000,'#' => '\\#',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub pretty { # adopted from Class::Classless
0.000000,0,0.000000,# Not the most brilliant routine, but passable.
0.000000,0,0.000000,# Don't give it a cyclic data structure!
0.000000,0,0.000000,my @stuff = @_; # copy
0.000000,0,0.000000,my $x;
0.000000,0,0.000000,my $out =
0.000000,0,0.000000,# join ",\n" .
0.000000,0,0.000000,join ", ",
0.000000,0,0.000000,map {;
0.000000,0,0.000000,if(!defined($_)) {
0.000000,0,0.000000,"undef";
0.000000,0,0.000000,} elsif(ref($_) eq 'ARRAY' or ref($_) eq 'Pod::Simple::LinkSection') {
0.000000,0,0.000000,$x = "[ " . pretty(@$_) . " ]" ;
0.000000,0,0.000000,$x;
0.000000,0,0.000000,} elsif(ref($_) eq 'SCALAR') {
0.000000,0,0.000000,$x = "\\" . pretty($$_) ;
0.000000,0,0.000000,$x;
0.000000,0,0.000000,} elsif(ref($_) eq 'HASH') {
0.000000,0,0.000000,my $hr = $_;
0.000000,0,0.000000,$x = "{" . join(", ",
0.000000,0,0.000000,map(pretty($_) . '=>' . pretty($hr->{$_}),
0.000000,0,0.000000,sort keys %$hr ) ) . "}" ;
0.000000,0,0.000000,$x;
0.000000,0,0.000000,} elsif(!length($_)) { q{''} # empty string
0.000000,0,0.000000,} elsif(
0.000000,0,0.000000,$_ eq '0' # very common case
0.000000,0,0.000000,or(
0.000000,0,0.000000,m/^-?(?:[123456789]\d*|0)(?:\.\d+)?$/s
0.000000,0,0.000000,and $_ ne '-0' # the strange case that RE lets thru
0.000000,0,0.000000,)
0.000000,0,0.000000,) { $_;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# Yes, explicitly name every character desired. There are shorcuts one
0.000000,0,0.000000,# could make, but I (Karl Williamson) was afraid that some Perl
0.000000,0,0.000000,# releases would have bugs in some of them. For example [A-Z] works
0.000000,0,0.000000,# even on EBCDIC platforms to match exactly the 26 uppercase English
0.000000,0,0.000000,# letters, but I don't know if it has always worked without bugs. It
0.000000,0,0.000000,# seemed safest just to list the characters.
0.000000,0,0.000000,# s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
0.000000,0,0.000000,s<([^ !"#'()*+,\-./0123456789:;\<=\>?ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\]^_`abcdefghijklmnopqrstuvwxyz{|}~])>
0.000000,0,0.000000,<$pretty_form{$1} || '\\x{'.sprintf("%x", ord($1)).'}'>eg;
0.000000,0,0.000000,#<$pretty_form{$1} || '\\x'.(unpack("H2",$1))>eg;
0.000000,0,0.000000,qq{"$_"};
0.000000,0,0.000000,}
0.000000,0,0.000000,} @stuff;
0.000000,0,0.000000,# $out =~ s/\n */ /g if length($out) < 75;
0.000000,0,0.000000,return $out;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,# A rather unsubtle method of blowing away all the state information
0.000000,0,0.000000,# from a parser object so it can be reused. Provided as a utility for
0.000000,0,0.000000,# backward compatibility in Pod::Man, etc. but not recommended for
0.000000,0,0.000000,# general use.
0.000000,0,0.000000,
0.000000,0,0.000000,sub reinit {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,foreach (qw(source_dead source_filename doc_has_started
0.000000,0,0.000000,start_of_pod_block content_seen last_was_blank paras curr_open
0.000000,0,0.000000,line_count pod_para_count in_pod ~tried_gen_errata all_errata errata errors_seen
0.000000,0,0.000000,Title)) {
0.000000,0,0.000000,
0.000000,0,0.000000,delete $self->{$_};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000015,1,0.000015,1;
0.000000,0,0.000000,
