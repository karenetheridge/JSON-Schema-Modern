# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Params::Util::PP;
0.000000,0,0.000000,
0.000033,2,0.000017,use strict;
0.000044,2,0.000022,use warnings;
0.000000,0,0.000000,
0.000003,1,0.000003,our $VERSION = '1.102';
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,Params::Util::PP - PurePerl Params::Util routines
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000028,2,0.000014,use Scalar::Util ();
0.001757,2,0.000879,use overload     ();
0.000000,0,0.000000,
0.000065,1,0.000065,Scalar::Util->can("looks_like_number") and Scalar::Util->import("looks_like_number");
0.000000,0,0.000000,# Use a private pure-perl copy of looks_like_number if the version of
0.000000,0,0.000000,# Scalar::Util is old (for whatever reason).
0.000000,0,0.000000,Params::Util::PP->can("looks_like_number") or *looks_like_number = sub {
0.000000,0,0.000000,local $_ = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# checks from perlfaq4
0.000000,0,0.000000,return 0 if !defined($_);
0.000000,0,0.000000,if (ref($_))
0.000000,0,0.000000,{
0.000000,0,0.000000,return overload::Overloaded($_) ? defined(0 + $_) : 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1 if (/^[+-]?[0-9]+$/);    # is a +/- integer
0.000000,0,0.000000,## no critic (RegularExpressions::ProhibitComplexRegexes)
0.000000,0,0.000000,return 1 if (/^(?:[+-]?)(?=[0-9]|\.[0-9])[0-9]*(?:\.[0-9]*)?(?:[Ee](?:[+-]?[0-9]+))?$/);     # a C float
0.000000,0,0.000000,return 1 if ($] >= 5.008 and /^(?:Inf(?:inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
0.000000,0,0.000000,
0.000000,0,0.000000,0;
0.000012,1,0.000012,};
0.000000,0,0.000000,
0.000000,0,0.000000,## no critic (Subroutines::ProhibitSubroutinePrototypes, Subroutines::RequireArgUnpacking)
0.000000,0,0.000000,## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
0.000000,0,0.000000,
0.000000,0,0.000000,sub _XScompiled { return 0; }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _STRING ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $arg = $_[0];
0.000000,0,0.000000,return (defined $arg and not ref $arg and length($arg)) ? $arg : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _IDENTIFIER ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $arg = $_[0];
0.000000,0,0.000000,return (defined $arg and not ref $arg and $arg =~ m/^[^\W\d]\w*\z/s) ? $arg : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _CLASS ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $arg = $_[0];
0.000000,0,0.000000,return (defined $arg and not ref $arg and $arg =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $arg : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _CLASSISA ($$)
0.000000,0,0.000000,{
0.000000,0,0.000000,return (defined $_[0] and not ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _CLASSDOES ($$)
0.000000,0,0.000000,{
0.000000,0,0.000000,return (defined $_[0] and not ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _SUBCLASS ($$)
0.000000,0,0.000000,{
0.000000,0,0.000000,return (defined $_[0] and not ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1]))
0.000000,0,0.000000,? $_[0]
0.000000,0,0.000000,: undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _NUMBER ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $arg = $_[0];
0.000000,0,0.000000,return (defined $arg and not ref $arg and looks_like_number($arg)) ? $arg : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _POSINT ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $arg = $_[0];
0.000000,0,0.000000,return (defined $arg and not ref $arg and $arg =~ m/^[1-9]\d*$/) ? $arg : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _NONNEGINT ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $arg = $_[0];
0.000000,0,0.000000,return (defined $arg and not ref $arg and $arg =~ m/^(?:0|[1-9]\d*)$/) ? $arg : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _SCALAR ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,return (ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _SCALAR0 ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,return ref $_[0] eq 'SCALAR' ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ARRAY ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,return (ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ARRAY0 ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,return ref $_[0] eq 'ARRAY' ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ARRAYLIKE
0.000000,0,0.000000,{
0.000000,0,0.000000,return (
0.000000,0,0.000000,defined $_[0] and ref $_[0] and ((Scalar::Util::reftype($_[0]) eq 'ARRAY')
0.000000,0,0.000000,or overload::Method($_[0], '@{}'))
0.000000,0,0.000000,) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _HASH ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,return (ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _HASH0 ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,return ref $_[0] eq 'HASH' ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _HASHLIKE
0.000000,0,0.000000,{
0.000000,0,0.000000,return (
0.000000,0,0.000000,defined $_[0] and ref $_[0] and ((Scalar::Util::reftype($_[0]) eq 'HASH')
0.000000,0,0.000000,or overload::Method($_[0], '%{}'))
0.000000,0,0.000000,) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _CODE ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,return ref $_[0] eq 'CODE' ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _CODELIKE($)
0.000000,0,0.000000,{
0.000000,0,0.000000,return (
0.000000,0,0.000000,(Scalar::Util::reftype($_[0]) || '') eq 'CODE'
0.000000,0,0.000000,or Scalar::Util::blessed($_[0]) and overload::Method($_[0], '&{}')
0.000000,0,0.000000,) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _INVOCANT($)
0.000000,0,0.000000,{
0.000000,0,0.000000,return (
0.000000,0,0.000000,defined $_[0]
0.000000,0,0.000000,and (
0.000000,0,0.000000,defined Scalar::Util::blessed($_[0])
0.000000,0,0.000000,or
0.000000,0,0.000000,_CLASS($_[0])
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,)
0.000000,0,0.000000,) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _INSTANCE ($$)
0.000000,0,0.000000,{
0.000000,0,0.000000,return (Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _INSTANCEDOES ($$)
0.000000,0,0.000000,{
0.000000,0,0.000000,return (Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _REGEX ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,return (defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _SET ($$)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $set_param = shift;
0.000000,0,0.000000,_ARRAY($set_param) or return undef;
0.000000,0,0.000000,foreach my $item (@$set_param)
0.000000,0,0.000000,{
0.000000,0,0.000000,_INSTANCE($item, $_[0]) or return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $set_param;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _SET0 ($$)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $set_param = shift;
0.000000,0,0.000000,_ARRAY0($set_param) or return undef;
0.000000,0,0.000000,foreach my $item (@$set_param)
0.000000,0,0.000000,{
0.000000,0,0.000000,_INSTANCE($item, $_[0]) or return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $set_param;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# We're doing this longhand for now. Once everything is perfect,
0.000000,0,0.000000,# we'll compress this into something that compiles more efficiently.
0.000000,0,0.000000,# Further, testing file handles is not something that is generally
0.000000,0,0.000000,# done millions of times, so doing it slowly is not a big speed hit.
0.000000,0,0.000000,sub _HANDLE
0.000000,0,0.000000,{
0.000000,0,0.000000,my $it = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# It has to be defined, of course
0.000000,0,0.000000,unless (defined $it)
0.000000,0,0.000000,{
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Normal globs are considered to be file handles
0.000000,0,0.000000,if (ref $it eq 'GLOB')
0.000000,0,0.000000,{
0.000000,0,0.000000,return $it;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Check for a normal tied filehandle
0.000000,0,0.000000,# Side Note: 5.5.4's tied() and can() doesn't like getting undef
0.000000,0,0.000000,if (tied($it) and tied($it)->can('TIEHANDLE'))
0.000000,0,0.000000,{
0.000000,0,0.000000,return $it;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# There are no other non-object handles that we support
0.000000,0,0.000000,unless (Scalar::Util::blessed($it))
0.000000,0,0.000000,{
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Check for a common base classes for conventional IO::Handle object
0.000000,0,0.000000,if ($it->isa('IO::Handle'))
0.000000,0,0.000000,{
0.000000,0,0.000000,return $it;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Check for tied file handles using Tie::Handle
0.000000,0,0.000000,if ($it->isa('Tie::Handle'))
0.000000,0,0.000000,{
0.000000,0,0.000000,return $it;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# IO::Scalar is not a proper seekable, but it is valid is a
0.000000,0,0.000000,# regular file handle
0.000000,0,0.000000,if ($it->isa('IO::Scalar'))
0.000000,0,0.000000,{
0.000000,0,0.000000,return $it;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Yet another special case for IO::String, which refuses (for now
0.000000,0,0.000000,# anyway) to become a subclass of IO::Handle.
0.000000,0,0.000000,if ($it->isa('IO::String'))
0.000000,0,0.000000,{
0.000000,0,0.000000,return $it;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This is not any sort of object we know about
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _DRIVER ($$)
0.000000,0,0.000000,{
0.000000,0,0.000000,## no critic (BuiltinFunctions::ProhibitStringyEval)
0.000000,0,0.000000,return (defined _CLASS($_[0]) and eval "require $_[0];" and not $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000009,1,0.000009,1;
