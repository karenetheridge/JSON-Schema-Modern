# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000029,2,0.000015,use strict;
0.000042,2,0.000021,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Result;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Contains the result of a JSON Schema evaluation
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.556';
0.000000,0,0.000000,
0.000026,2,0.000013,use 5.020;
0.000020,2,0.000010,use Moo;
0.000029,3,0.000010,use strictures 2;
0.000030,2,0.000015,use experimental qw(signatures postderef);
0.000023,2,0.000012,use if "$]" >= 5.022, experimental => 're_strict';
0.000023,2,0.000012,no if "$]" >= 5.031009, feature => 'indirect';
0.000017,2,0.000008,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000014,2,0.000007,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000022,2,0.000011,use MooX::TypeTiny;
0.000067,2,0.000034,use Types::Standard qw(ArrayRef InstanceOf Enum Bool);
0.000057,2,0.000029,use MooX::HandlesVia;
0.000763,2,0.000382,use JSON::Schema::Modern::Annotation;
0.000036,2,0.000018,use JSON::Schema::Modern::Error;
0.000028,2,0.000014,use JSON::PP ();
0.000124,3,0.000041,use List::Util 1.50 qw(any uniq);
0.000037,2,0.000018,use Scalar::Util 'refaddr';
0.000035,2,0.000017,use Safe::Isa;
0.000158,2,0.000079,use namespace::clean;
0.000000,0,0.000000,
0.000000,0,0.000000,use overload
0.000015,1,0.000015,'bool'  => sub { $_[0]->valid },
0.000000,0,0.000000,'&'     => \&combine,
0.000000,0,0.000000,'0+'    => sub { Scalar::Util::refaddr($_[0]) },
0.000000,0,0.000000,'""' => sub { $_[0]->stringify },
0.000267,2,0.000134,fallback => 1;
0.000000,0,0.000000,
0.000000,0,0.000000,has valid => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => InstanceOf['JSON::PP::Boolean'],
0.000005,1,0.000005,coerce => sub { $_[0] ? JSON::PP::true : JSON::PP::false },
0.000009,1,0.000009,);
0.000000,0,0.000000,sub result { shift->valid } # backcompat only
0.000000,0,0.000000,
0.000000,0,0.000000,has exception => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => InstanceOf['JSON::PP::Boolean'],
0.000000,0,0.000000,coerce => sub { $_[0] ? JSON::PP::true : JSON::PP::false },
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,default => sub { any { $_->exception } $_[0]->errors },
0.000015,1,0.000015,);
0.000000,0,0.000000,
0.000000,0,0.000000,has $_.'s' => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => ArrayRef[InstanceOf['JSON::Schema::Modern::'.ucfirst]],
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,default => sub { [] },
0.000000,0,0.000000,handles_via => 'Array',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,$_.'s' => 'elements',
0.000000,0,0.000000,$_.'_count' => 'count',
0.000000,0,0.000000,},
0.000040,1,0.000040,) foreach qw(error annotation);
0.000000,0,0.000000,
0.000000,0,0.000000,# strict_basic can only be used with draft2019-09.
0.000843,2,0.000421,use constant OUTPUT_FORMATS => [qw(flag basic strict_basic detailed verbose terse data_only)];
0.000000,0,0.000000,
0.000004,1,0.000004,has output_format => (
0.000000,0,0.000000,is => 'rw',
0.000000,0,0.000000,isa => Enum(OUTPUT_FORMATS),
0.000000,0,0.000000,default => 'basic',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000005,1,0.000005,has formatted_annotations => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Bool,
0.000000,0,0.000000,default => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000007,2,0.000003,sub BUILD ($self, $) {
0.000012,1,0.000012,warn 'result is false but there are no errors' if not $self->valid and not $self->error_count;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub format ($self, $style, $formatted_annotations = undef) {
0.000000,0,0.000000,$formatted_annotations //= $self->formatted_annotations;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($style eq 'flag') {
0.000000,0,0.000000,return +{ valid => $self->valid };
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($style eq 'basic') {
0.000000,0,0.000000,return +{
0.000000,0,0.000000,valid => $self->valid,
0.000000,0,0.000000,$self->valid
0.000000,0,0.000000,? ($formatted_annotations && $self->annotation_count ? (annotations => [ map $_->TO_JSON, $self->annotations ]) : ())
0.000000,0,0.000000,: (errors => [ map $_->TO_JSON, $self->errors ]),
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,# note: strict_basic will NOT be supported after draft 2019-09!
0.000000,0,0.000000,elsif ($style eq 'strict_basic') {
0.000000,0,0.000000,return +{
0.000000,0,0.000000,valid => $self->valid,
0.000000,0,0.000000,$self->valid
0.000000,0,0.000000,? ($formatted_annotations && $self->annotation_count ? (annotations => [ map _map_uris($_->TO_JSON), $self->annotations ]) : ())
0.000000,0,0.000000,: (errors => [ map _map_uris($_->TO_JSON), $self->errors ]),
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($style eq 'terse') {
0.000000,0,0.000000,my (%instance_locations, %keyword_locations);
0.000000,0,0.000000,
0.000000,0,0.000000,my @errors = grep {
0.000000,0,0.000000,my ($keyword, $error) = ($_->keyword, $_->error);
0.000000,0,0.000000,
0.000000,0,0.000000,my $keep = 0+!!(
0.000000,0,0.000000,not $keyword
0.000000,0,0.000000,or (
0.000000,0,0.000000,not grep $keyword eq $_, qw(allOf anyOf if then else dependentSchemas contains propertyNames)
0.000000,0,0.000000,and ($keyword ne 'oneOf' or $error ne 'no subschemas are valid')
0.000000,0,0.000000,and ($keyword ne 'prefixItems' or $error eq 'item not permitted')
0.000000,0,0.000000,and ($keyword ne 'items' or $error eq 'item not permitted' or $error eq 'additional item not permitted')
0.000000,0,0.000000,and ($keyword ne 'additionalItems' or $error eq 'additional item not permitted')
0.000000,0,0.000000,and (not grep $keyword eq $_, qw(properties patternProperties)
0.000000,0,0.000000,or $error eq 'property not permitted')
0.000000,0,0.000000,and ($keyword ne 'additionalProperties' or $error eq 'additional property not permitted'))
0.000000,0,0.000000,and ($keyword ne 'dependentRequired' or $error ne 'not all dependencies are satisfied')
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,++$instance_locations{$_->instance_location} if $keep;
0.000000,0,0.000000,++$keyword_locations{$_->keyword_location} if $keep;
0.000000,0,0.000000,
0.000000,0,0.000000,$keep;
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->errors;
0.000000,0,0.000000,
0.000000,0,0.000000,die 'uh oh, have no errors left to report' if not $self->valid and not @errors;
0.000000,0,0.000000,
0.000000,0,0.000000,return +{
0.000000,0,0.000000,valid => $self->valid,
0.000000,0,0.000000,$self->valid
0.000000,0,0.000000,? ($formatted_annotations && $self->annotation_count ? (annotations => [ map $_->TO_JSON, $self->annotations ]) : ())
0.000000,0,0.000000,: (errors => [ map $_->TO_JSON, @errors ]),
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($style eq 'data_only') {
0.000000,0,0.000000,return 'valid' if not $self->error_count;
0.000000,0,0.000000,# Note: this output is going to be confusing when coming from a schema with a 'oneOf', 'not',
0.000000,0,0.000000,# etc. Perhaps generating the strings with indentation levels, as derived from a nested format,
0.000000,0,0.000000,# might be more readable.
0.000000,0,0.000000,return join("\n", uniq(map $_->stringify, $self->errors));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,die 'unsupported output format';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub count { $_[0]->valid ? $_[0]->annotation_count : $_[0]->error_count }
0.000000,0,0.000000,
0.000000,0,0.000000,sub combine ($self, $other, $swap) {
0.000000,0,0.000000,die 'wrong type for & operation' if not $other->$_isa(__PACKAGE__);
0.000000,0,0.000000,
0.000000,0,0.000000,return $self if refaddr($other) == refaddr($self);
0.000000,0,0.000000,
0.000000,0,0.000000,return ref($self)->new(
0.000000,0,0.000000,valid => $self->valid && $other->valid,
0.000000,0,0.000000,annotations => [
0.000000,0,0.000000,$self->annotations,
0.000000,0,0.000000,$other->annotations,
0.000000,0,0.000000,],
0.000000,0,0.000000,errors => [
0.000000,0,0.000000,$self->errors,
0.000000,0,0.000000,$other->errors,
0.000000,0,0.000000,],
0.000000,0,0.000000,output_format => $self->output_format,
0.000000,0,0.000000,formatted_annotations => $self->formatted_annotations || $other->formatted_annotations,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub stringify ($self) {
0.000000,0,0.000000,return $self->format('data_only');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub TO_JSON ($self) {
0.000000,0,0.000000,die 'cannot produce JSON output for data_only format' if $self->output_format eq 'data_only';
0.000000,0,0.000000,$self->format($self->output_format);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub dump ($self) {
0.000000,0,0.000000,my $encoder = JSON::MaybeXS->new(utf8 => 0, convert_blessed => 1, canonical => 1, pretty => 1);
0.000000,0,0.000000,$encoder->indent_length(2) if $encoder->can('indent_length');
0.000000,0,0.000000,$encoder->encode($self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# turns the JSON pointers in instance_location, keyword_location  into a URI fragments,
0.000000,0,0.000000,# for strict draft-201909 adherence
0.000000,0,0.000000,sub _map_uris ($data) {
0.000000,0,0.000000,return +{
0.000000,0,0.000000,%$data,
0.000000,0,0.000000,map +($_ => Mojo::URL->new->fragment($data->{$_})->to_string),
0.000000,0,0.000000,qw(instanceLocation keywordLocation),
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000023,1,0.000023,1;
0.000000,0,0.000000,
0.000049,1,0.000049,__END__
