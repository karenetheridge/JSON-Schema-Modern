# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000038,2,0.000019,use strict;
0.000062,2,0.000031,use warnings;
0.000000,0,0.000000,package YAML::PP::Representer;
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000046,2,0.000023,use Scalar::Util qw/ reftype blessed refaddr /;
0.000000,0,0.000000,
0.000000,1,0.000000,use YAML::PP::Common qw/
0.000000,0,0.000000,YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,YAML_DOUBLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,YAML_ANY_SCALAR_STYLE
0.000000,0,0.000000,YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE
0.000000,0,0.000000,YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE
0.000000,0,0.000000,YAML_BLOCK_MAPPING_STYLE YAML_BLOCK_SEQUENCE_STYLE
0.000000,0,0.000000,PRESERVE_ORDER PRESERVE_SCALAR_STYLE PRESERVE_FLOW_STYLE PRESERVE_ALIAS
0.000029,1,0.000029,/;
0.001408,2,0.000704,use B;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000002,1,0.000002,my ($class, %args) = @_;
0.000000,1,0.000000,my $preserve = delete $args{preserve} || 0;
0.000001,1,0.000001,if ($preserve == 1) {
0.000000,0,0.000000,$preserve = PRESERVE_ORDER | PRESERVE_SCALAR_STYLE | PRESERVE_FLOW_STYLE | PRESERVE_ALIAS;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $self = bless {
0.000000,0,0.000000,schema => delete $args{schema},
0.000002,1,0.000002,preserve => $preserve,
0.000000,0,0.000000,}, $class;
0.000001,1,0.000001,if (keys %args) {
0.000000,0,0.000000,die "Unexpected arguments: " . join ', ', sort keys %args;
0.000000,0,0.000000,}
0.000003,1,0.000003,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my $clone = {
0.000000,0,0.000000,schema => $self->schema,
0.000000,0,0.000000,preserve => $self->{preserve},
0.000000,0,0.000000,};
0.000000,0,0.000000,return bless $clone, ref $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub schema { return $_[0]->{schema} }
0.000000,0,0.000000,sub preserve_order { return $_[0]->{preserve} & PRESERVE_ORDER }
0.000000,0,0.000000,sub preserve_scalar_style { return $_[0]->{preserve} & PRESERVE_SCALAR_STYLE }
0.000000,0,0.000000,sub preserve_flow_style { return $_[0]->{preserve} & PRESERVE_FLOW_STYLE }
0.000000,0,0.000000,sub preserve_alias { return $_[0]->{preserve} & PRESERVE_ALIAS }
0.000000,0,0.000000,
0.000000,0,0.000000,sub represent_node {
0.000000,0,0.000000,my ($self, $node) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $preserve_alias = $self->preserve_alias;
0.000000,0,0.000000,my $preserve_style = $self->preserve_scalar_style;
0.000000,0,0.000000,if ($preserve_style or $preserve_alias) {
0.000000,0,0.000000,if (ref $node->{value} eq 'YAML::PP::Preserve::Scalar') {
0.000000,0,0.000000,my $value = $node->{value}->value;
0.000000,0,0.000000,if ($preserve_style) {
0.000000,0,0.000000,$node->{style} = $node->{value}->style;
0.000000,0,0.000000,}
0.000000,0,0.000000,#            $node->{tag} = $node->{value}->tag;
0.000000,0,0.000000,$node->{value} = $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$node->{reftype} = reftype($node->{value});
0.000000,0,0.000000,if (not $node->{reftype} and reftype(\$node->{value}) eq 'GLOB') {
0.000000,0,0.000000,$node->{reftype} = 'GLOB';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($node->{reftype}) {
0.000000,0,0.000000,$self->_represent_noderef($node);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->_represent_node_nonref($node);
0.000000,0,0.000000,}
0.000000,0,0.000000,$node->{reftype} = (reftype $node->{data}) || '';
0.000000,0,0.000000,
0.000000,0,0.000000,if ($node->{reftype} eq 'HASH' and my $tied = tied(%{ $node->{data} })) {
0.000000,0,0.000000,my $representers = $self->schema->representers;
0.000000,0,0.000000,$tied = ref $tied;
0.000000,0,0.000000,if (my $def = $representers->{tied_equals}->{ $tied }) {
0.000000,0,0.000000,my $code = $def->{code};
0.000000,0,0.000000,my $done = $code->($self, $node);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($node->{reftype} eq 'HASH') {
0.000000,0,0.000000,unless (defined $node->{items}) {
0.000000,0,0.000000,# by default we sort hash keys
0.000000,0,0.000000,my @keys;
0.000000,0,0.000000,if ($self->preserve_order) {
0.000000,0,0.000000,@keys = keys %{ $node->{data} };
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,@keys = sort keys %{ $node->{data} };
0.000000,0,0.000000,}
0.000000,0,0.000000,for my $key (@keys) {
0.000000,0,0.000000,push @{ $node->{items} }, $key, $node->{data}->{ $key };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my %args;
0.000000,0,0.000000,if ($self->preserve_flow_style and reftype $node->{value} eq 'HASH') {
0.000000,0,0.000000,if (my $tied = tied %{ $node->{value} } ) {
0.000000,0,0.000000,$args{style} = $tied->{style};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return [ mapping => $node, %args ];
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($node->{reftype} eq 'ARRAY') {
0.000000,0,0.000000,unless (defined $node->{items}) {
0.000000,0,0.000000,@{ $node->{items} } = @{ $node->{data} };
0.000000,0,0.000000,}
0.000000,0,0.000000,my %args;
0.000000,0,0.000000,if ($self->preserve_flow_style and reftype $node->{value} eq 'ARRAY') {
0.000000,0,0.000000,if (my $tied = tied @{ $node->{value} } ) {
0.000000,0,0.000000,$args{style} = $tied->{style};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return [ sequence => $node, %args ];
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($node->{reftype}) {
0.000000,0,0.000000,die "Cannot handle reftype '$node->{reftype}' (you might want to enable YAML::PP::Schema::Perl)";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,unless (defined $node->{items}) {
0.000000,0,0.000000,$node->{items} = [$node->{data}];
0.000000,0,0.000000,}
0.000000,0,0.000000,return [ scalar => $node ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my $bool_code = <<'EOM';
0.000000,0,0.000000,sub {
0.000000,0,0.000000,my ($x) = @_;
0.000000,0,0.000000,use experimental qw/ builtin /;
0.000000,0,0.000000,builtin::is_bool($x);
0.000000,0,0.000000,}
0.000000,0,0.000000,EOM
0.000000,1,0.000000,my $is_bool;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _represent_node_nonref {
0.000000,0,0.000000,my ($self, $node) = @_;
0.000000,0,0.000000,my $representers = $self->schema->representers;
0.000000,0,0.000000,
0.000000,0,0.000000,if (not defined $node->{value}) {
0.000000,0,0.000000,if (my $undef = $representers->{undef}) {
0.000000,0,0.000000,return 1 if $undef->($self, $node);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$node->{style} = YAML_SINGLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,$node->{data} = '';
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($] >= 5.036000 and my $rep = $representers->{bool}) {
0.000000,0,0.000000,$is_bool ||= eval $bool_code;
0.000000,0,0.000000,if ($is_bool->($node->{value})) {
0.000000,0,0.000000,return $rep->{code}->($self, $node);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,for my $rep (@{ $representers->{flags} }) {
0.000000,0,0.000000,my $check_flags = $rep->{flags};
0.000000,0,0.000000,my $flags = B::svref_2object(\$node->{value})->FLAGS;
0.000000,0,0.000000,if ($flags & $check_flags) {
0.000000,0,0.000000,return 1 if $rep->{code}->($self, $node);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,if (my $rep = $representers->{equals}->{ $node->{value} }) {
0.000000,0,0.000000,return 1 if $rep->{code}->($self, $node);
0.000000,0,0.000000,}
0.000000,0,0.000000,for my $rep (@{ $representers->{regex} }) {
0.000000,0,0.000000,if ($node->{value} =~ $rep->{regex}) {
0.000000,0,0.000000,return 1 if $rep->{code}->($self, $node);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,unless (defined $node->{data}) {
0.000000,0,0.000000,$node->{data} = $node->{value};
0.000000,0,0.000000,}
0.000000,0,0.000000,unless (defined $node->{style}) {
0.000000,0,0.000000,$node->{style} = YAML_ANY_SCALAR_STYLE;
0.000000,0,0.000000,$node->{style} = "";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _represent_noderef {
0.000000,0,0.000000,my ($self, $node) = @_;
0.000000,0,0.000000,my $representers = $self->schema->representers;
0.000000,0,0.000000,
0.000000,0,0.000000,if (my $classname = blessed($node->{value})) {
0.000000,0,0.000000,if (my $def = $representers->{class_equals}->{ $classname }) {
0.000000,0,0.000000,my $code = $def->{code};
0.000000,0,0.000000,return 1 if $code->($self, $node);
0.000000,0,0.000000,}
0.000000,0,0.000000,for my $matches (@{ $representers->{class_matches} }) {
0.000000,0,0.000000,my ($re, $code) = @$matches;
0.000000,0,0.000000,if (ref $re and $classname =~ $re or $re) {
0.000000,0,0.000000,return 1 if $code->($self, $node);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,for my $isa (@{ $representers->{class_isa} }) {
0.000000,0,0.000000,my ($class_name, $code) = @$isa;
0.000000,0,0.000000,if ($node->{ value }->isa($class_name)) {
0.000000,0,0.000000,return 1 if $code->($self, $node);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($node->{reftype} eq 'SCALAR' and my $scalarref = $representers->{scalarref}) {
0.000000,0,0.000000,my $code = $scalarref->{code};
0.000000,0,0.000000,return 1 if $code->($self, $node);
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($node->{reftype} eq 'REF' and my $refref = $representers->{refref}) {
0.000000,0,0.000000,my $code = $refref->{code};
0.000000,0,0.000000,return 1 if $code->($self, $node);
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($node->{reftype} eq 'CODE' and my $coderef = $representers->{coderef}) {
0.000000,0,0.000000,my $code = $coderef->{code};
0.000000,0,0.000000,return 1 if $code->($self, $node);
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($node->{reftype} eq 'GLOB' and my $glob = $representers->{glob}) {
0.000000,0,0.000000,my $code = $glob->{code};
0.000000,0,0.000000,return 1 if $code->($self, $node);
0.000000,0,0.000000,}
0.000000,0,0.000000,$node->{data} = $node->{value};
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
