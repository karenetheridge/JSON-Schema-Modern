# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000033,2,0.000017,use strict;
0.000039,2,0.000019,use warnings;
0.000000,0,0.000000,package YAML::PP::Lexer;
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000027,2,0.000013,use constant TRACE => $ENV{YAML_PP_TRACE} ? 1 : 0;
0.000017,2,0.000008,use constant DEBUG => ($ENV{YAML_PP_DEBUG} || $ENV{YAML_PP_TRACE}) ? 1 : 0;
0.000000,0,0.000000,
0.000546,2,0.000273,use YAML::PP::Grammar qw/ $GRAMMAR /;
0.004843,2,0.002422,use Carp qw/ croak /;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000001,1,0.000001,my ($class, %args) = @_;
0.000000,0,0.000000,my $self = bless {
0.000000,0,0.000000,reader => $args{reader},
0.000002,1,0.000002,}, $class;
0.000003,1,0.000003,$self->init;
0.000003,1,0.000003,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub init {
0.000003,3,0.000001,my ($self) = @_;
0.000005,3,0.000002,$self->{next_tokens} = [];
0.000002,3,0.000001,$self->{next_line} = undef;
0.000001,3,0.000000,$self->{line} = 0;
0.000002,3,0.000001,$self->{offset} = 0;
0.000009,3,0.000003,$self->{flowcontext} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.062872,39438,0.000002,sub next_line { return $_[0]->{next_line} }
0.041510,26911,0.000002,sub set_next_line { $_[0]->{next_line} = $_[1] }
0.019302,13456,0.000001,sub reader { return $_[0]->{reader} }
0.000009,1,0.000009,sub set_reader { $_[0]->{reader} = $_[1] }
0.131482,77194,0.000002,sub next_tokens { return $_[0]->{next_tokens} }
0.231051,160784,0.000001,sub line { return $_[0]->{line} }
0.000000,0,0.000000,sub set_line { $_[0]->{line} = $_[1] }
0.142271,63742,0.000002,sub offset { return $_[0]->{offset} }
0.104615,63742,0.000002,sub set_offset { $_[0]->{offset} = $_[1] }
0.021798,13455,0.000002,sub inc_line { return $_[0]->{line}++ }
0.054081,37475,0.000001,sub context { return $_[0]->{context} }
0.000302,176,0.000002,sub set_context { $_[0]->{context} = $_[1] }
0.109348,76215,0.000001,sub flowcontext { return $_[0]->{flowcontext} }
0.001927,1102,0.000002,sub set_flowcontext { $_[0]->{flowcontext} = $_[1] }
0.021910,14025,0.000002,sub block { return $_[0]->{block} }
0.024632,13455,0.000002,sub set_block { $_[0]->{block} = $_[1] }
0.000000,0,0.000000,
0.000000,1,0.000000,my $RE_WS = '[\t ]';
0.000000,1,0.000000,my $RE_LB = '[\r\n]';
0.000033,1,0.000033,my $RE_DOC_END = qr/\A(\.\.\.)(?=$RE_WS|$)/m;
0.000010,1,0.000010,my $RE_DOC_START = qr/\A(---)(?=$RE_WS|$)/m;
0.000017,1,0.000017,my $RE_EOL = qr/\A($RE_WS+#.*|$RE_WS+)\z/;
0.000000,0,0.000000,#my $RE_COMMENT_EOL = qr/\A(#.*)?(?:$RE_LB|\z)/;
0.000000,0,0.000000,
0.000000,0,0.000000,#ns-word-char    ::= ns-dec-digit | ns-ascii-letter | “-”
0.000000,1,0.000000,my $RE_NS_WORD_CHAR = '[0-9A-Za-z-]';
0.000001,1,0.000001,my $RE_URI_CHAR = '(?:' . '%[0-9a-fA-F]{2}' .'|'.  q{[0-9A-Za-z#;/?:@&=+$,_.!*'\(\)\[\]-]} . ')';
0.000000,1,0.000000,my $RE_NS_TAG_CHAR = '(?:' . '%[0-9a-fA-F]{2}' .'|'.  q{[0-9A-Za-z#;/?:@&=+$_.~*'\(\)-]} . ')';
0.000000,0,0.000000,
0.000000,0,0.000000,#  [#x21-#x7E]          /* 8 bit */
0.000000,0,0.000000,# | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD] /* 16 bit */
0.000000,0,0.000000,# | [#x10000-#x10FFFF]                     /* 32 bit */
0.000000,0,0.000000,
0.000000,0,0.000000,#nb-char ::= c-printable - b-char - c-byte-order-mark
0.000000,0,0.000000,#my $RE_NB_CHAR = '[\x21-\x7E]';
0.000000,1,0.000000,my $RE_ANCHOR_CAR = '[\x21-\x2B\x2D-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
0.000000,0,0.000000,
0.000000,1,0.000000,my $RE_PLAIN_START = '[\x21\x22\x24-\x39\x3B-\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
0.000000,1,0.000000,my $RE_PLAIN_END = '[\x21-\x39\x3B-\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';
0.000000,1,0.000000,my $RE_PLAIN_FIRST = '[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
0.000000,0,0.000000,
0.000000,1,0.000000,my $RE_PLAIN_START_FLOW = '[\x21\x22\x24-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
0.000000,1,0.000000,my $RE_PLAIN_END_FLOW = '[\x21-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';
0.000000,1,0.000000,my $RE_PLAIN_FIRST_FLOW = '[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
0.000000,0,0.000000,# c-indicators
0.000000,0,0.000000,#! 21
0.000000,0,0.000000,#" 22
0.000000,0,0.000000,## 23
0.000000,0,0.000000,#% 25
0.000000,0,0.000000,#& 26
0.000000,0,0.000000,#' 27
0.000000,0,0.000000,#* 2A
0.000000,0,0.000000,#, 2C FLOW
0.000000,0,0.000000,#- 2D XX
0.000000,0,0.000000,#: 3A XX
0.000000,0,0.000000,#> 3E
0.000000,0,0.000000,#? 3F XX
0.000000,0,0.000000,#@ 40
0.000000,0,0.000000,#[ 5B FLOW
0.000000,0,0.000000,#] 5D FLOW
0.000000,0,0.000000,#` 60
0.000000,0,0.000000,#{ 7B FLOW
0.000000,0,0.000000,#| 7C
0.000000,0,0.000000,#} 7D FLOW
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000003,1,0.000003,my $RE_PLAIN_WORD = "(?::+$RE_PLAIN_END|$RE_PLAIN_START)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";
0.000000,1,0.000000,my $RE_PLAIN_FIRST_WORD = "(?:[:?-]+$RE_PLAIN_END|$RE_PLAIN_FIRST)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";
0.000000,1,0.000000,my $RE_PLAIN_WORDS = "(?:$RE_PLAIN_FIRST_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";
0.000000,1,0.000000,my $RE_PLAIN_WORDS2 = "(?:$RE_PLAIN_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";
0.000000,0,0.000000,
0.000000,1,0.000000,my $RE_PLAIN_WORD_FLOW = "(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_START_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";
0.000000,1,0.000000,my $RE_PLAIN_FIRST_WORD_FLOW = "(?:[:?-]+$RE_PLAIN_END_FLOW|$RE_PLAIN_FIRST_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";
0.000001,1,0.000001,my $RE_PLAIN_WORDS_FLOW = "(?:$RE_PLAIN_FIRST_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";
0.000000,1,0.000000,my $RE_PLAIN_WORDS_FLOW2 = "(?:$RE_PLAIN_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#c-secondary-tag-handle  ::= “!” “!”
0.000000,0,0.000000,#c-named-tag-handle  ::= “!” ns-word-char+ “!”
0.000000,0,0.000000,#ns-tag-char ::= ns-uri-char - “!” - c-flow-indicator
0.000000,0,0.000000,#ns-global-tag-prefix    ::= ns-tag-char ns-uri-char*
0.000000,0,0.000000,#c-ns-local-tag-prefix   ::= “!” ns-uri-char*
0.000000,1,0.000000,my $RE_TAG = "!(?:$RE_NS_WORD_CHAR*!$RE_NS_TAG_CHAR+|$RE_NS_TAG_CHAR+|<$RE_URI_CHAR+>|)";
0.000000,0,0.000000,
0.000000,0,0.000000,#c-ns-anchor-property    ::= “&” ns-anchor-name
0.000000,0,0.000000,#ns-char ::= nb-char - s-white
0.000000,0,0.000000,#ns-anchor-char  ::= ns-char - c-flow-indicator
0.000000,0,0.000000,#ns-anchor-name  ::= ns-anchor-char+
0.000000,0,0.000000,
0.000011,1,0.000011,my $RE_SEQSTART = qr/\A(-)(?=$RE_WS|$)/m;
0.000009,1,0.000009,my $RE_COMPLEX = qr/(\?)(?=$RE_WS|$)/m;
0.000011,1,0.000011,my $RE_COMPLEXCOLON = qr/\A(:)(?=$RE_WS|$)/m;
0.000001,1,0.000001,my $RE_ANCHOR = "&$RE_ANCHOR_CAR+";
0.000000,1,0.000000,my $RE_ALIAS = "\\*$RE_ANCHOR_CAR+";
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000116,1,0.000116,my %REGEXES = (
0.000000,0,0.000000,ANCHOR => qr{($RE_ANCHOR)},
0.000000,0,0.000000,TAG => qr{($RE_TAG)},
0.000000,0,0.000000,ALIAS => qr{($RE_ALIAS)},
0.000000,0,0.000000,SINGLEQUOTED => qr{(?:''|[^'\r\n]+)*},
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fetch_next_line {
0.004427,18497,0.000000,my ($self) = @_;
0.016036,18497,0.000001,my $next_line = $self->next_line;
0.012961,18497,0.000001,if (defined $next_line ) {
0.000000,0,0.000000,return $next_line;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.032588,13456,0.000002,my $line = $self->reader->readline;
0.003364,13456,0.000000,unless (defined $line) {
0.000001,1,0.000001,$self->set_next_line(undef);
0.000002,1,0.000002,return;
0.000000,0,0.000000,}
0.011729,13455,0.000001,$self->set_block(1);
0.012725,13455,0.000001,$self->inc_line;
0.067486,13455,0.000005,$line =~ m/\A( *)([^\r\n]*)([\r\n]|\z)/ or die "Unexpected";
0.026499,13455,0.000002,$next_line = [ $1,  $2, $3 ];
0.009861,13455,0.000001,$self->set_next_line($next_line);
0.000000,0,0.000000,# $ESCAPE_CHAR from YAML.pm
0.007735,13455,0.000001,if ($line =~ tr/\x00-\x08\x0b-\x0c\x0e-\x1f//) {
0.000000,0,0.000000,$self->exception("Control characters are not allowed");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.027911,13455,0.000002,return $next_line;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,my %TOKEN_NAMES = (
0.000000,0,0.000000,'"' => 'DOUBLEQUOTE',
0.000000,0,0.000000,"'" => 'SINGLEQUOTE',
0.000000,0,0.000000,'|' => 'LITERAL',
0.000000,0,0.000000,'>' => 'FOLDED',
0.000000,0,0.000000,'!' => 'TAG',
0.000000,0,0.000000,'*' => 'ALIAS',
0.000000,0,0.000000,'&' => 'ANCHOR',
0.000000,0,0.000000,':' => 'COLON',
0.000000,0,0.000000,'-' => 'DASH',
0.000000,0,0.000000,'?' => 'QUESTION',
0.000000,0,0.000000,'[' => 'FLOWSEQ_START',
0.000000,0,0.000000,']' => 'FLOWSEQ_END',
0.000000,0,0.000000,'{' => 'FLOWMAP_START',
0.000000,0,0.000000,'}' => 'FLOWMAP_END',
0.000000,0,0.000000,',' => 'FLOW_COMMA',
0.000000,0,0.000000,'---' => 'DOC_START',
0.000000,0,0.000000,'...' => 'DOC_END',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetch_next_tokens {
0.003676,13451,0.000000,my ($self) = @_;
0.011771,13451,0.000001,my $next = $self->next_tokens;
0.003606,13451,0.000000,return $next if @$next;
0.000000,0,0.000000,
0.015806,13451,0.000001,my $next_line = $self->_fetch_next_line;
0.002036,13451,0.000000,if (not $next_line) {
0.000000,0,0.000000,return [];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.005725,13450,0.000000,my $spaces = $next_line->[0];
0.005869,13450,0.000000,my $yaml = \$next_line->[1];
0.005114,13450,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,$self->_push_tokens([ EOL => join('', @$next_line), $self->line ]);
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,return $next;
0.000000,0,0.000000,}
0.014247,13450,0.000001,if (substr($$yaml, 0, 1) eq '#') {
0.000000,0,0.000000,$self->_push_tokens([ EOL => join('', @$next_line), $self->line ]);
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,return $next;
0.000000,0,0.000000,}
0.003937,13450,0.000000,if (not $spaces and substr($$yaml, 0, 1) eq "%") {
0.000000,0,0.000000,$self->_fetch_next_tokens_directive($yaml, $next_line->[2]);
0.000000,0,0.000000,$self->set_context(0);
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,return $next;
0.000000,0,0.000000,}
0.023535,13450,0.000002,if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//) {
0.000000,0,0.000000,$self->_push_tokens([ $TOKEN_NAMES{ $1 } => $1, $self->line ]);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->flowcontext and $$yaml =~ m/\A[ \t]+(#.*)?\z/) {
0.000000,0,0.000000,$self->_push_tokens([ EOL => join('', @$next_line), $self->line ]);
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,return $next;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.027131,13449,0.000002,$self->_push_tokens([ SPACE => $spaces, $self->line ]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.015382,13450,0.000001,my $partial = $self->_fetch_next_tokens($next_line);
0.002053,13450,0.000000,unless ($partial) {
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,}
0.035701,13450,0.000003,return $next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my %ANCHOR_ALIAS_TAG =    ( '&' => 1, '*' => 1, '!' => 1 );
0.000001,1,0.000001,my %BLOCK_SCALAR =        ( '|' => 1, '>' => 1 );
0.000001,1,0.000001,my %COLON_DASH_QUESTION = ( ':' => 1, '-' => 1, '?' => 1 );
0.000001,1,0.000001,my %QUOTED =              ( '"' => 1, "'" => 1 );
0.000000,1,0.000000,my %FLOW =                ( '{' => 1, '[' => 1, '}' => 1, ']' => 1, ',' => 1 );
0.000001,1,0.000001,my %CONTEXT =             ( '"' => 1, "'" => 1, '>' => 1, '|' => 1 );
0.000000,0,0.000000,
0.000002,1,0.000002,my $RE_ESCAPES = qr{(?:
0.000000,0,0.000000,\\([ \\\/_0abefnrtvLNP\t"]) | \\x([0-9a-fA-F]{2})
0.000000,0,0.000000,| \\u([A-Fa-f0-9]{4}) | \\U([A-Fa-f0-9]{4,8})
0.000000,0,0.000000,)}x;
0.000007,1,0.000007,my %CONTROL = (
0.000000,0,0.000000,'\\' => '\\', '/' => '/', n => "\n", t => "\t", r => "\r", b => "\b",
0.000000,0,0.000000,'a' => "\a", 'b' => "\b", 'e' => "\e", 'f' => "\f", 'v' => "\x0b", "\t" => "\t",
0.000000,0,0.000000,'P' => "\x{2029}", L => "\x{2028}", 'N' => "\x85",
0.000000,0,0.000000,'0' => "\0", '_' => "\xa0", ' ' => ' ', q/"/ => q/"/,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fetch_next_tokens {
0.000000,0,0.000000,TRACE and warn __PACKAGE__.':'.__LINE__.": _fetch_next_tokens\n";
0.006527,27926,0.000000,my ($self, $next_line) = @_;
0.000000,0,0.000000,
0.010810,27926,0.000000,my $yaml = \$next_line->[1];
0.006380,27926,0.000000,my $eol = $next_line->[2];
0.000000,0,0.000000,
0.003673,27926,0.000000,my @tokens;
0.000000,0,0.000000,
0.004534,27926,0.000000,while (1) {
0.007925,38004,0.000000,unless (length $$yaml) {
0.000981,529,0.000002,push @tokens, ( EOL => $eol, $self->line );
0.000499,529,0.000001,$self->_push_tokens(\@tokens);
0.001464,529,0.000003,return;
0.000000,0,0.000000,}
0.016967,37475,0.000000,my $first = substr($$yaml, 0, 1);
0.004663,37475,0.000000,my $plain = 0;
0.000000,0,0.000000,
0.027239,37475,0.000001,if ($self->context) {
0.000448,88,0.000005,if ($$yaml =~ s/\A($RE_WS*)://) {
0.000000,0,0.000000,push @tokens, ( WS => $1, $self->line ) if $1;
0.000000,0,0.000000,push @tokens, ( COLON => ':', $self->line );
0.000000,0,0.000000,$self->set_context(0);
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000326,88,0.000004,if ($$yaml =~ s/\A($RE_WS*(?: #.*))\z//) {
0.000000,0,0.000000,push @tokens, ( EOL => $1 . $eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000104,88,0.000001,$self->set_context(0);
0.000000,0,0.000000,}
0.036465,37475,0.000001,if ($CONTEXT{ $first }) {
0.002830,2057,0.000001,push @tokens, ( CONTEXT => $first, $self->line );
0.004189,2057,0.000002,$self->_push_tokens(\@tokens);
0.005185,2057,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($COLON_DASH_QUESTION{ $first }) {
0.006034,14054,0.000000,my $token_name = $TOKEN_NAMES{ $first };
0.116082,14054,0.000008,if ($$yaml =~ s/\A\Q$first\E($RE_WS+|\z)//) {
0.006194,14054,0.000000,my $after = $1;
0.021661,14054,0.000002,if (not $self->flowcontext and not $self->block) {
0.000000,0,0.000000,push @tokens, ERROR => $first . $after, $self->line;
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Tabs can not be used for indentation");
0.000000,0,0.000000,}
0.006726,14054,0.000000,if ($after =~ tr/\t//) {
0.000000,0,0.000000,$self->set_block(0);
0.000000,0,0.000000,}
0.004936,14054,0.000000,my $token_name = $TOKEN_NAMES{ $first };
0.019343,14054,0.000001,push @tokens, ( $token_name => $first, $self->line );
0.005863,14054,0.000000,if (not defined $1) {
0.000000,0,0.000000,push @tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.004499,14054,0.000000,my $ws = $1;
0.041657,14054,0.000003,if ($$yaml =~ s/\A(#.*|)\z//) {
0.016420,6456,0.000003,push @tokens, ( EOL => $ws . $1 . $eol, $self->line );
0.005664,6456,0.000001,$self->_push_tokens(\@tokens);
0.022846,6456,0.000004,return;
0.000000,0,0.000000,}
0.010564,7598,0.000001,push @tokens, ( WS => $ws, $self->line );
0.008958,7598,0.000001,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->flowcontext and $$yaml =~ s/\A:(?=[,\{\}\[\]])//) {
0.000000,0,0.000000,push @tokens, ( $token_name => $first, $self->line );
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,$plain = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($ANCHOR_ALIAS_TAG{ $first }) {
0.000000,0,0.000000,my $token_name = $TOKEN_NAMES{ $first };
0.000000,0,0.000000,my $REGEX = $REGEXES{ $token_name };
0.000000,0,0.000000,if ($$yaml =~ s/\A$REGEX//) {
0.000000,0,0.000000,push @tokens, ( $token_name => $1, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, ( "Invalid $token_name" => $$yaml, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($first eq ' ' or $first eq "\t") {
0.004310,689,0.000006,if ($$yaml =~ s/\A($RE_WS+)//) {
0.000375,689,0.000001,my $ws = $1;
0.001734,689,0.000003,if ($$yaml =~ s/\A((?:#.*)?\z)//) {
0.000000,0,0.000000,push @tokens, ( EOL => $ws . $1 . $eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000949,689,0.000001,push @tokens, ( WS => $ws, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($FLOW{ $first }) {
0.002760,1791,0.000002,push @tokens, ( $TOKEN_NAMES{ $first } => $first, $self->line );
0.002130,1791,0.000001,substr($$yaml, 0, 1, '');
0.001332,1791,0.000001,my $flowcontext = $self->flowcontext;
0.002803,1791,0.000002,if ($first eq '{' or $first eq '[') {
0.000000,0,0.000000,$self->set_flowcontext(++$flowcontext);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($first eq '}' or $first eq ']') {
0.000000,0,0.000000,$self->set_flowcontext(--$flowcontext);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.002816,18884,0.000000,$plain = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.004307,21364,0.000000,if ($plain) {
0.017743,18884,0.000001,push @tokens, ( CONTEXT => '', $self->line );
0.013368,18884,0.000001,$self->_push_tokens(\@tokens);
0.060213,18884,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetch_plain {
0.007378,18884,0.000000,my ($self, $indent, $context) = @_;
0.017073,18884,0.000001,my $next_line = $self->next_line;
0.007195,18884,0.000000,my $yaml = \$next_line->[1];
0.006094,18884,0.000000,my $eol = $next_line->[2];
0.004536,18884,0.000000,my $REGEX = $RE_PLAIN_WORDS;
0.012413,18884,0.000001,if ($self->flowcontext) {
0.000000,0,0.000000,$REGEX = $RE_PLAIN_WORDS_FLOW;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002906,18884,0.000000,my @tokens;
0.320427,18884,0.000017,unless ($$yaml =~ s/\A($REGEX)//) {
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Invalid plain scalar");
0.000000,0,0.000000,}
0.015610,18884,0.000001,my $plain = $1;
0.026582,18884,0.000001,push @tokens, ( PLAIN => $plain, $self->line );
0.000000,0,0.000000,
0.104763,18884,0.000006,if ($$yaml =~ s/\A(?:($RE_WS+#.*)|($RE_WS*))\z//) {
0.002767,5040,0.000001,if (defined $1) {
0.000000,0,0.000000,push @tokens, ( EOL => $1 . $eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.009215,5040,0.000002,push @tokens, ( EOL => $2. $eol, $self->line );
0.005353,5040,0.000001,$self->set_next_line(undef);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.013084,13844,0.000001,$self->_push_tokens(\@tokens);
0.014151,13844,0.000001,my $partial = $self->_fetch_next_tokens($next_line);
0.007653,13844,0.000001,if (not $partial) {
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,}
0.056955,13844,0.000004,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001599,5040,0.000000,my $RE2 = $RE_PLAIN_WORDS2;
0.004652,5040,0.000001,if ($self->flowcontext) {
0.000000,0,0.000000,$RE2 = $RE_PLAIN_WORDS_FLOW2;
0.000000,0,0.000000,}
0.001285,5040,0.000000,my $fetch_next = 0;
0.003687,5040,0.000001,my @lines = ($plain);
0.001279,5040,0.000000,my @next;
0.001036,5040,0.000000,LOOP: while (1) {
0.009289,5040,0.000002,$next_line = $self->_fetch_next_line;
0.001132,5040,0.000000,if (not $next_line) {
0.000000,0,0.000000,last LOOP;
0.000000,0,0.000000,}
0.002461,5040,0.000000,my $spaces = $next_line->[0];
0.008872,5040,0.000002,my $yaml = \$next_line->[1];
0.002046,5040,0.000000,my $eol = $next_line->[2];
0.000000,0,0.000000,
0.001768,5040,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, ( EOL => $spaces . $eol, $self->line );
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,push @lines, '';
0.000000,0,0.000000,next LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001611,5040,0.000000,if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//) {
0.000000,0,0.000000,push @next, $TOKEN_NAMES{ $1 } => $1, $self->line;
0.000000,0,0.000000,$fetch_next = 1;
0.000000,0,0.000000,last LOOP;
0.000000,0,0.000000,}
0.005149,5040,0.000001,if ((length $spaces) < $indent) {
0.005593,5040,0.000001,last LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $ws = '';
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE_WS+)//) {
0.000000,0,0.000000,$ws = $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, ( EOL => $spaces . $ws . $eol, $self->line );
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,push @lines, '';
0.000000,0,0.000000,next LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($$yaml =~ s/\A(#.*)\z//) {
0.000000,0,0.000000,push @tokens, ( EOL => $spaces . $ws . $1 . $eol, $self->line );
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,last LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE2)//) {
0.000000,0,0.000000,push @tokens, INDENT => $spaces, $self->line;
0.000000,0,0.000000,push @tokens, WS => $ws, $self->line;
0.000000,0,0.000000,push @tokens, PLAIN => $1, $self->line;
0.000000,0,0.000000,push @lines, $1;
0.000000,0,0.000000,my $ws = '';
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE_WS+)//) {
0.000000,0,0.000000,$ws = $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, EOL => $ws . $eol, $self->line;
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,next LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($$yaml =~ s/\A(#.*)\z//) {
0.000000,0,0.000000,push @tokens, EOL => $ws . $1 . $eol, $self->line;
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,last LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, WS => $ws, $self->line if $ws;
0.000000,0,0.000000,$fetch_next = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, SPACE => $spaces, $self->line;
0.000000,0,0.000000,push @tokens, WS => $ws, $self->line;
0.000000,0,0.000000,if ($self->flowcontext) {
0.000000,0,0.000000,$fetch_next = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, ERROR => $$yaml, $self->line;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,last LOOP;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,# remove empty lines at the end
0.003742,5040,0.000001,while (@lines > 1 and $lines[-1] eq '') {
0.000000,0,0.000000,pop @lines;
0.000000,0,0.000000,}
0.006542,5040,0.000001,if (@lines > 1) {
0.000000,0,0.000000,my $value = YAML::PP::Render->render_multi_val(\@lines);
0.000000,0,0.000000,my @eol;
0.000000,0,0.000000,if ($tokens[-3] eq 'EOL') {
0.000000,0,0.000000,@eol = splice @tokens, -3;
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->push_subtokens( { name => 'PLAIN_MULTI', value => $value }, \@tokens);
0.000000,0,0.000000,$self->_push_tokens([ @eol, @next ]);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.009358,5040,0.000002,$self->_push_tokens([ @tokens, @next ]);
0.000000,0,0.000000,}
0.004286,5040,0.000001,@tokens = ();
0.001180,5040,0.000000,if ($fetch_next) {
0.000000,0,0.000000,my $partial = $self->_fetch_next_tokens($next_line);
0.000000,0,0.000000,if (not $partial) {
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.016680,5040,0.000003,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetch_block {
0.000001,1,0.000001,my ($self, $indent, $context) = @_;
0.000001,1,0.000001,my $next_line = $self->next_line;
0.000000,1,0.000000,my $yaml = \$next_line->[1];
0.000000,1,0.000000,my $eol = $next_line->[2];
0.000000,0,0.000000,
0.000000,1,0.000000,my @tokens;
0.000001,1,0.000001,my $token_name = $TOKEN_NAMES{ $context };
0.000023,1,0.000023,$$yaml =~ s/\A\Q$context\E// or die "Unexpected";
0.000002,1,0.000002,push @tokens, ( $token_name => $context, $self->line );
0.000001,1,0.000001,my $current_indent = $indent;
0.000000,1,0.000000,my $started = 0;
0.000000,1,0.000000,my $set_indent = 0;
0.000007,1,0.000007,my $chomp = '';
0.000008,1,0.000008,if ($$yaml =~ s/\A([1-9])([+-]?)//) {
0.000000,0,0.000000,push @tokens, ( BLOCK_SCALAR_INDENT => $1, $self->line );
0.000000,0,0.000000,$set_indent = $1;
0.000000,0,0.000000,$chomp = $2 if $2;
0.000000,0,0.000000,push @tokens, ( BLOCK_SCALAR_CHOMP => $2, $self->line ) if $2;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($$yaml =~ s/\A([+-])([1-9])?//) {
0.000002,1,0.000002,push @tokens, ( BLOCK_SCALAR_CHOMP => $1, $self->line );
0.000000,1,0.000000,$chomp = $1;
0.000000,1,0.000000,push @tokens, ( BLOCK_SCALAR_INDENT => $2, $self->line ) if $2;
0.000000,1,0.000000,$set_indent = $2 if $2;
0.000000,0,0.000000,}
0.000001,1,0.000001,if ($set_indent) {
0.000000,0,0.000000,$started = 1;
0.000000,0,0.000000,$indent-- if $indent > 0;
0.000000,0,0.000000,$current_indent = $indent + $set_indent;
0.000000,0,0.000000,}
0.000003,1,0.000003,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($$yaml =~ s/\A($RE_WS*(?:$RE_WS#.*|))\z//) {
0.000000,0,0.000000,push @tokens, ( EOL => $1 . $eol, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Invalid block scalar");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my @lines;
0.000000,1,0.000000,while (1) {
0.000009,6,0.000002,$self->set_next_line(undef);
0.000009,6,0.000002,$next_line = $self->_fetch_next_line;
0.000000,6,0.000000,if (not $next_line) {
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000002,6,0.000000,my $spaces = $next_line->[0];
0.000005,6,0.000001,my $content = $next_line->[1];
0.000002,6,0.000000,my $eol = $next_line->[2];
0.000004,6,0.000001,if (not $spaces and $content =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/) {
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000003,6,0.000000,if ((length $spaces) < $current_indent) {
0.000000,1,0.000000,if (length $content) {
0.000005,1,0.000005,if ($content =~ m/\A\t/) {
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Invalid block scalar");
0.000000,0,0.000000,}
0.000001,1,0.000001,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @lines, '';
0.000000,0,0.000000,push @tokens, ( EOL => $spaces . $eol, $self->line );
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000002,5,0.000000,if ((length $spaces) > $current_indent) {
0.000000,1,0.000000,if ($started) {
0.000000,0,0.000000,($spaces, my $more_spaces) = unpack "a${current_indent}a*", $spaces;
0.000000,0,0.000000,$content = $more_spaces . $content;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000001,5,0.000000,unless (length $content) {
0.000000,0,0.000000,push @lines, '';
0.000000,0,0.000000,push @tokens, ( INDENT => $spaces, $self->line, EOL => $eol, $self->line );
0.000000,0,0.000000,unless ($started) {
0.000000,0,0.000000,$current_indent = length $spaces;
0.000000,0,0.000000,}
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000001,5,0.000000,unless ($started) {
0.000000,1,0.000000,$started = 1;
0.000001,1,0.000001,$current_indent = length $spaces;
0.000000,0,0.000000,}
0.000002,5,0.000000,push @lines, $content;
0.000032,5,0.000006,push @tokens, (
0.000000,0,0.000000,INDENT => $spaces, $self->line,
0.000000,0,0.000000,BLOCK_SCALAR_CONTENT => $content, $self->line,
0.000000,0,0.000000,EOL => $eol, $self->line,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000008,1,0.000008,my $value = YAML::PP::Render->render_block_scalar($context, $chomp, \@lines);
0.000002,1,0.000002,my @eol = splice @tokens, -3;
0.000003,1,0.000003,$self->push_subtokens( { name => 'BLOCK_SCALAR', value => $value }, \@tokens );
0.000002,1,0.000002,$self->_push_tokens([ @eol ]);
0.000007,1,0.000007,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetch_quoted {
0.001082,2056,0.000001,my ($self, $indent, $context) = @_;
0.002425,2056,0.000001,my $next_line = $self->next_line;
0.001298,2056,0.000001,my $yaml = \$next_line->[1];
0.001019,2056,0.000000,my $spaces = $next_line->[0];
0.000000,0,0.000000,
0.001374,2056,0.000001,my $token_name = $TOKEN_NAMES{ $context };
0.015180,2056,0.000007,$$yaml =~ s/\A\Q$context// or die "Unexpected";;
0.004012,2056,0.000002,my @tokens = ( $token_name => $context, $self->line );
0.000000,0,0.000000,
0.000745,2056,0.000000,my $start = 1;
0.000584,2056,0.000000,my @values;
0.000496,2056,0.000000,while (1) {
0.000000,0,0.000000,
0.000487,2056,0.000000,unless ($start) {
0.000000,0,0.000000,$next_line = $self->_fetch_next_line or do {
0.000000,0,0.000000,for (my $i = 0; $i < @tokens; $i+= 3) {
0.000000,0,0.000000,my $token = $tokens[ $i + 1 ];
0.000000,0,0.000000,if (ref $token) {
0.000000,0,0.000000,$tokens[ $i + 1 ] = $token->{orig};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Missing closing quote <$context> at EOF");
0.000000,0,0.000000,};
0.000000,0,0.000000,$start = 0;
0.000000,0,0.000000,$spaces = $next_line->[0];
0.000000,0,0.000000,$yaml = \$next_line->[1];
0.000000,0,0.000000,
0.000000,0,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, ( EOL => $spaces . $next_line->[2], $self->line );
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,push @values, { value => '', orig => '' };
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (not $spaces and $$yaml =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/) {
0.000000,0,0.000000,for (my $i = 0; $i < @tokens; $i+= 3) {
0.000000,0,0.000000,my $token = $tokens[ $i + 1 ];
0.000000,0,0.000000,if (ref $token) {
0.000000,0,0.000000,$tokens[ $i + 1 ] = $token->{orig};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Missing closing quote <$context> or invalid document marker");
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ((length $spaces) < $indent) {
0.000000,0,0.000000,for (my $i = 0; $i < @tokens; $i+= 3) {
0.000000,0,0.000000,my $token = $tokens[ $i + 1 ];
0.000000,0,0.000000,if (ref $token) {
0.000000,0,0.000000,$tokens[ $i + 1 ] = $token->{orig};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Wrong indendation or missing closing quote <$context>");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE_WS+)//) {
0.000000,0,0.000000,$spaces .= $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,push @tokens, ( WS => $spaces, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.004511,2056,0.000002,my $v = $self->_read_quoted_tokens($start, $context, $yaml, \@tokens);
0.000657,2056,0.000000,push @values, $v;
0.001115,2056,0.000001,if ($tokens[-3] eq $token_name) {
0.006780,2056,0.000003,if ($start) {
0.000000,0,0.000000,$self->push_subtokens(
0.000000,0,0.000000,{ name => 'QUOTED', value => $v->{value} }, \@tokens
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $value = YAML::PP::Render->render_quoted($context, \@values);
0.000000,0,0.000000,$self->push_subtokens(
0.000000,0,0.000000,{ name => 'QUOTED_MULTILINE', value => $value }, \@tokens
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.002142,2056,0.000001,$self->set_context(1) if $self->flowcontext;
0.000956,2056,0.000000,if (length $$yaml) {
0.000776,632,0.000001,my $partial = $self->_fetch_next_tokens($next_line);
0.000802,632,0.000001,if (not $partial) {
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,}
0.003907,632,0.000006,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.001332,1424,0.000001,@tokens = ();
0.002352,1424,0.000002,push @tokens, ( EOL => $next_line->[2], $self->line );
0.001737,1424,0.000001,$self->_push_tokens(\@tokens);
0.001375,1424,0.000001,$self->set_next_line(undef);
0.007342,1424,0.000005,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$tokens[-2] .= $next_line->[2];
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,$start = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _read_quoted_tokens {
0.001248,2056,0.000001,my ($self, $start, $first, $yaml, $tokens) = @_;
0.000854,2056,0.000000,my $quoted = '';
0.000751,2056,0.000000,my $decoded = '';
0.001046,2056,0.000001,my $token_name = $TOKEN_NAMES{ $first };
0.000661,2056,0.000000,my $eol = '';
0.001295,2056,0.000001,if ($first eq "'") {
0.001356,2056,0.000001,my $regex = $REGEXES{SINGLEQUOTED};
0.016298,2056,0.000008,if ($$yaml =~ s/\A($regex)//) {
0.002864,2056,0.000001,$quoted .= $1;
0.001085,2056,0.000001,$decoded .= $1;
0.004421,2056,0.000002,$decoded =~ s/''/'/g;
0.000000,0,0.000000,}
0.001561,2056,0.000001,unless (length $$yaml) {
0.000000,0,0.000000,if ($quoted =~ s/($RE_WS+)\z//) {
0.000000,0,0.000000,$eol = $1;
0.000000,0,0.000000,$decoded =~ s/($eol)\z//;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,($quoted, $decoded, $eol) = $self->_read_doublequoted($yaml);
0.000000,0,0.000000,}
0.003816,2056,0.000002,my $value = { value => $decoded, orig => $quoted };
0.000000,0,0.000000,
0.009968,2056,0.000005,if ($$yaml =~ s/\A$first//) {
0.004389,2056,0.000002,if ($start) {
0.000000,0,0.000000,push @$tokens, ( $token_name . 'D' => $value, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @$tokens, ( $token_name . 'D_LINE' => $value, $self->line );
0.000000,0,0.000000,}
0.002317,2056,0.000001,push @$tokens, ( $token_name => $first, $self->line );
0.004968,2056,0.000002,return $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (length $$yaml) {
0.000000,0,0.000000,push @$tokens, ( $token_name . 'D' => $value->{orig}, $self->line );
0.000000,0,0.000000,$self->_push_tokens($tokens);
0.000000,0,0.000000,$self->exception("Invalid quoted <$first> string");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @$tokens, ( $token_name . 'D_LINE' => $value, $self->line );
0.000000,0,0.000000,push @$tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,
0.000000,0,0.000000,return $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _read_doublequoted {
0.000000,0,0.000000,my ($self, $yaml) = @_;
0.000000,0,0.000000,my $quoted = '';
0.000000,0,0.000000,my $decoded = '';
0.000000,0,0.000000,my $eol = '';
0.000000,0,0.000000,while (1) {
0.000000,0,0.000000,my $last = 1;
0.000000,0,0.000000,if ($$yaml =~ s/\A([^"\\ \t]+)//) {
0.000000,0,0.000000,$quoted .= $1;
0.000000,0,0.000000,$decoded .= $1;
0.000000,0,0.000000,$last = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE_ESCAPES)//) {
0.000000,0,0.000000,$quoted .= $1;
0.000000,0,0.000000,my $dec = defined $2 ? $CONTROL{ $2 }
0.000000,0,0.000000,: defined $3 ? chr hex $3
0.000000,0,0.000000,: defined $4 ? chr hex $4
0.000000,0,0.000000,: chr hex $5;
0.000000,0,0.000000,$decoded .= $dec;
0.000000,0,0.000000,$last = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($$yaml =~ s/\A([ \t]+)//) {
0.000000,0,0.000000,my $spaces = $1;
0.000000,0,0.000000,if (length $$yaml) {
0.000000,0,0.000000,$quoted .= $spaces;
0.000000,0,0.000000,$decoded .= $spaces;
0.000000,0,0.000000,$last = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$eol = $spaces;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($$yaml =~ s/\A(\\)\z//) {
0.000000,0,0.000000,$quoted .= $1;
0.000000,0,0.000000,$decoded .= $1;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if $last;
0.000000,0,0.000000,}
0.000000,0,0.000000,return ($quoted, $decoded, $eol);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fetch_next_tokens_directive {
0.000000,0,0.000000,my ($self, $yaml, $eol) = @_;
0.000000,0,0.000000,my @tokens;
0.000000,0,0.000000,
0.000000,0,0.000000,my $trailing_ws = '';
0.000000,0,0.000000,my $warn = $ENV{YAML_PP_RESERVED_DIRECTIVE} || 'warn';
0.000000,0,0.000000,if ($$yaml =~ s/\A(\s*%YAML[ \t]+([0-9]+\.[0-9]+))//) {
0.000000,0,0.000000,my $dir = $1;
0.000000,0,0.000000,my $version = $2;
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE_WS+)//) {
0.000000,0,0.000000,$trailing_ws = $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (length $$yaml) {
0.000000,0,0.000000,push @tokens, ( 'Invalid directive' => $dir.$$yaml.$eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($version !~ m/^1\.[12]$/) {
0.000000,0,0.000000,if ($warn eq 'warn') {
0.000000,0,0.000000,warn "Unsupported YAML version '$dir'";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($warn eq 'fatal') {
0.000000,0,0.000000,push @tokens, ( 'Unsupported YAML version' => $dir, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,push @tokens, ( YAML_DIRECTIVE => $dir, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($$yaml =~ s/\A(\s*%TAG[ \t]+(!$RE_NS_WORD_CHAR*!|!)[ \t]+(tag:\S+|!$RE_URI_CHAR+))($RE_WS*)//) {
0.000000,0,0.000000,push @tokens, ( TAG_DIRECTIVE => $1, $self->line );
0.000000,0,0.000000,# TODO
0.000000,0,0.000000,my $tag_alias = $2;
0.000000,0,0.000000,my $tag_url = $3;
0.000000,0,0.000000,$trailing_ws = $4;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($$yaml =~ s/\A(\s*\A%(?:\w+).*)//) {
0.000000,0,0.000000,push @tokens, ( RESERVED_DIRECTIVE => $1, $self->line );
0.000000,0,0.000000,if ($warn eq 'warn') {
0.000000,0,0.000000,warn "Found reserved directive '$1'";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($warn eq 'fatal') {
0.000000,0,0.000000,die "Found reserved directive '$1'";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, ( 'Invalid directive' => $$yaml, $self->line );
0.000000,0,0.000000,push @tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($trailing_ws and $$yaml =~ s/\A(#.*)?\z//) {
0.000000,0,0.000000,push @tokens, ( EOL => "$trailing_ws$1$eol", $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($$yaml =~ s/\A([ \t]+#.*)?\z//) {
0.000000,0,0.000000,push @tokens, ( EOL => "$1$eol", $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, ( 'Invalid directive' => $trailing_ws.$$yaml, $self->line );
0.000000,0,0.000000,push @tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _push_tokens {
0.013193,61685,0.000000,my ($self, $new_tokens) = @_;
0.042731,61685,0.000001,my $next = $self->next_tokens;
0.038044,61685,0.000001,my $line = $self->line;
0.042121,61685,0.000001,my $column = $self->offset;
0.000000,0,0.000000,
0.068442,61685,0.000001,for (my $i = 0; $i < @$new_tokens; $i += 3) {
0.029655,90857,0.000000,my $value = $new_tokens->[ $i + 1 ];
0.021816,90857,0.000000,my $name = $new_tokens->[ $i ];
0.017089,90857,0.000000,my $line = $new_tokens->[ $i + 2 ];
0.116569,90857,0.000001,my $push = {
0.000000,0,0.000000,name => $name,
0.000000,0,0.000000,line => $line,
0.000000,0,0.000000,column => $column,
0.000000,0,0.000000,value => $value,
0.000000,0,0.000000,};
0.031693,90857,0.000000,$column += length $value unless $name eq 'CONTEXT';
0.016672,90857,0.000000,push @$next, $push;
0.034405,90857,0.000000,if ($name eq 'EOL') {
0.000000,0,0.000000,$column = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.045851,61685,0.000001,$self->set_offset($column);
0.138509,61685,0.000002,return $next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub push_subtokens {
0.000646,2057,0.000000,my ($self, $token, $subtokens) = @_;
0.002100,2057,0.000001,my $next = $self->next_tokens;
0.002058,2057,0.000001,my $line = $self->line;
0.001857,2057,0.000001,my $column = $self->offset;
0.000825,2057,0.000000,$token->{column} = $column;
0.001084,2057,0.000001,$token->{subtokens} = \my @sub;
0.000000,0,0.000000,
0.004431,2057,0.000002,for (my $i = 0; $i < @$subtokens; $i+=3) {
0.001426,6185,0.000000,my $name = $subtokens->[ $i ];
0.003392,6185,0.000001,my $value = $subtokens->[ $i + 1 ];
0.001552,6185,0.000000,my $line = $subtokens->[ $i + 2 ];
0.010579,6185,0.000002,my $push = {
0.000000,0,0.000000,name => $subtokens->[ $i ],
0.000000,0,0.000000,line => $line,
0.000000,0,0.000000,column => $column,
0.000000,0,0.000000,};
0.003072,6185,0.000000,if (ref $value eq 'HASH') {
0.007360,2056,0.000004,%$push = ( %$push, %$value );
0.001544,2056,0.000001,$column += length $value->{orig};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.001919,4129,0.000000,$push->{value} = $value;
0.000875,4129,0.000000,$column += length $value;
0.000000,0,0.000000,}
0.001403,6185,0.000000,if ($push->{name} eq 'EOL') {
0.000000,0,0.000000,$column = 0;
0.000000,0,0.000000,}
0.002490,6185,0.000000,push @sub, $push;
0.000000,0,0.000000,}
0.001083,2057,0.000001,$token->{line} = $sub[0]->{line};
0.000695,2057,0.000000,push @$next, $token;
0.001790,2057,0.000001,$self->set_offset($column);
0.004698,2057,0.000002,return $next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub exception {
0.000000,0,0.000000,my ($self, $msg) = @_;
0.000000,0,0.000000,my $next = $self->next_tokens;
0.000000,0,0.000000,$next = [];
0.000000,0,0.000000,my $line = @$next ? $next->[0]->{line} : $self->line;
0.000000,0,0.000000,my @caller = caller(0);
0.000000,0,0.000000,my $yaml = '';
0.000000,0,0.000000,if (my $nl = $self->next_line) {
0.000000,0,0.000000,$yaml = join '', @$nl;
0.000000,0,0.000000,$yaml = $nl->[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,my $e = YAML::PP::Exception->new(
0.000000,0,0.000000,line => $line,
0.000000,0,0.000000,column => $self->offset + 1,
0.000000,0,0.000000,msg => $msg,
0.000000,0,0.000000,next => $next,
0.000000,0,0.000000,where => $caller[1] . ' line ' . $caller[2],
0.000000,0,0.000000,yaml => $yaml,
0.000000,0,0.000000,);
0.000000,0,0.000000,croak $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000032,1,0.000032,1;
