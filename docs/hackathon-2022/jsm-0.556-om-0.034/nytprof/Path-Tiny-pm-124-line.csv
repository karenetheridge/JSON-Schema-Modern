# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000037,2,0.000019,use 5.008001;
0.000022,2,0.000011,use strict;
0.000051,2,0.000025,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,package Path::Tiny;
0.000000,0,0.000000,# ABSTRACT: File path utility
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '0.144';
0.000000,0,0.000000,
0.000000,0,0.000000,# Dependencies
0.000055,2,0.000028,use Config;
0.000061,3,0.000020,use Exporter 5.57   (qw/import/);
0.000041,3,0.000014,use File::Spec 0.86 ();          # shipped with 5.8.1
0.000123,2,0.000062,use Carp ();
0.000000,0,0.000000,
0.000001,1,0.000001,our @EXPORT    = qw/path/;
0.000001,1,0.000001,our @EXPORT_OK = qw/cwd rootdir tempfile tempdir/;
0.000000,0,0.000000,
0.000000,0,0.000000,use constant {
0.000001,1,0.000001,PATH     => 0,
0.000000,0,0.000000,CANON    => 1,
0.000000,0,0.000000,VOL      => 2,
0.000000,0,0.000000,DIR      => 3,
0.000000,0,0.000000,FILE     => 4,
0.000000,0,0.000000,TEMP     => 5,
0.000000,0,0.000000,IS_WIN32 => ( $^O eq 'MSWin32' ),
0.000097,1,0.000097,};
0.000000,0,0.000000,
0.000000,0,0.000000,use overload (
0.000000,0,0.000000,q{""}    => 'stringify',
0.000000,0,0.000000,bool     => sub () { 1 },
0.000001,1,0.000001,fallback => 1,
0.000102,1,0.000102,);
0.000000,0,0.000000,
0.000000,0,0.000000,# FREEZE/THAW per Sereal/CBOR/Types::Serialiser protocol
0.000000,0,0.000000,sub THAW   { return path( $_[2] ) }
0.000432,4,0.000108,{ no warnings 'once'; *TO_JSON = *FREEZE = \&stringify };
0.000000,0,0.000000,
0.000000,1,0.000000,my $HAS_UU; # has Unicode::UTF8; lazily populated
0.000000,0,0.000000,
0.000000,0,0.000000,sub _check_UU {
0.000000,0,0.000000,local $SIG{__DIE__}; # prevent outer handler from being called
0.000000,0,0.000000,!!eval {
0.000000,0,0.000000,require Unicode::UTF8;
0.000000,0,0.000000,Unicode::UTF8->VERSION(0.58);
0.000000,0,0.000000,1;
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $HAS_PU;              # has PerlIO::utf8_strict; lazily populated
0.000000,0,0.000000,
0.000000,0,0.000000,sub _check_PU {
0.000000,0,0.000000,local $SIG{__DIE__}; # prevent outer handler from being called
0.000000,0,0.000000,!!eval {
0.000000,0,0.000000,# MUST preload Encode or $SIG{__DIE__} localization fails
0.000000,0,0.000000,# on some Perl 5.8.8 (maybe other 5.8.*) compiled with -O2.
0.000000,0,0.000000,require Encode;
0.000000,0,0.000000,require PerlIO::utf8_strict;
0.000000,0,0.000000,PerlIO::utf8_strict->VERSION(0.003);
0.000000,0,0.000000,1;
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,my $HAS_FLOCK = $Config{d_flock} || $Config{d_fcntl_can_lock} || $Config{d_lockf};
0.000000,0,0.000000,
0.000000,0,0.000000,# notions of "root" directories differ on Win32: \\server\dir\ or C:\ or \
0.000006,1,0.000006,my $SLASH      = qr{[\\/]};
0.000002,1,0.000002,my $NOTSLASH   = qr{[^\\/]};
0.000002,1,0.000002,my $DRV_VOL    = qr{[a-z]:}i;
0.000048,1,0.000048,my $UNC_VOL    = qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;
0.000075,1,0.000075,my $WIN32_ROOT = qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _win32_vol {
0.000000,0,0.000000,my ( $path, $drv ) = @_;
0.000000,0,0.000000,require Cwd;
0.000000,0,0.000000,my $dcwd = eval { Cwd::getdcwd($drv) }; # C: -> C:\some\cwd
0.000000,0,0.000000,# getdcwd on non-existent drive returns empty string
0.000000,0,0.000000,# so just use the original drive Z: -> Z:
0.000000,0,0.000000,$dcwd = "$drv" unless defined $dcwd && length $dcwd;
0.000000,0,0.000000,# normalize dwcd to end with a slash: might be C:\some\cwd or D:\ or Z:
0.000000,0,0.000000,$dcwd =~ s{$SLASH?\z}{/};
0.000000,0,0.000000,# make the path absolute with dcwd
0.000000,0,0.000000,$path =~ s{^$DRV_VOL}{$dcwd};
0.000000,0,0.000000,return $path;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This is a string test for before we have the object; see is_rootdir for well-formed
0.000000,0,0.000000,# object test
0.000000,0,0.000000,sub _is_root {
0.000076,28,0.000003,return IS_WIN32() ? ( $_[0] =~ /^$WIN32_ROOT\z/ ) : ( $_[0] eq '/' );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,*_same = IS_WIN32() ? sub { lc( $_[0] ) eq lc( $_[1] ) } : sub { $_[0] eq $_[1] };
0.000364,1,0.000364,}
0.000000,0,0.000000,
0.000000,0,0.000000,# mode bits encoded for chmod in symbolic mode
0.000003,1,0.000003,my %MODEBITS = ( om => 0007, gm => 0070, um => 0700 ); ## no critic
0.000008,3,0.000003,{ my $m = 0; $MODEBITS{$_} = ( 1 << $m++ ) for qw/ox ow or gx gw gr ux uw ur/ };
0.000000,0,0.000000,
0.000000,0,0.000000,sub _symbolic_chmod {
0.000000,0,0.000000,my ( $mode, $symbolic ) = @_;
0.000000,0,0.000000,for my $clause ( split /,\s*/, $symbolic ) {
0.000000,0,0.000000,if ( $clause =~ m{\A([augo]+)([=+-])([rwx]+)\z} ) {
0.000000,0,0.000000,my ( $who, $action, $perms ) = ( $1, $2, $3 );
0.000000,0,0.000000,$who =~ s/a/ugo/g;
0.000000,0,0.000000,for my $w ( split //, $who ) {
0.000000,0,0.000000,my $p = 0;
0.000000,0,0.000000,$p |= $MODEBITS{"$w$_"} for split //, $perms;
0.000000,0,0.000000,if ( $action eq '=' ) {
0.000000,0,0.000000,$mode = ( $mode & ~$MODEBITS{"${w}m"} ) | $p;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$mode = $action eq "+" ? ( $mode | $p ) : ( $mode & ~$p );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Carp::croak("Invalid mode clause '$clause' for chmod()");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return $mode;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# flock doesn't work on NFS on BSD or on some filesystems like lustre.
0.000000,0,0.000000,# Since program authors often can't control or detect that, we warn once
0.000000,0,0.000000,# instead of being fatal if we can detect it and people who need it strict
0.000000,0,0.000000,# can fatalize the 'flock' category
0.000000,0,0.000000,
0.000000,0,0.000000,#<<< No perltidy
0.004479,2,0.002239,{ package flock; use warnings::register }
0.000000,0,0.000000,#>>>
0.000000,0,0.000000,
0.000001,2,0.000000,my $WARNED_NO_FLOCK = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _throw {
0.000000,0,0.000000,my ( $self, $function, $file, $msg ) = @_;
0.000000,0,0.000000,if (   $function =~ /^flock/
0.000000,0,0.000000,&& $! =~ /operation not supported|function not implemented/i
0.000000,0,0.000000,&& !warnings::fatal_enabled('flock') )
0.000000,0,0.000000,{
0.000000,0,0.000000,if ( !$WARNED_NO_FLOCK ) {
0.000000,0,0.000000,warnings::warn( flock => "Flock not available: '$!': continuing in unsafe mode" );
0.000000,0,0.000000,$WARNED_NO_FLOCK++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$msg = $! unless defined $msg;
0.000000,0,0.000000,Path::Tiny::Error->throw( $function, ( defined $file ? $file : $self->[PATH] ),
0.000000,0,0.000000,$msg );
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# cheapo option validation
0.000000,0,0.000000,sub _get_args {
0.000019,28,0.000001,my ( $raw, @valid ) = @_;
0.000016,28,0.000001,if ( defined($raw) && ref($raw) ne 'HASH' ) {
0.000000,0,0.000000,my ( undef, undef, undef, $called_as ) = caller(1);
0.000000,0,0.000000,$called_as =~ s{^.*::}{};
0.000000,0,0.000000,Carp::croak("Options for $called_as must be a hash reference");
0.000000,0,0.000000,}
0.000010,28,0.000000,my $cooked = {};
0.000024,28,0.000001,for my $k (@valid) {
0.000039,42,0.000001,$cooked->{$k} = delete $raw->{$k} if exists $raw->{$k};
0.000000,0,0.000000,}
0.000009,28,0.000000,if ( keys %$raw ) {
0.000000,0,0.000000,my ( undef, undef, undef, $called_as ) = caller(1);
0.000000,0,0.000000,$called_as =~ s{^.*::}{};
0.000000,0,0.000000,Carp::croak( "Invalid option(s) for $called_as: " . join( ", ", keys %$raw ) );
0.000000,0,0.000000,}
0.000052,28,0.000002,return $cooked;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#--------------------------------------------------------------------------#
0.000000,0,0.000000,# Constructors
0.000000,0,0.000000,#--------------------------------------------------------------------------#
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =construct path
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $path = path("foo/bar");
0.000000,0,0.000000,#pod     $path = path("/tmp", "file.txt"); # list
0.000000,0,0.000000,#pod     $path = path(".");                # cwd
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
0.000000,0,0.000000,#pod directory path.  It's still up to you to call directory-like methods only on
0.000000,0,0.000000,#pod directories and file-like methods only on files.  This function is exported
0.000000,0,0.000000,#pod automatically by default.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod The first argument must be defined and have non-zero length or an exception
0.000000,0,0.000000,#pod will be thrown.  This prevents subtle, dangerous errors with code like
0.000000,0,0.000000,#pod C<< path( maybe_undef() )->remove_tree >>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod B<DEPRECATED>: If and only if the B<first> character of the B<first> argument
0.000000,0,0.000000,#pod to C<path> is a tilde ('~'), then tilde replacement will be applied to the
0.000000,0,0.000000,#pod first path segment. A single tilde will be replaced with C<glob('~')> and a
0.000000,0,0.000000,#pod tilde followed by a username will be replaced with output of
0.000000,0,0.000000,#pod C<glob('~username')>. B<No other method does tilde expansion on its arguments>.
0.000000,0,0.000000,#pod See L</Tilde expansion (deprecated)> for more.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod On Windows, if the path consists of a drive identifier without a path component
0.000000,0,0.000000,#pod (C<C:> or C<D:>), it will be expanded to the absolute path of the current
0.000000,0,0.000000,#pod directory on that volume using C<Cwd::getdcwd()>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If called with a single C<Path::Tiny> argument, the original is returned unless
0.000000,0,0.000000,#pod the original is holding a temporary file or directory reference in which case a
0.000000,0,0.000000,#pod stringified copy is made.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $path = path("foo/bar");
0.000000,0,0.000000,#pod     $temp = Path::Tiny->tempfile;
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $p2 = path($path); # like $p2 = $path
0.000000,0,0.000000,#pod     $t2 = path($temp); # like $t2 = path( "$temp" )
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod This optimizes copies without proliferating references unexpectedly if a copy is
0.000000,0,0.000000,#pod made by code outside your control.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.017.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub path {
0.000004,14,0.000000,my $path = shift;
0.000000,0,0.000000,Carp::croak("Path::Tiny paths require defined, positive-length parts")
0.000033,14,0.000002,unless 1 + @_ == grep { defined && length } $path, @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# non-temp Path::Tiny objects are effectively immutable and can be reused
0.000001,14,0.000000,if ( !@_ && ref($path) eq __PACKAGE__ && !$path->[TEMP] ) {
0.000000,0,0.000000,return $path;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# stringify objects
0.000002,14,0.000000,$path = "$path";
0.000000,0,0.000000,
0.000000,0,0.000000,# do any tilde expansions
0.000045,14,0.000003,my ($tilde) = $path =~ m{^(~[^/]*)};
0.000001,14,0.000000,if ( defined $tilde ) {
0.000000,0,0.000000,# Escape File::Glob metacharacters
0.000000,0,0.000000,(my $escaped = $tilde) =~ s/([\[\{\*\?\\])/\\$1/g;
0.000000,0,0.000000,require File::Glob;
0.000000,0,0.000000,my ($homedir) = File::Glob::bsd_glob($escaped);
0.000000,0,0.000000,if (defined $homedir && ! $File::Glob::ERROR) {
0.000000,0,0.000000,$homedir =~ tr[\\][/] if IS_WIN32();
0.000000,0,0.000000,$path =~ s{^\Q$tilde\E}{$homedir};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000013,14,0.000001,unshift @_, $path;
0.000064,14,0.000005,goto &_pathify;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# _path is like path but without tilde expansion
0.000000,0,0.000000,sub _path {
0.000000,0,0.000000,my $path = shift;
0.000000,0,0.000000,Carp::croak("Path::Tiny paths require defined, positive-length parts")
0.000000,0,0.000000,unless 1 + @_ == grep { defined && length } $path, @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# non-temp Path::Tiny objects are effectively immutable and can be reused
0.000000,0,0.000000,if ( !@_ && ref($path) eq __PACKAGE__ && !$path->[TEMP] ) {
0.000000,0,0.000000,return $path;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# stringify objects
0.000000,0,0.000000,$path = "$path";
0.000000,0,0.000000,
0.000000,0,0.000000,unshift @_, $path;
0.000000,0,0.000000,goto &_pathify;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# _pathify expects one or more string arguments, then joins and canonicalizes
0.000000,0,0.000000,# them into an object.
0.000000,0,0.000000,sub _pathify {
0.000007,14,0.000000,my $path = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# expand relative volume paths on windows; put trailing slash on UNC root
0.000000,0,0.000000,if ( IS_WIN32() ) {
0.000000,0,0.000000,$path = _win32_vol( $path, $1 ) if $path =~ m{^($DRV_VOL)(?:$NOTSLASH|\z)};
0.000000,0,0.000000,$path .= "/" if $path =~ m{^$UNC_VOL\z};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# concatenations stringifies objects, too
0.000050,14,0.000004,if (@_) {
0.000000,0,0.000000,$path .= ( _is_root($path) ? "" : "/" ) . join( "/", @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# canonicalize, but with unix slashes and put back trailing volume slash
0.000047,14,0.000003,my $cpath = $path = File::Spec->canonpath($path);
0.000000,0,0.000000,$path =~ tr[\\][/] if IS_WIN32();
0.000006,14,0.000000,$path = "/" if $path eq '/..'; # for old File::Spec
0.000000,0,0.000000,$path .= "/" if IS_WIN32() && $path =~ m{^$UNC_VOL\z};
0.000000,0,0.000000,
0.000000,0,0.000000,# root paths must always have a trailing slash, but other paths must not
0.000018,14,0.000001,if ( _is_root($path) ) {
0.000000,0,0.000000,$path =~ s{/?\z}{/};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000029,14,0.000002,$path =~ s{/\z}{};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000104,14,0.000007,bless [ $path, $cpath ], __PACKAGE__;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =construct new
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $path = Path::Tiny->new("foo/bar");
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod This is just like C<path>, but with method call overhead.  (Why would you
0.000000,0,0.000000,#pod do that?)
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.001.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub new { shift; path(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =construct cwd
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $path = Path::Tiny->cwd; # path( Cwd::getcwd )
0.000000,0,0.000000,#pod     $path = cwd; # optional export
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Gives you the absolute path to the current directory as a C<Path::Tiny> object.
0.000000,0,0.000000,#pod This is slightly faster than C<< path(".")->absolute >>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<cwd> may be exported on request and used as a function instead of as a
0.000000,0,0.000000,#pod method.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.018.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub cwd {
0.000000,0,0.000000,require Cwd;
0.000000,0,0.000000,return _path( Cwd::getcwd() );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =construct rootdir
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $path = Path::Tiny->rootdir; # /
0.000000,0,0.000000,#pod     $path = rootdir;             # optional export 
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
0.000000,0,0.000000,#pod picky for C<path("/")>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<rootdir> may be exported on request and used as a function instead of as a
0.000000,0,0.000000,#pod method.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.018.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub rootdir { _path( File::Spec->rootdir ) }
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =construct tempfile, tempdir
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $temp = Path::Tiny->tempfile( @options );
0.000000,0,0.000000,#pod     $temp = Path::Tiny->tempdir( @options );
0.000000,0,0.000000,#pod     $temp = $dirpath->tempfile( @options );
0.000000,0,0.000000,#pod     $temp = $dirpath->tempdir( @options );
0.000000,0,0.000000,#pod     $temp = tempfile( @options ); # optional export
0.000000,0,0.000000,#pod     $temp = tempdir( @options );  # optional export
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<tempfile> passes the options to C<< File::Temp->new >> and returns a
0.000000,0,0.000000,#pod C<Path::Tiny> object with the file name.  The C<TMPDIR> option will be enabled
0.000000,0,0.000000,#pod by default, but you can override that by passing C<< TMPDIR => 0 >> along with
0.000000,0,0.000000,#pod the options.  (If you use an absolute C<TEMPLATE> option, you will want to
0.000000,0,0.000000,#pod disable C<TMPDIR>.)
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
0.000000,0,0.000000,#pod destroyed, the C<File::Temp> object will be as well.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<File::Temp> annoyingly requires you to specify a custom template in slightly
0.000000,0,0.000000,#pod different ways depending on which function or method you call, but
0.000000,0,0.000000,#pod C<Path::Tiny> lets you ignore that and can take either a leading template or a
0.000000,0,0.000000,#pod C<TEMPLATE> option and does the right thing.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
0.000000,0,0.000000,#pod     $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod The tempfile path object will be normalized to have an absolute path, even if
0.000000,0,0.000000,#pod created in a relative directory using C<DIR>.  If you want it to have
0.000000,0,0.000000,#pod the C<realpath> instead, pass a leading options hash like this:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $real_temp = tempfile({realpath => 1}, @options);
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<tempdir> is just like C<tempfile>, except it calls
0.000000,0,0.000000,#pod C<< File::Temp->newdir >> instead.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Both C<tempfile> and C<tempdir> may be exported on request and used as
0.000000,0,0.000000,#pod functions instead of as methods.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod The methods can be called on an instances representing a
0.000000,0,0.000000,#pod directory. In this case, the directory is used as the base to create the
0.000000,0,0.000000,#pod temporary file/directory, setting the C<DIR> option in File::Temp.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     my $target_dir = path('/to/destination');
0.000000,0,0.000000,#pod     my $tempfile = $target_dir->tempfile('foobarXXXXXX');
0.000000,0,0.000000,#pod     $tempfile->spew('A lot of data...');  # not atomic
0.000000,0,0.000000,#pod     $tempfile->move($target_dir->child('foobar')); # hopefully atomic
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod In this case, any value set for option C<DIR> is ignored.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod B<Note>: for tempfiles, the filehandles from File::Temp are closed and not
0.000000,0,0.000000,#pod reused.  This is not as secure as using File::Temp handles directly, but is
0.000000,0,0.000000,#pod less prone to deadlocks or access problems on some platforms.  Think of what
0.000000,0,0.000000,#pod C<Path::Tiny> gives you to be just a temporary file B<name> that gets cleaned
0.000000,0,0.000000,#pod up.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod B<Note 2>: if you don't want these cleaned up automatically when the object
0.000000,0,0.000000,#pod is destroyed, File::Temp requires different options for directories and
0.000000,0,0.000000,#pod files.  Use C<< CLEANUP => 0 >> for directories and C<< UNLINK => 0 >> for
0.000000,0,0.000000,#pod files.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod B<Note 3>: Don't lose the temporary object by chaining a method call instead
0.000000,0,0.000000,#pod of storing it:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     my $lost = tempdir()->child("foo"); # tempdir cleaned up right away
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod B<Note 4>: The cached object may be accessed with the L</cached_temp> method.
0.000000,0,0.000000,#pod Keeping a reference to, or modifying the cached object may break the
0.000000,0,0.000000,#pod behavior documented above and is not supported.  Use at your own risk.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.119.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub tempfile {
0.000000,0,0.000000,my ( $opts, $maybe_template, $args )
0.000000,0,0.000000,= _parse_file_temp_args(tempfile => @_);
0.000000,0,0.000000,
0.000000,0,0.000000,# File::Temp->new demands TEMPLATE
0.000000,0,0.000000,$args->{TEMPLATE} = $maybe_template->[0] if @$maybe_template;
0.000000,0,0.000000,
0.000000,0,0.000000,require File::Temp;
0.000000,0,0.000000,my $temp = File::Temp->new( TMPDIR => 1, %$args );
0.000000,0,0.000000,close $temp;
0.000000,0,0.000000,my $self = $opts->{realpath} ? _path($temp)->realpath : _path($temp)->absolute;
0.000000,0,0.000000,$self->[TEMP] = $temp;                # keep object alive while we are
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub tempdir {
0.000000,0,0.000000,my ( $opts, $maybe_template, $args )
0.000000,0,0.000000,= _parse_file_temp_args(tempdir => @_);
0.000000,0,0.000000,
0.000000,0,0.000000,require File::Temp;
0.000000,0,0.000000,my $temp = File::Temp->newdir( @$maybe_template, TMPDIR => 1, %$args );
0.000000,0,0.000000,my $self = $opts->{realpath} ? _path($temp)->realpath : _path($temp)->absolute;
0.000000,0,0.000000,$self->[TEMP] = $temp;                # keep object alive while we are
0.000000,0,0.000000,# Some ActiveState Perls for Windows break Cwd in ways that lead
0.000000,0,0.000000,# File::Temp to get confused about what path to remove; this
0.000000,0,0.000000,# monkey-patches the object with our own view of the absolute path
0.000000,0,0.000000,$temp->{REALNAME} = $self->[CANON] if IS_WIN32;
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# normalize the various ways File::Temp does templates
0.000000,0,0.000000,sub _parse_file_temp_args {
0.000000,0,0.000000,my $called_as = shift;
0.000000,0,0.000000,if ( @_ && $_[0] eq 'Path::Tiny' ) { shift } # class method
0.000000,0,0.000000,elsif ( @_ && eval{$_[0]->isa('Path::Tiny')} ) {
0.000000,0,0.000000,my $dir = shift;
0.000000,0,0.000000,if (! $dir->is_dir) {
0.000000,0,0.000000,$dir->_throw( $called_as, $dir, "is not a directory object" );
0.000000,0,0.000000,}
0.000000,0,0.000000,push @_, DIR => $dir->stringify; # no overriding
0.000000,0,0.000000,}
0.000000,0,0.000000,my $opts = ( @_ && ref $_[0] eq 'HASH' ) ? shift @_ : {};
0.000000,0,0.000000,$opts = _get_args( $opts, qw/realpath/ );
0.000000,0,0.000000,
0.000000,0,0.000000,my $leading_template = ( scalar(@_) % 2 == 1 ? shift(@_) : '' );
0.000000,0,0.000000,my %args = @_;
0.000000,0,0.000000,%args = map { uc($_), $args{$_} } keys %args;
0.000000,0,0.000000,my @template = (
0.000000,0,0.000000,exists $args{TEMPLATE} ? delete $args{TEMPLATE}
0.000000,0,0.000000,: $leading_template      ? $leading_template
0.000000,0,0.000000,:                          ()
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,return ( $opts, \@template, \%args );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#--------------------------------------------------------------------------#
0.000000,0,0.000000,# Private methods
0.000000,0,0.000000,#--------------------------------------------------------------------------#
0.000000,0,0.000000,
0.000000,0,0.000000,sub _splitpath {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,@{$self}[ VOL, DIR, FILE ] = File::Spec->splitpath( $self->[PATH] );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _resolve_symlinks {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my $new = $self;
0.000000,0,0.000000,my ( $count, %seen ) = 0;
0.000000,0,0.000000,while ( -l $new->[PATH] ) {
0.000000,0,0.000000,if ( $seen{ $new->[PATH] }++ ) {
0.000000,0,0.000000,$self->_throw( 'readlink', $self->[PATH], "symlink loop detected" );
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( ++$count > 100 ) {
0.000000,0,0.000000,$self->_throw( 'readlink', $self->[PATH], "maximum symlink depth exceeded" );
0.000000,0,0.000000,}
0.000000,0,0.000000,my $resolved = readlink $new->[PATH];
0.000000,0,0.000000,$new->_throw( 'readlink', $new->[PATH] ) unless defined $resolved;
0.000000,0,0.000000,$resolved = _path($resolved);
0.000000,0,0.000000,$new = $resolved->is_absolute ? $resolved : $new->sibling($resolved);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _replacment_path {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $unique_suffix = $$ . int( rand( 2**31 ) );
0.000000,0,0.000000,my $temp          = _path( $self . $unique_suffix );
0.000000,0,0.000000,
0.000000,0,0.000000,# If filename with process+random suffix is too long, use a shorter
0.000000,0,0.000000,# version that doesn't preserve the basename.
0.000000,0,0.000000,if ( length $temp->basename > 255 ) {
0.000000,0,0.000000,$temp = $self->sibling( "temp" . $unique_suffix );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $temp;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#--------------------------------------------------------------------------#
0.000000,0,0.000000,# Public methods
0.000000,0,0.000000,#--------------------------------------------------------------------------#
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method absolute
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $abs = path("foo/bar")->absolute;
0.000000,0,0.000000,#pod     $abs = path("foo/bar")->absolute("/tmp");
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns a new C<Path::Tiny> object with an absolute path (or itself if already
0.000000,0,0.000000,#pod absolute).  If no argument is given, the current directory is used as the
0.000000,0,0.000000,#pod absolute base path.  If an argument is given, it will be converted to an
0.000000,0,0.000000,#pod absolute path (if it is not already) and used as the absolute base path.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod This will not resolve upward directories ("foo/../bar") unless C<canonpath>
0.000000,0,0.000000,#pod in L<File::Spec> would normally do so on your platform.  If you need them
0.000000,0,0.000000,#pod resolved, you must call the more expensive C<realpath> method instead.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod On Windows, an absolute path without a volume component will have it added
0.000000,0,0.000000,#pod based on the current drive.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.101.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub absolute {
0.000000,0,0.000000,my ( $self, $base ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# absolute paths handled differently by OS
0.000000,0,0.000000,if (IS_WIN32) {
0.000000,0,0.000000,return $self if length $self->volume;
0.000000,0,0.000000,# add missing volume
0.000000,0,0.000000,if ( $self->is_absolute ) {
0.000000,0,0.000000,require Cwd;
0.000000,0,0.000000,# use Win32::GetCwd not Cwd::getdcwd because we're sure
0.000000,0,0.000000,# to have the former but not necessarily the latter
0.000000,0,0.000000,my ($drv) = Win32::GetCwd() =~ /^($DRV_VOL | $UNC_VOL)/x;
0.000000,0,0.000000,return _path( $drv . $self->[PATH] );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $self if $self->is_absolute;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# no base means use current directory as base
0.000000,0,0.000000,require Cwd;
0.000000,0,0.000000,return _path( Cwd::getcwd(), $_[0]->[PATH] ) unless defined $base;
0.000000,0,0.000000,
0.000000,0,0.000000,# relative base should be made absolute; we check is_absolute rather
0.000000,0,0.000000,# than unconditionally make base absolute so that "/foo" doesn't become
0.000000,0,0.000000,# "C:/foo" on Windows.
0.000000,0,0.000000,$base = _path($base);
0.000000,0,0.000000,return _path( ( $base->is_absolute ? $base : $base->absolute ), $_[0]->[PATH] );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method append, append_raw, append_utf8
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("foo.txt")->append(@data);
0.000000,0,0.000000,#pod     path("foo.txt")->append(\@data);
0.000000,0,0.000000,#pod     path("foo.txt")->append({binmode => ":raw"}, @data);
0.000000,0,0.000000,#pod     path("foo.txt")->append_raw(@data);
0.000000,0,0.000000,#pod     path("foo.txt")->append_utf8(@data);
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Appends data to a file.  The file is locked with C<flock> prior to writing
0.000000,0,0.000000,#pod and closed afterwards.  An optional hash reference may be used to pass
0.000000,0,0.000000,#pod options.  Valid options are:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =for :list
0.000000,0,0.000000,#pod * C<binmode>: passed to C<binmode()> on the handle used for writing.
0.000000,0,0.000000,#pod * C<truncate>: truncates the file after locking and before appending
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod The C<truncate> option is a way to replace the contents of a file
0.000000,0,0.000000,#pod B<in place>, unlike L</spew> which writes to a temporary file and then
0.000000,0,0.000000,#pod replaces the original (if it exists).
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<append_raw> is like C<append> with a C<binmode> of C<:unix> for a fast,
0.000000,0,0.000000,#pod unbuffered, raw write.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<append_utf8> is like C<append> with an unbuffered C<binmode>
0.000000,0,0.000000,#pod C<:unix:encoding(UTF-8)> (or C<:unix:utf8_strict> with
0.000000,0,0.000000,#pod L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, an
0.000000,0,0.000000,#pod unbuffered, raw append will be done instead on the data encoded with
0.000000,0,0.000000,#pod C<Unicode::UTF8>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.060.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub append {
0.000000,0,0.000000,my ( $self, @data ) = @_;
0.000000,0,0.000000,my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
0.000000,0,0.000000,$args = _get_args( $args, qw/binmode truncate/ );
0.000000,0,0.000000,my $binmode = $args->{binmode};
0.000000,0,0.000000,$binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
0.000000,0,0.000000,my $mode = $args->{truncate} ? ">" : ">>";
0.000000,0,0.000000,my $fh = $self->filehandle( { locked => 1 }, $mode, $binmode );
0.000000,0,0.000000,print( {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data ) or self->_throw('print');
0.000000,0,0.000000,close $fh or $self->_throw('close');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub append_raw {
0.000000,0,0.000000,my ( $self, @data ) = @_;
0.000000,0,0.000000,my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
0.000000,0,0.000000,$args = _get_args( $args, qw/binmode truncate/ );
0.000000,0,0.000000,$args->{binmode} = ':unix';
0.000000,0,0.000000,append( $self, $args, @data );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub append_utf8 {
0.000000,0,0.000000,my ( $self, @data ) = @_;
0.000000,0,0.000000,my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
0.000000,0,0.000000,$args = _get_args( $args, qw/binmode truncate/ );
0.000000,0,0.000000,if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
0.000000,0,0.000000,$args->{binmode} = ":unix";
0.000000,0,0.000000,append( $self, $args, map { Unicode::UTF8::encode_utf8($_) } @data );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
0.000000,0,0.000000,$args->{binmode} = ":unix:utf8_strict";
0.000000,0,0.000000,append( $self, $args, @data );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$args->{binmode} = ":unix:encoding(UTF-8)";
0.000000,0,0.000000,append( $self, $args, @data );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method assert
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $path = path("foo.txt")->assert( sub { $_->exists } );
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns the invocant after asserting that a code reference argument returns
0.000000,0,0.000000,#pod true.  When the assertion code reference runs, it will have the invocant
0.000000,0,0.000000,#pod object in the C<$_> variable.  If it returns false, an exception will be
0.000000,0,0.000000,#pod thrown.  The assertion code reference may also throw its own exception.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If no assertion is provided, the invocant is returned without error.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.062.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub assert {
0.000000,0,0.000000,my ( $self, $assertion ) = @_;
0.000000,0,0.000000,return $self unless $assertion;
0.000000,0,0.000000,if ( ref $assertion eq 'CODE' ) {
0.000000,0,0.000000,local $_ = $self;
0.000000,0,0.000000,$assertion->()
0.000000,0,0.000000,or Path::Tiny::Error->throw( "assert", $self->[PATH], "failed assertion" );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Carp::croak("argument to assert must be a code reference argument");
0.000000,0,0.000000,}
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method basename
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $name = path("foo/bar.txt")->basename;        # bar.txt
0.000000,0,0.000000,#pod     $name = path("foo.txt")->basename('.txt');    # foo
0.000000,0,0.000000,#pod     $name = path("foo.txt")->basename(qr/.txt/);  # foo
0.000000,0,0.000000,#pod     $name = path("foo.txt")->basename(@suffixes);
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns the file portion or last directory portion of a path.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Given a list of suffixes as strings or regular expressions, any that match at
0.000000,0,0.000000,#pod the end of the file portion or last directory portion will be removed before
0.000000,0,0.000000,#pod the result is returned.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.054.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub basename {
0.000000,0,0.000000,my ( $self, @suffixes ) = @_;
0.000000,0,0.000000,$self->_splitpath unless defined $self->[FILE];
0.000000,0,0.000000,my $file = $self->[FILE];
0.000000,0,0.000000,for my $s (@suffixes) {
0.000000,0,0.000000,my $re = ref($s) eq 'Regexp' ? qr/$s\z/ : qr/\Q$s\E\z/;
0.000000,0,0.000000,last if $file =~ s/$re//;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $file;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method canonpath
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns a string with the canonical format of the path name for
0.000000,0,0.000000,#pod the platform.  In particular, this means directory separators
0.000000,0,0.000000,#pod will be C<\> on Windows.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.001.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub canonpath { $_[0]->[CANON] }
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method cached_temp
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns the cached C<File::Temp> or C<File::Temp::Dir> object if the
0.000000,0,0.000000,#pod C<Path::Tiny> object was created with C</tempfile> or C</tempdir>.
0.000000,0,0.000000,#pod If there is no such object, this method throws.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod B<WARNING>: Keeping a reference to, or modifying the cached object may
0.000000,0,0.000000,#pod break the behavior documented for temporary files and directories created
0.000000,0,0.000000,#pod with C<Path::Tiny> and is not supported.  Use at your own risk.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.101.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub cached_temp {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->_throw( "cached_temp", $self, "has no cached File::Temp object" )
0.000000,0,0.000000,unless defined $self->[TEMP];
0.000000,0,0.000000,return $self->[TEMP];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method child
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
0.000000,0,0.000000,#pod     $file = path("/tmp")->child(@parts);
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns a new C<Path::Tiny> object relative to the original.  Works
0.000000,0,0.000000,#pod like C<catfile> or C<catdir> from File::Spec, but without caring about
0.000000,0,0.000000,#pod file or directories.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod B<WARNING>: because the argument could contain C<..> or refer to symlinks,
0.000000,0,0.000000,#pod there is no guarantee that the new path refers to an actual descendent of
0.000000,0,0.000000,#pod the original.  If this is important to you, transform parent and child with
0.000000,0,0.000000,#pod L</realpath> and check them with L</subsumes>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.001.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub child {
0.000000,0,0.000000,my ( $self, @parts ) = @_;
0.000000,0,0.000000,return _path( $self->[PATH], @parts );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method children
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     @paths = path("/tmp")->children;
0.000000,0,0.000000,#pod     @paths = path("/tmp")->children( qr/\.txt\z/ );
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns a list of C<Path::Tiny> objects for all files and directories
0.000000,0,0.000000,#pod within a directory.  Excludes "." and ".." automatically.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If an optional C<qr//> argument is provided, it only returns objects for child
0.000000,0,0.000000,#pod names that match the given regular expression.  Only the base name is used
0.000000,0,0.000000,#pod for matching:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     @paths = path("/tmp")->children( qr/^foo/ );
0.000000,0,0.000000,#pod     # matches children like the glob foo*
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.028.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub children {
0.000000,0,0.000000,my ( $self, $filter ) = @_;
0.000000,0,0.000000,my $dh;
0.000000,0,0.000000,opendir $dh, $self->[PATH] or $self->_throw('opendir');
0.000000,0,0.000000,my @children = readdir $dh;
0.000000,0,0.000000,closedir $dh or $self->_throw('closedir');
0.000000,0,0.000000,
0.000000,0,0.000000,if ( not defined $filter ) {
0.000000,0,0.000000,@children = grep { $_ ne '.' && $_ ne '..' } @children;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $filter && ref($filter) eq 'Regexp' ) {
0.000000,0,0.000000,@children = grep { $_ ne '.' && $_ ne '..' && $_ =~ $filter } @children;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Carp::croak("Invalid argument '$filter' for children()");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return map { _path( $self->[PATH], $_ ) } @children;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method chmod
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("foo.txt")->chmod(0777);
0.000000,0,0.000000,#pod     path("foo.txt")->chmod("0755");
0.000000,0,0.000000,#pod     path("foo.txt")->chmod("go-w");
0.000000,0,0.000000,#pod     path("foo.txt")->chmod("a=r,u+wx");
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Sets file or directory permissions.  The argument can be a numeric mode, a
0.000000,0,0.000000,#pod octal string beginning with a "0" or a limited subset of the symbolic mode use
0.000000,0,0.000000,#pod by F</bin/chmod>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod The symbolic mode must be a comma-delimited list of mode clauses.  Clauses must
0.000000,0,0.000000,#pod match C<< qr/\A([augo]+)([=+-])([rwx]+)\z/ >>, which defines "who", "op" and
0.000000,0,0.000000,#pod "perms" parameters for each clause.  Unlike F</bin/chmod>, all three parameters
0.000000,0,0.000000,#pod are required for each clause, multiple ops are not allowed and permissions
0.000000,0,0.000000,#pod C<stugoX> are not supported.  (See L<File::chmod> for more complex needs.)
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.053.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub chmod {
0.000000,0,0.000000,my ( $self, $new_mode ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $mode;
0.000000,0,0.000000,if ( $new_mode =~ /\d/ ) {
0.000000,0,0.000000,$mode = ( $new_mode =~ /^0/ ? oct($new_mode) : $new_mode );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $new_mode =~ /[=+-]/ ) {
0.000000,0,0.000000,$mode = _symbolic_chmod( $self->stat->mode & 07777, $new_mode ); ## no critic
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Carp::croak("Invalid mode argument '$new_mode' for chmod()");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,CORE::chmod( $mode, $self->[PATH] ) or $self->_throw("chmod");
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method copy
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("/tmp/foo.txt")->copy("/tmp/bar.txt");
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Copies the current path to the given destination using L<File::Copy>'s
0.000000,0,0.000000,#pod C<copy> function. Upon success, returns the C<Path::Tiny> object for the
0.000000,0,0.000000,#pod newly copied file.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.070.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX do recursively for directories?
0.000000,0,0.000000,sub copy {
0.000000,0,0.000000,my ( $self, $dest ) = @_;
0.000000,0,0.000000,require File::Copy;
0.000000,0,0.000000,File::Copy::copy( $self->[PATH], $dest )
0.000000,0,0.000000,or Carp::croak("copy failed for $self to $dest: $!");
0.000000,0,0.000000,
0.000000,0,0.000000,return -d $dest ? _path( $dest, $self->basename ) : _path($dest);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method digest
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $obj = path("/tmp/foo.txt")->digest;        # SHA-256
0.000000,0,0.000000,#pod     $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
0.000000,0,0.000000,#pod     $obj = path("/tmp/foo.txt")->digest( { chunk_size => 1e6 }, "MD5" );
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns a hexadecimal digest for a file.  An optional hash reference of options may
0.000000,0,0.000000,#pod be given.  The only option is C<chunk_size>.  If C<chunk_size> is given, that many
0.000000,0,0.000000,#pod bytes will be read at a time.  If not provided, the entire file will be slurped
0.000000,0,0.000000,#pod into memory to compute the digest.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Any subsequent arguments are passed to the constructor for L<Digest> to select
0.000000,0,0.000000,#pod an algorithm.  If no arguments are given, the default is SHA-256.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.056.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub digest {
0.000000,0,0.000000,my ( $self, @opts ) = @_;
0.000000,0,0.000000,my $args = ( @opts && ref $opts[0] eq 'HASH' ) ? shift @opts : {};
0.000000,0,0.000000,$args = _get_args( $args, qw/chunk_size/ );
0.000000,0,0.000000,unshift @opts, 'SHA-256' unless @opts;
0.000000,0,0.000000,require Digest;
0.000000,0,0.000000,my $digest = Digest->new(@opts);
0.000000,0,0.000000,if ( $args->{chunk_size} ) {
0.000000,0,0.000000,my $fh = $self->filehandle( { locked => 1 }, "<", ":unix" );
0.000000,0,0.000000,my $buf;
0.000000,0,0.000000,while (!eof($fh)) {
0.000000,0,0.000000,my $rc = read $fh, $buf, $args->{chunk_size};
0.000000,0,0.000000,$self->_throw('read') unless defined $rc;
0.000000,0,0.000000,$digest->add($buf);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$digest->add( $self->slurp_raw );
0.000000,0,0.000000,}
0.000000,0,0.000000,return $digest->hexdigest;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method dirname (deprecated)
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns the directory portion you would get from calling
0.000000,0,0.000000,#pod C<< File::Spec->splitpath( $path->stringify ) >> or C<"."> for a path without a
0.000000,0,0.000000,#pod parent directory portion.  Because L<File::Spec> is inconsistent, the result
0.000000,0,0.000000,#pod might or might not have a trailing slash.  Because of this, this method is
0.000000,0,0.000000,#pod B<deprecated>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod A better, more consistently approach is likely C<< $path->parent->stringify >>,
0.000000,0,0.000000,#pod which will not have a trailing slash except for a root directory.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Deprecated in 0.056.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub dirname {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,$self->_splitpath unless defined $self->[DIR];
0.000000,0,0.000000,return length $self->[DIR] ? $self->[DIR] : ".";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method edit, edit_raw, edit_utf8
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("foo.txt")->edit( \&callback, $options );
0.000000,0,0.000000,#pod     path("foo.txt")->edit_utf8( \&callback );
0.000000,0,0.000000,#pod     path("foo.txt")->edit_raw( \&callback );
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod These are convenience methods that allow "editing" a file using a single
0.000000,0,0.000000,#pod callback argument. They slurp the file using C<slurp>, place the contents
0.000000,0,0.000000,#pod inside a localized C<$_> variable, call the callback function (without
0.000000,0,0.000000,#pod arguments), and then write C<$_> (presumably mutated) back to the
0.000000,0,0.000000,#pod file with C<spew>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod An optional hash reference may be used to pass options.  The only option is
0.000000,0,0.000000,#pod C<binmode>, which is passed to C<slurp> and C<spew>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<edit_utf8> and C<edit_raw> act like their respective C<slurp_*> and
0.000000,0,0.000000,#pod C<spew_*> methods.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.077.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub edit {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $cb   = shift;
0.000000,0,0.000000,my $args = _get_args( shift, qw/binmode/ );
0.000000,0,0.000000,Carp::croak("Callback for edit() must be a code reference")
0.000000,0,0.000000,unless defined($cb) && ref($cb) eq 'CODE';
0.000000,0,0.000000,
0.000000,0,0.000000,local $_ =
0.000000,0,0.000000,$self->slurp( exists( $args->{binmode} ) ? { binmode => $args->{binmode} } : () );
0.000000,0,0.000000,$cb->();
0.000000,0,0.000000,$self->spew( $args, $_ );
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# this is done long-hand to benefit from slurp_utf8 optimizations
0.000000,0,0.000000,sub edit_utf8 {
0.000000,0,0.000000,my ( $self, $cb ) = @_;
0.000000,0,0.000000,Carp::croak("Callback for edit_utf8() must be a code reference")
0.000000,0,0.000000,unless defined($cb) && ref($cb) eq 'CODE';
0.000000,0,0.000000,
0.000000,0,0.000000,local $_ = $self->slurp_utf8;
0.000000,0,0.000000,$cb->();
0.000000,0,0.000000,$self->spew_utf8($_);
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub edit_raw { $_[2] = { binmode => ":unix" }; goto &edit }
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method edit_lines, edit_lines_utf8, edit_lines_raw
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("foo.txt")->edit_lines( \&callback, $options );
0.000000,0,0.000000,#pod     path("foo.txt")->edit_lines_utf8( \&callback );
0.000000,0,0.000000,#pod     path("foo.txt")->edit_lines_raw( \&callback );
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod These are convenience methods that allow "editing" a file's lines using a
0.000000,0,0.000000,#pod single callback argument.  They iterate over the file: for each line, the
0.000000,0,0.000000,#pod line is put into a localized C<$_> variable, the callback function is
0.000000,0,0.000000,#pod executed (without arguments) and then C<$_> is written to a temporary file.
0.000000,0,0.000000,#pod When iteration is finished, the temporary file is atomically renamed over
0.000000,0,0.000000,#pod the original.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod An optional hash reference may be used to pass options.  The only option is
0.000000,0,0.000000,#pod C<binmode>, which is passed to the method that open handles for reading and
0.000000,0,0.000000,#pod writing.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<edit_lines_raw> is like C<edit_lines> with a buffered C<binmode> of
0.000000,0,0.000000,#pod C<:raw>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<edit_lines_utf8> is like C<edit_lines> with a buffered C<binmode>
0.000000,0,0.000000,#pod C<:raw:encoding(UTF-8)> (or C<:raw:utf8_strict> with
0.000000,0,0.000000,#pod L<PerlIO::utf8_strict>).
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.077.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub edit_lines {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $cb   = shift;
0.000000,0,0.000000,my $args = _get_args( shift, qw/binmode/ );
0.000000,0,0.000000,Carp::croak("Callback for edit_lines() must be a code reference")
0.000000,0,0.000000,unless defined($cb) && ref($cb) eq 'CODE';
0.000000,0,0.000000,
0.000000,0,0.000000,my $binmode = $args->{binmode};
0.000000,0,0.000000,# get default binmode from caller's lexical scope (see "perldoc open")
0.000000,0,0.000000,$binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
0.000000,0,0.000000,
0.000000,0,0.000000,# writing needs to follow the link and create the tempfile in the same
0.000000,0,0.000000,# dir for later atomic rename
0.000000,0,0.000000,my $resolved_path = $self->_resolve_symlinks;
0.000000,0,0.000000,my $temp          = $resolved_path->_replacment_path;
0.000000,0,0.000000,
0.000000,0,0.000000,my $temp_fh = $temp->filehandle( { exclusive => 1, locked => 1 }, ">", $binmode );
0.000000,0,0.000000,my $in_fh = $self->filehandle( { locked => 1 }, '<', $binmode );
0.000000,0,0.000000,
0.000000,0,0.000000,local $_;
0.000000,0,0.000000,while (! eof($in_fh) ) {
0.000000,0,0.000000,defined( $_ = readline($in_fh) ) or $self->_throw('readline');
0.000000,0,0.000000,$cb->();
0.000000,0,0.000000,$temp_fh->print($_) or self->_throw('print', $temp);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,close $temp_fh or $self->_throw( 'close', $temp );
0.000000,0,0.000000,close $in_fh or $self->_throw('close');
0.000000,0,0.000000,
0.000000,0,0.000000,return $temp->move($resolved_path);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub edit_lines_raw { $_[2] = { binmode => ":raw" }; goto &edit_lines }
0.000000,0,0.000000,
0.000000,0,0.000000,sub edit_lines_utf8 {
0.000000,0,0.000000,if ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
0.000000,0,0.000000,$_[2] = { binmode => ":raw:utf8_strict" };
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$_[2] = { binmode => ":raw:encoding(UTF-8)" };
0.000000,0,0.000000,}
0.000000,0,0.000000,goto &edit_lines;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method exists, is_file, is_dir
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     if ( path("/tmp")->exists ) { ... }     # -e
0.000000,0,0.000000,#pod     if ( path("/tmp")->is_dir ) { ... }     # -d
0.000000,0,0.000000,#pod     if ( path("/tmp")->is_file ) { ... }    # -e && ! -d
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Implements file test operations, this means the file or directory actually has
0.000000,0,0.000000,#pod to exist on the filesystem.  Until then, it's just a path.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod B<Note>: C<is_file> is not C<-f> because C<-f> is not the opposite of C<-d>.
0.000000,0,0.000000,#pod C<-f> means "plain file", excluding symlinks, devices, etc. that often can be
0.000000,0,0.000000,#pod read just like files.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Use C<-f> instead if you really mean to check for a plain file.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.053.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub exists { -e $_[0]->[PATH] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_file { -e $_[0]->[PATH] && !-d _ }
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_dir { -d $_[0]->[PATH] }
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method filehandle
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
0.000000,0,0.000000,#pod     $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
0.000000,0,0.000000,#pod     $fh = path("/tmp/foo.txt")->filehandle({ exclusive => 1  }, $mode, $binmode);
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns an open file handle.  The C<$mode> argument must be a Perl-style
0.000000,0,0.000000,#pod read/write mode string ("<" ,">", ">>", etc.).  If a C<$binmode>
0.000000,0,0.000000,#pod is given, it is set during the C<open> call.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod An optional hash reference may be used to pass options.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod The C<locked> option governs file locking; if true, handles opened for writing,
0.000000,0,0.000000,#pod appending or read-write are locked with C<LOCK_EX>; otherwise, they are
0.000000,0,0.000000,#pod locked with C<LOCK_SH>.  When using C<locked>, ">" or "+>" modes will delay
0.000000,0,0.000000,#pod truncation until after the lock is acquired.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod The C<exclusive> option causes the open() call to fail if the file already
0.000000,0,0.000000,#pod exists.  This corresponds to the O_EXCL flag to sysopen / open(2).
0.000000,0,0.000000,#pod C<exclusive> implies C<locked> and will set it for you if you forget it.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.066.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,# Note: must put binmode on open line, not subsequent binmode() call, so things
0.000000,0,0.000000,# like ":unix" actually stop perlio/crlf from being added
0.000000,0,0.000000,
0.000000,0,0.000000,sub filehandle {
0.000012,14,0.000001,my ( $self, @args ) = @_;
0.000012,14,0.000001,my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
0.000015,14,0.000001,$args = _get_args( $args, qw/locked exclusive/ );
0.000004,14,0.000000,$args->{locked} = 1 if $args->{exclusive};
0.000012,14,0.000001,my ( $opentype, $binmode ) = @args;
0.000000,0,0.000000,
0.000005,14,0.000000,$opentype = "<" unless defined $opentype;
0.000000,0,0.000000,Carp::croak("Invalid file mode '$opentype'")
0.000022,14,0.000002,unless grep { $opentype eq $_ } qw/< +< > +> >> +>>/;
0.000000,0,0.000000,
0.000006,14,0.000000,$binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $opentype, -1, 1 ) }
0.000000,0,0.000000,unless defined $binmode;
0.000005,14,0.000000,$binmode = "" unless defined $binmode;
0.000000,0,0.000000,
0.000005,14,0.000000,my ( $fh, $lock, $trunc );
0.000044,14,0.000003,if ( $HAS_FLOCK && $args->{locked} && !$ENV{PERL_PATH_TINY_NO_FLOCK} ) {
0.000017,14,0.000001,require Fcntl;
0.000000,0,0.000000,# truncating file modes shouldn't truncate until lock acquired
0.000034,14,0.000002,if ( grep { $opentype eq $_ } qw( > +> ) ) {
0.000000,0,0.000000,# sysopen in write mode without truncation
0.000000,0,0.000000,my $flags = $opentype eq ">" ? Fcntl::O_WRONLY() : Fcntl::O_RDWR();
0.000000,0,0.000000,$flags |= Fcntl::O_CREAT();
0.000000,0,0.000000,$flags |= Fcntl::O_EXCL() if $args->{exclusive};
0.000000,0,0.000000,sysopen( $fh, $self->[PATH], $flags ) or $self->_throw("sysopen");
0.000000,0,0.000000,
0.000000,0,0.000000,# fix up the binmode since sysopen() can't specify layers like
0.000000,0,0.000000,# open() and binmode() can't start with just :unix like open()
0.000000,0,0.000000,if ( $binmode =~ s/^:unix// ) {
0.000000,0,0.000000,# eliminate pseudo-layers
0.000000,0,0.000000,binmode( $fh, ":raw" ) or $self->_throw("binmode (:raw)");
0.000000,0,0.000000,# strip off real layers until only :unix is left
0.000000,0,0.000000,while ( 1 < ( my $layers =()= PerlIO::get_layers( $fh, output => 1 ) ) ) {
0.000000,0,0.000000,binmode( $fh, ":pop" ) or $self->_throw("binmode (:pop)");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# apply any remaining binmode layers
0.000000,0,0.000000,if ( length $binmode ) {
0.000000,0,0.000000,binmode( $fh, $binmode ) or $self->_throw("binmode ($binmode)");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# ask for lock and truncation
0.000000,0,0.000000,$lock  = Fcntl::LOCK_EX();
0.000000,0,0.000000,$trunc = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $^O eq 'aix' && $opentype eq "<" ) {
0.000000,0,0.000000,# AIX can only lock write handles, so upgrade to RW and LOCK_EX if
0.000000,0,0.000000,# the file is writable; otherwise give up on locking.  N.B.
0.000000,0,0.000000,# checking -w before open to determine the open mode is an
0.000000,0,0.000000,# unavoidable race condition
0.000000,0,0.000000,if ( -w $self->[PATH] ) {
0.000000,0,0.000000,$opentype = "+<";
0.000000,0,0.000000,$lock     = Fcntl::LOCK_EX();
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000008,14,0.000001,$lock = $opentype eq "<" ? Fcntl::LOCK_SH() : Fcntl::LOCK_EX();
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000010,14,0.000001,unless ($fh) {
0.000006,14,0.000000,my $mode = $opentype . $binmode;
0.001918,14,0.000137,open $fh, $mode, $self->[PATH] or $self->_throw("open ($mode)");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000224,14,0.000016,do { flock( $fh, $lock ) or $self->_throw("flock ($lock)") } if $lock;
0.000007,14,0.000000,do { truncate( $fh, 0 ) or $self->_throw("truncate") } if $trunc;
0.000000,0,0.000000,
0.000081,14,0.000006,return $fh;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method has_same_bytes
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     if ( path("foo.txt")->has_same_bytes("bar.txt") ) {
0.000000,0,0.000000,#pod        # ...
0.000000,0,0.000000,#pod     }
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod This method returns true if both the invocant and the argument can be opened as
0.000000,0,0.000000,#pod file handles and the handles contain the same bytes.  It returns false if their
0.000000,0,0.000000,#pod contents differ.  If either can't be opened as a file (e.g. a directory or
0.000000,0,0.000000,#pod non-existent file), the method throws an exception.  If both can be opened and
0.000000,0,0.000000,#pod both have the same C<realpath>, the method returns true without scanning any
0.000000,0,0.000000,#pod data.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.125.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_same_bytes {
0.000000,0,0.000000,my ($self, $other_path) = @_;
0.000000,0,0.000000,my $other = _path($other_path);
0.000000,0,0.000000,
0.000000,0,0.000000,my $fh1 = $self->openr_raw({ locked => 1 });
0.000000,0,0.000000,my $fh2 = $other->openr_raw({ locked => 1 });
0.000000,0,0.000000,
0.000000,0,0.000000,# check for directories
0.000000,0,0.000000,if (-d $fh1) {
0.000000,0,0.000000,$self->_throw('has_same_bytes', $self->[PATH], "directory not allowed");
0.000000,0,0.000000,}
0.000000,0,0.000000,if (-d $fh2) {
0.000000,0,0.000000,$self->_throw('has_same_bytes', $other->[PATH], "directory not allowed");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Now that handles are open, we know the inputs are readable files that
0.000000,0,0.000000,# exist, so it's safe to compare via realpath
0.000000,0,0.000000,if ($self->realpath eq $other->realpath) {
0.000000,0,0.000000,return 1
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# result is 0 for equal, 1 for unequal, -1 for error
0.000000,0,0.000000,require File::Compare;
0.000000,0,0.000000,my $res = File::Compare::compare($fh1, $fh2, 65536);
0.000000,0,0.000000,if ($res < 0) {
0.000000,0,0.000000,$self->_throw('has_same_bytes')
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $res == 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method is_absolute, is_relative
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     if ( path("/tmp")->is_absolute ) { ... }
0.000000,0,0.000000,#pod     if ( path("/tmp")->is_relative ) { ... }
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Booleans for whether the path appears absolute or relative.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.001.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_absolute { substr( $_[0]->dirname, 0, 1 ) eq '/' }
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_relative { substr( $_[0]->dirname, 0, 1 ) ne '/' }
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method is_rootdir
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     while ( ! $path->is_rootdir ) {
0.000000,0,0.000000,#pod         $path = $path->parent;
0.000000,0,0.000000,#pod         ...
0.000000,0,0.000000,#pod     }
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Boolean for whether the path is the root directory of the volume.  I.e. the
0.000000,0,0.000000,#pod C<dirname> is C<q[/]> and the C<basename> is C<q[]>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod This works even on C<MSWin32> with drives and UNC volumes:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("C:/")->is_rootdir;             # true
0.000000,0,0.000000,#pod     path("//server/share/")->is_rootdir; #true
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.038.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_rootdir {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,$self->_splitpath unless defined $self->[DIR];
0.000000,0,0.000000,return $self->[DIR] eq '/' && $self->[FILE] eq '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method iterator
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $iter = path("/tmp")->iterator( \%options );
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns a code reference that walks a directory lazily.  Each invocation
0.000000,0,0.000000,#pod returns a C<Path::Tiny> object or undef when the iterator is exhausted.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $iter = path("/tmp")->iterator;
0.000000,0,0.000000,#pod     while ( $path = $iter->() ) {
0.000000,0,0.000000,#pod         ...
0.000000,0,0.000000,#pod     }
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod The current and parent directory entries ("." and "..") will not
0.000000,0,0.000000,#pod be included.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If the C<recurse> option is true, the iterator will walk the directory
0.000000,0,0.000000,#pod recursively, breadth-first.  If the C<follow_symlinks> option is also true,
0.000000,0,0.000000,#pod directory links will be followed recursively.  There is no protection against
0.000000,0,0.000000,#pod loops when following links. If a directory is not readable, it will not be
0.000000,0,0.000000,#pod followed.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod The default is the same as:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $iter = path("/tmp")->iterator( {
0.000000,0,0.000000,#pod         recurse         => 0,
0.000000,0,0.000000,#pod         follow_symlinks => 0,
0.000000,0,0.000000,#pod     } );
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod For a more powerful, recursive iterator with built-in loop avoidance, see
0.000000,0,0.000000,#pod L<Path::Iterator::Rule>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod See also L</visit>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.016.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub iterator {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $args = _get_args( shift, qw/recurse follow_symlinks/ );
0.000000,0,0.000000,my @dirs = $self;
0.000000,0,0.000000,my $current;
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,my $next;
0.000000,0,0.000000,while (@dirs) {
0.000000,0,0.000000,if ( ref $dirs[0] eq 'Path::Tiny' ) {
0.000000,0,0.000000,if ( !-r $dirs[0] ) {
0.000000,0,0.000000,# Directory is missing or not readable, so skip it.  There
0.000000,0,0.000000,# is still a race condition possible between the check and
0.000000,0,0.000000,# the opendir, but we can't easily differentiate between
0.000000,0,0.000000,# error cases that are OK to skip and those that we want
0.000000,0,0.000000,# to be exceptions, so we live with the race and let opendir
0.000000,0,0.000000,# be fatal.
0.000000,0,0.000000,shift @dirs and next;
0.000000,0,0.000000,}
0.000000,0,0.000000,$current = $dirs[0];
0.000000,0,0.000000,my $dh;
0.000000,0,0.000000,opendir( $dh, $current->[PATH] )
0.000000,0,0.000000,or $self->_throw( 'opendir', $current->[PATH] );
0.000000,0,0.000000,$dirs[0] = $dh;
0.000000,0,0.000000,if ( -l $current->[PATH] && !$args->{follow_symlinks} ) {
0.000000,0,0.000000,# Symlink attack! It was a real dir, but is now a symlink!
0.000000,0,0.000000,# N.B. we check *after* opendir so the attacker has to win
0.000000,0,0.000000,# two races: replace dir with symlink before opendir and
0.000000,0,0.000000,# replace symlink with dir before -l check above
0.000000,0,0.000000,shift @dirs and next;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,while ( defined( $next = readdir $dirs[0] ) ) {
0.000000,0,0.000000,next if $next eq '.' || $next eq '..';
0.000000,0,0.000000,my $path = $current->child($next);
0.000000,0,0.000000,push @dirs, $path
0.000000,0,0.000000,if $args->{recurse} && -d $path && !( !$args->{follow_symlinks} && -l $path );
0.000000,0,0.000000,return $path;
0.000000,0,0.000000,}
0.000000,0,0.000000,shift @dirs;
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method lines, lines_raw, lines_utf8
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     @contents = path("/tmp/foo.txt")->lines;
0.000000,0,0.000000,#pod     @contents = path("/tmp/foo.txt")->lines(\%options);
0.000000,0,0.000000,#pod     @contents = path("/tmp/foo.txt")->lines_raw;
0.000000,0,0.000000,#pod     @contents = path("/tmp/foo.txt")->lines_utf8;
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns a list of lines from a file.  Optionally takes a hash-reference of
0.000000,0,0.000000,#pod options.  Valid options are C<binmode>, C<count> and C<chomp>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If C<binmode> is provided, it will be set on the handle prior to reading.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If a positive C<count> is provided, that many lines will be returned from the
0.000000,0,0.000000,#pod start of the file.  If a negative C<count> is provided, the entire file will be
0.000000,0,0.000000,#pod read, but only C<abs(count)> will be kept and returned.  If C<abs(count)>
0.000000,0,0.000000,#pod exceeds the number of lines in the file, all lines will be returned.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If C<chomp> is set, any end-of-line character sequences (C<CR>, C<CRLF>, or
0.000000,0,0.000000,#pod C<LF>) will be removed from the lines returned.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Because the return is a list, C<lines> in scalar context will return the number
0.000000,0,0.000000,#pod of lines (and throw away the data).
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $number_of_lines = path("/tmp/foo.txt")->lines;
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
0.000000,0,0.000000,#pod instead of C<:unix> so PerlIO buffering can manage reading by line.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<lines_utf8> is like C<lines> with a C<binmode> of C<:raw:encoding(UTF-8)>
0.000000,0,0.000000,#pod (or C<:raw:utf8_strict> with L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
0.000000,0,0.000000,#pod 0.58+ is installed, a raw, unbuffered UTF-8 slurp will be done and then the
0.000000,0,0.000000,#pod lines will be split.  This is actually faster than relying on
0.000000,0,0.000000,#pod IO layers, though a bit memory intensive.  If memory use is a
0.000000,0,0.000000,#pod concern, consider C<openr_utf8> and iterating directly on the handle.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.065.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub lines {
0.000000,0,0.000000,my $self    = shift;
0.000000,0,0.000000,my $args    = _get_args( shift, qw/binmode chomp count/ );
0.000000,0,0.000000,my $binmode = $args->{binmode};
0.000000,0,0.000000,$binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
0.000000,0,0.000000,my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
0.000000,0,0.000000,my $chomp = $args->{chomp};
0.000000,0,0.000000,# XXX more efficient to read @lines then chomp(@lines) vs map?
0.000000,0,0.000000,if ( $args->{count} ) {
0.000000,0,0.000000,my ( $counter, $mod, @result ) = ( 0, abs( $args->{count} ) );
0.000000,0,0.000000,my $line;
0.000000,0,0.000000,while ( !eof($fh) ) {
0.000000,0,0.000000,defined( $line = readline($fh) ) or $self->_throw('readline');
0.000000,0,0.000000,
0.000000,0,0.000000,$line =~ s/(?:\x{0d}?\x{0a}|\x{0d})\z// if $chomp;
0.000000,0,0.000000,$result[ $counter++ ] = $line;
0.000000,0,0.000000,# for positive count, terminate after right number of lines
0.000000,0,0.000000,last if $counter == $args->{count};
0.000000,0,0.000000,# for negative count, eventually wrap around in the result array
0.000000,0,0.000000,$counter %= $mod;
0.000000,0,0.000000,}
0.000000,0,0.000000,# reorder results if full and wrapped somewhere in the middle
0.000000,0,0.000000,splice( @result, 0, 0, splice( @result, $counter ) )
0.000000,0,0.000000,if @result == $mod && $counter % $mod;
0.000000,0,0.000000,return @result;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($chomp) {
0.000000,0,0.000000,local $!;
0.000000,0,0.000000,my @lines = map { s/(?:\x{0d}?\x{0a}|\x{0d})\z//; $_ } <$fh>; ## no critic
0.000000,0,0.000000,$self->_throw('readline') if $!;
0.000000,0,0.000000,return @lines;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ( wantarray ) {
0.000000,0,0.000000,local $!;
0.000000,0,0.000000,my @lines = <$fh>;
0.000000,0,0.000000,$self->_throw('readline') if $!;
0.000000,0,0.000000,return @lines;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,local $!;
0.000000,0,0.000000,my $count =()= <$fh>;
0.000000,0,0.000000,$self->_throw('readline') if $!;
0.000000,0,0.000000,return $count;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub lines_raw {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $args = _get_args( shift, qw/binmode chomp count/ );
0.000000,0,0.000000,if ( $args->{chomp} && !$args->{count} ) {
0.000000,0,0.000000,return split /\n/, slurp_raw($self);                    ## no critic
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$args->{binmode} = ":raw";
0.000000,0,0.000000,return lines( $self, $args );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,my $CRLF = qr/(?:\x{0d}?\x{0a}|\x{0d})/;
0.000000,0,0.000000,
0.000000,0,0.000000,sub lines_utf8 {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $args = _get_args( shift, qw/binmode chomp count/ );
0.000000,0,0.000000,if (   ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) )
0.000000,0,0.000000,&& $args->{chomp}
0.000000,0,0.000000,&& !$args->{count} )
0.000000,0,0.000000,{
0.000000,0,0.000000,my $slurp = slurp_utf8($self);
0.000000,0,0.000000,$slurp =~ s/$CRLF\z//; # like chomp, but full CR?LF|CR
0.000000,0,0.000000,return split $CRLF, $slurp, -1; ## no critic
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
0.000000,0,0.000000,$args->{binmode} = ":raw:utf8_strict";
0.000000,0,0.000000,return lines( $self, $args );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$args->{binmode} = ":raw:encoding(UTF-8)";
0.000000,0,0.000000,return lines( $self, $args );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method mkdir
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("foo/bar/baz")->mkdir;
0.000000,0,0.000000,#pod     path("foo/bar/baz")->mkdir( \%options );
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Like calling C<make_path> from L<File::Path>.  An optional hash reference
0.000000,0,0.000000,#pod is passed through to C<make_path>.  Errors will be trapped and an exception
0.000000,0,0.000000,#pod thrown.  Returns the the path object to facilitate chaining.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod B<NOTE>: unlike Perl's builtin C<mkdir>, this will create intermediate paths
0.000000,0,0.000000,#pod similar to the Unix C<mkdir -p> command.  It will not error if applied to an
0.000000,0,0.000000,#pod existing directory.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.125.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub mkdir {
0.000000,0,0.000000,my ( $self, $args ) = @_;
0.000000,0,0.000000,$args = {} unless ref $args eq 'HASH';
0.000000,0,0.000000,my $err;
0.000000,0,0.000000,$args->{error} = \$err unless defined $args->{error};
0.000000,0,0.000000,require File::Path;
0.000000,0,0.000000,my @dirs;
0.000000,0,0.000000,my $ok = eval {
0.000000,0,0.000000,File::Path::make_path( $self->[PATH], $args );
0.000000,0,0.000000,1;
0.000000,0,0.000000,};
0.000000,0,0.000000,if (!$ok) {
0.000000,0,0.000000,$self->_throw('mkdir', $self->[PATH], "error creating path: $@");
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( $err && @$err ) {
0.000000,0,0.000000,my ( $file, $message ) = %{ $err->[0] };
0.000000,0,0.000000,$self->_throw('mkdir', $file, $message);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method mkpath (deprecated)
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Like calling C<mkdir>, but returns the list of directories created or an empty list if
0.000000,0,0.000000,#pod the directories already exist, just like C<make_path>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Deprecated in 0.125.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub mkpath {
0.000000,0,0.000000,my ( $self, $args ) = @_;
0.000000,0,0.000000,$args = {} unless ref $args eq 'HASH';
0.000000,0,0.000000,my $err;
0.000000,0,0.000000,$args->{error} = \$err unless defined $args->{error};
0.000000,0,0.000000,require File::Path;
0.000000,0,0.000000,my @dirs = File::Path::make_path( $self->[PATH], $args );
0.000000,0,0.000000,if ( $err && @$err ) {
0.000000,0,0.000000,my ( $file, $message ) = %{ $err->[0] };
0.000000,0,0.000000,Carp::croak("mkpath failed for $file: $message");
0.000000,0,0.000000,}
0.000000,0,0.000000,return @dirs;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method move
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("foo.txt")->move("bar.txt");
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Moves the current path to the given destination using L<File::Copy>'s
0.000000,0,0.000000,#pod C<move> function. Upon success, returns the C<Path::Tiny> object for the
0.000000,0,0.000000,#pod newly moved file.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If the destination already exists and is a directory, and the source is not a
0.000000,0,0.000000,#pod directory, then the source file will be renamed into the directory
0.000000,0,0.000000,#pod specified by the destination.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If possible, move() will simply rename the file. Otherwise, it
0.000000,0,0.000000,#pod copies the file to the new location and deletes the original. If an
0.000000,0,0.000000,#pod error occurs during this copy-and-delete process, you may be left
0.000000,0,0.000000,#pod with a (possibly partial) copy of the file under the destination
0.000000,0,0.000000,#pod name.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.124. Prior versions used Perl's
0.000000,0,0.000000,#pod -built-in (and less robust) L<rename|perlfunc/rename> function
0.000000,0,0.000000,#pod and did not return an object.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub move {
0.000000,0,0.000000,my ( $self, $dest ) = @_;
0.000000,0,0.000000,require File::Copy;
0.000000,0,0.000000,File::Copy::move( $self->[PATH], $dest )
0.000000,0,0.000000,or $self->_throw( 'move', $self->[PATH] . "' -> '$dest" );
0.000000,0,0.000000,
0.000000,0,0.000000,return -d $dest ? _path( $dest, $self->basename ) : _path($dest);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method openr, openw, openrw, opena
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $fh = path("foo.txt")->openr($binmode);  # read
0.000000,0,0.000000,#pod     $fh = path("foo.txt")->openr_raw;
0.000000,0,0.000000,#pod     $fh = path("foo.txt")->openr_utf8;
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $fh = path("foo.txt")->openw($binmode);  # write
0.000000,0,0.000000,#pod     $fh = path("foo.txt")->openw_raw;
0.000000,0,0.000000,#pod     $fh = path("foo.txt")->openw_utf8;
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $fh = path("foo.txt")->opena($binmode);  # append
0.000000,0,0.000000,#pod     $fh = path("foo.txt")->opena_raw;
0.000000,0,0.000000,#pod     $fh = path("foo.txt")->opena_utf8;
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $fh = path("foo.txt")->openrw($binmode); # read/write
0.000000,0,0.000000,#pod     $fh = path("foo.txt")->openrw_raw;
0.000000,0,0.000000,#pod     $fh = path("foo.txt")->openrw_utf8;
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns a file handle opened in the specified mode.  The C<openr> style methods
0.000000,0,0.000000,#pod take a single C<binmode> argument.  All of the C<open*> methods have
0.000000,0,0.000000,#pod C<open*_raw> and C<open*_utf8> equivalents that use buffered I/O layers C<:raw>
0.000000,0,0.000000,#pod and C<:raw:encoding(UTF-8)> (or C<:raw:utf8_strict> with
0.000000,0,0.000000,#pod L<PerlIO::utf8_strict>).
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod An optional hash reference may be used to pass options.  The only option is
0.000000,0,0.000000,#pod C<locked>.  If true, handles opened for writing, appending or read-write are
0.000000,0,0.000000,#pod locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod See L</filehandle> for more on locking.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.011.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,# map method names to corresponding open mode
0.000002,1,0.000002,my %opens = (
0.000000,0,0.000000,opena  => ">>",
0.000000,0,0.000000,openr  => "<",
0.000000,0,0.000000,openw  => ">",
0.000000,0,0.000000,openrw => "+<"
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000005,1,0.000005,while ( my ( $k, $v ) = each %opens ) {
0.001895,2,0.000947,no strict 'refs';
0.000000,0,0.000000,# must check for lexical IO mode hint
0.000000,0,0.000000,*{$k} = sub {
0.000000,0,0.000000,my ( $self, @args ) = @_;
0.000000,0,0.000000,my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
0.000000,0,0.000000,$args = _get_args( $args, qw/locked/ );
0.000000,0,0.000000,my ($binmode) = @args;
0.000000,0,0.000000,$binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $v, -1, 1 ) }
0.000000,0,0.000000,unless defined $binmode;
0.000000,0,0.000000,$self->filehandle( $args, $v, $binmode );
0.000007,4,0.000002,};
0.000000,0,0.000000,*{ $k . "_raw" } = sub {
0.000000,0,0.000000,my ( $self, @args ) = @_;
0.000000,0,0.000000,my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
0.000000,0,0.000000,$args = _get_args( $args, qw/locked/ );
0.000000,0,0.000000,$self->filehandle( $args, $v, ":raw" );
0.000006,4,0.000002,};
0.000000,0,0.000000,*{ $k . "_utf8" } = sub {
0.000000,0,0.000000,my ( $self, @args ) = @_;
0.000000,0,0.000000,my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
0.000000,0,0.000000,$args = _get_args( $args, qw/locked/ );
0.000000,0,0.000000,my $layer;
0.000000,0,0.000000,if ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
0.000000,0,0.000000,$layer = ":raw:utf8_strict";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$layer = ":raw:encoding(UTF-8)";
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->filehandle( $args, $v, $layer );
0.000006,4,0.000001,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method parent
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $parent = path("foo/bar/baz")->parent; # foo/bar
0.000000,0,0.000000,#pod     $parent = path("foo/wibble.txt")->parent; # foo
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $parent = path("foo/bar/baz")->parent(2); # foo
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns a C<Path::Tiny> object corresponding to the parent directory of the
0.000000,0,0.000000,#pod original directory or file. An optional positive integer argument is the number
0.000000,0,0.000000,#pod of parent directories upwards to return.  C<parent> by itself is equivalent to
0.000000,0,0.000000,#pod C<parent(1)>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.014.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX this is ugly and coverage is incomplete.  I think it's there for windows
0.000000,0,0.000000,# so need to check coverage there and compare
0.000000,0,0.000000,sub parent {
0.000000,0,0.000000,my ( $self, $level ) = @_;
0.000000,0,0.000000,$level = 1 unless defined $level && $level > 0;
0.000000,0,0.000000,$self->_splitpath unless defined $self->[FILE];
0.000000,0,0.000000,my $parent;
0.000000,0,0.000000,if ( length $self->[FILE] ) {
0.000000,0,0.000000,if ( $self->[FILE] eq '.' || $self->[FILE] eq ".." ) {
0.000000,0,0.000000,$parent = _path( $self->[PATH] . "/.." );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$parent = _path( _non_empty( $self->[VOL] . $self->[DIR] ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( length $self->[DIR] ) {
0.000000,0,0.000000,# because of symlinks, any internal updir requires us to
0.000000,0,0.000000,# just add more updirs at the end
0.000000,0,0.000000,if ( $self->[DIR] =~ m{(?:^\.\./|/\.\./|/\.\.\z)} ) {
0.000000,0,0.000000,$parent = _path( $self->[VOL] . $self->[DIR] . "/.." );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,( my $dir = $self->[DIR] ) =~ s{/[^\/]+/\z}{/};
0.000000,0,0.000000,$parent = _path( $self->[VOL] . $dir );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$parent = _path( _non_empty( $self->[VOL] ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,return $level == 1 ? $parent : $parent->parent( $level - 1 );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _non_empty {
0.000000,0,0.000000,my ($string) = shift;
0.000000,0,0.000000,return ( ( defined($string) && length($string) ) ? $string : "." );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method realpath
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $real = path("/baz/foo/../bar")->realpath;
0.000000,0,0.000000,#pod     $real = path("foo/../bar")->realpath;
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns a new C<Path::Tiny> object with all symbolic links and upward directory
0.000000,0,0.000000,#pod parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
0.000000,0,0.000000,#pod more expensive as it must actually consult the filesystem.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If the parent path can't be resolved (e.g. if it includes directories that
0.000000,0,0.000000,#pod don't exist), an exception will be thrown:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $real = path("doesnt_exist/foo")->realpath; # dies
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod However, if the parent path exists and only the last component (e.g. filename)
0.000000,0,0.000000,#pod doesn't exist, the realpath will be the realpath of the parent plus the
0.000000,0,0.000000,#pod non-existent last component:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $real = path("./aasdlfasdlf")->realpath; # works
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod The underlying L<Cwd> module usually worked this way on Unix, but died on
0.000000,0,0.000000,#pod Windows (and some Unixes) if the full path didn't exist.  As of version 0.064,
0.000000,0,0.000000,#pod it's safe to use anywhere.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.001.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,# Win32 and some Unixes need parent path resolved separately so realpath
0.000000,0,0.000000,# doesn't throw an error resolving non-existent basename
0.000000,0,0.000000,sub realpath {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self = $self->_resolve_symlinks;
0.000000,0,0.000000,require Cwd;
0.000000,0,0.000000,$self->_splitpath if !defined $self->[FILE];
0.000000,0,0.000000,my $check_parent =
0.000000,0,0.000000,length $self->[FILE] && $self->[FILE] ne '.' && $self->[FILE] ne '..';
0.000000,0,0.000000,my $realpath = eval {
0.000000,0,0.000000,# pure-perl Cwd can carp
0.000000,0,0.000000,local $SIG{__WARN__} = sub { };
0.000000,0,0.000000,Cwd::realpath( $check_parent ? $self->parent->[PATH] : $self->[PATH] );
0.000000,0,0.000000,};
0.000000,0,0.000000,# parent realpath must exist; not all Cwd::realpath will error if it doesn't
0.000000,0,0.000000,$self->_throw("resolving realpath")
0.000000,0,0.000000,unless defined $realpath && length $realpath && -e $realpath;
0.000000,0,0.000000,return ( $check_parent ? _path( $realpath, $self->[FILE] ) : _path($realpath) );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method relative
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns a C<Path::Tiny> object with a path relative to a new base path
0.000000,0,0.000000,#pod given as an argument.  If no argument is given, the current directory will
0.000000,0,0.000000,#pod be used as the new base path.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If either path is already relative, it will be made absolute based on the
0.000000,0,0.000000,#pod current directly before determining the new relative path.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod The algorithm is roughly as follows:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =for :list
0.000000,0,0.000000,#pod * If the original and new base path are on different volumes, an exception
0.000000,0,0.000000,#pod   will be thrown.
0.000000,0,0.000000,#pod * If the original and new base are identical, the relative path is C<".">.
0.000000,0,0.000000,#pod * If the new base subsumes the original, the relative path is the original
0.000000,0,0.000000,#pod   path with the new base chopped off the front
0.000000,0,0.000000,#pod * If the new base does not subsume the original, a common prefix path is
0.000000,0,0.000000,#pod   determined (possibly the root directory) and the relative path will
0.000000,0,0.000000,#pod   consist of updirs (C<"..">) to reach the common prefix, followed by the
0.000000,0,0.000000,#pod   original path less the common prefix.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Unlike C<File::Spec::abs2rel>, in the last case above, the calculation based
0.000000,0,0.000000,#pod on a common prefix takes into account symlinks that could affect the updir
0.000000,0,0.000000,#pod process.  Given an original path "/A/B" and a new base "/A/C",
0.000000,0,0.000000,#pod (where "A", "B" and "C" could each have multiple path components):
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =for :list
0.000000,0,0.000000,#pod * Symlinks in "A" don't change the result unless the last component of A is
0.000000,0,0.000000,#pod   a symlink and the first component of "C" is an updir.
0.000000,0,0.000000,#pod * Symlinks in "B" don't change the result and will exist in the result as
0.000000,0,0.000000,#pod   given.
0.000000,0,0.000000,#pod * Symlinks and updirs in "C" must be resolved to actual paths, taking into
0.000000,0,0.000000,#pod   account the possibility that not all path components might exist on the
0.000000,0,0.000000,#pod   filesystem.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.001.  New algorithm (that accounts for
0.000000,0,0.000000,#pod symlinks) available since 0.079.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub relative {
0.000000,0,0.000000,my ( $self, $base ) = @_;
0.000000,0,0.000000,$base = _path( defined $base && length $base ? $base : '.' );
0.000000,0,0.000000,
0.000000,0,0.000000,# relative paths must be converted to absolute first
0.000000,0,0.000000,$self = $self->absolute if $self->is_relative;
0.000000,0,0.000000,$base = $base->absolute if $base->is_relative;
0.000000,0,0.000000,
0.000000,0,0.000000,# normalize volumes if they exist
0.000000,0,0.000000,$self = $self->absolute if !length $self->volume && length $base->volume;
0.000000,0,0.000000,$base = $base->absolute if length $self->volume  && !length $base->volume;
0.000000,0,0.000000,
0.000000,0,0.000000,# can't make paths relative across volumes
0.000000,0,0.000000,if ( !_same( $self->volume, $base->volume ) ) {
0.000000,0,0.000000,Carp::croak("relative() can't cross volumes: '$self' vs '$base'");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# if same absolute path, relative is current directory
0.000000,0,0.000000,return _path(".") if _same( $self->[PATH], $base->[PATH] );
0.000000,0,0.000000,
0.000000,0,0.000000,# if base is a prefix of self, chop prefix off self
0.000000,0,0.000000,if ( $base->subsumes($self) ) {
0.000000,0,0.000000,$base = "" if $base->is_rootdir;
0.000000,0,0.000000,my $relative = "$self";
0.000000,0,0.000000,$relative =~ s{\A\Q$base/}{};
0.000000,0,0.000000,return _path(".", $relative);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# base is not a prefix, so must find a common prefix (even if root)
0.000000,0,0.000000,my ( @common, @self_parts, @base_parts );
0.000000,0,0.000000,@base_parts = split /\//, $base->_just_filepath;
0.000000,0,0.000000,
0.000000,0,0.000000,# if self is rootdir, then common directory is root (shown as empty
0.000000,0,0.000000,# string for later joins); otherwise, must be computed from path parts.
0.000000,0,0.000000,if ( $self->is_rootdir ) {
0.000000,0,0.000000,@common = ("");
0.000000,0,0.000000,shift @base_parts;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,@self_parts = split /\//, $self->_just_filepath;
0.000000,0,0.000000,
0.000000,0,0.000000,while ( @self_parts && @base_parts && _same( $self_parts[0], $base_parts[0] ) ) {
0.000000,0,0.000000,push @common, shift @base_parts;
0.000000,0,0.000000,shift @self_parts;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# if there are any symlinks from common to base, we have a problem, as
0.000000,0,0.000000,# you can't guarantee that updir from base reaches the common prefix;
0.000000,0,0.000000,# we must resolve symlinks and try again; likewise, any updirs are
0.000000,0,0.000000,# a problem as it throws off calculation of updirs needed to get from
0.000000,0,0.000000,# self's path to the common prefix.
0.000000,0,0.000000,if ( my $new_base = $self->_resolve_between( \@common, \@base_parts ) ) {
0.000000,0,0.000000,return $self->relative($new_base);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# otherwise, symlinks in common or from common to A don't matter as
0.000000,0,0.000000,# those don't involve updirs
0.000000,0,0.000000,my @new_path = ( ("..") x ( 0+ @base_parts ), @self_parts );
0.000000,0,0.000000,return _path(@new_path);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _just_filepath {
0.000000,0,0.000000,my $self     = shift;
0.000000,0,0.000000,my $self_vol = $self->volume;
0.000000,0,0.000000,return "$self" if !length $self_vol;
0.000000,0,0.000000,
0.000000,0,0.000000,( my $self_path = "$self" ) =~ s{\A\Q$self_vol}{};
0.000000,0,0.000000,
0.000000,0,0.000000,return $self_path;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _resolve_between {
0.000000,0,0.000000,my ( $self, $common, $base ) = @_;
0.000000,0,0.000000,my $path = $self->volume . join( "/", @$common );
0.000000,0,0.000000,my $changed = 0;
0.000000,0,0.000000,for my $p (@$base) {
0.000000,0,0.000000,$path .= "/$p";
0.000000,0,0.000000,if ( $p eq '..' ) {
0.000000,0,0.000000,$changed = 1;
0.000000,0,0.000000,if ( -e $path ) {
0.000000,0,0.000000,$path = _path($path)->realpath->[PATH];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$path =~ s{/[^/]+/..\z}{/};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( -l $path ) {
0.000000,0,0.000000,$changed = 1;
0.000000,0,0.000000,$path    = _path($path)->realpath->[PATH];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return $changed ? _path($path) : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method remove
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("foo.txt")->remove;
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod This is just like C<unlink>, except for its error handling: if the path does
0.000000,0,0.000000,#pod not exist, it returns false; if deleting the file fails, it throws an
0.000000,0,0.000000,#pod exception.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.012.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return 0 if !-e $self->[PATH] && !-l $self->[PATH];
0.000000,0,0.000000,
0.000000,0,0.000000,return unlink( $self->[PATH] ) || $self->_throw('unlink');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method remove_tree
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     # directory
0.000000,0,0.000000,#pod     path("foo/bar/baz")->remove_tree;
0.000000,0,0.000000,#pod     path("foo/bar/baz")->remove_tree( \%options );
0.000000,0,0.000000,#pod     path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
0.000000,0,0.000000,#pod An optional hash reference is passed through to C<remove_tree>.  Errors will be
0.000000,0,0.000000,#pod trapped and an exception thrown.  Returns the number of directories deleted,
0.000000,0,0.000000,#pod just like C<remove_tree>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If you want to remove a directory only if it is empty, use the built-in
0.000000,0,0.000000,#pod C<rmdir> function instead.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     rmdir path("foo/bar/baz/");
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.013.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove_tree {
0.000000,0,0.000000,my ( $self, $args ) = @_;
0.000000,0,0.000000,return 0 if !-e $self->[PATH] && !-l $self->[PATH];
0.000000,0,0.000000,$args = {} unless ref $args eq 'HASH';
0.000000,0,0.000000,my $err;
0.000000,0,0.000000,$args->{error} = \$err unless defined $args->{error};
0.000000,0,0.000000,$args->{safe}  = 1     unless defined $args->{safe};
0.000000,0,0.000000,require File::Path;
0.000000,0,0.000000,my $count = File::Path::remove_tree( $self->[PATH], $args );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $err && @$err ) {
0.000000,0,0.000000,my ( $file, $message ) = %{ $err->[0] };
0.000000,0,0.000000,Carp::croak("remove_tree failed for $file: $message");
0.000000,0,0.000000,}
0.000000,0,0.000000,return $count;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method sibling
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $foo = path("/tmp/foo.txt");
0.000000,0,0.000000,#pod     $sib = $foo->sibling("bar.txt");        # /tmp/bar.txt
0.000000,0,0.000000,#pod     $sib = $foo->sibling("baz", "bam.txt"); # /tmp/baz/bam.txt
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns a new C<Path::Tiny> object relative to the parent of the original.
0.000000,0,0.000000,#pod This is slightly more efficient than C<< $path->parent->child(...) >>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.058.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub sibling {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return _path( $self->parent->[PATH], @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method size, size_human
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     my $p = path("foo"); # with size 1025 bytes
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $p->size;                            # "1025"
0.000000,0,0.000000,#pod     $p->size_human;                      # "1.1 K"
0.000000,0,0.000000,#pod     $p->size_human( {format => "iec"} ); # "1.1 KiB"
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns the size of a file.  The C<size> method is just a wrapper around C<-s>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod The C<size_human> method provides a human-readable string similar to
0.000000,0,0.000000,#pod C<ls -lh>.  Like C<ls>, it rounds upwards and provides one decimal place for
0.000000,0,0.000000,#pod single-digit sizes and no decimal places for larger sizes.  The only available
0.000000,0,0.000000,#pod option is C<format>, which has three valid values:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =for :list
0.000000,0,0.000000,#pod * 'ls' (the default): base-2 sizes, with C<ls> style single-letter suffixes (K, M, etc.)
0.000000,0,0.000000,#pod * 'iec': base-2 sizes, with IEC binary suffixes (KiB, MiB, etc.)
0.000000,0,0.000000,#pod * 'si': base-10 sizes, with SI decimal suffixes (kB, MB, etc.)
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If C<-s> would return C<undef>, C<size_human> returns the empty string.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.122.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub size { -s $_[0]->[PATH] }
0.000000,0,0.000000,
0.000000,0,0.000000,my %formats = (
0.000000,0,0.000000,'ls'  => [ 1024, log(1024), [ "", map { " $_" } qw/K M G T/ ] ],
0.000000,0,0.000000,'iec' => [ 1024, log(1024), [ "", map { " $_" } qw/KiB MiB GiB TiB/ ] ],
0.000013,1,0.000013,'si'  => [ 1000, log(1000), [ "", map { " $_" } qw/kB MB GB TB/ ] ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub _formats { return $formats{$_[0]} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub size_human {
0.000000,0,0.000000,my $self     = shift;
0.000000,0,0.000000,my $args     = _get_args( shift, qw/format/ );
0.000000,0,0.000000,my $format   = defined $args->{format} ? $args->{format} : "ls";
0.000000,0,0.000000,my $fmt_opts = $formats{$format}
0.000000,0,0.000000,or Carp::croak("Invalid format '$format' for size_human()");
0.000000,0,0.000000,my $size = -s $self->[PATH];
0.000000,0,0.000000,return defined $size ? _human_size( $size, @$fmt_opts ) : "";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ceil {
0.000000,0,0.000000,return $_[0] == int($_[0]) ? $_[0] : int($_[0]+1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _human_size {
0.000000,0,0.000000,my ( $size, $base, $log_base, $suffixes ) = @_;
0.000000,0,0.000000,return "0" if $size == 0;
0.000000,0,0.000000,
0.000000,0,0.000000,my $mag = int( log($size) / $log_base );
0.000000,0,0.000000,$size /= $base**$mag;
0.000000,0,0.000000,$size =
0.000000,0,0.000000,$mag == 0               ? $size
0.000000,0,0.000000,: length( int($size) ) == 1 ? _ceil( $size * 10 ) / 10
0.000000,0,0.000000,:                             _ceil($size);
0.000000,0,0.000000,if ( $size >= $base ) {
0.000000,0,0.000000,$size /= $base;
0.000000,0,0.000000,$mag++;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $fmt = ( $mag == 0 || length( int($size) ) > 1 ) ? "%.0f%s" : "%.1f%s";
0.000000,0,0.000000,return sprintf( $fmt, $size, $suffixes->[$mag] );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method slurp, slurp_raw, slurp_utf8
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $data = path("foo.txt")->slurp;
0.000000,0,0.000000,#pod     $data = path("foo.txt")->slurp( {binmode => ":raw"} );
0.000000,0,0.000000,#pod     $data = path("foo.txt")->slurp_raw;
0.000000,0,0.000000,#pod     $data = path("foo.txt")->slurp_utf8;
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Reads file contents into a scalar.  Takes an optional hash reference which may
0.000000,0,0.000000,#pod be used to pass options.  The only available option is C<binmode>, which is
0.000000,0,0.000000,#pod passed to C<binmode()> on the handle used for reading.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
0.000000,0,0.000000,#pod a fast, unbuffered, raw read.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<slurp_utf8> is like C<slurp> with a C<binmode> of
0.000000,0,0.000000,#pod C<:unix:encoding(UTF-8)> (or C<:unix:utf8_strict> with
0.000000,0,0.000000,#pod L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a
0.000000,0,0.000000,#pod unbuffered, raw slurp will be done instead and the result decoded with
0.000000,0,0.000000,#pod C<Unicode::UTF8>. This is just as strict and is roughly an order of
0.000000,0,0.000000,#pod magnitude faster than using C<:encoding(UTF-8)>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod B<Note>: C<slurp> and friends lock the filehandle before slurping.  If
0.000000,0,0.000000,#pod you plan to slurp from a file created with L<File::Temp>, be sure to
0.000000,0,0.000000,#pod close other handles or open without locking to avoid a deadlock:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     my $tempfile = File::Temp->new(EXLOCK => 0);
0.000000,0,0.000000,#pod     my $guts = path($tempfile)->slurp;
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.004.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub slurp {
0.000011,14,0.000001,my $self    = shift;
0.000035,14,0.000002,my $args    = _get_args( shift, qw/binmode/ );
0.000003,14,0.000000,my $binmode = $args->{binmode};
0.000003,14,0.000000,$binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
0.000069,14,0.000005,my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
0.000092,14,0.000007,if ( ( defined($binmode) ? $binmode : "" ) eq ":unix"
0.000000,0,0.000000,and my $size = -s $fh )
0.000000,0,0.000000,{
0.000003,14,0.000000,my $buf;
0.004578,14,0.000327,my $rc = read $fh, $buf, $size; # File::Slurp in a nutshell
0.000008,14,0.000001,$self->_throw('read') unless defined $rc;
0.001121,14,0.000080,return $buf;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,local $/;
0.000000,0,0.000000,my $buf = scalar <$fh>;
0.000000,0,0.000000,$self->_throw('read') unless defined $buf;
0.000000,0,0.000000,return $buf;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000091,28,0.000003,sub slurp_raw { $_[1] = { binmode => ":unix" }; goto &slurp }
0.000000,0,0.000000,
0.000000,0,0.000000,sub slurp_utf8 {
0.000000,0,0.000000,if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
0.000000,0,0.000000,return Unicode::UTF8::decode_utf8( slurp( $_[0], { binmode => ":unix" } ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
0.000000,0,0.000000,$_[1] = { binmode => ":unix:utf8_strict" };
0.000000,0,0.000000,goto &slurp;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$_[1] = { binmode => ":unix:encoding(UTF-8)" };
0.000000,0,0.000000,goto &slurp;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method spew, spew_raw, spew_utf8
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("foo.txt")->spew(@data);
0.000000,0,0.000000,#pod     path("foo.txt")->spew(\@data);
0.000000,0,0.000000,#pod     path("foo.txt")->spew({binmode => ":raw"}, @data);
0.000000,0,0.000000,#pod     path("foo.txt")->spew_raw(@data);
0.000000,0,0.000000,#pod     path("foo.txt")->spew_utf8(@data);
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Writes data to a file atomically.  The file is written to a temporary file in
0.000000,0,0.000000,#pod the same directory, then renamed over the original.  An optional hash reference
0.000000,0,0.000000,#pod may be used to pass options.  The only option is C<binmode>, which is passed to
0.000000,0,0.000000,#pod C<binmode()> on the handle used for writing.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
0.000000,0,0.000000,#pod unbuffered, raw write.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>
0.000000,0,0.000000,#pod (or C<:unix:utf8_strict> with L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
0.000000,0,0.000000,#pod 0.58+ is installed, a raw, unbuffered spew will be done instead on the data
0.000000,0,0.000000,#pod encoded with C<Unicode::UTF8>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod B<NOTE>: because the file is written to a temporary file and then renamed, the
0.000000,0,0.000000,#pod new file will wind up with permissions based on your current umask.  This is a
0.000000,0,0.000000,#pod feature to protect you from a race condition that would otherwise give
0.000000,0,0.000000,#pod different permissions than you might expect.  If you really want to keep the
0.000000,0,0.000000,#pod original mode flags, use L</append> with the C<truncate> option.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.011.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub spew {
0.000000,0,0.000000,my ( $self, @data ) = @_;
0.000000,0,0.000000,my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
0.000000,0,0.000000,$args = _get_args( $args, qw/binmode/ );
0.000000,0,0.000000,my $binmode = $args->{binmode};
0.000000,0,0.000000,# get default binmode from caller's lexical scope (see "perldoc open")
0.000000,0,0.000000,$binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
0.000000,0,0.000000,
0.000000,0,0.000000,# writing needs to follow the link and create the tempfile in the same
0.000000,0,0.000000,# dir for later atomic rename
0.000000,0,0.000000,my $resolved_path = $self->_resolve_symlinks;
0.000000,0,0.000000,my $temp          = $resolved_path->_replacment_path;
0.000000,0,0.000000,
0.000000,0,0.000000,my $fh   = $temp->filehandle( { exclusive => 1, locked => 1 }, ">", $binmode );
0.000000,0,0.000000,print( {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data) or self->_throw('print', $temp->[PATH]);
0.000000,0,0.000000,close $fh or $self->_throw( 'close', $temp->[PATH] );
0.000000,0,0.000000,
0.000000,0,0.000000,return $temp->move($resolved_path);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub spew_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &spew }
0.000000,0,0.000000,
0.000000,0,0.000000,sub spew_utf8 {
0.000000,0,0.000000,if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,spew(
0.000000,0,0.000000,$self,
0.000000,0,0.000000,{ binmode => ":unix" },
0.000000,0,0.000000,map { Unicode::UTF8::encode_utf8($_) } map { ref eq 'ARRAY' ? @$_ : $_ } @_
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
0.000000,0,0.000000,splice @_, 1, 0, { binmode => ":unix:utf8_strict" };
0.000000,0,0.000000,goto &spew;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
0.000000,0,0.000000,goto &spew;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method stat, lstat
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $stat = path("foo.txt")->stat;
0.000000,0,0.000000,#pod     $stat = path("/some/symlink")->lstat;
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Like calling C<stat> or C<lstat> from L<File::stat>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.001.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX break out individual stat() components as subs?
0.000000,0,0.000000,sub stat {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,require File::stat;
0.000000,0,0.000000,return File::stat::stat( $self->[PATH] ) || $self->_throw('stat');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub lstat {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,require File::stat;
0.000000,0,0.000000,return File::stat::lstat( $self->[PATH] ) || $self->_throw('lstat');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method stringify
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $path = path("foo.txt");
0.000000,0,0.000000,#pod     say $path->stringify; # same as "$path"
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns a string representation of the path.  Unlike C<canonpath>, this method
0.000000,0,0.000000,#pod returns the path standardized with Unix-style C</> directory separators.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.001.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub stringify { $_[0]->[PATH] =~ /^~/ ? './' . $_[0]->[PATH] : $_[0]->[PATH] }
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method subsumes
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("foo/bar")->subsumes("foo/bar/baz"); # true
0.000000,0,0.000000,#pod     path("/foo/bar")->subsumes("/foo/baz");   # false
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns true if the first path is a prefix of the second path at a directory
0.000000,0,0.000000,#pod boundary.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod This B<does not> resolve parent directory entries (C<..>) or symlinks:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("foo/bar")->subsumes("foo/bar/../baz"); # true
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If such things are important to you, ensure that both paths are resolved to
0.000000,0,0.000000,#pod the filesystem with C<realpath>:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     my $p1 = path("foo/bar")->realpath;
0.000000,0,0.000000,#pod     my $p2 = path("foo/bar/../baz")->realpath;
0.000000,0,0.000000,#pod     if ( $p1->subsumes($p2) ) { ... }
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.048.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub subsumes {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,Carp::croak("subsumes() requires a defined, positive-length argument")
0.000000,0,0.000000,unless defined $_[0];
0.000000,0,0.000000,my $other = _path(shift);
0.000000,0,0.000000,
0.000000,0,0.000000,# normalize absolute vs relative
0.000000,0,0.000000,if ( $self->is_absolute && !$other->is_absolute ) {
0.000000,0,0.000000,$other = $other->absolute;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $other->is_absolute && !$self->is_absolute ) {
0.000000,0,0.000000,$self = $self->absolute;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# normalize volume vs non-volume; do this after absolute path
0.000000,0,0.000000,# adjustments above since that might add volumes already
0.000000,0,0.000000,if ( length $self->volume && !length $other->volume ) {
0.000000,0,0.000000,$other = $other->absolute;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( length $other->volume && !length $self->volume ) {
0.000000,0,0.000000,$self = $self->absolute;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->[PATH] eq '.' ) {
0.000000,0,0.000000,return !!1; # cwd subsumes everything relative
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $self->is_rootdir ) {
0.000000,0,0.000000,# a root directory ("/", "c:/") already ends with a separator
0.000000,0,0.000000,return $other->[PATH] =~ m{^\Q$self->[PATH]\E};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# exact match or prefix breaking at a separator
0.000000,0,0.000000,return $other->[PATH] =~ m{^\Q$self->[PATH]\E(?:/|\z)};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method touch
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("foo.txt")->touch;
0.000000,0,0.000000,#pod     path("foo.txt")->touch($epoch_secs);
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
0.000000,0,0.000000,#pod changes the modification and access times to the current time.  If the first
0.000000,0,0.000000,#pod argument is the epoch seconds then it will be used.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns the path object so it can be easily chained with other methods:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     # won't die if foo.txt doesn't exist
0.000000,0,0.000000,#pod     $content = path("foo.txt")->touch->slurp;
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.015.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub touch {
0.000000,0,0.000000,my ( $self, $epoch ) = @_;
0.000000,0,0.000000,if ( !-e $self->[PATH] ) {
0.000000,0,0.000000,my $fh = $self->openw;
0.000000,0,0.000000,close $fh or $self->_throw('close');
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( defined $epoch ) {
0.000000,0,0.000000,utime $epoch, $epoch, $self->[PATH]
0.000000,0,0.000000,or $self->_throw("utime ($epoch)");
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# literal undef prevents warnings :-(
0.000000,0,0.000000,utime undef, undef, $self->[PATH]
0.000000,0,0.000000,or $self->_throw("utime ()");
0.000000,0,0.000000,}
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method touchpath
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("bar/baz/foo.txt")->touchpath;
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Combines C<mkdir> and C<touch>.  Creates the parent directory if it doesn't exist,
0.000000,0,0.000000,#pod before touching the file.  Returns the path object like C<touch> does.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If you need to pass options, use C<mkdir> and C<touch> separately:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("bar/baz")->mkdir( \%options )->child("foo.txt")->touch($epoch_secs);
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.022.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub touchpath {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my $parent = $self->parent;
0.000000,0,0.000000,$parent->mkdir unless $parent->exists;
0.000000,0,0.000000,$self->touch;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method visit
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     path("/tmp")->visit( \&callback, \%options );
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Executes a callback for each child of a directory.  It returns a hash
0.000000,0,0.000000,#pod reference with any state accumulated during iteration.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod The options are the same as for L</iterator> (which it uses internally):
0.000000,0,0.000000,#pod C<recurse> and C<follow_symlinks>.  Both default to false.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod The callback function will receive a C<Path::Tiny> object as the first argument
0.000000,0,0.000000,#pod and a hash reference to accumulate state as the second argument.  For example:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     # collect files sizes
0.000000,0,0.000000,#pod     my $sizes = path("/tmp")->visit(
0.000000,0,0.000000,#pod         sub {
0.000000,0,0.000000,#pod             my ($path, $state) = @_;
0.000000,0,0.000000,#pod             return if $path->is_dir;
0.000000,0,0.000000,#pod             $state->{$path} = -s $path;
0.000000,0,0.000000,#pod         },
0.000000,0,0.000000,#pod         { recurse => 1 }
0.000000,0,0.000000,#pod     );
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod For convenience, the C<Path::Tiny> object will also be locally aliased as the
0.000000,0,0.000000,#pod C<$_> global variable:
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     # print paths matching /foo/
0.000000,0,0.000000,#pod     path("/tmp")->visit( sub { say if /foo/ }, { recurse => 1} );
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If the callback returns a B<reference> to a false scalar value, iteration will
0.000000,0,0.000000,#pod terminate.  This is not the same as "pruning" a directory search; this just
0.000000,0,0.000000,#pod stops all iteration and returns the state hash reference.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     # find up to 10 files larger than 100K
0.000000,0,0.000000,#pod     my $files = path("/tmp")->visit(
0.000000,0,0.000000,#pod         sub {
0.000000,0,0.000000,#pod             my ($path, $state) = @_;
0.000000,0,0.000000,#pod             $state->{$path}++ if -s $path > 102400
0.000000,0,0.000000,#pod             return \0 if keys %$state == 10;
0.000000,0,0.000000,#pod         },
0.000000,0,0.000000,#pod         { recurse => 1 }
0.000000,0,0.000000,#pod     );
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod If you want more flexible iteration, use a module like L<Path::Iterator::Rule>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.062.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub visit {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $cb   = shift;
0.000000,0,0.000000,my $args = _get_args( shift, qw/recurse follow_symlinks/ );
0.000000,0,0.000000,Carp::croak("Callback for visit() must be a code reference")
0.000000,0,0.000000,unless defined($cb) && ref($cb) eq 'CODE';
0.000000,0,0.000000,my $next  = $self->iterator($args);
0.000000,0,0.000000,my $state = {};
0.000000,0,0.000000,while ( my $file = $next->() ) {
0.000000,0,0.000000,local $_ = $file;
0.000000,0,0.000000,my $r = $cb->( $file, $state );
0.000000,0,0.000000,last if ref($r) eq 'SCALAR' && !$$r;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#pod =method volume
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod     $vol = path("/tmp/foo.txt")->volume;   # ""
0.000000,0,0.000000,#pod     $vol = path("C:/tmp/foo.txt")->volume; # "C:"
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Returns the volume portion of the path.  This is equivalent
0.000000,0,0.000000,#pod to what L<File::Spec> would give from C<splitpath> and thus
0.000000,0,0.000000,#pod usually is the empty string on Unix-like operating systems or the
0.000000,0,0.000000,#pod drive letter for an absolute path on C<MSWin32>.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod Current API available since 0.001.
0.000000,0,0.000000,#pod
0.000000,0,0.000000,#pod =cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub volume {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,$self->_splitpath unless defined $self->[VOL];
0.000000,0,0.000000,return $self->[VOL];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,package Path::Tiny::Error;
0.000000,0,0.000000,
0.000001,1,0.000001,our @CARP_NOT = qw/Path::Tiny/;
0.000000,0,0.000000,
0.000209,2,0.000105,use overload ( q{""} => sub { (shift)->{msg} }, fallback => 1 );
0.000000,0,0.000000,
0.000000,0,0.000000,sub throw {
0.000000,0,0.000000,my ( $class, $op, $file, $err ) = @_;
0.000000,0,0.000000,chomp( my $trace = Carp::shortmess );
0.000000,0,0.000000,my $msg = "Error $op on '$file': $err$trace\n";
0.000000,0,0.000000,die bless { op => $op, file => $file, err => $err, msg => $msg }, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000021,1,0.000021,1;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# vim: ts=4 sts=4 sw=4 et:
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
