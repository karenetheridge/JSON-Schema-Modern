# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package JSON::PP;
0.000000,0,0.000000,
0.000000,0,0.000000,# JSON-2.0
0.000000,0,0.000000,
0.000027,2,0.000013,use 5.005;
0.000015,2,0.000007,use strict;
0.000000,0,0.000000,
0.000019,2,0.000010,use Exporter ();
0.000018,1,0.000018,BEGIN { @JSON::PP::ISA = ('Exporter') }
0.000000,0,0.000000,
0.000015,2,0.000007,use overload ();
0.000158,2,0.000079,use JSON::PP::Boolean;
0.000000,0,0.000000,
0.000024,2,0.000012,use Carp ();
0.000000,0,0.000000,#use Devel::Peek;
0.000000,0,0.000000,
0.000001,1,0.000001,$JSON::PP::VERSION = '4.07';
0.000000,0,0.000000,
0.000001,1,0.000001,@JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
0.000000,0,0.000000,
0.000000,0,0.000000,# instead of hash-access, i tried index-access for speed.
0.000000,0,0.000000,# but this method is not faster than what i expected. so it will be changed.
0.000000,0,0.000000,
0.000015,2,0.000007,use constant P_ASCII                => 0;
0.000012,2,0.000006,use constant P_LATIN1               => 1;
0.000011,2,0.000005,use constant P_UTF8                 => 2;
0.000010,2,0.000005,use constant P_INDENT               => 3;
0.000011,2,0.000005,use constant P_CANONICAL            => 4;
0.000012,2,0.000006,use constant P_SPACE_BEFORE         => 5;
0.000009,2,0.000005,use constant P_SPACE_AFTER          => 6;
0.000011,2,0.000005,use constant P_ALLOW_NONREF         => 7;
0.000009,2,0.000005,use constant P_SHRINK               => 8;
0.000013,2,0.000007,use constant P_ALLOW_BLESSED        => 9;
0.000018,2,0.000009,use constant P_CONVERT_BLESSED      => 10;
0.000026,2,0.000013,use constant P_RELAXED              => 11;
0.000000,0,0.000000,
0.000036,2,0.000018,use constant P_LOOSE                => 12;
0.000037,2,0.000018,use constant P_ALLOW_BIGNUM         => 13;
0.000039,2,0.000019,use constant P_ALLOW_BAREKEY        => 14;
0.000142,2,0.000071,use constant P_ALLOW_SINGLEQUOTE    => 15;
0.000029,2,0.000015,use constant P_ESCAPE_SLASH         => 16;
0.000025,2,0.000012,use constant P_AS_NONBLESSED        => 17;
0.000000,0,0.000000,
0.000058,2,0.000029,use constant P_ALLOW_UNKNOWN        => 18;
0.000078,2,0.000039,use constant P_ALLOW_TAGS           => 19;
0.000000,0,0.000000,
0.000047,2,0.000024,use constant OLD_PERL => $] < 5.008 ? 1 : 0;
0.000040,2,0.000020,use constant USE_B => $ENV{PERL_JSON_PP_USE_B} || 0;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000002,1,0.000002,if (USE_B) {
0.000000,0,0.000000,require B;
0.000000,0,0.000000,}
0.000294,1,0.000294,}
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000004,1,0.000004,my @xs_compati_bit_properties = qw(
0.000000,0,0.000000,latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
0.000000,0,0.000000,allow_blessed convert_blessed relaxed allow_unknown
0.000000,0,0.000000,allow_tags
0.000000,0,0.000000,);
0.000001,1,0.000001,my @pp_bit_properties = qw(
0.000000,0,0.000000,allow_singlequote allow_bignum loose
0.000000,0,0.000000,allow_barekey escape_slash as_nonblessed
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Perl version check, Unicode handling is enabled?
0.000000,0,0.000000,# Helper module sets @JSON::PP::_properties.
0.000000,0,0.000000,if ( OLD_PERL ) {
0.000000,0,0.000000,my $helper = $] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';
0.000000,0,0.000000,eval qq| require $helper |;
0.000000,0,0.000000,if ($@) { Carp::croak $@; }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
0.000009,20,0.000000,my $property_id = 'P_' . uc($name);
0.000000,0,0.000000,
0.000868,20,0.000043,eval qq/
0.000000,0,0.000000,sub $name {
0.000000,0,0.000000,my \$enable = defined \$_[1] ? \$_[1] : 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if (\$enable) {
0.000000,0,0.000000,\$_[0]->{PROPS}->[$property_id] = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,\$_[0]->{PROPS}->[$property_id] = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,\$_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_$name {
0.000000,0,0.000000,\$_[0]->{PROPS}->[$property_id] ? 1 : '';
0.000000,0,0.000000,}
0.000000,0,0.000000,/;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001028,1,0.001028,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# Functions
0.000000,0,0.000000,
0.000000,1,0.000000,my $JSON; # cache
0.000000,0,0.000000,
0.000000,0,0.000000,sub encode_json ($) { # encode
0.000000,0,0.000000,($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub decode_json { # decode
0.000000,0,0.000000,($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Obsoleted
0.000000,0,0.000000,
0.000000,0,0.000000,sub to_json($) {
0.000000,0,0.000000,Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub from_json($) {
0.000000,0,0.000000,Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# Methods
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $self  = {
0.000000,0,0.000000,max_depth   => 512,
0.000000,0,0.000000,max_size    => 0,
0.000000,0,0.000000,indent_length => 3,
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{PROPS}[P_ALLOW_NONREF] = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,bless $self, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub encode {
0.000000,0,0.000000,return $_[0]->PP_encode_json($_[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub decode {
0.000000,0,0.000000,return $_[0]->PP_decode_json($_[1], 0x00000000);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub decode_prefix {
0.000000,0,0.000000,return $_[0]->PP_decode_json($_[1], 0x00000001);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# accessor
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# pretty printing
0.000000,0,0.000000,
0.000000,0,0.000000,sub pretty {
0.000000,0,0.000000,my ($self, $v) = @_;
0.000000,0,0.000000,my $enable = defined $v ? $v : 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($enable) { # indent_length(3) for JSON::XS compatibility
0.000000,0,0.000000,$self->indent(1)->space_before(1)->space_after(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->indent(0)->space_before(0)->space_after(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# etc
0.000000,0,0.000000,
0.000000,0,0.000000,sub max_depth {
0.000000,0,0.000000,my $max  = defined $_[1] ? $_[1] : 0x80000000;
0.000000,0,0.000000,$_[0]->{max_depth} = $max;
0.000000,0,0.000000,$_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_max_depth { $_[0]->{max_depth}; }
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub max_size {
0.000000,0,0.000000,my $max  = defined $_[1] ? $_[1] : 0;
0.000000,0,0.000000,$_[0]->{max_size} = $max;
0.000000,0,0.000000,$_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_max_size { $_[0]->{max_size}; }
0.000000,0,0.000000,
0.000000,0,0.000000,sub boolean_values {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,if (@_) {
0.000000,0,0.000000,my ($false, $true) = @_;
0.000000,0,0.000000,$self->{false} = $false;
0.000000,0,0.000000,$self->{true} = $true;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,delete $self->{false};
0.000000,0,0.000000,delete $self->{true};
0.000000,0,0.000000,}
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_boolean_values {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,if (exists $self->{true} and exists $self->{false}) {
0.000000,0,0.000000,return @$self{qw/false true/};
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub filter_json_object {
0.000000,0,0.000000,if (defined $_[1] and ref $_[1] eq 'CODE') {
0.000000,0,0.000000,$_[0]->{cb_object} = $_[1];
0.000000,0,0.000000,} else {
0.000000,0,0.000000,delete $_[0]->{cb_object};
0.000000,0,0.000000,}
0.000000,0,0.000000,$_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
0.000000,0,0.000000,$_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub filter_json_single_key_object {
0.000000,0,0.000000,if (@_ == 1 or @_ > 3) {
0.000000,0,0.000000,Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)");
0.000000,0,0.000000,}
0.000000,0,0.000000,if (defined $_[2] and ref $_[2] eq 'CODE') {
0.000000,0,0.000000,$_[0]->{cb_sk_object}->{$_[1]} = $_[2];
0.000000,0,0.000000,} else {
0.000000,0,0.000000,delete $_[0]->{cb_sk_object}->{$_[1]};
0.000000,0,0.000000,delete $_[0]->{cb_sk_object} unless %{$_[0]->{cb_sk_object} || {}};
0.000000,0,0.000000,}
0.000000,0,0.000000,$_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
0.000000,0,0.000000,$_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub indent_length {
0.000000,0,0.000000,if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
0.000000,0,0.000000,Carp::carp "The acceptable range of indent_length() is 0 to 15.";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$_[0]->{indent_length} = $_[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,$_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_indent_length {
0.000000,0,0.000000,$_[0]->{indent_length};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sort_by {
0.000000,0,0.000000,$_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
0.000000,0,0.000000,$_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub allow_bigint {
0.000000,0,0.000000,Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");
0.000000,0,0.000000,$_[0]->allow_bignum;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###############################
0.000000,0,0.000000,
0.000000,0,0.000000,###
0.000000,0,0.000000,### Perl => JSON
0.000000,0,0.000000,###
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,{ # Convert
0.000000,0,0.000000,
0.000000,1,0.000000,my $max_depth;
0.000000,0,0.000000,my $indent;
0.000000,0,0.000000,my $ascii;
0.000000,0,0.000000,my $latin1;
0.000000,0,0.000000,my $utf8;
0.000000,0,0.000000,my $space_before;
0.000000,0,0.000000,my $space_after;
0.000000,0,0.000000,my $canonical;
0.000000,0,0.000000,my $allow_blessed;
0.000000,0,0.000000,my $convert_blessed;
0.000000,0,0.000000,
0.000000,0,0.000000,my $indent_length;
0.000000,0,0.000000,my $escape_slash;
0.000000,0,0.000000,my $bignum;
0.000000,0,0.000000,my $as_nonblessed;
0.000000,0,0.000000,my $allow_tags;
0.000000,0,0.000000,
0.000000,0,0.000000,my $depth;
0.000000,0,0.000000,my $indent_count;
0.000000,0,0.000000,my $keysort;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub PP_encode_json {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $obj  = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,$indent_count = 0;
0.000000,0,0.000000,$depth        = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,my $props = $self->{PROPS};
0.000000,0,0.000000,
0.000000,0,0.000000,($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
0.000000,0,0.000000,$convert_blessed, $escape_slash, $bignum, $as_nonblessed, $allow_tags)
0.000000,0,0.000000,= @{$props}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
0.000000,0,0.000000,P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED, P_ALLOW_TAGS];
0.000000,0,0.000000,
0.000000,0,0.000000,($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
0.000000,0,0.000000,
0.000000,0,0.000000,$keysort = $canonical ? sub { $a cmp $b } : undef;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->{sort_by}) {
0.000000,0,0.000000,$keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
0.000000,0,0.000000,: $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
0.000000,0,0.000000,: sub { $a cmp $b };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
0.000000,0,0.000000,if(!ref $obj and !$props->[ P_ALLOW_NONREF ]);
0.000000,0,0.000000,
0.000000,0,0.000000,my $str  = $self->object_to_json($obj);
0.000000,0,0.000000,
0.000000,0,0.000000,$str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible
0.000000,0,0.000000,
0.000000,0,0.000000,unless ($ascii or $latin1 or $utf8) {
0.000000,0,0.000000,utf8::upgrade($str);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($props->[ P_SHRINK ]) {
0.000000,0,0.000000,utf8::downgrade($str, 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub object_to_json {
0.000000,0,0.000000,my ($self, $obj) = @_;
0.000000,0,0.000000,my $type = ref($obj);
0.000000,0,0.000000,
0.000000,0,0.000000,if($type eq 'HASH'){
0.000000,0,0.000000,return $self->hash_to_json($obj);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif($type eq 'ARRAY'){
0.000000,0,0.000000,return $self->array_to_json($obj);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type) { # blessed object?
0.000000,0,0.000000,if (blessed($obj)) {
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $allow_tags and $obj->can('FREEZE') ) {
0.000000,0,0.000000,my $obj_class = ref $obj || $obj;
0.000000,0,0.000000,$obj = bless $obj, $obj_class;
0.000000,0,0.000000,my @results = $obj->FREEZE('JSON');
0.000000,0,0.000000,if ( @results and ref $results[0] ) {
0.000000,0,0.000000,if ( refaddr( $obj ) eq refaddr( $results[0] ) ) {
0.000000,0,0.000000,encode_error( sprintf(
0.000000,0,0.000000,"%s::FREEZE method returned same object as was passed instead of a new one",
0.000000,0,0.000000,ref $obj
0.000000,0,0.000000,) );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return '("'.$obj_class.'")['.join(',', @results).']';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $convert_blessed and $obj->can('TO_JSON') ) {
0.000000,0,0.000000,my $result = $obj->TO_JSON();
0.000000,0,0.000000,if ( defined $result and ref( $result ) ) {
0.000000,0,0.000000,if ( refaddr( $obj ) eq refaddr( $result ) ) {
0.000000,0,0.000000,encode_error( sprintf(
0.000000,0,0.000000,"%s::TO_JSON method returned same object as was passed instead of a new one",
0.000000,0,0.000000,ref $obj
0.000000,0,0.000000,) );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->object_to_json( $result );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return "$obj" if ( $bignum and _is_bignum($obj) );
0.000000,0,0.000000,
0.000000,0,0.000000,if ($allow_blessed) {
0.000000,0,0.000000,return $self->blessed_to_json($obj) if ($as_nonblessed); # will be removed.
0.000000,0,0.000000,return 'null';
0.000000,0,0.000000,}
0.000000,0,0.000000,encode_error( sprintf("encountered object '%s', but neither allow_blessed, convert_blessed nor allow_tags settings are enabled (or TO_JSON/FREEZE method missing)", $obj)
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $self->value_to_json($obj);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else{
0.000000,0,0.000000,return $self->value_to_json($obj);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub hash_to_json {
0.000000,0,0.000000,my ($self, $obj) = @_;
0.000000,0,0.000000,my @res;
0.000000,0,0.000000,
0.000000,0,0.000000,encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
0.000000,0,0.000000,if (++$depth > $max_depth);
0.000000,0,0.000000,
0.000000,0,0.000000,my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
0.000000,0,0.000000,my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
0.000000,0,0.000000,
0.000000,0,0.000000,for my $k ( _sort( $obj ) ) {
0.000000,0,0.000000,if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
0.000000,0,0.000000,push @res, $self->string_to_json( $k )
0.000000,0,0.000000,.  $del
0.000000,0,0.000000,. ( ref $obj->{$k} ? $self->object_to_json( $obj->{$k} ) : $self->value_to_json( $obj->{$k} ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,--$depth;
0.000000,0,0.000000,$self->_down_indent() if ($indent);
0.000000,0,0.000000,
0.000000,0,0.000000,return '{}' unless @res;
0.000000,0,0.000000,return '{' . $pre . join( ",$pre", @res ) . $post . '}';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub array_to_json {
0.000000,0,0.000000,my ($self, $obj) = @_;
0.000000,0,0.000000,my @res;
0.000000,0,0.000000,
0.000000,0,0.000000,encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
0.000000,0,0.000000,if (++$depth > $max_depth);
0.000000,0,0.000000,
0.000000,0,0.000000,my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
0.000000,0,0.000000,
0.000000,0,0.000000,for my $v (@$obj){
0.000000,0,0.000000,push @res, ref($v) ? $self->object_to_json($v) : $self->value_to_json($v);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,--$depth;
0.000000,0,0.000000,$self->_down_indent() if ($indent);
0.000000,0,0.000000,
0.000000,0,0.000000,return '[]' unless @res;
0.000000,0,0.000000,return '[' . $pre . join( ",$pre", @res ) . $post . ']';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _looks_like_number {
0.000000,0,0.000000,my $value = shift;
0.000000,0,0.000000,if (USE_B) {
0.000000,0,0.000000,my $b_obj = B::svref_2object(\$value);
0.000000,0,0.000000,my $flags = $b_obj->FLAGS;
0.000000,0,0.000000,return 1 if $flags & ( B::SVp_IOK() | B::SVp_NOK() ) and !( $flags & B::SVp_POK() );
0.000000,0,0.000000,return;
0.000000,0,0.000000,} else {
0.000611,2,0.000305,no warnings 'numeric';
0.000000,0,0.000000,# if the utf8 flag is on, it almost certainly started as a string
0.000000,0,0.000000,return if utf8::is_utf8($value);
0.000000,0,0.000000,# detect numbers
0.000000,0,0.000000,# string & "" -> ""
0.000000,0,0.000000,# number & "" -> 0 (with warning)
0.000000,0,0.000000,# nan and inf can detect as numbers, so check with * 0
0.000000,0,0.000000,return unless length((my $dummy = "") & $value);
0.000000,0,0.000000,return unless 0 + $value eq $value;
0.000000,0,0.000000,return 1 if $value * 0 == 0;
0.000000,0,0.000000,return -1; # inf/nan
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub value_to_json {
0.000000,0,0.000000,my ($self, $value) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return 'null' if(!defined $value);
0.000000,0,0.000000,
0.000000,0,0.000000,my $type = ref($value);
0.000000,0,0.000000,
0.000000,0,0.000000,if (!$type) {
0.000000,0,0.000000,if (_looks_like_number($value)) {
0.000000,0,0.000000,return $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $self->string_to_json($value);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
0.000000,0,0.000000,return $$value == 1 ? 'true' : 'false';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
0.000000,0,0.000000,return $self->value_to_json("$value");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($type eq 'SCALAR' and defined $$value) {
0.000000,0,0.000000,return   $$value eq '1' ? 'true'
0.000000,0,0.000000,: $$value eq '0' ? 'false'
0.000000,0,0.000000,: $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
0.000000,0,0.000000,: encode_error("cannot encode reference to scalar");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
0.000000,0,0.000000,return 'null';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ( $type eq 'SCALAR' or $type eq 'REF' ) {
0.000000,0,0.000000,encode_error("cannot encode reference to scalar");
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000003,1,0.000003,my %esc = (
0.000000,0,0.000000,"\n" => '\n',
0.000000,0,0.000000,"\r" => '\r',
0.000000,0,0.000000,"\t" => '\t',
0.000000,0,0.000000,"\f" => '\f',
0.000000,0,0.000000,"\b" => '\b',
0.000000,0,0.000000,"\"" => '\"',
0.000000,0,0.000000,"\\" => '\\\\',
0.000000,0,0.000000,"\'" => '\\\'',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub string_to_json {
0.000000,0,0.000000,my ($self, $arg) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
0.000000,0,0.000000,$arg =~ s/\//\\\//g if ($escape_slash);
0.000000,0,0.000000,$arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($ascii) {
0.000000,0,0.000000,$arg = JSON_PP_encode_ascii($arg);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($latin1) {
0.000000,0,0.000000,$arg = JSON_PP_encode_latin1($arg);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($utf8) {
0.000000,0,0.000000,utf8::encode($arg);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return '"' . $arg . '"';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub blessed_to_json {
0.000000,0,0.000000,my $reftype = reftype($_[1]) || '';
0.000000,0,0.000000,if ($reftype eq 'HASH') {
0.000000,0,0.000000,return $_[0]->hash_to_json($_[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($reftype eq 'ARRAY') {
0.000000,0,0.000000,return $_[0]->array_to_json($_[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return 'null';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub encode_error {
0.000000,0,0.000000,my $error  = shift;
0.000000,0,0.000000,Carp::croak "$error";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _sort {
0.000000,0,0.000000,defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _up_indent {
0.000000,0,0.000000,my $self  = shift;
0.000000,0,0.000000,my $space = ' ' x $indent_length;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($pre,$post) = ('','');
0.000000,0,0.000000,
0.000000,0,0.000000,$post = "\n" . $space x $indent_count;
0.000000,0,0.000000,
0.000000,0,0.000000,$indent_count++;
0.000000,0,0.000000,
0.000000,0,0.000000,$pre = "\n" . $space x $indent_count;
0.000000,0,0.000000,
0.000000,0,0.000000,return ($pre,$post);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _down_indent { $indent_count--; }
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub PP_encode_box {
0.000000,0,0.000000,{
0.000000,0,0.000000,depth        => $depth,
0.000000,0,0.000000,indent_count => $indent_count,
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} # Convert
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,1,0.000000,sub _encode_ascii {
0.000000,0,0.000000,join('',
0.000000,0,0.000000,map {
0.000000,0,0.000000,$_ <= 127 ?
0.000000,0,0.000000,chr($_) :
0.000000,0,0.000000,$_ <= 65535 ?
0.000000,0,0.000000,sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
0.000000,0,0.000000,} unpack('U*', $_[0])
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _encode_latin1 {
0.000000,0,0.000000,join('',
0.000000,0,0.000000,map {
0.000000,0,0.000000,$_ <= 255 ?
0.000000,0,0.000000,chr($_) :
0.000000,0,0.000000,$_ <= 65535 ?
0.000000,0,0.000000,sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
0.000000,0,0.000000,} unpack('U*', $_[0])
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _encode_surrogates { # from perlunicode
0.000000,0,0.000000,my $uni = $_[0] - 0x10000;
0.000000,0,0.000000,return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _is_bignum {
0.000000,0,0.000000,$_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# JSON => Perl
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,1,0.000000,my $max_intsize;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,my $checkint = 1111;
0.000001,1,0.000001,for my $d (5..64) {
0.000002,17,0.000000,$checkint .= 1;
0.000113,17,0.000007,my $int   = eval qq| $checkint |;
0.000034,17,0.000002,if ($int =~ /[eE]/) {
0.000001,1,0.000001,$max_intsize = $d - 1;
0.000004,1,0.000004,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000258,1,0.000258,}
0.000000,0,0.000000,
0.000000,0,0.000000,{ # PARSE 
0.000000,0,0.000000,
0.000003,1,0.000003,my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
0.000000,0,0.000000,b    => "\x8",
0.000000,0,0.000000,t    => "\x9",
0.000000,0,0.000000,n    => "\xA",
0.000000,0,0.000000,f    => "\xC",
0.000000,0,0.000000,r    => "\xD",
0.000000,0,0.000000,'\\' => '\\',
0.000000,0,0.000000,'"'  => '"',
0.000000,0,0.000000,'/'  => '/',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,1,0.000000,my $text; # json data
0.000000,0,0.000000,my $at;   # offset
0.000000,0,0.000000,my $ch;   # first character
0.000000,0,0.000000,my $len;  # text length (changed according to UTF8 or NON UTF8)
0.000000,0,0.000000,# INTERNAL
0.000000,0,0.000000,my $depth;          # nest counter
0.000000,0,0.000000,my $encoding;       # json text encoding
0.000000,0,0.000000,my $is_valid_utf8;  # temp variable
0.000000,0,0.000000,my $utf8_len;       # utf8 byte length
0.000000,0,0.000000,# FLAGS
0.000000,0,0.000000,my $utf8;           # must be utf8
0.000000,0,0.000000,my $max_depth;      # max nest number of objects and arrays
0.000000,0,0.000000,my $max_size;
0.000000,0,0.000000,my $relaxed;
0.000000,0,0.000000,my $cb_object;
0.000000,0,0.000000,my $cb_sk_object;
0.000000,0,0.000000,
0.000000,0,0.000000,my $F_HOOK;
0.000000,0,0.000000,
0.000000,0,0.000000,my $allow_bignum;   # using Math::BigInt/BigFloat
0.000000,0,0.000000,my $singlequote;    # loosely quoting
0.000000,0,0.000000,my $loose;          # 
0.000000,0,0.000000,my $allow_barekey;  # bareKey
0.000000,0,0.000000,my $allow_tags;
0.000000,0,0.000000,
0.000000,0,0.000000,my $alt_true;
0.000000,1,0.000000,my $alt_false;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _detect_utf_encoding {
0.000000,0,0.000000,my $text = shift;
0.000000,0,0.000000,my @octets = unpack('C4', $text);
0.000000,0,0.000000,return 'unknown' unless defined $octets[3];
0.000000,0,0.000000,return ( $octets[0] and  $octets[1]) ? 'UTF-8'
0.000000,0,0.000000,: (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
0.000000,0,0.000000,: (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
0.000000,0,0.000000,: ( $octets[2]                ) ? 'UTF-16LE'
0.000000,0,0.000000,: (!$octets[2]                ) ? 'UTF-32LE'
0.000000,0,0.000000,: 'unknown';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub PP_decode_json {
0.000000,0,0.000000,my ($self, $want_offset);
0.000000,0,0.000000,
0.000000,0,0.000000,($self, $text, $want_offset) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,($at, $ch, $depth) = (0, '', 0);
0.000000,0,0.000000,
0.000000,0,0.000000,if ( !defined $text or ref $text ) {
0.000000,0,0.000000,decode_error("malformed JSON string, neither array, object, number, string or atom");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $props = $self->{PROPS};
0.000000,0,0.000000,
0.000000,0,0.000000,($utf8, $relaxed, $loose, $allow_bignum, $allow_barekey, $singlequote, $allow_tags)
0.000000,0,0.000000,= @{$props}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE, P_ALLOW_TAGS];
0.000000,0,0.000000,
0.000000,0,0.000000,($alt_true, $alt_false) = @$self{qw/true false/};
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $utf8 ) {
0.000000,0,0.000000,$encoding = _detect_utf_encoding($text);
0.000000,0,0.000000,if ($encoding ne 'UTF-8' and $encoding ne 'unknown') {
0.000000,0,0.000000,require Encode;
0.000000,0,0.000000,Encode::from_to($text, $encoding, 'utf-8');
0.000000,0,0.000000,} else {
0.000000,0,0.000000,utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,utf8::upgrade( $text );
0.000000,0,0.000000,utf8::encode( $text );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$len = length $text;
0.000000,0,0.000000,
0.000000,0,0.000000,($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
0.000000,0,0.000000,= @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
0.000000,0,0.000000,
0.000000,0,0.000000,if ($max_size > 1) {
0.002867,2,0.001434,use bytes;
0.000000,0,0.000000,my $bytes = length $text;
0.000000,0,0.000000,decode_error(
0.000000,0,0.000000,sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
0.000000,0,0.000000,, $bytes, $max_size), 1
0.000000,0,0.000000,) if ($bytes > $max_size);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,white(); # remove head white space
0.000000,0,0.000000,
0.000000,0,0.000000,decode_error("malformed JSON string, neither array, object, number, string or atom") unless defined $ch; # Is there a first character for JSON structure?
0.000000,0,0.000000,
0.000000,0,0.000000,my $result = value();
0.000000,0,0.000000,
0.000000,0,0.000000,if ( !$props->[ P_ALLOW_NONREF ] and !ref $result ) {
0.000000,0,0.000000,decode_error(
0.000000,0,0.000000,'JSON text must be an object or array (but found number, string, true, false or null,'
0.000000,0,0.000000,. ' use allow_nonref to allow this)', 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak('something wrong.') if $len < $at; # we won't arrive here.
0.000000,0,0.000000,
0.000000,0,0.000000,my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length
0.000000,0,0.000000,
0.000000,0,0.000000,white(); # remove tail white space
0.000000,0,0.000000,
0.000000,0,0.000000,return ( $result, $consumed ) if $want_offset; # all right if decode_prefix
0.000000,0,0.000000,
0.000000,0,0.000000,decode_error("garbage after JSON object") if defined $ch;
0.000000,0,0.000000,
0.000000,0,0.000000,$result;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub next_chr {
0.000000,0,0.000000,return $ch = undef if($at >= $len);
0.000000,0,0.000000,$ch = substr($text, $at++, 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub value {
0.000000,0,0.000000,white();
0.000000,0,0.000000,return          if(!defined $ch);
0.000000,0,0.000000,return object() if($ch eq '{');
0.000000,0,0.000000,return array()  if($ch eq '[');
0.000000,0,0.000000,return tag()    if($ch eq '(');
0.000000,0,0.000000,return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
0.000000,0,0.000000,return number() if($ch =~ /[0-9]/ or $ch eq '-');
0.000000,0,0.000000,return word();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub string {
0.000000,0,0.000000,my $utf16;
0.000000,0,0.000000,my $is_utf8;
0.000000,0,0.000000,
0.000000,0,0.000000,($is_valid_utf8, $utf8_len) = ('', 0);
0.000000,0,0.000000,
0.000000,0,0.000000,my $s = ''; # basically UTF8 flag on
0.000000,0,0.000000,
0.000000,0,0.000000,if($ch eq '"' or ($singlequote and $ch eq "'")){
0.000000,0,0.000000,my $boundChar = $ch;
0.000000,0,0.000000,
0.000000,0,0.000000,OUTER: while( defined(next_chr()) ){
0.000000,0,0.000000,
0.000000,0,0.000000,if($ch eq $boundChar){
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,
0.000000,0,0.000000,if ($utf16) {
0.000000,0,0.000000,decode_error("missing low surrogate character in surrogate pair");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,utf8::decode($s) if($is_utf8);
0.000000,0,0.000000,
0.000000,0,0.000000,return $s;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif($ch eq '\\'){
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,if(exists $escapes{$ch}){
0.000000,0,0.000000,$s .= $escapes{$ch};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif($ch eq 'u'){ # UNICODE handling
0.000000,0,0.000000,my $u = '';
0.000000,0,0.000000,
0.000000,0,0.000000,for(1..4){
0.000000,0,0.000000,$ch = next_chr();
0.000000,0,0.000000,last OUTER if($ch !~ /[0-9a-fA-F]/);
0.000000,0,0.000000,$u .= $ch;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# U+D800 - U+DBFF
0.000000,0,0.000000,if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
0.000000,0,0.000000,$utf16 = $u;
0.000000,0,0.000000,}
0.000000,0,0.000000,# U+DC00 - U+DFFF
0.000000,0,0.000000,elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
0.000000,0,0.000000,unless (defined $utf16) {
0.000000,0,0.000000,decode_error("missing high surrogate character in surrogate pair");
0.000000,0,0.000000,}
0.000000,0,0.000000,$is_utf8 = 1;
0.000000,0,0.000000,$s .= JSON_PP_decode_surrogates($utf16, $u) || next;
0.000000,0,0.000000,$utf16 = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if (defined $utf16) {
0.000000,0,0.000000,decode_error("surrogate pair expected");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ( my $hex = hex( $u ) ) > 127 ) {
0.000000,0,0.000000,$is_utf8 = 1;
0.000000,0,0.000000,$s .= JSON_PP_decode_unicode($u) || next;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$s .= chr $hex;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,else{
0.000000,0,0.000000,unless ($loose) {
0.000000,0,0.000000,$at -= 2;
0.000000,0,0.000000,decode_error('illegal backslash escape sequence in string');
0.000000,0,0.000000,}
0.000000,0,0.000000,$s .= $ch;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else{
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ord $ch  > 127 ) {
0.000000,0,0.000000,unless( $ch = is_valid_utf8($ch) ) {
0.000000,0,0.000000,$at -= 1;
0.000000,0,0.000000,decode_error("malformed UTF-8 character in JSON string");
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$at += $utf8_len - 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$is_utf8 = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (!$loose) {
0.000000,0,0.000000,if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
0.000000,0,0.000000,if (!$relaxed or $ch ne "\t") {
0.000000,0,0.000000,$at--;
0.000000,0,0.000000,decode_error('invalid character encountered while parsing JSON string');
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$s .= $ch;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,decode_error("unexpected end of string while parsing JSON string");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub white {
0.000000,0,0.000000,while( defined $ch  ){
0.000000,0,0.000000,if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif($relaxed and $ch eq '/'){
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,if(defined $ch and $ch eq '/'){
0.000000,0,0.000000,1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif(defined $ch and $ch eq '*'){
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,while(1){
0.000000,0,0.000000,if(defined $ch){
0.000000,0,0.000000,if($ch eq '*'){
0.000000,0,0.000000,if(defined(next_chr()) and $ch eq '/'){
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else{
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else{
0.000000,0,0.000000,decode_error("Unterminated comment");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,else{
0.000000,0,0.000000,$at--;
0.000000,0,0.000000,decode_error("malformed JSON string, neither array, object, number, string or atom");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else{
0.000000,0,0.000000,if ($relaxed and $ch eq '#') { # correctly?
0.000000,0,0.000000,pos($text) = $at;
0.000000,0,0.000000,$text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
0.000000,0,0.000000,$at = pos($text);
0.000000,0,0.000000,next_chr;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub array {
0.000000,0,0.000000,my $a  = $_[0] || []; # you can use this code to use another array ref object.
0.000000,0,0.000000,
0.000000,0,0.000000,decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
0.000000,0,0.000000,if (++$depth > $max_depth);
0.000000,0,0.000000,
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,white();
0.000000,0,0.000000,
0.000000,0,0.000000,if(defined $ch and $ch eq ']'){
0.000000,0,0.000000,--$depth;
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,return $a;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,while(defined($ch)){
0.000000,0,0.000000,push @$a, value();
0.000000,0,0.000000,
0.000000,0,0.000000,white();
0.000000,0,0.000000,
0.000000,0,0.000000,if (!defined $ch) {
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if($ch eq ']'){
0.000000,0,0.000000,--$depth;
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,return $a;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if($ch ne ','){
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,white();
0.000000,0,0.000000,
0.000000,0,0.000000,if ($relaxed and $ch eq ']') {
0.000000,0,0.000000,--$depth;
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,return $a;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$at-- if defined $ch and $ch ne '';
0.000000,0,0.000000,decode_error(", or ] expected while parsing array");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub tag {
0.000000,0,0.000000,decode_error('malformed JSON string, neither array, object, number, string or atom') unless $allow_tags;
0.000000,0,0.000000,
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,white();
0.000000,0,0.000000,
0.000000,0,0.000000,my $tag = value();
0.000000,0,0.000000,return unless defined $tag;
0.000000,0,0.000000,decode_error('malformed JSON string, (tag) must be a string') if ref $tag;
0.000000,0,0.000000,
0.000000,0,0.000000,white();
0.000000,0,0.000000,
0.000000,0,0.000000,if (!defined $ch or $ch ne ')') {
0.000000,0,0.000000,decode_error(') expected after tag');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,white();
0.000000,0,0.000000,
0.000000,0,0.000000,my $val = value();
0.000000,0,0.000000,return unless defined $val;
0.000000,0,0.000000,decode_error('malformed JSON string, tag value must be an array') unless ref $val eq 'ARRAY';
0.000000,0,0.000000,
0.000000,0,0.000000,if (!eval { $tag->can('THAW') }) {
0.000000,0,0.000000,decode_error('cannot decode perl-object (package does not exist)') if $@;
0.000000,0,0.000000,decode_error('cannot decode perl-object (package does not have a THAW method)');
0.000000,0,0.000000,}
0.000000,0,0.000000,$tag->THAW('JSON', @$val);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub object {
0.000000,0,0.000000,my $o = $_[0] || {}; # you can use this code to use another hash ref object.
0.000000,0,0.000000,my $k;
0.000000,0,0.000000,
0.000000,0,0.000000,decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
0.000000,0,0.000000,if (++$depth > $max_depth);
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,white();
0.000000,0,0.000000,
0.000000,0,0.000000,if(defined $ch and $ch eq '}'){
0.000000,0,0.000000,--$depth;
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,if ($F_HOOK) {
0.000000,0,0.000000,return _json_object_hook($o);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $o;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,while (defined $ch) {
0.000000,0,0.000000,$k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
0.000000,0,0.000000,white();
0.000000,0,0.000000,
0.000000,0,0.000000,if(!defined $ch or $ch ne ':'){
0.000000,0,0.000000,$at--;
0.000000,0,0.000000,decode_error("':' expected");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,$o->{$k} = value();
0.000000,0,0.000000,white();
0.000000,0,0.000000,
0.000000,0,0.000000,last if (!defined $ch);
0.000000,0,0.000000,
0.000000,0,0.000000,if($ch eq '}'){
0.000000,0,0.000000,--$depth;
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,if ($F_HOOK) {
0.000000,0,0.000000,return _json_object_hook($o);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $o;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if($ch ne ','){
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,white();
0.000000,0,0.000000,
0.000000,0,0.000000,if ($relaxed and $ch eq '}') {
0.000000,0,0.000000,--$depth;
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,if ($F_HOOK) {
0.000000,0,0.000000,return _json_object_hook($o);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $o;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$at-- if defined $ch and $ch ne '';
0.000000,0,0.000000,decode_error(", or } expected while parsing object/hash");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
0.000000,0,0.000000,my $key;
0.000000,0,0.000000,while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
0.000000,0,0.000000,$key .= $ch;
0.000000,0,0.000000,next_chr();
0.000000,0,0.000000,}
0.000000,0,0.000000,return $key;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub word {
0.000000,0,0.000000,my $word =  substr($text,$at-1,4);
0.000000,0,0.000000,
0.000000,0,0.000000,if($word eq 'true'){
0.000000,0,0.000000,$at += 3;
0.000000,0,0.000000,next_chr;
0.000000,0,0.000000,return defined $alt_true ? $alt_true : $JSON::PP::true;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif($word eq 'null'){
0.000000,0,0.000000,$at += 3;
0.000000,0,0.000000,next_chr;
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif($word eq 'fals'){
0.000000,0,0.000000,$at += 3;
0.000000,0,0.000000,if(substr($text,$at,1) eq 'e'){
0.000000,0,0.000000,$at++;
0.000000,0,0.000000,next_chr;
0.000000,0,0.000000,return defined $alt_false ? $alt_false : $JSON::PP::false;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$at--; # for decode_error report
0.000000,0,0.000000,
0.000000,0,0.000000,decode_error("'null' expected")  if ($word =~ /^n/);
0.000000,0,0.000000,decode_error("'true' expected")  if ($word =~ /^t/);
0.000000,0,0.000000,decode_error("'false' expected") if ($word =~ /^f/);
0.000000,0,0.000000,decode_error("malformed JSON string, neither array, object, number, string or atom");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub number {
0.000000,0,0.000000,my $n    = '';
0.000000,0,0.000000,my $v;
0.000000,0,0.000000,my $is_dec;
0.000000,0,0.000000,my $is_exp;
0.000000,0,0.000000,
0.000000,0,0.000000,if($ch eq '-'){
0.000000,0,0.000000,$n = '-';
0.000000,0,0.000000,next_chr;
0.000000,0,0.000000,if (!defined $ch or $ch !~ /\d/) {
0.000000,0,0.000000,decode_error("malformed number (no digits after initial minus)");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# According to RFC4627, hex or oct digits are invalid.
0.000000,0,0.000000,if($ch eq '0'){
0.000000,0,0.000000,my $peek = substr($text,$at,1);
0.000000,0,0.000000,if($peek =~ /^[0-9a-dfA-DF]/){ # e may be valid (exponential)
0.000000,0,0.000000,decode_error("malformed number (leading zero must not be followed by another digit)");
0.000000,0,0.000000,}
0.000000,0,0.000000,$n .= $ch;
0.000000,0,0.000000,next_chr;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,while(defined $ch and $ch =~ /\d/){
0.000000,0,0.000000,$n .= $ch;
0.000000,0,0.000000,next_chr;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(defined $ch and $ch eq '.'){
0.000000,0,0.000000,$n .= '.';
0.000000,0,0.000000,$is_dec = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,next_chr;
0.000000,0,0.000000,if (!defined $ch or $ch !~ /\d/) {
0.000000,0,0.000000,decode_error("malformed number (no digits after decimal point)");
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$n .= $ch;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,while(defined(next_chr) and $ch =~ /\d/){
0.000000,0,0.000000,$n .= $ch;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
0.000000,0,0.000000,$n .= $ch;
0.000000,0,0.000000,$is_exp = 1;
0.000000,0,0.000000,next_chr;
0.000000,0,0.000000,
0.000000,0,0.000000,if(defined($ch) and ($ch eq '+' or $ch eq '-')){
0.000000,0,0.000000,$n .= $ch;
0.000000,0,0.000000,next_chr;
0.000000,0,0.000000,if (!defined $ch or $ch =~ /\D/) {
0.000000,0,0.000000,decode_error("malformed number (no digits after exp sign)");
0.000000,0,0.000000,}
0.000000,0,0.000000,$n .= $ch;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif(defined($ch) and $ch =~ /\d/){
0.000000,0,0.000000,$n .= $ch;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,decode_error("malformed number (no digits after exp sign)");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,while(defined(next_chr) and $ch =~ /\d/){
0.000000,0,0.000000,$n .= $ch;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$v .= $n;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($is_dec or $is_exp) {
0.000000,0,0.000000,if ($allow_bignum) {
0.000000,0,0.000000,require Math::BigFloat;
0.000000,0,0.000000,return Math::BigFloat->new($v);
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,if (length $v > $max_intsize) {
0.000000,0,0.000000,if ($allow_bignum) { # from Adam Sussman
0.000000,0,0.000000,require Math::BigInt;
0.000000,0,0.000000,return Math::BigInt->new($v);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return "$v";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $is_dec ? $v/1.0 : 0+$v;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_valid_utf8 {
0.000000,0,0.000000,
0.000000,0,0.000000,$utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
0.000000,0,0.000000,: $_[0] =~ /[\xC2-\xDF]/  ? 2
0.000000,0,0.000000,: $_[0] =~ /[\xE0-\xEF]/  ? 3
0.000000,0,0.000000,: $_[0] =~ /[\xF0-\xF4]/  ? 4
0.000000,0,0.000000,: 0
0.000000,0,0.000000,;
0.000000,0,0.000000,
0.000000,0,0.000000,return unless $utf8_len;
0.000000,0,0.000000,
0.000000,0,0.000000,my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
0.000000,0,0.000000,
0.000000,0,0.000000,return ( $is_valid_utf8 =~ /^(?:
0.000000,0,0.000000,[\x00-\x7F]
0.000000,0,0.000000,|[\xC2-\xDF][\x80-\xBF]
0.000000,0,0.000000,|[\xE0][\xA0-\xBF][\x80-\xBF]
0.000000,0,0.000000,|[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
0.000000,0,0.000000,|[\xED][\x80-\x9F][\x80-\xBF]
0.000000,0,0.000000,|[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
0.000000,0,0.000000,|[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
0.000000,0,0.000000,|[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
0.000000,0,0.000000,|[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
0.000000,0,0.000000,)$/x )  ? $is_valid_utf8 : '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub decode_error {
0.000000,0,0.000000,my $error  = shift;
0.000000,0,0.000000,my $no_rep = shift;
0.000000,0,0.000000,my $str    = defined $text ? substr($text, $at) : '';
0.000000,0,0.000000,my $mess   = '';
0.000000,0,0.000000,my $type   = 'U*';
0.000000,0,0.000000,
0.000000,0,0.000000,if ( OLD_PERL ) {
0.000000,0,0.000000,my $type   =  $] <  5.006           ? 'C*'
0.000000,0,0.000000,: utf8::is_utf8( $str ) ? 'U*' # 5.6
0.000000,0,0.000000,: 'C*'
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
0.000000,0,0.000000,$mess .=  $c == 0x07 ? '\a'
0.000000,0,0.000000,: $c == 0x09 ? '\t'
0.000000,0,0.000000,: $c == 0x0a ? '\n'
0.000000,0,0.000000,: $c == 0x0d ? '\r'
0.000000,0,0.000000,: $c == 0x0c ? '\f'
0.000000,0,0.000000,: $c <  0x20 ? sprintf('\x{%x}', $c)
0.000000,0,0.000000,: $c == 0x5c ? '\\\\'
0.000000,0,0.000000,: $c <  0x80 ? chr($c)
0.000000,0,0.000000,: sprintf('\x{%x}', $c)
0.000000,0,0.000000,;
0.000000,0,0.000000,if ( length $mess >= 20 ) {
0.000000,0,0.000000,$mess .= '...';
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( length $mess ) {
0.000000,0,0.000000,$mess = '(end of string)';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak (
0.000000,0,0.000000,$no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _json_object_hook {
0.000000,0,0.000000,my $o    = $_[0];
0.000000,0,0.000000,my @ks = keys %{$o};
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
0.000000,0,0.000000,my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
0.000000,0,0.000000,if (@val == 0) {
0.000000,0,0.000000,return $o;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (@val == 1) {
0.000000,0,0.000000,return $val[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Carp::croak("filter_json_single_key_object callbacks must not return more than one scalar");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @val = $cb_object->($o) if ($cb_object);
0.000000,0,0.000000,if (@val == 0) {
0.000000,0,0.000000,return $o;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (@val == 1) {
0.000000,0,0.000000,return $val[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Carp::croak("filter_json_object callbacks must not return more than one scalar");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub PP_decode_box {
0.000000,0,0.000000,{
0.000000,0,0.000000,text    => $text,
0.000000,0,0.000000,at      => $at,
0.000000,0,0.000000,ch      => $ch,
0.000000,0,0.000000,len     => $len,
0.000000,0,0.000000,depth   => $depth,
0.000000,0,0.000000,encoding      => $encoding,
0.000000,0,0.000000,is_valid_utf8 => $is_valid_utf8,
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} # PARSE
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,1,0.000000,sub _decode_surrogates { # from perlunicode
0.000000,0,0.000000,my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
0.000000,0,0.000000,my $un  = pack('U*', $uni);
0.000000,0,0.000000,utf8::encode( $un );
0.000000,0,0.000000,return $un;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _decode_unicode {
0.000000,0,0.000000,my $un = pack('U', hex shift);
0.000000,0,0.000000,utf8::encode( $un );
0.000000,0,0.000000,return $un;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# Setup for various Perl versions (the code from JSON::PP58)
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,
0.000000,1,0.000000,unless ( defined &utf8::is_utf8 ) {
0.000000,0,0.000000,require Encode;
0.000000,0,0.000000,*utf8::is_utf8 = *Encode::is_utf8;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,if ( !OLD_PERL ) {
0.000001,1,0.000001,*JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
0.000001,1,0.000001,*JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
0.000000,1,0.000000,*JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
0.000001,1,0.000001,*JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
0.000000,0,0.000000,
0.000000,1,0.000000,if ($] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
0.000000,0,0.000000,package JSON::PP;
0.000000,0,0.000000,require subs;
0.000000,0,0.000000,subs->import('join');
0.000000,0,0.000000,eval q|
0.000000,0,0.000000,sub join {
0.000000,0,0.000000,return '' if (@_ < 2);
0.000000,0,0.000000,my $j   = shift;
0.000000,0,0.000000,my $str = shift;
0.000000,0,0.000000,for (@_) { $str .= $j . $_; }
0.000000,0,0.000000,return $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,|;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub JSON::PP::incr_parse {
0.000000,0,0.000000,local $Carp::CarpLevel = 1;
0.000000,0,0.000000,( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub JSON::PP::incr_skip {
0.000000,0,0.000000,( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub JSON::PP::incr_reset {
0.000000,0,0.000000,( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000053,1,0.000053,eval q{
0.000000,0,0.000000,sub JSON::PP::incr_text : lvalue {
0.000000,0,0.000000,$_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $_[0]->{_incr_parser}->{incr_pos} ) {
0.000000,0,0.000000,Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
0.000000,0,0.000000,}
0.000000,0,0.000000,$_[0]->{_incr_parser}->{incr_text};
0.000000,0,0.000000,}
0.000000,0,0.000000,} if ( $] >= 5.006 );
0.000000,0,0.000000,
0.000252,1,0.000252,} # Setup for various Perl versions (the code from JSON::PP58)
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,###############################
0.000000,0,0.000000,# Utilities
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000019,1,0.000019,eval 'require Scalar::Util';
0.000004,1,0.000004,unless($@){
0.000001,1,0.000001,*JSON::PP::blessed = \&Scalar::Util::blessed;
0.000001,1,0.000001,*JSON::PP::reftype = \&Scalar::Util::reftype;
0.000000,1,0.000000,*JSON::PP::refaddr = \&Scalar::Util::refaddr;
0.000000,0,0.000000,}
0.000000,0,0.000000,else{ # This code is from Scalar::Util.
0.000000,0,0.000000,# warn $@;
0.000000,0,0.000000,eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
0.000000,0,0.000000,*JSON::PP::blessed = sub {
0.000000,0,0.000000,local($@, $SIG{__DIE__}, $SIG{__WARN__});
0.000000,0,0.000000,ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
0.000000,0,0.000000,};
0.000000,0,0.000000,require B;
0.000000,0,0.000000,my %tmap = qw(
0.000000,0,0.000000,B::NULL   SCALAR
0.000000,0,0.000000,B::HV     HASH
0.000000,0,0.000000,B::AV     ARRAY
0.000000,0,0.000000,B::CV     CODE
0.000000,0,0.000000,B::IO     IO
0.000000,0,0.000000,B::GV     GLOB
0.000000,0,0.000000,B::REGEXP REGEXP
0.000000,0,0.000000,);
0.000000,0,0.000000,*JSON::PP::reftype = sub {
0.000000,0,0.000000,my $r = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef unless length(ref($r));
0.000000,0,0.000000,
0.000000,0,0.000000,my $t = ref(B::svref_2object($r));
0.000000,0,0.000000,
0.000000,0,0.000000,return
0.000000,0,0.000000,exists $tmap{$t} ? $tmap{$t}
0.000000,0,0.000000,: length(ref($$r)) ? 'REF'
0.000000,0,0.000000,:                    'SCALAR';
0.000000,0,0.000000,};
0.000000,0,0.000000,*JSON::PP::refaddr = sub {
0.000000,0,0.000000,return undef unless length(ref($_[0]));
0.000000,0,0.000000,
0.000000,0,0.000000,my $addr;
0.000000,0,0.000000,if(defined(my $pkg = blessed($_[0]))) {
0.000000,0,0.000000,$addr .= bless $_[0], 'Scalar::Util::Fake';
0.000000,0,0.000000,bless $_[0], $pkg;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$addr .= $_[0]
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$addr =~ /0x(\w+)/;
0.000000,0,0.000000,local $^W;
0.000000,0,0.000000,#no warnings 'portable';
0.000000,0,0.000000,hex($1);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000117,1,0.000117,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# shamelessly copied and modified from JSON::XS code.
0.000000,0,0.000000,
0.000001,1,0.000001,$JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
0.000000,1,0.000000,$JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_bool { blessed $_[0] and ( $_[0]->isa("JSON::PP::Boolean") or $_[0]->isa("Types::Serialiser::BooleanBase") or $_[0]->isa("JSON::XS::Boolean") ); }
0.000000,0,0.000000,
0.001917,584,0.000003,sub true  { $JSON::PP::true  }
0.001239,410,0.000003,sub false { $JSON::PP::false }
0.000000,0,0.000000,sub null  { undef; }
0.000000,0,0.000000,
0.000000,0,0.000000,###############################
0.000000,0,0.000000,
0.000000,0,0.000000,package JSON::PP::IncrParser;
0.000000,0,0.000000,
0.000031,2,0.000016,use strict;
0.000000,0,0.000000,
0.000040,2,0.000020,use constant INCR_M_WS   => 0; # initial whitespace skipping
0.000023,2,0.000012,use constant INCR_M_STR  => 1; # inside string
0.000073,2,0.000036,use constant INCR_M_BS   => 2; # inside backslash
0.000038,2,0.000019,use constant INCR_M_JSON => 3; # outside anything, count nesting
0.000041,2,0.000020,use constant INCR_M_C0   => 4;
0.000026,2,0.000013,use constant INCR_M_C1   => 5;
0.000029,2,0.000015,use constant INCR_M_TFN  => 6;
0.000189,2,0.000094,use constant INCR_M_NUM  => 7;
0.000000,0,0.000000,
0.000001,1,0.000001,$JSON::PP::IncrParser::VERSION = '1.01';
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my ( $class ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,bless {
0.000000,0,0.000000,incr_nest    => 0,
0.000000,0,0.000000,incr_text    => undef,
0.000000,0,0.000000,incr_pos     => 0,
0.000000,0,0.000000,incr_mode    => 0,
0.000000,0,0.000000,}, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub incr_parse {
0.000000,0,0.000000,my ( $self, $coder, $text ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{incr_text} = '' unless ( defined $self->{incr_text} );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( defined $text ) {
0.000000,0,0.000000,if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
0.000000,0,0.000000,utf8::upgrade( $self->{incr_text} ) ;
0.000000,0,0.000000,utf8::decode( $self->{incr_text} ) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->{incr_text} .= $text;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( defined wantarray ) {
0.000000,0,0.000000,my $max_size = $coder->get_max_size;
0.000000,0,0.000000,my $p = $self->{incr_pos};
0.000000,0,0.000000,my @ret;
0.000000,0,0.000000,{
0.000000,0,0.000000,do {
0.000000,0,0.000000,unless ( $self->{incr_nest} <= 0 and $self->{incr_mode} == INCR_M_JSON ) {
0.000000,0,0.000000,$self->_incr_parse( $coder );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $max_size and $self->{incr_pos} > $max_size ) {
0.000000,0,0.000000,Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size");
0.000000,0,0.000000,}
0.000000,0,0.000000,unless ( $self->{incr_nest} <= 0 and $self->{incr_mode} == INCR_M_JSON ) {
0.000000,0,0.000000,# as an optimisation, do not accumulate white space in the incr buffer
0.000000,0,0.000000,if ( $self->{incr_mode} == INCR_M_WS and $self->{incr_pos} ) {
0.000000,0,0.000000,$self->{incr_pos} = 0;
0.000000,0,0.000000,$self->{incr_text} = '';
0.000000,0,0.000000,}
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( $coder->get_utf8 ) {
0.000000,0,0.000000,utf8::upgrade( $self->{incr_text} );
0.000000,0,0.000000,utf8::decode( $self->{incr_text} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my ($obj, $offset) = $coder->PP_decode_json( $self->{incr_text}, 0x00000001 );
0.000000,0,0.000000,push @ret, $obj;
0.000673,2,0.000336,use bytes;
0.000000,0,0.000000,$self->{incr_text} = substr( $self->{incr_text}, $offset || 0 );
0.000000,0,0.000000,$self->{incr_pos} = 0;
0.000000,0,0.000000,$self->{incr_nest} = 0;
0.000000,0,0.000000,$self->{incr_mode} = 0;
0.000000,0,0.000000,last unless wantarray;
0.000000,0,0.000000,} while ( wantarray );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( wantarray ) {
0.000000,0,0.000000,return @ret;
0.000000,0,0.000000,}
0.000000,0,0.000000,else { # in scalar context
0.000000,0,0.000000,return defined $ret[0] ? $ret[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _incr_parse {
0.000000,0,0.000000,my ($self, $coder) = @_;
0.000000,0,0.000000,my $text = $self->{incr_text};
0.000000,0,0.000000,my $len = length $text;
0.000000,0,0.000000,my $p = $self->{incr_pos};
0.000000,0,0.000000,
0.000000,0,0.000000,INCR_PARSE:
0.000000,0,0.000000,while ( $len > $p ) {
0.000000,0,0.000000,my $s = substr( $text, $p, 1 );
0.000000,0,0.000000,last INCR_PARSE unless defined $s;
0.000000,0,0.000000,my $mode = $self->{incr_mode};
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $mode == INCR_M_WS ) {
0.000000,0,0.000000,while ( $len > $p ) {
0.000000,0,0.000000,$s = substr( $text, $p, 1 );
0.000000,0,0.000000,last INCR_PARSE unless defined $s;
0.000000,0,0.000000,if ( ord($s) > 0x20 ) {
0.000000,0,0.000000,if ( $s eq '#' ) {
0.000000,0,0.000000,$self->{incr_mode} = INCR_M_C0;
0.000000,0,0.000000,redo INCR_PARSE;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$self->{incr_mode} = INCR_M_JSON;
0.000000,0,0.000000,redo INCR_PARSE;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$p++;
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif ( $mode == INCR_M_BS ) {
0.000000,0,0.000000,$p++;
0.000000,0,0.000000,$self->{incr_mode} = INCR_M_STR;
0.000000,0,0.000000,redo INCR_PARSE;
0.000000,0,0.000000,} elsif ( $mode == INCR_M_C0 or $mode == INCR_M_C1 ) {
0.000000,0,0.000000,while ( $len > $p ) {
0.000000,0,0.000000,$s = substr( $text, $p, 1 );
0.000000,0,0.000000,last INCR_PARSE unless defined $s;
0.000000,0,0.000000,if ( $s eq "\n" ) {
0.000000,0,0.000000,$self->{incr_mode} = $self->{incr_mode} == INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,$p++;
0.000000,0,0.000000,}
0.000000,0,0.000000,next;
0.000000,0,0.000000,} elsif ( $mode == INCR_M_TFN ) {
0.000000,0,0.000000,while ( $len > $p ) {
0.000000,0,0.000000,$s = substr( $text, $p++, 1 );
0.000000,0,0.000000,next if defined $s and $s =~ /[rueals]/;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,$p--;
0.000000,0,0.000000,$self->{incr_mode} = INCR_M_JSON;
0.000000,0,0.000000,
0.000000,0,0.000000,last INCR_PARSE unless $self->{incr_nest};
0.000000,0,0.000000,redo INCR_PARSE;
0.000000,0,0.000000,} elsif ( $mode == INCR_M_NUM ) {
0.000000,0,0.000000,while ( $len > $p ) {
0.000000,0,0.000000,$s = substr( $text, $p++, 1 );
0.000000,0,0.000000,next if defined $s and $s =~ /[0-9eE.+\-]/;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,$p--;
0.000000,0,0.000000,$self->{incr_mode} = INCR_M_JSON;
0.000000,0,0.000000,
0.000000,0,0.000000,last INCR_PARSE unless $self->{incr_nest};
0.000000,0,0.000000,redo INCR_PARSE;
0.000000,0,0.000000,} elsif ( $mode == INCR_M_STR ) {
0.000000,0,0.000000,while ( $len > $p ) {
0.000000,0,0.000000,$s = substr( $text, $p, 1 );
0.000000,0,0.000000,last INCR_PARSE unless defined $s;
0.000000,0,0.000000,if ( $s eq '"' ) {
0.000000,0,0.000000,$p++;
0.000000,0,0.000000,$self->{incr_mode} = INCR_M_JSON;
0.000000,0,0.000000,
0.000000,0,0.000000,last INCR_PARSE unless $self->{incr_nest};
0.000000,0,0.000000,redo INCR_PARSE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $s eq '\\' ) {
0.000000,0,0.000000,$p++;
0.000000,0,0.000000,if ( !defined substr($text, $p, 1) ) {
0.000000,0,0.000000,$self->{incr_mode} = INCR_M_BS;
0.000000,0,0.000000,last INCR_PARSE;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$p++;
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif ( $mode == INCR_M_JSON ) {
0.000000,0,0.000000,while ( $len > $p ) {
0.000000,0,0.000000,$s = substr( $text, $p++, 1 );
0.000000,0,0.000000,if ( $s eq "\x00" ) {
0.000000,0,0.000000,$p--;
0.000000,0,0.000000,last INCR_PARSE;
0.000000,0,0.000000,} elsif ( $s eq "\x09" or $s eq "\x0a" or $s eq "\x0d" or $s eq "\x20" ) {
0.000000,0,0.000000,if ( !$self->{incr_nest} ) {
0.000000,0,0.000000,$p--; # do not eat the whitespace, let the next round do it
0.000000,0,0.000000,last INCR_PARSE;
0.000000,0,0.000000,}
0.000000,0,0.000000,next;
0.000000,0,0.000000,} elsif ( $s eq 't' or $s eq 'f' or $s eq 'n' ) {
0.000000,0,0.000000,$self->{incr_mode} = INCR_M_TFN;
0.000000,0,0.000000,redo INCR_PARSE;
0.000000,0,0.000000,} elsif ( $s =~ /^[0-9\-]$/ ) {
0.000000,0,0.000000,$self->{incr_mode} = INCR_M_NUM;
0.000000,0,0.000000,redo INCR_PARSE;
0.000000,0,0.000000,} elsif ( $s eq '"' ) {
0.000000,0,0.000000,$self->{incr_mode} = INCR_M_STR;
0.000000,0,0.000000,redo INCR_PARSE;
0.000000,0,0.000000,} elsif ( $s eq '[' or $s eq '{' ) {
0.000000,0,0.000000,if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
0.000000,0,0.000000,Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
0.000000,0,0.000000,}
0.000000,0,0.000000,next;
0.000000,0,0.000000,} elsif ( $s eq ']' or $s eq '}' ) {
0.000000,0,0.000000,if ( --$self->{incr_nest} <= 0 ) {
0.000000,0,0.000000,last INCR_PARSE;
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif ( $s eq '#' ) {
0.000000,0,0.000000,$self->{incr_mode} = INCR_M_C1;
0.000000,0,0.000000,redo INCR_PARSE;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{incr_pos} = $p;
0.000000,0,0.000000,$self->{incr_parsing} = $p ? 1 : 0; # for backward compatibility
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub incr_text {
0.000000,0,0.000000,if ( $_[0]->{incr_pos} ) {
0.000000,0,0.000000,Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
0.000000,0,0.000000,}
0.000000,0,0.000000,$_[0]->{incr_text};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub incr_skip {
0.000000,0,0.000000,my $self  = shift;
0.000000,0,0.000000,$self->{incr_text} = substr( $self->{incr_text}, $self->{incr_pos} );
0.000000,0,0.000000,$self->{incr_pos}     = 0;
0.000000,0,0.000000,$self->{incr_mode}    = 0;
0.000000,0,0.000000,$self->{incr_nest}    = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub incr_reset {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->{incr_text}    = undef;
0.000000,0,0.000000,$self->{incr_pos}     = 0;
0.000000,0,0.000000,$self->{incr_mode}    = 0;
0.000000,0,0.000000,$self->{incr_nest}    = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###############################
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000009,1,0.000009,1;
0.000000,0,0.000000,__END__
