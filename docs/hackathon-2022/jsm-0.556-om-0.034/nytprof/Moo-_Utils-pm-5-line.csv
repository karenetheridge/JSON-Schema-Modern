# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Moo::_Utils;
0.000022,2,0.000011,use strict;
0.000015,2,0.000008,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000028,2,0.000014,no strict 'refs';
0.000262,2,0.000131,no warnings 'once';
0.000800,206,0.000004,sub _getglob { \*{$_[0]} }
0.000124,40,0.000003,sub _getstash { \%{"$_[0]::"} }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,BEGIN {
0.000001,1,0.000001,my ($su, $sn);
0.000000,0,0.000000,$su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname
0.000000,0,0.000000,or $sn = $INC{'Sub/Name.pm'}
0.000176,1,0.000176,or $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname
0.000001,1,0.000001,or $sn = eval { require Sub::Name; };
0.000000,0,0.000000,
0.000000,0,0.000000,*_subname = $su ? \&Sub::Util::set_subname
0.000000,0,0.000000,: $sn ? \&Sub::Name::subname
0.000002,1,0.000002,: sub { $_[1] };
0.000001,1,0.000001,*_CAN_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
0.000000,0,0.000000,
0.000004,1,0.000004,*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
0.000000,0,0.000000,*_WORK_AROUND_HINT_LEAKAGE
0.000000,0,0.000000,= "$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
0.000000,1,0.000000,? sub(){1} : sub(){0};
0.000000,0,0.000000,
0.000006,1,0.000006,my $module_name_rx = qr/\A(?!\d)\w+(?:::\w+)*\z/;
0.000010,1,0.000010,*_module_name_rx = sub(){$module_name_rx};
0.000040,1,0.000040,}
0.000000,0,0.000000,
0.000023,2,0.000012,use Exporter ();
0.000011,1,0.000011,BEGIN { *import = \&Exporter::import }
0.000190,2,0.000095,use Config ();
0.000165,2,0.000082,use Scalar::Util qw(weaken);
0.001195,2,0.000597,use Carp qw(croak);
0.000000,0,0.000000,
0.000000,0,0.000000,# this should be empty, but some CPAN modules expect these
0.000005,1,0.000005,our @EXPORT = qw(
0.000000,0,0.000000,_install_coderef
0.000000,0,0.000000,_load_module
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000008,1,0.000008,our @EXPORT_OK = qw(
0.000000,0,0.000000,_check_tracked
0.000000,0,0.000000,_getglob
0.000000,0,0.000000,_getstash
0.000000,0,0.000000,_install_coderef
0.000000,0,0.000000,_install_modifier
0.000000,0,0.000000,_install_tracked
0.000000,0,0.000000,_load_module
0.000000,0,0.000000,_maybe_load_module
0.000000,0,0.000000,_module_name_rx
0.000000,0,0.000000,_name_coderef
0.000000,0,0.000000,_set_loaded
0.000000,0,0.000000,_unimport_coderefs
0.000000,0,0.000000,_linear_isa
0.000000,0,0.000000,_in_global_destruction
0.000000,0,0.000000,_in_global_destruction_code
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000001,1,0.000001,my %EXPORTS;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_modifier {
0.000008,16,0.000000,my $target = $_[0];
0.000010,16,0.000001,my $type = $_[1];
0.000004,16,0.000000,my $code = $_[-1];
0.000037,16,0.000002,my @names = @_[2 .. $#_ - 1];
0.000000,0,0.000000,
0.000019,16,0.000001,@names = @{ $names[0] }
0.000000,0,0.000000,if ref($names[0]) eq 'ARRAY';
0.000000,0,0.000000,
0.000034,16,0.000002,my @tracked = _check_tracked($target, \@names);
0.000000,0,0.000000,
0.000020,16,0.000001,if ($INC{'Sub/Defer.pm'}) {
0.000000,0,0.000000,for my $name (@names) {
0.000000,0,0.000000,# CMM will throw for us if it doesn't exist
0.000156,24,0.000006,if (my $to_modify = $target->can($name)) {
0.000000,0,0.000000,Sub::Defer::undefer_sub($to_modify);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000379,16,0.000024,require Class::Method::Modifiers;
0.000032,16,0.000002,Class::Method::Modifiers::install_modifier(@_);
0.000000,0,0.000000,
0.000008,16,0.000000,if (@tracked) {
0.000007,7,0.000001,my $exports = $EXPORTS{$target};
0.000000,0,0.000000,weaken($exports->{$_} = $target->can($_))
0.000122,7,0.000017,for @tracked;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000055,16,0.000003,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_tracked {
0.000036,119,0.000000,my ($target, $name, $code) = @_;
0.000040,119,0.000000,my $from = caller;
0.000446,119,0.000004,weaken($EXPORTS{$target}{$name} = $code);
0.000489,119,0.000004,_install_coderef("${target}::${name}", "${from}::${name}", $code);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Moo::_Util::__GUARD__::DESTROY {
0.000000,0,0.000000,delete $INC{$_[0]->[0]} if @{$_[0]};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _require {
0.000003,4,0.000001,my ($file) = @_;
0.000002,4,0.000000,my $guard = _WORK_AROUND_BROKEN_MODULE_STATE
0.000000,0,0.000000,&& bless([ $file ], 'Moo::_Util::__GUARD__');
0.000000,0,0.000000,local %^H if _WORK_AROUND_HINT_LEAKAGE;
0.001947,11,0.000177,if (!eval { require $file; 1 }) {
0.000001,1,0.000001,my $e = $@ || "Can't locate $file";
0.000001,1,0.000001,my $me = __FILE__;
0.000052,1,0.000052,$e =~ s{ at \Q$me\E line \d+\.\n\z}{};
0.000007,1,0.000007,return $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;
0.000009,3,0.000003,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _load_module {
0.000014,26,0.000001,my ($module) = @_;
0.000208,26,0.000008,croak qq{"$module" is not a module name!}
0.000000,0,0.000000,unless $module =~ _module_name_rx;
0.000137,26,0.000005,(my $file = "$module.pm") =~ s{::}{/}g;
0.000000,0,0.000000,return 1
0.000055,26,0.000002,if $INC{$file};
0.000000,0,0.000000,
0.000007,3,0.000002,my $e = _require $file;
0.000010,3,0.000003,return 1
0.000000,0,0.000000,if !defined $e;
0.000000,0,0.000000,
0.000000,0,0.000000,croak $e
0.000000,0,0.000000,if $e !~ /\ACan't locate \Q$file\E /;
0.000000,0,0.000000,
0.000000,0,0.000000,# can't just ->can('can') because a sub-package Foo::Bar::Baz
0.000000,0,0.000000,# creates a 'Baz::' key in Foo::Bar's symbol table
0.000000,0,0.000000,my $stash = _getstash($module)||{};
0.000396,2,0.000198,no strict 'refs';
0.000000,0,0.000000,return 1 if grep +exists &{"${module}::$_"}, grep !/::\z/, keys %$stash;
0.000000,0,0.000000,return 1
0.000000,0,0.000000,if $INC{"Moose.pm"} && Class::MOP::class_of($module)
0.000000,0,0.000000,or Mouse::Util->can('find_meta') && Mouse::Util::find_meta($module);
0.000000,0,0.000000,
0.000000,0,0.000000,croak $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,our %MAYBE_LOADED;
0.000000,0,0.000000,sub _maybe_load_module {
0.000001,1,0.000001,my $module = $_[0];
0.000000,0,0.000000,return $MAYBE_LOADED{$module}
0.000001,1,0.000001,if exists $MAYBE_LOADED{$module};
0.000010,1,0.000010,(my $file = "$module.pm") =~ s{::}{/}g;
0.000000,0,0.000000,
0.000003,1,0.000003,my $e = _require $file;
0.000023,1,0.000023,if (!defined $e) {
0.000000,0,0.000000,return $MAYBE_LOADED{$module} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($e !~ /\ACan't locate \Q$file\E /) {
0.000000,0,0.000000,warn "$module exists but failed to load with error: $e";
0.000000,0,0.000000,}
0.000006,1,0.000006,return $MAYBE_LOADED{$module} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,# optimize for newer perls
0.000000,0,0.000000,require mro
0.000411,1,0.000411,if "$]" >= 5.009_005;
0.000000,0,0.000000,
0.000064,1,0.000064,if (defined &mro::get_linear_isa) {
0.000000,0,0.000000,*_linear_isa = \&mro::get_linear_isa;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $e;
0.000000,0,0.000000,{
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,eval <<'END_CODE' or $e = $@;
0.000000,0,0.000000,sub _linear_isa($;$) {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $type = shift || exists $Class::C3::MRO{$class} ? 'c3' : 'dfs';
0.000000,0,0.000000,
0.000000,0,0.000000,if ($type eq 'c3') {
0.000000,0,0.000000,require Class::C3;
0.000000,0,0.000000,return [Class::C3::calculateMRO($class)];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @check = ($class);
0.000000,0,0.000000,my @lin;
0.000000,0,0.000000,
0.000000,0,0.000000,my %found;
0.000000,0,0.000000,while (defined(my $check = shift @check)) {
0.000000,0,0.000000,push @lin, $check;
0.000000,0,0.000000,no strict 'refs';
0.000000,0,0.000000,unshift @check, grep !$found{$_}++, @{"$check\::ISA"};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return \@lin;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,1;
0.000000,0,0.000000,END_CODE
0.000000,0,0.000000,}
0.000000,0,0.000000,die $e if defined $e;
0.000000,0,0.000000,}
0.000438,1,0.000438,}
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000010,1,0.000010,my $gd_code
0.000000,0,0.000000,= "$]" >= 5.014
0.000000,0,0.000000,? q[${^GLOBAL_PHASE} eq 'DESTRUCT']
0.000000,0,0.000000,: _maybe_load_module('Devel::GlobalDestruction::XS')
0.000000,0,0.000000,? 'Devel::GlobalDestruction::XS::in_global_destruction()'
0.000000,0,0.000000,: 'do { use B (); ${B::main_cv()} == 0 }';
0.000033,1,0.000033,*_in_global_destruction_code = sub () { $gd_code };
0.000165,1,0.000165,eval "sub _in_global_destruction () { $gd_code }; 1"
0.000000,0,0.000000,or die $@;
0.000243,1,0.000243,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _set_loaded {
0.000247,27,0.000009,(my $file = "$_[0].pm") =~ s{::}{/}g;
0.000082,27,0.000003,$INC{$file} ||= $_[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_coderef {
0.000276,119,0.000002,my ($glob, $code) = (_getglob($_[0]), _name_coderef(@_));
0.000075,2,0.000037,no warnings 'redefine';
0.000245,119,0.000002,if (*{$glob}{CODE}) {
0.000000,0,0.000000,*{$glob} = $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,# perl will sometimes warn about mismatched prototypes coming from the
0.000000,0,0.000000,# inheritance cache, so disable them if we aren't redefining a sub
0.000000,0,0.000000,else {
0.000350,2,0.000175,no warnings 'prototype';
0.000031,114,0.000000,*{$glob} = $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _name_coderef {
0.000040,129,0.000000,shift if @_ > 2; # three args is (target, name, sub)
0.000949,129,0.000007,_CAN_SUBNAME ? _subname(@_) : $_[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _check_tracked {
0.000005,20,0.000000,my ($target, $names) = @_;
0.000032,20,0.000002,my $stash = _getstash($target);
0.000026,20,0.000001,my $exports = $EXPORTS{$target}
0.000000,0,0.000000,or return;
0.000000,0,0.000000,
0.000003,16,0.000000,$names = [keys %$exports]
0.000000,0,0.000000,if !$names;
0.000000,0,0.000000,my %rev =
0.000000,0,0.000000,map +($exports->{$_} => $_),
0.000135,16,0.000008,grep defined $exports->{$_},
0.000000,0,0.000000,keys %$exports;
0.000000,0,0.000000,
0.000000,0,0.000000,return
0.000000,0,0.000000,grep {
0.000125,63,0.000002,my $g = $stash->{$_};
0.000038,47,0.000001,$g && defined &$g && exists $rev{\&$g};
0.000000,0,0.000000,}
0.000000,0,0.000000,@$names;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _unimport_coderefs {
0.000000,0,0.000000,my ($target) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $stash = _getstash($target);
0.000000,0,0.000000,my @exports = _check_tracked($target);
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $name (@exports) {
0.000000,0,0.000000,my $old = delete $stash->{$name};
0.000000,0,0.000000,my $full_name = join('::',$target,$name);
0.000000,0,0.000000,# Copy everything except the code slot back into place (e.g. $has)
0.000000,0,0.000000,foreach my $type (qw(SCALAR HASH ARRAY IO)) {
0.000000,0,0.000000,next unless defined(*{$old}{$type});
0.000343,2,0.000171,no strict 'refs';
0.000000,0,0.000000,*$full_name = *{$old}{$type};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000026,1,0.000026,if ($Config::Config{useithreads}) {
0.000000,0,0.000000,require Moo::HandleMoose::_TypeMap;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000016,1,0.000016,1;
