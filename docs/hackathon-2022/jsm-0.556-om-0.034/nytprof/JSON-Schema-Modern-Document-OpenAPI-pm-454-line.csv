# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000028,2,0.000014,use strict;
0.000041,2,0.000020,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Document::OpenAPI;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: One OpenAPI v3.1 document
0.000000,0,0.000000,# KEYWORDS: JSON Schema data validation request response OpenAPI
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.034';
0.000000,0,0.000000,
0.000029,2,0.000015,use 5.020;
0.000023,2,0.000012,use Moo;
0.000038,3,0.000013,use strictures 2;
0.000043,2,0.000022,use experimental qw(signatures postderef);
0.000073,2,0.000036,use if "$]" >= 5.022, experimental => 're_strict';
0.000044,2,0.000022,no if "$]" >= 5.031009, feature => 'indirect';
0.000068,2,0.000034,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000043,2,0.000021,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000061,3,0.000020,use JSON::Schema::Modern::Utilities 0.525 qw(assert_keyword_exists assert_keyword_type E canonical_uri get_type);
0.000044,2,0.000022,use Safe::Isa;
0.000041,2,0.000021,use File::ShareDir 'dist_dir';
0.000122,2,0.000061,use Path::Tiny;
0.000050,2,0.000025,use List::Util qw(any pairs);
0.000025,2,0.000013,use Ref::Util 'is_plain_hashref';
0.000041,2,0.000021,use MooX::HandlesVia;
0.000050,3,0.000017,use MooX::TypeTiny 0.002002;
0.000031,2,0.000016,use Types::Standard qw(InstanceOf HashRef Str);
0.000044,2,0.000022,use namespace::clean;
0.000000,0,0.000000,
0.000001,1,0.000001,extends 'JSON::Schema::Modern::Document';
0.000000,0,0.000000,
0.000048,2,0.000024,use constant DEFAULT_DIALECT => 'https://spec.openapis.org/oas/3.1/dialect/base';
0.000000,0,0.000000,
0.000000,1,0.000000,use constant DEFAULT_SCHEMAS => {
0.000000,0,0.000000,# local filename => identifier to add the schema as
0.000000,0,0.000000,'oas/dialect/base.schema.json' => 'https://spec.openapis.org/oas/3.1/dialect/base', # metaschema for json schemas contained within openapi documents
0.000000,0,0.000000,'oas/meta/base.schema.json' => 'https://spec.openapis.org/oas/3.1/meta/base',  # vocabulary definition
0.000000,0,0.000000,'oas/schema-base.json' => 'https://spec.openapis.org/oas/3.1/schema-base',  # the main openapi document schema + draft2020-12 jsonSchemaDialect
0.000000,0,0.000000,'oas/schema.json' => 'https://spec.openapis.org/oas/3.1/schema', # the main openapi document schema + permissive jsonSchemaDialect
0.000000,0,0.000000,'strict-schema.json' => 'https://raw.githubusercontent.com/karenetheridge/OpenAPI-Modern/master/share/strict-schema.json',
0.000000,0,0.000000,'strict-dialect.json' => 'https://raw.githubusercontent.com/karenetheridge/OpenAPI-Modern/master/share/strict-dialect.json',
0.000080,1,0.000080,};
0.000000,0,0.000000,
0.001067,2,0.000534,use constant DEFAULT_METASCHEMA => 'https://spec.openapis.org/oas/3.1/schema-base/latest';
0.000000,0,0.000000,
0.000002,1,0.000002,has '+evaluator' => (
0.000000,0,0.000000,required => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000003,1,0.000003,has '+metaschema_uri' => (
0.000000,0,0.000000,default => DEFAULT_METASCHEMA,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,has json_schema_dialect => (
0.000000,0,0.000000,is => 'rwp',
0.000000,0,0.000000,isa => InstanceOf['Mojo::URL'],
0.000008,1,0.000008,coerce => sub { $_[0]->$_isa('Mojo::URL') ? $_[0] : Mojo::URL->new($_[0]) },
0.000007,1,0.000007,);
0.000000,0,0.000000,
0.000000,0,0.000000,# operationId => document path
0.000000,0,0.000000,has operationIds => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => HashRef[Str],
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,_add_operationId => 'set',
0.000000,0,0.000000,get_operationId_path => 'get',
0.000000,0,0.000000,},
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,default => sub { {} },
0.000010,1,0.000010,);
0.000000,0,0.000000,
0.000000,3,0.000000,sub traverse ($self, $evaluator) {
0.000008,1,0.000008,$self->_add_vocab_and_default_schemas;
0.000000,0,0.000000,
0.000012,1,0.000012,my $schema = $self->schema;
0.000028,1,0.000028,my $state = {
0.000000,0,0.000000,initial_schema_uri => $self->canonical_uri,
0.000000,0,0.000000,traversed_schema_path => '',
0.000000,0,0.000000,schema_path => '',
0.000000,0,0.000000,data_path => '',
0.000000,0,0.000000,errors => [],
0.000000,0,0.000000,evaluator => $evaluator,
0.000000,0,0.000000,identifiers => [],
0.000000,0,0.000000,configs => {},
0.000000,0,0.000000,spec_version => $evaluator->SPECIFICATION_VERSION_DEFAULT,
0.000000,0,0.000000,vocabularies => [],
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000003,1,0.000003,if ((my $type = get_type($schema)) ne 'object') {
0.000000,0,0.000000,()= E($state, 'invalid document type: %s', $type);
0.000000,0,0.000000,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# /openapi: https://spec.openapis.org/oas/v3.1.0#openapi-object
0.000017,1,0.000017,return $state if not assert_keyword_exists({ %$state, keyword => 'openapi' }, $schema)
0.000000,0,0.000000,or not assert_keyword_type({ %$state, keyword => 'openapi' }, $schema, 'string');
0.000000,0,0.000000,
0.000011,1,0.000011,if ($schema->{openapi} !~ /^3\.1\.[0-9]+(-.+)?$/) {
0.000000,0,0.000000,()= E({ %$state, keyword => 'openapi' }, 'unrecognized openapi version %s', $schema->{openapi});
0.000000,0,0.000000,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# /jsonSchemaDialect: https://spec.openapis.org/oas/v3.1.0#specifying-schema-dialects
0.000000,0,0.000000,{
0.000001,1,0.000001,return $state if exists $schema->{jsonSchemaDialect}
0.000001,1,0.000001,and not assert_keyword_type({ %$state, keyword => 'jsonSchemaDialect' }, $schema, 'string');
0.000000,0,0.000000,
0.000007,1,0.000007,my $json_schema_dialect = $self->json_schema_dialect // $schema->{jsonSchemaDialect};
0.000000,0,0.000000,
0.000000,0,0.000000,# "If [jsonSchemaDialect] is not set, then the OAS dialect schema id MUST be used for these Schema Objects."
0.000001,1,0.000001,$json_schema_dialect //= DEFAULT_DIALECT;
0.000000,0,0.000000,
0.000000,0,0.000000,# traverse an empty schema with this metaschema uri to confirm it is valid
0.000010,1,0.000010,my $check_metaschema_state = $evaluator->traverse({}, {
0.000000,0,0.000000,metaschema_uri => $json_schema_dialect,
0.000000,0,0.000000,initial_schema_uri => $self->canonical_uri->clone->fragment('/jsonSchemaDialect'),
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,# we cannot continue if the metaschema is invalid
0.000001,1,0.000001,if ($check_metaschema_state->{errors}->@*) {
0.000000,0,0.000000,push $state->{errors}->@*, $check_metaschema_state->{errors}->@*;
0.000000,0,0.000000,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,$state->@{qw(spec_version vocabularies)} = $check_metaschema_state->@{qw(spec_version vocabularies)};
0.000011,1,0.000011,$self->_set_json_schema_dialect($json_schema_dialect);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# evaluate the document against its metaschema to find any errors, to identify all schema
0.000000,0,0.000000,# resources within to add to the global resource index, and to extract all operationIds
0.000001,1,0.000001,my (@json_schema_paths, @operation_paths);
0.000663,2586,0.000000,my $result = $self->evaluator->evaluate(
0.000000,0,0.000000,$self->schema,
0.000000,0,0.000000,$self->metaschema_uri,
0.000000,0,0.000000,{
0.000000,0,0.000000,callbacks => {
0.001214,5172,0.000000,'$dynamicRef' => sub ($, $schema, $state) {
0.010068,2586,0.000004,push @json_schema_paths, $state->{data_path} if $schema->{'$dynamicRef'} eq '#meta';
0.000000,0,0.000000,},
0.029457,156220,0.000000,'$ref' => sub ($data, $schema, $state) {
0.000000,0,0.000000,push @operation_paths, [ $data->{operationId} => $state->{data_path} ]
0.120646,39055,0.000003,if $schema->{'$ref'} eq '#/$defs/operation' and defined $data->{operationId};
0.000000,0,0.000000,},
0.000000,0,0.000000,},
0.000000,0,0.000000,},
0.000033,1,0.000033,);
0.000000,0,0.000000,
0.000009,1,0.000009,if (not $result) {
0.000000,0,0.000000,$_->mode('evaluate') foreach $result->errors;
0.000000,0,0.000000,push $state->{errors}->@*, $result->errors;
0.000000,0,0.000000,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my @real_json_schema_paths;
0.001974,1,0.001974,foreach my $path (sort @json_schema_paths) {
0.000000,0,0.000000,# disregard paths that are not the root of each embedded subschema.
6.515368,469405,0.000014,next if any { $path =~ m{^\Q$_\E(?:/|\z)} } @real_json_schema_paths;
0.000000,0,0.000000,
0.002361,965,0.000002,unshift @real_json_schema_paths, $path;
0.018437,965,0.000019,$self->_traverse_schema($self->get($path), { %$state, schema_path => $path });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000159,1,0.000159,foreach my $pair (@operation_paths) {
0.000000,0,0.000000,my ($operation_id, $path) = @$pair;
0.000000,0,0.000000,if (my $existing = $self->get_operationId_path($operation_id)) {
0.000000,0,0.000000,()= E({ %$state, keyword => 'operationId', schema_path => $path },
0.000000,0,0.000000,'duplicate of operationId at %s', $existing);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->_add_operationId($operation_id => $path);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.011294,1,0.011294,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,######## NO PUBLIC INTERFACES FOLLOW THIS POINT ########
0.000000,0,0.000000,
0.000001,2,0.000000,sub _add_vocab_and_default_schemas ($self) {
0.000001,1,0.000001,my $js = $self->evaluator;
0.000007,1,0.000007,$js->add_vocabulary('JSON::Schema::Modern::Vocabulary::OpenAPI');
0.000000,0,0.000000,
0.000000,0,0.000000,$js->add_format_validation(
0.000000,0,0.000000,int32 => +{ type => 'integer', sub => sub ($x) {
0.000000,0,0.000000,require Math::BigInt;
0.000000,0,0.000000,$x = Math::BigInt->new($x);
0.000000,0,0.000000,my $bound = Math::BigInt->new(2) ** 31;
0.000000,0,0.000000,$x >= -$bound && $x < $bound;
0.000000,0,0.000000,} },
0.000000,0,0.000000,int64 => +{ type => 'integer', sub => sub ($x) {
0.000000,0,0.000000,require Math::BigInt;
0.000000,0,0.000000,$x = Math::BigInt->new($x);
0.000000,0,0.000000,my $bound = Math::BigInt->new(2) ** 63;
0.000000,0,0.000000,$x >= -$bound && $x < $bound;
0.000000,0,0.000000,} },
0.000000,0,0.000000,float => +{ type => 'number', sub => sub ($) { 1 } },
0.000000,0,0.000000,double => +{ type => 'number', sub => sub ($) { 1 } },
0.000000,0,0.000000,password => +{ type => 'string', sub => sub ($) { 1 } },
0.000016,1,0.000016,);
0.000000,0,0.000000,
0.000041,1,0.000041,foreach my $pairs (pairs DEFAULT_SCHEMAS->%*) {
0.000004,6,0.000001,my ($filename, $uri) = @$pairs;
0.000726,6,0.000121,my $document = $js->add_schema($uri,
0.000000,0,0.000000,$js->_json_decoder->decode(path(dist_dir('OpenAPI-Modern'), $filename)->slurp_raw));
0.000043,6,0.000007,$js->add_schema($uri.'/latest', $document) if $uri =~ /schema(-base)?$/;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# https://spec.openapis.org/oas/v3.1.0#schema-object
0.001311,3860,0.000000,sub _traverse_schema ($self, $schema, $state) {
0.002001,965,0.000002,return if not is_plain_hashref($schema) or not keys %$schema;
0.000000,0,0.000000,
0.000000,0,0.000000,my $subschema_state = $self->evaluator->traverse($schema, {
0.000000,0,0.000000,%$state,  # so we don't have to enumerate everything that may be in config_override
0.000000,0,0.000000,initial_schema_uri => canonical_uri($state),
0.000000,0,0.000000,traversed_schema_path => $state->{traversed_schema_path}.$state->{schema_path},
0.020530,727,0.000028,metaschema_uri => $self->json_schema_dialect,
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.001086,727,0.000001,push $state->{errors}->@*, $subschema_state->{errors}->@*;
0.000315,727,0.000000,return if $subschema_state->{errors}->@*;
0.000000,0,0.000000,
0.007325,727,0.000010,push $state->{identifiers}->@*, $subschema_state->{identifiers}->@*;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000018,1,0.000018,1;
0.000000,0,0.000000,
0.000039,1,0.000039,__END__
