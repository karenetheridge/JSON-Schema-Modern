# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# -*- buffer-read-only: t -*-
0.000000,0,0.000000,# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
0.000000,0,0.000000,# This file is built by regen/warnings.pl.
0.000000,0,0.000000,# Any changes made here will be lost!
0.000000,0,0.000000,
0.000000,0,0.000000,package warnings;
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = "1.58";
0.000000,0,0.000000,
0.000000,0,0.000000,# Verify that we're called correctly so that warnings will work.
0.000000,0,0.000000,# Can't use Carp, since Carp uses us!
0.000000,0,0.000000,# String regexps because constant folding = smaller optree = less memory vs regexp literal
0.000000,0,0.000000,# see also strict.pm.
0.000043,1,0.000043,die sprintf "Incorrect use of pragma '%s' at %s line %d.\n", __PACKAGE__, +(caller)[1,2]
0.000000,0,0.000000,if __FILE__ !~ ( '(?x) \b     '.__PACKAGE__.'  \.pmc? \z' )
0.000000,0,0.000000,&& __FILE__ =~ ( '(?x) \b (?i:'.__PACKAGE__.') \.pmc? \z' );
0.000000,0,0.000000,
0.000051,1,0.000051,our %Offsets = (
0.000000,0,0.000000,# Warnings Categories added in Perl 5.008
0.000000,0,0.000000,'all'				=> 0,
0.000000,0,0.000000,'closure'				=> 2,
0.000000,0,0.000000,'deprecated'			=> 4,
0.000000,0,0.000000,'exiting'				=> 6,
0.000000,0,0.000000,'glob'				=> 8,
0.000000,0,0.000000,'io'				=> 10,
0.000000,0,0.000000,'closed'				=> 12,
0.000000,0,0.000000,'exec'				=> 14,
0.000000,0,0.000000,'layer'				=> 16,
0.000000,0,0.000000,'newline'				=> 18,
0.000000,0,0.000000,'pipe'				=> 20,
0.000000,0,0.000000,'unopened'				=> 22,
0.000000,0,0.000000,'misc'				=> 24,
0.000000,0,0.000000,'numeric'				=> 26,
0.000000,0,0.000000,'once'				=> 28,
0.000000,0,0.000000,'overflow'				=> 30,
0.000000,0,0.000000,'pack'				=> 32,
0.000000,0,0.000000,'portable'				=> 34,
0.000000,0,0.000000,'recursion'				=> 36,
0.000000,0,0.000000,'redefine'				=> 38,
0.000000,0,0.000000,'regexp'				=> 40,
0.000000,0,0.000000,'severe'				=> 42,
0.000000,0,0.000000,'debugging'				=> 44,
0.000000,0,0.000000,'inplace'				=> 46,
0.000000,0,0.000000,'internal'				=> 48,
0.000000,0,0.000000,'malloc'				=> 50,
0.000000,0,0.000000,'signal'				=> 52,
0.000000,0,0.000000,'substr'				=> 54,
0.000000,0,0.000000,'syntax'				=> 56,
0.000000,0,0.000000,'ambiguous'				=> 58,
0.000000,0,0.000000,'bareword'				=> 60,
0.000000,0,0.000000,'digit'				=> 62,
0.000000,0,0.000000,'parenthesis'			=> 64,
0.000000,0,0.000000,'precedence'			=> 66,
0.000000,0,0.000000,'printf'				=> 68,
0.000000,0,0.000000,'prototype'				=> 70,
0.000000,0,0.000000,'qw'				=> 72,
0.000000,0,0.000000,'reserved'				=> 74,
0.000000,0,0.000000,'semicolon'				=> 76,
0.000000,0,0.000000,'taint'				=> 78,
0.000000,0,0.000000,'threads'				=> 80,
0.000000,0,0.000000,'uninitialized'			=> 82,
0.000000,0,0.000000,'unpack'				=> 84,
0.000000,0,0.000000,'untie'				=> 86,
0.000000,0,0.000000,'utf8'				=> 88,
0.000000,0,0.000000,'void'				=> 90,
0.000000,0,0.000000,
0.000000,0,0.000000,# Warnings Categories added in Perl 5.011
0.000000,0,0.000000,'imprecision'			=> 92,
0.000000,0,0.000000,'illegalproto'			=> 94,
0.000000,0,0.000000,
0.000000,0,0.000000,# Warnings Categories added in Perl 5.013
0.000000,0,0.000000,'non_unicode'			=> 96,
0.000000,0,0.000000,'nonchar'				=> 98,
0.000000,0,0.000000,'surrogate'				=> 100,
0.000000,0,0.000000,
0.000000,0,0.000000,# Warnings Categories added in Perl 5.017
0.000000,0,0.000000,'experimental'			=> 102,
0.000000,0,0.000000,'experimental::lexical_subs'	=> 104,
0.000000,0,0.000000,'experimental::regex_sets'		=> 106,
0.000000,0,0.000000,'experimental::smartmatch'		=> 108,
0.000000,0,0.000000,
0.000000,0,0.000000,# Warnings Categories added in Perl 5.019
0.000000,0,0.000000,'experimental::postderef'		=> 110,
0.000000,0,0.000000,'experimental::signatures'		=> 112,
0.000000,0,0.000000,'syscalls'				=> 114,
0.000000,0,0.000000,
0.000000,0,0.000000,# Warnings Categories added in Perl 5.021
0.000000,0,0.000000,'experimental::bitwise'		=> 116,
0.000000,0,0.000000,'experimental::const_attr'		=> 118,
0.000000,0,0.000000,'experimental::re_strict'		=> 120,
0.000000,0,0.000000,'experimental::refaliasing'		=> 122,
0.000000,0,0.000000,'locale'				=> 124,
0.000000,0,0.000000,'missing'				=> 126,
0.000000,0,0.000000,'redundant'				=> 128,
0.000000,0,0.000000,
0.000000,0,0.000000,# Warnings Categories added in Perl 5.025
0.000000,0,0.000000,'experimental::declared_refs'	=> 130,
0.000000,0,0.000000,
0.000000,0,0.000000,# Warnings Categories added in Perl 5.027
0.000000,0,0.000000,'experimental::alpha_assertions'	=> 132,
0.000000,0,0.000000,'experimental::script_run'		=> 134,
0.000000,0,0.000000,'shadow'				=> 136,
0.000000,0,0.000000,
0.000000,0,0.000000,# Warnings Categories added in Perl 5.029
0.000000,0,0.000000,'experimental::private_use'		=> 138,
0.000000,0,0.000000,'experimental::uniprop_wildcards'	=> 140,
0.000000,0,0.000000,'experimental::vlb'			=> 142,
0.000000,0,0.000000,
0.000000,0,0.000000,# Warnings Categories added in Perl 5.031
0.000000,0,0.000000,'experimental::isa'			=> 144,
0.000000,0,0.000000,
0.000000,0,0.000000,# Warnings Categories added in Perl 5.033
0.000000,0,0.000000,'experimental::try'			=> 146,
0.000000,0,0.000000,
0.000000,0,0.000000,# Warnings Categories added in Perl 5.035
0.000000,0,0.000000,'experimental::args_array_with_signatures'=> 148,
0.000000,0,0.000000,'experimental::builtin'		=> 150,
0.000000,0,0.000000,'experimental::defer'		=> 152,
0.000000,0,0.000000,'experimental::extra_paired_delimiters'=> 154,
0.000000,0,0.000000,'experimental::for_list'		=> 156,
0.000000,0,0.000000,'scalar'				=> 158,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000025,1,0.000025,our %Bits = (
0.000000,0,0.000000,'all'				=> "\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55", # [0..79]
0.000000,0,0.000000,'ambiguous'				=> "\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [29]
0.000000,0,0.000000,'bareword'				=> "\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [30]
0.000000,0,0.000000,'closed'				=> "\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [6]
0.000000,0,0.000000,'closure'				=> "\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [1]
0.000000,0,0.000000,'debugging'				=> "\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [22]
0.000000,0,0.000000,'deprecated'			=> "\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [2]
0.000000,0,0.000000,'digit'				=> "\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [31]
0.000000,0,0.000000,'exec'				=> "\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [7]
0.000000,0,0.000000,'exiting'				=> "\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [3]
0.000000,0,0.000000,'experimental'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x55\x51\x05\x54\x54\x55\x15", # [51..56,58..61,65..67,69..78]
0.000000,0,0.000000,'experimental::alpha_assertions'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00", # [66]
0.000000,0,0.000000,'experimental::args_array_with_signatures'=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00", # [74]
0.000000,0,0.000000,'experimental::bitwise'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00", # [58]
0.000000,0,0.000000,'experimental::builtin'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00", # [75]
0.000000,0,0.000000,'experimental::const_attr'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00", # [59]
0.000000,0,0.000000,'experimental::declared_refs'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00", # [65]
0.000000,0,0.000000,'experimental::defer'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01", # [76]
0.000000,0,0.000000,'experimental::extra_paired_delimiters'=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04", # [77]
0.000000,0,0.000000,'experimental::for_list'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10", # [78]
0.000000,0,0.000000,'experimental::isa'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00", # [72]
0.000000,0,0.000000,'experimental::lexical_subs'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00", # [52]
0.000000,0,0.000000,'experimental::postderef'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00", # [55]
0.000000,0,0.000000,'experimental::private_use'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00", # [69]
0.000000,0,0.000000,'experimental::re_strict'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00", # [60]
0.000000,0,0.000000,'experimental::refaliasing'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00", # [61]
0.000000,0,0.000000,'experimental::regex_sets'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00", # [53]
0.000000,0,0.000000,'experimental::script_run'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00", # [67]
0.000000,0,0.000000,'experimental::signatures'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00", # [56]
0.000000,0,0.000000,'experimental::smartmatch'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00", # [54]
0.000000,0,0.000000,'experimental::try'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00", # [73]
0.000000,0,0.000000,'experimental::uniprop_wildcards'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00", # [70]
0.000000,0,0.000000,'experimental::vlb'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00", # [71]
0.000000,0,0.000000,'glob'				=> "\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [4]
0.000000,0,0.000000,'illegalproto'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00", # [47]
0.000000,0,0.000000,'imprecision'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00", # [46]
0.000000,0,0.000000,'inplace'				=> "\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [23]
0.000000,0,0.000000,'internal'				=> "\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [24]
0.000000,0,0.000000,'io'				=> "\x00\x54\x55\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00", # [5..11,57]
0.000000,0,0.000000,'layer'				=> "\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [8]
0.000000,0,0.000000,'locale'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00", # [62]
0.000000,0,0.000000,'malloc'				=> "\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [25]
0.000000,0,0.000000,'misc'				=> "\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [12]
0.000000,0,0.000000,'missing'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00", # [63]
0.000000,0,0.000000,'newline'				=> "\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [9]
0.000000,0,0.000000,'non_unicode'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00", # [48]
0.000000,0,0.000000,'nonchar'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00", # [49]
0.000000,0,0.000000,'numeric'				=> "\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [13]
0.000000,0,0.000000,'once'				=> "\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [14]
0.000000,0,0.000000,'overflow'				=> "\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [15]
0.000000,0,0.000000,'pack'				=> "\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [16]
0.000000,0,0.000000,'parenthesis'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [32]
0.000000,0,0.000000,'pipe'				=> "\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [10]
0.000000,0,0.000000,'portable'				=> "\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [17]
0.000000,0,0.000000,'precedence'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [33]
0.000000,0,0.000000,'printf'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [34]
0.000000,0,0.000000,'prototype'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [35]
0.000000,0,0.000000,'qw'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [36]
0.000000,0,0.000000,'recursion'				=> "\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [18]
0.000000,0,0.000000,'redefine'				=> "\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [19]
0.000000,0,0.000000,'redundant'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00", # [64]
0.000000,0,0.000000,'regexp'				=> "\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [20]
0.000000,0,0.000000,'reserved'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [37]
0.000000,0,0.000000,'scalar'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40", # [79]
0.000000,0,0.000000,'semicolon'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [38]
0.000000,0,0.000000,'severe'				=> "\x00\x00\x00\x00\x00\x54\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [21..25]
0.000000,0,0.000000,'shadow'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00", # [68]
0.000000,0,0.000000,'signal'				=> "\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [26]
0.000000,0,0.000000,'substr'				=> "\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [27]
0.000000,0,0.000000,'surrogate'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00", # [50]
0.000000,0,0.000000,'syntax'				=> "\x00\x00\x00\x00\x00\x00\x00\x55\x55\x15\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00", # [28..38,47]
0.000000,0,0.000000,'syscalls'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00", # [57]
0.000000,0,0.000000,'taint'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [39]
0.000000,0,0.000000,'threads'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [40]
0.000000,0,0.000000,'uninitialized'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [41]
0.000000,0,0.000000,'unopened'				=> "\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [11]
0.000000,0,0.000000,'unpack'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [42]
0.000000,0,0.000000,'untie'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [43]
0.000000,0,0.000000,'utf8'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x15\x00\x00\x00\x00\x00\x00\x00", # [44,48..50]
0.000000,0,0.000000,'void'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00", # [45]
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000016,1,0.000016,our %DeadBits = (
0.000000,0,0.000000,'all'				=> "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa", # [0..79]
0.000000,0,0.000000,'ambiguous'				=> "\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [29]
0.000000,0,0.000000,'bareword'				=> "\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [30]
0.000000,0,0.000000,'closed'				=> "\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [6]
0.000000,0,0.000000,'closure'				=> "\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [1]
0.000000,0,0.000000,'debugging'				=> "\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [22]
0.000000,0,0.000000,'deprecated'			=> "\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [2]
0.000000,0,0.000000,'digit'				=> "\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [31]
0.000000,0,0.000000,'exec'				=> "\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [7]
0.000000,0,0.000000,'exiting'				=> "\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [3]
0.000000,0,0.000000,'experimental'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\xaa\xa2\x0a\xa8\xa8\xaa\x2a", # [51..56,58..61,65..67,69..78]
0.000000,0,0.000000,'experimental::alpha_assertions'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00", # [66]
0.000000,0,0.000000,'experimental::args_array_with_signatures'=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00", # [74]
0.000000,0,0.000000,'experimental::bitwise'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00", # [58]
0.000000,0,0.000000,'experimental::builtin'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00", # [75]
0.000000,0,0.000000,'experimental::const_attr'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00", # [59]
0.000000,0,0.000000,'experimental::declared_refs'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00", # [65]
0.000000,0,0.000000,'experimental::defer'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02", # [76]
0.000000,0,0.000000,'experimental::extra_paired_delimiters'=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08", # [77]
0.000000,0,0.000000,'experimental::for_list'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20", # [78]
0.000000,0,0.000000,'experimental::isa'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00", # [72]
0.000000,0,0.000000,'experimental::lexical_subs'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00", # [52]
0.000000,0,0.000000,'experimental::postderef'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00", # [55]
0.000000,0,0.000000,'experimental::private_use'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00", # [69]
0.000000,0,0.000000,'experimental::re_strict'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00", # [60]
0.000000,0,0.000000,'experimental::refaliasing'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00", # [61]
0.000000,0,0.000000,'experimental::regex_sets'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00", # [53]
0.000000,0,0.000000,'experimental::script_run'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00", # [67]
0.000000,0,0.000000,'experimental::signatures'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00", # [56]
0.000000,0,0.000000,'experimental::smartmatch'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00", # [54]
0.000000,0,0.000000,'experimental::try'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00", # [73]
0.000000,0,0.000000,'experimental::uniprop_wildcards'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00", # [70]
0.000000,0,0.000000,'experimental::vlb'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00", # [71]
0.000000,0,0.000000,'glob'				=> "\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [4]
0.000000,0,0.000000,'illegalproto'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00", # [47]
0.000000,0,0.000000,'imprecision'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00", # [46]
0.000000,0,0.000000,'inplace'				=> "\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [23]
0.000000,0,0.000000,'internal'				=> "\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [24]
0.000000,0,0.000000,'io'				=> "\x00\xa8\xaa\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00", # [5..11,57]
0.000000,0,0.000000,'layer'				=> "\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [8]
0.000000,0,0.000000,'locale'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00", # [62]
0.000000,0,0.000000,'malloc'				=> "\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [25]
0.000000,0,0.000000,'misc'				=> "\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [12]
0.000000,0,0.000000,'missing'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00", # [63]
0.000000,0,0.000000,'newline'				=> "\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [9]
0.000000,0,0.000000,'non_unicode'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00", # [48]
0.000000,0,0.000000,'nonchar'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00", # [49]
0.000000,0,0.000000,'numeric'				=> "\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [13]
0.000000,0,0.000000,'once'				=> "\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [14]
0.000000,0,0.000000,'overflow'				=> "\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [15]
0.000000,0,0.000000,'pack'				=> "\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [16]
0.000000,0,0.000000,'parenthesis'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [32]
0.000000,0,0.000000,'pipe'				=> "\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [10]
0.000000,0,0.000000,'portable'				=> "\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [17]
0.000000,0,0.000000,'precedence'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [33]
0.000000,0,0.000000,'printf'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [34]
0.000000,0,0.000000,'prototype'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [35]
0.000000,0,0.000000,'qw'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [36]
0.000000,0,0.000000,'recursion'				=> "\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [18]
0.000000,0,0.000000,'redefine'				=> "\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [19]
0.000000,0,0.000000,'redundant'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00", # [64]
0.000000,0,0.000000,'regexp'				=> "\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [20]
0.000000,0,0.000000,'reserved'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [37]
0.000000,0,0.000000,'scalar'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80", # [79]
0.000000,0,0.000000,'semicolon'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [38]
0.000000,0,0.000000,'severe'				=> "\x00\x00\x00\x00\x00\xa8\x0a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [21..25]
0.000000,0,0.000000,'shadow'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00", # [68]
0.000000,0,0.000000,'signal'				=> "\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [26]
0.000000,0,0.000000,'substr'				=> "\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [27]
0.000000,0,0.000000,'surrogate'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00", # [50]
0.000000,0,0.000000,'syntax'				=> "\x00\x00\x00\x00\x00\x00\x00\xaa\xaa\x2a\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00", # [28..38,47]
0.000000,0,0.000000,'syscalls'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00", # [57]
0.000000,0,0.000000,'taint'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [39]
0.000000,0,0.000000,'threads'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [40]
0.000000,0,0.000000,'uninitialized'			=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [41]
0.000000,0,0.000000,'unopened'				=> "\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [11]
0.000000,0,0.000000,'unpack'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [42]
0.000000,0,0.000000,'untie'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [43]
0.000000,0,0.000000,'utf8'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x2a\x00\x00\x00\x00\x00\x00\x00", # [44,48..50]
0.000000,0,0.000000,'void'				=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00", # [45]
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# These are used by various things, including our own tests
0.000001,1,0.000001,our $NONE				=  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
0.000000,1,0.000000,our $DEFAULT				=  "\x10\x01\x00\x00\x00\x50\x04\x00\x00\x00\x00\x00\x00\x51\x51\x15\x54\x54\x55\x15"; # [2,4,22,23,25,52,54..56,58..62,65..67,69..78]
0.000001,1,0.000001,our $LAST_BIT				=  160 ;
0.000000,1,0.000000,our $BYTES				=  20 ;
0.000000,0,0.000000,
0.000000,0,0.000000,sub Croaker
0.000000,0,0.000000,{
0.000000,0,0.000000,require Carp; # this initializes %CarpInternal
0.000000,0,0.000000,local $Carp::CarpInternal{'warnings'};
0.000000,0,0.000000,delete $Carp::CarpInternal{'warnings'};
0.000000,0,0.000000,Carp::croak(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _expand_bits {
0.000329,1992,0.000000,my $bits = shift;
0.000635,1992,0.000000,my $want_len = ($LAST_BIT + 7) >> 3;
0.000307,1992,0.000000,my $len = length($bits);
0.000328,1992,0.000000,if ($len != $want_len) {
0.000371,494,0.000001,if ($bits eq "") {
0.000000,0,0.000000,$bits = "\x00" x $want_len;
0.000000,0,0.000000,} elsif ($len > $want_len) {
0.000000,0,0.000000,substr $bits, $want_len, $len-$want_len, "";
0.000000,0,0.000000,} else {
0.000699,494,0.000001,my $x = vec($bits, $Offsets{all} >> 1, 2);
0.000207,494,0.000000,$x |= $x << 2;
0.000061,494,0.000000,$x |= $x << 4;
0.000875,494,0.000002,$bits .= chr($x) x ($want_len - $len);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.003835,1992,0.000002,return $bits;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _bits {
0.000241,1576,0.000000,my $mask = shift ;
0.000129,1576,0.000000,my $catmask ;
0.000197,1576,0.000000,my $fatal = 0 ;
0.000169,1576,0.000000,my $no_fatal = 0 ;
0.000000,0,0.000000,
0.001117,1576,0.000001,$mask = _expand_bits($mask);
0.000515,1576,0.000000,foreach my $word ( @_ ) {
0.002021,2825,0.000001,if ($word eq 'FATAL') {
0.000114,1249,0.000000,$fatal = 1;
0.000136,1249,0.000000,$no_fatal = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($word eq 'NONFATAL') {
0.000000,0,0.000000,$fatal = 0;
0.000000,0,0.000000,$no_fatal = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($catmask = $Bits{$word}) {
0.000390,1576,0.000000,$mask |= $catmask ;
0.000557,1576,0.000000,$mask |= $DeadBits{$word} if $fatal ;
0.000183,1576,0.000000,$mask = ~(~$mask | $DeadBits{$word}) if $no_fatal ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{ Croaker("Unknown warnings category '$word'")}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002368,1576,0.000002,return $mask ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub bits
0.000000,0,0.000000,{
0.000000,0,0.000000,# called from B::Deparse.pm
0.000000,0,0.000000,push @_, 'all' unless @_ ;
0.000000,0,0.000000,return _bits("", @_) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub import
0.000000,0,0.000000,{
0.000081,226,0.000000,my $invocant = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# append 'all' when implied (empty import list or after a lone
0.000000,0,0.000000,# "FATAL" or "NONFATAL")
0.000291,226,0.000001,push @_, 'all'
0.000000,0,0.000000,if !@_ || (@_==1 && ($_[0] eq 'FATAL' || $_[0] eq 'NONFATAL'));
0.000000,0,0.000000,
0.000130,226,0.000001,my @fatal = ();
0.001016,226,0.000004,foreach my $warning (@_) {
0.003914,1601,0.000002,if($warning =~ /^(NON)?FATAL$/) {
0.000000,0,0.000000,@fatal = ($warning);
0.000000,0,0.000000,} elsif(substr($warning, 0, 1) ne '-') {
0.000713,1576,0.000000,my $mask = ${^WARNING_BITS} // ($^W ? $Bits{all} : $DEFAULT) ;
0.001787,1576,0.000001,${^WARNING_BITS} = _bits($mask, @fatal, $warning);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$invocant->unimport(substr($warning, 1));
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unimport
0.000000,0,0.000000,{
0.000063,416,0.000000,shift;
0.000000,0,0.000000,
0.000055,416,0.000000,my $catmask ;
0.000464,416,0.000001,my $mask = ${^WARNING_BITS} // ($^W ? $Bits{all} : $DEFAULT) ;
0.000000,0,0.000000,
0.000000,0,0.000000,# append 'all' when implied (empty import list or after a lone "FATAL")
0.000494,416,0.000001,push @_, 'all' if !@_ || @_==1 && $_[0] eq 'FATAL';
0.000000,0,0.000000,
0.000657,416,0.000002,$mask = _expand_bits($mask);
0.000238,416,0.000001,foreach my $word ( @_ ) {
0.001461,569,0.000003,if ($word eq 'FATAL') {
0.000012,18,0.000001,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($catmask = $Bits{$word}) {
0.000000,0,0.000000,$mask = ~(~$mask | $catmask | $DeadBits{$word});
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{ Croaker("Unknown warnings category '$word'")}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001674,416,0.000004,${^WARNING_BITS} = $mask ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000009,2,0.000005,my %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();
0.000000,0,0.000000,
0.000000,0,0.000000,sub LEVEL () { 8 };
0.000000,0,0.000000,sub MESSAGE () { 4 };
0.000000,0,0.000000,sub FATAL () { 2 };
0.000000,0,0.000000,sub NORMAL () { 1 };
0.000000,0,0.000000,
0.000000,0,0.000000,sub __chk
0.000000,0,0.000000,{
0.000000,0,0.000000,my $category ;
0.000000,0,0.000000,my $offset ;
0.000000,0,0.000000,my $isobj = 0 ;
0.000000,0,0.000000,my $wanted = shift;
0.000000,0,0.000000,my $has_message = $wanted & MESSAGE;
0.000000,0,0.000000,my $has_level   = $wanted & LEVEL  ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($has_level) {
0.000000,0,0.000000,if (@_ != ($has_message ? 3 : 2)) {
0.000000,0,0.000000,my $sub = (caller 1)[3];
0.000000,0,0.000000,my $syntax = $has_message
0.000000,0,0.000000,? "category, level, 'message'"
0.000000,0,0.000000,: 'category, level';
0.000000,0,0.000000,Croaker("Usage: $sub($syntax)");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (not @_ == 1 || @_ == ($has_message ? 2 : 0)) {
0.000000,0,0.000000,my $sub = (caller 1)[3];
0.000000,0,0.000000,my $syntax = $has_message ? "[category,] 'message'" : '[category]';
0.000000,0,0.000000,Croaker("Usage: $sub($syntax)");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $message = pop if $has_message;
0.000000,0,0.000000,
0.000000,0,0.000000,if (@_) {
0.000000,0,0.000000,# check the category supplied.
0.000000,0,0.000000,$category = shift ;
0.000000,0,0.000000,if (my $type = ref $category) {
0.000000,0,0.000000,Croaker("not an object")
0.000000,0,0.000000,if exists $builtin_type{$type};
0.000000,0,0.000000,$category = $type;
0.000000,0,0.000000,$isobj = 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,$offset = $Offsets{$category};
0.000000,0,0.000000,Croaker("Unknown warnings category '$category'")
0.000000,0,0.000000,unless defined $offset;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$category = (caller(1))[0] ;
0.000000,0,0.000000,$offset = $Offsets{$category};
0.000000,0,0.000000,Croaker("package '$category' not registered for warnings")
0.000000,0,0.000000,unless defined $offset ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $i;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($isobj) {
0.000000,0,0.000000,my $pkg;
0.000000,0,0.000000,$i = 2;
0.000000,0,0.000000,while (do { { package DB; $pkg = (caller($i++))[0] } } ) {
0.000000,0,0.000000,last unless @DB::args && $DB::args[0] =~ /^$category=/ ;
0.000000,0,0.000000,}
0.000000,0,0.000000,$i -= 2 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($has_level) {
0.000000,0,0.000000,$i = 2 + shift;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$i = _error_loc(); # see where Carp will allocate the error
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Default to 0 if caller returns nothing.  Default to $DEFAULT if it
0.000000,0,0.000000,# explicitly returns undef.
0.000000,0,0.000000,my(@callers_bitmask) = (caller($i))[9] ;
0.000000,0,0.000000,my $callers_bitmask =
0.000000,0,0.000000,@callers_bitmask ? $callers_bitmask[0] // $DEFAULT : 0 ;
0.000000,0,0.000000,length($callers_bitmask) > ($offset >> 3) or $offset = $Offsets{all};
0.000000,0,0.000000,
0.000000,0,0.000000,my @results;
0.000000,0,0.000000,foreach my $type (FATAL, NORMAL) {
0.000000,0,0.000000,next unless $wanted & $type;
0.000000,0,0.000000,
0.000000,0,0.000000,push @results, vec($callers_bitmask, $offset + $type - 1, 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# &enabled and &fatal_enabled
0.000000,0,0.000000,return $results[0] unless $has_message;
0.000000,0,0.000000,
0.000000,0,0.000000,# &warnif, and the category is neither enabled as warning nor as fatal
0.000000,0,0.000000,return if ($wanted & (NORMAL | FATAL | MESSAGE))
0.000000,0,0.000000,== (NORMAL | FATAL | MESSAGE)
0.000000,0,0.000000,&& !($results[0] || $results[1]);
0.000000,0,0.000000,
0.000000,0,0.000000,# If we have an explicit level, bypass Carp.
0.000000,0,0.000000,if ($has_level and @callers_bitmask) {
0.000000,0,0.000000,# logic copied from util.c:mess_sv
0.000000,0,0.000000,my $stuff = " at " . join " line ", (caller $i)[1,2];
0.000000,0,0.000000,$stuff .= sprintf ", <%s> %s %d",
0.000000,0,0.000000,*${^LAST_FH}{NAME},
0.000000,0,0.000000,($/ eq "\n" ? "line" : "chunk"), $.
0.000000,0,0.000000,if $. && ${^LAST_FH};
0.000000,0,0.000000,die "$message$stuff.\n" if $results[0];
0.000000,0,0.000000,return warn "$message$stuff.\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak($message) if $results[0];
0.000000,0,0.000000,# will always get here for &warn. will only get here for &warnif if the
0.000000,0,0.000000,# category is enabled
0.000000,0,0.000000,Carp::carp($message);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _mkMask
0.000000,0,0.000000,{
0.000002,14,0.000000,my ($bit) = @_;
0.000004,14,0.000000,my $mask = "";
0.000000,0,0.000000,
0.000028,14,0.000002,vec($mask, $bit, 1) = 1;
0.000108,14,0.000008,return $mask;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub register_categories
0.000000,0,0.000000,{
0.000012,8,0.000002,my @names = @_;
0.000000,0,0.000000,
0.000037,8,0.000005,for my $name (@names) {
0.000009,8,0.000001,if (! defined $Bits{$name}) {
0.000010,7,0.000001,$Offsets{$name}  = $LAST_BIT;
0.000050,7,0.000007,$Bits{$name}     = _mkMask($LAST_BIT++);
0.000014,7,0.000002,$DeadBits{$name} = _mkMask($LAST_BIT++);
0.000011,7,0.000002,if (length($Bits{$name}) > length($Bits{all})) {
0.000002,2,0.000001,$Bits{all} .= "\x55";
0.000002,2,0.000001,$DeadBits{all} .= "\xaa";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _error_loc {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,goto &Carp::short_error_loc; # don't introduce another stack frame
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub enabled
0.000000,0,0.000000,{
0.000000,0,0.000000,return __chk(NORMAL, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fatal_enabled
0.000000,0,0.000000,{
0.000000,0,0.000000,return __chk(FATAL, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub warn
0.000000,0,0.000000,{
0.000000,0,0.000000,return __chk(FATAL | MESSAGE, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub warnif
0.000000,0,0.000000,{
0.000000,0,0.000000,return __chk(NORMAL | FATAL | MESSAGE, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub enabled_at_level
0.000000,0,0.000000,{
0.000000,0,0.000000,return __chk(NORMAL | LEVEL, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fatal_enabled_at_level
0.000000,0,0.000000,{
0.000000,0,0.000000,return __chk(FATAL | LEVEL, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub warn_at_level
0.000000,0,0.000000,{
0.000000,0,0.000000,return __chk(FATAL | MESSAGE | LEVEL, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub warnif_at_level
0.000000,0,0.000000,{
0.000000,0,0.000000,return __chk(NORMAL | FATAL | MESSAGE | LEVEL, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# These are not part of any public interface, so we can delete them to save
0.000000,0,0.000000,# space.
0.000012,1,0.000012,delete @warnings::{qw(NORMAL FATAL MESSAGE LEVEL)};
0.000000,0,0.000000,
0.000054,1,0.000054,1;
0.000000,0,0.000000,__END__
