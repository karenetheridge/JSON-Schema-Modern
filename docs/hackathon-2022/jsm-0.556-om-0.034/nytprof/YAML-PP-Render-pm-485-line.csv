# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# ABSTRACT: YAML::PP Rendering functions
0.000032,2,0.000016,use strict;
0.000050,2,0.000025,use warnings;
0.000000,0,0.000000,package YAML::PP::Render;
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000574,2,0.000287,use constant TRACE => $ENV{YAML_PP_TRACE} ? 1 : 0;
0.000000,0,0.000000,
0.000000,0,0.000000,sub render_quoted {
0.000000,0,0.000000,my ($self, $style, $lines) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $quoted = '';
0.000000,0,0.000000,my $addspace = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $i (0 .. $#$lines) {
0.000000,0,0.000000,my $line = $lines->[ $i ];
0.000000,0,0.000000,my $value = $line->{value};
0.000000,0,0.000000,my $last = $i == $#$lines;
0.000000,0,0.000000,my $first = $i == 0;
0.000000,0,0.000000,if ($value eq '') {
0.000000,0,0.000000,if ($first) {
0.000000,0,0.000000,$addspace = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last) {
0.000000,0,0.000000,$quoted .= ' ' if $addspace;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$addspace = 0;
0.000000,0,0.000000,$quoted .= "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$quoted .= ' ' if $addspace;
0.000000,0,0.000000,$addspace = 1;
0.000000,0,0.000000,if ($style eq '"') {
0.000000,0,0.000000,if ($line->{orig} =~ m/\\$/) {
0.000000,0,0.000000,$line->{value} =~ s/\\$//;
0.000000,0,0.000000,$value =~ s/\\$//;
0.000000,0,0.000000,$addspace = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$quoted .= $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $quoted;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub render_block_scalar {
0.000001,1,0.000001,my ($self, $block_type, $chomp, $lines) = @_;
0.000000,0,0.000000,
0.000001,1,0.000001,my ($folded, $keep, $trim);
0.000001,1,0.000001,if ($block_type eq '>') {
0.000000,0,0.000000,$folded = 1;
0.000000,0,0.000000,}
0.000002,1,0.000002,if ($chomp eq '+') {
0.000000,0,0.000000,$keep = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($chomp eq '-') {
0.000000,0,0.000000,$trim = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,my $string = '';
0.000001,1,0.000001,if (not $keep) {
0.000000,0,0.000000,# remove trailing empty lines
0.000001,1,0.000001,while (@$lines) {
0.000001,1,0.000001,last if $lines->[-1] ne '';
0.000000,0,0.000000,pop @$lines;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000001,1,0.000001,if ($folded) {
0.000000,0,0.000000,
0.000000,0,0.000000,my $prev = 'START';
0.000000,0,0.000000,my $trailing = '';
0.000000,0,0.000000,if ($keep) {
0.000000,0,0.000000,while (@$lines and $lines->[-1] eq '') {
0.000000,0,0.000000,pop @$lines;
0.000000,0,0.000000,$trailing .= "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,for my $i (0 .. $#$lines) {
0.000000,0,0.000000,my $line = $lines->[ $i ];
0.000000,0,0.000000,
0.000000,0,0.000000,my $type = $line eq ''
0.000000,0,0.000000,? 'EMPTY'
0.000000,0,0.000000,: $line =~ m/\A[ \t]/
0.000000,0,0.000000,? 'MORE'
0.000000,0,0.000000,: 'CONTENT';
0.000000,0,0.000000,
0.000000,0,0.000000,if ($prev eq 'MORE' and $type eq 'EMPTY') {
0.000000,0,0.000000,$type = 'MORE';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($prev eq 'CONTENT') {
0.000000,0,0.000000,if ($type ne 'CONTENT') {
0.000000,0,0.000000,$string .= "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type eq 'CONTENT') {
0.000000,0,0.000000,$string .= ' ';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($prev eq 'START' and $type eq 'EMPTY') {
0.000000,0,0.000000,$string .= "\n";
0.000000,0,0.000000,$type = 'START';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($prev eq 'EMPTY' and $type ne 'CONTENT') {
0.000000,0,0.000000,$string .= "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$string .= $line;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($type eq 'MORE' and $i < $#$lines) {
0.000000,0,0.000000,$string .= "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$prev = $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($keep) {
0.000000,0,0.000000,$string .= $trailing;
0.000000,0,0.000000,}
0.000000,0,0.000000,$string .= "\n" if @$lines and not $trim;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000002,1,0.000002,for my $i (0 .. $#$lines) {
0.000004,5,0.000001,$string .= $lines->[ $i ];
0.000004,5,0.000001,$string .= "\n" if ($i != $#$lines or not $trim);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$string], ['string']);
0.000005,1,0.000005,return $string;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub render_multi_val {
0.000000,0,0.000000,my ($self, $multi) = @_;
0.000000,0,0.000000,my $string = '';
0.000000,0,0.000000,my $start = 1;
0.000000,0,0.000000,for my $line (@$multi) {
0.000000,0,0.000000,if (not $start) {
0.000000,0,0.000000,if ($line eq '') {
0.000000,0,0.000000,$string .= "\n";
0.000000,0,0.000000,$start = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$string .= " $line";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$string .= $line;
0.000000,0,0.000000,$start = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return $string;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000003,1,0.000003,1;
