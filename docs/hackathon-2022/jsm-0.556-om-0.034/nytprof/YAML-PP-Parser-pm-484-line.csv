# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# ABSTRACT: YAML Parser
0.000036,2,0.000018,use strict;
0.000055,2,0.000028,use warnings;
0.000000,0,0.000000,package YAML::PP::Parser;
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000046,2,0.000023,use constant TRACE => $ENV{YAML_PP_TRACE} ? 1 : 0;
0.000054,2,0.000027,use constant DEBUG => ($ENV{YAML_PP_DEBUG} || $ENV{YAML_PP_TRACE}) ? 1 : 0;
0.000000,0,0.000000,
0.000001,1,0.000001,use YAML::PP::Common qw/
0.000000,0,0.000000,YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,YAML_DOUBLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE
0.000000,0,0.000000,YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE
0.000050,1,0.000050,/;
0.000531,2,0.000266,use YAML::PP::Render;
0.000496,2,0.000248,use YAML::PP::Lexer;
0.000033,2,0.000016,use YAML::PP::Grammar qw/ $GRAMMAR /;
0.000607,2,0.000304,use YAML::PP::Exception;
0.000377,2,0.000189,use YAML::PP::Reader;
0.000472,2,0.000236,use Carp qw/ croak /;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000001,1,0.000001,my ($class, %args) = @_;
0.000004,1,0.000004,my $reader = delete $args{reader} || YAML::PP::Reader->new;
0.000000,1,0.000000,my $default_yaml_version = delete $args{default_yaml_version};
0.000007,1,0.000007,my $self = bless {
0.000000,0,0.000000,default_yaml_version => $default_yaml_version || '1.2',
0.000000,0,0.000000,lexer => YAML::PP::Lexer->new(
0.000000,0,0.000000,reader => $reader,
0.000000,0,0.000000,),
0.000000,0,0.000000,}, $class;
0.000000,1,0.000000,my $receiver = delete $args{receiver};
0.000000,1,0.000000,if ($receiver) {
0.000000,0,0.000000,$self->set_receiver($receiver);
0.000000,0,0.000000,}
0.000005,1,0.000005,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my $clone = {
0.000000,0,0.000000,default_yaml_version => $self->default_yaml_version,
0.000000,0,0.000000,lexer => YAML::PP::Lexer->new(),
0.000000,0,0.000000,};
0.000000,0,0.000000,return bless $clone, ref $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,sub receiver { return $_[0]->{receiver} }
0.000000,0,0.000000,sub set_receiver {
0.000001,1,0.000001,my ($self, $receiver) = @_;
0.000000,1,0.000000,my $callback;
0.000002,1,0.000002,if (ref $receiver eq 'CODE') {
0.000000,0,0.000000,$callback = $receiver;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$callback = sub {
0.010066,36113,0.000000,my ($self, $event, $info) = @_;
0.104833,36113,0.000003,return $receiver->$event($info);
0.000004,1,0.000004,};
0.000000,0,0.000000,}
0.000000,1,0.000000,$self->{callback} = $callback;
0.000002,1,0.000002,$self->{receiver} = $receiver;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub reader { return $_[0]->lexer->{reader} }
0.000000,0,0.000000,sub set_reader {
0.000000,1,0.000000,my ($self, $reader) = @_;
0.000007,1,0.000007,$self->lexer->set_reader($reader);
0.000000,0,0.000000,}
0.081196,55337,0.000001,sub lexer { return $_[0]->{lexer} }
0.046545,36113,0.000001,sub callback { return $_[0]->{callback} }
0.000000,0,0.000000,sub set_callback { $_[0]->{callback} = $_[1] }
0.017126,6993,0.000002,sub level { return $#{ $_[0]->{offset} } }
0.057600,31969,0.000002,sub offset { return $_[0]->{offset} }
0.000005,1,0.000005,sub set_offset { $_[0]->{offset} = $_[1] }
0.095886,62745,0.000002,sub events { return $_[0]->{events} }
0.000002,1,0.000002,sub set_events { $_[0]->{events} = $_[1] }
0.042747,27450,0.000002,sub new_node { return $_[0]->{new_node} }
0.054495,36237,0.000002,sub set_new_node { $_[0]->{new_node} = $_[1] }
0.000000,0,0.000000,sub tagmap { return $_[0]->{tagmap} }
0.000006,2,0.000003,sub set_tagmap { $_[0]->{tagmap} = $_[1] }
0.022855,13450,0.000002,sub tokens { return $_[0]->{tokens} }
0.000004,1,0.000004,sub set_tokens { $_[0]->{tokens} = $_[1] }
0.099173,70379,0.000001,sub event_stack { return $_[0]->{event_stack} }
0.000003,1,0.000003,sub set_event_stack { $_[0]->{event_stack} = $_[1] }
0.000002,1,0.000002,sub default_yaml_version { return $_[0]->{default_yaml_version} }
0.000002,1,0.000002,sub yaml_version { return $_[0]->{yaml_version} }
0.000002,1,0.000002,sub set_yaml_version { $_[0]->{yaml_version} = $_[1] }
0.000002,1,0.000002,sub yaml_version_directive { return $_[0]->{yaml_version_directive} }
0.000009,2,0.000005,sub set_yaml_version_directive { $_[0]->{yaml_version_directive} = $_[1] }
0.000000,0,0.000000,
0.024103,13450,0.000002,sub rule { return $_[0]->{rule} }
0.000000,0,0.000000,sub set_rule {
0.020157,55080,0.000000,my ($self, $name) = @_;
0.004901,2,0.002450,no warnings 'uninitialized';
0.000000,0,0.000000,DEBUG and $self->info("set_rule($name)");
0.093623,55080,0.000002,$self->{rule} = $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub init {
0.000000,1,0.000000,my ($self) = @_;
0.000003,1,0.000003,$self->set_offset([]);
0.000001,1,0.000001,$self->set_events([]);
0.000002,1,0.000002,$self->set_new_node(0);
0.000002,1,0.000002,$self->set_tagmap({
0.000000,0,0.000000,'!!' => "tag:yaml.org,2002:",
0.000000,0,0.000000,});
0.000001,1,0.000001,$self->set_tokens([]);
0.000002,1,0.000002,$self->set_rule(undef);
0.000001,1,0.000001,$self->set_event_stack([]);
0.000005,1,0.000005,$self->set_yaml_version($self->default_yaml_version);
0.000001,1,0.000001,$self->set_yaml_version_directive(undef);
0.000011,1,0.000011,$self->lexer->init;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_string {
0.000000,0,0.000000,my ($self, $yaml) = @_;
0.000000,0,0.000000,$self->set_reader(YAML::PP::Reader->new( input => $yaml ));
0.000000,0,0.000000,$self->parse();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_file {
0.000000,0,0.000000,my ($self, $file) = @_;
0.000000,0,0.000000,$self->set_reader(YAML::PP::Reader::File->new( input => $file ));
0.000000,0,0.000000,$self->parse();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,my %nodetypes = (
0.000000,0,0.000000,MAPVALUE     => 'NODETYPE_COMPLEX',
0.000000,0,0.000000,MAP          => 'NODETYPE_MAP',
0.000000,0,0.000000,#    IMAP         => 'NODETYPE_SEQ',
0.000000,0,0.000000,SEQ          => 'NODETYPE_SEQ',
0.000000,0,0.000000,SEQ0         => 'NODETYPE_SEQ',
0.000000,0,0.000000,FLOWMAP      => 'NODETYPE_FLOWMAP',
0.000000,0,0.000000,FLOWMAPVALUE => 'NODETYPE_FLOWMAPVALUE',
0.000000,0,0.000000,FLOWSEQ      => 'NODETYPE_FLOWSEQ',
0.000000,0,0.000000,FLOWSEQ_NEXT => 'FLOWSEQ_NEXT',
0.000000,0,0.000000,DOC          => 'FULLNODE',
0.000000,0,0.000000,DOC_END      => 'DOCUMENT_END',
0.000000,0,0.000000,STR          => 'STREAM',
0.000000,0,0.000000,END_FLOW     => 'END_FLOW',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse {
0.000001,1,0.000001,my ($self) = @_;
0.000000,0,0.000000,TRACE and warn "=== parse()\n";
0.000000,0,0.000000,TRACE and $self->debug_yaml;
0.000003,1,0.000003,$self->init;
0.000001,1,0.000001,$self->lexer->init;
0.000001,1,0.000001,eval {
0.000004,1,0.000004,$self->start_stream;
0.000001,1,0.000001,$self->set_rule( 'STREAM' );
0.000000,0,0.000000,
0.000002,1,0.000002,$self->parse_tokens();
0.000000,0,0.000000,
0.000002,1,0.000002,$self->end_stream;
0.000000,0,0.000000,};
0.000001,1,0.000001,if (my $error = $@) {
0.000000,0,0.000000,if (ref $error) {
0.000000,0,0.000000,croak "$error\n ";
0.000000,0,0.000000,}
0.000000,0,0.000000,croak $error;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and $self->highlight_yaml;
0.000003,1,0.000003,TRACE and $self->debug_tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub lex_next_tokens {
0.003707,13451,0.000000,my ($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and $self->info("----------------> lex_next_tokens");
0.000000,0,0.000000,TRACE and $self->debug_events;
0.000000,0,0.000000,
0.014253,13451,0.000001,my $indent = $self->offset->[-1];
0.009418,13451,0.000001,my $event_types = $self->events;
0.031478,13451,0.000002,my $next_tokens = $self->lexer->fetch_next_tokens($indent);
0.002686,13451,0.000000,return unless @$next_tokens;
0.000000,0,0.000000,
0.003843,13450,0.000000,my $next = $next_tokens->[0];
0.000000,0,0.000000,
0.005387,13450,0.000000,return 1 if ($next->{name} ne 'SPACE');
0.028281,13449,0.000002,my $flow = $event_types->[-1] =~ m/^FLOW/;
0.007548,13449,0.000001,my $space = length $next->{value};
0.014785,13449,0.000001,my $tokens = $self->tokens;
0.000000,0,0.000000,
0.005660,13449,0.000000,if (not $space) {
0.000000,0,0.000000,shift @$next_tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.005143,13444,0.000000,push @$tokens, shift @$next_tokens;
0.000000,0,0.000000,}
0.002183,13449,0.000000,if ($flow) {
0.000000,0,0.000000,if ($space >= $indent) {
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->exception("Bad indendation in " . $self->events->[-1]);
0.000000,0,0.000000,}
0.003149,13449,0.000000,$next = $next_tokens->[0];
0.004257,13449,0.000000,if ($space > $indent ) {
0.002205,6149,0.000000,return 1 if $indent < 0;
0.005376,6148,0.000001,unless ($self->new_node) {
0.000000,0,0.000000,$self->exception("Bad indendation in " . $self->events->[-1]);
0.000000,0,0.000000,}
0.013152,6148,0.000002,return 1;
0.000000,0,0.000000,}
0.009234,7300,0.000001,if ($self->new_node) {
0.000214,308,0.000001,if ($space < $indent) {
0.000000,0,0.000000,$self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
0.000000,0,0.000000,$self->remove_nodes($space);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# unindented sequence starts
0.000522,308,0.000002,my $exp = $self->events->[-1];
0.000146,308,0.000000,my $seq_start = $next->{name} eq 'DASH';
0.000211,308,0.000001,if ( $seq_start and ($exp eq 'MAPVALUE' or $exp eq 'MAP')) {
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.006092,6992,0.000001,if ($space < $indent) {
0.000000,0,0.000000,$self->remove_nodes($space);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.009043,7300,0.000001,my $exp = $self->events->[-1];
0.000000,0,0.000000,
0.003708,7300,0.000001,if ($exp eq 'SEQ0' and $next->{name} ne 'DASH') {
0.000000,0,0.000000,TRACE and $self->info("In unindented sequence");
0.000380,262,0.000001,$self->end_sequence;
0.000297,262,0.000001,$exp = $self->events->[-1];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.008497,7300,0.000001,if ($self->offset->[-1] != $space) {
0.000000,0,0.000000,$self->exception("Expected " . $self->events->[-1]);
0.000000,0,0.000000,}
0.016067,7300,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,my %next_event = (
0.000000,0,0.000000,MAP => 'MAPVALUE',
0.000000,0,0.000000,IMAP => 'IMAPVALUE',
0.000000,0,0.000000,MAPVALUE => 'MAP',
0.000000,0,0.000000,IMAPVALUE => 'IMAP',
0.000000,0,0.000000,SEQ => 'SEQ',
0.000000,0,0.000000,SEQ0 => 'SEQ0',
0.000000,0,0.000000,DOC => 'DOC_END',
0.000000,0,0.000000,STR => 'STR',
0.000000,0,0.000000,FLOWSEQ => 'FLOWSEQ_NEXT',
0.000000,0,0.000000,FLOWSEQ_NEXT => 'FLOWSEQ',
0.000000,0,0.000000,FLOWMAP => 'FLOWMAPVALUE',
0.000000,0,0.000000,FLOWMAPVALUE => 'FLOWMAP',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000001,1,0.000001,my %event_to_method = (
0.000000,0,0.000000,MAP => 'mapping',
0.000000,0,0.000000,IMAP => 'mapping',
0.000000,0,0.000000,FLOWMAP => 'mapping',
0.000000,0,0.000000,SEQ => 'sequence',
0.000000,0,0.000000,SEQ0 => 'sequence',
0.000000,0,0.000000,FLOWSEQ => 'sequence',
0.000000,0,0.000000,DOC => 'document',
0.000000,0,0.000000,STR => 'stream',
0.000000,0,0.000000,VAL => 'scalar',
0.000000,0,0.000000,ALI => 'alias',
0.000000,0,0.000000,MAPVALUE => 'mapping',
0.000000,0,0.000000,IMAPVALUE => 'mapping',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,#sub process_events {
0.000000,0,0.000000,#    my ($self, $res) = @_;
0.000000,0,0.000000,#
0.000000,0,0.000000,#    my $event_stack = $self->event_stack;
0.000000,0,0.000000,#    return unless @$event_stack;
0.000000,0,0.000000,#
0.000000,0,0.000000,#    if (@$event_stack == 1 and $event_stack->[0]->[0] eq 'properties') {
0.000000,0,0.000000,#        return;
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#
0.000000,0,0.000000,#    my $event_types = $self->events;
0.000000,0,0.000000,#    my $properties;
0.000000,0,0.000000,#    my @send_events;
0.000000,0,0.000000,#    for my $event (@$event_stack) {
0.000000,0,0.000000,#        TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$event], ['event']);
0.000000,0,0.000000,#        my ($type, $info) = @$event;
0.000000,0,0.000000,#        if ($type eq 'properties') {
0.000000,0,0.000000,#            $properties = $info;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#        elsif ($type eq 'scalar') {
0.000000,0,0.000000,#            $info->{name} = 'scalar_event';
0.000000,0,0.000000,#            $event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,#            push @send_events, $info;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#        elsif ($type eq 'begin') {
0.000000,0,0.000000,#            my $name = $info->{name};
0.000000,0,0.000000,#            $info->{name} = $event_to_method{ $name } . '_start_event';
0.000000,0,0.000000,#            push @{ $event_types }, $name;
0.000000,0,0.000000,#            push @{ $self->offset }, $info->{offset};
0.000000,0,0.000000,#            push @send_events, $info;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#        elsif ($type eq 'end') {
0.000000,0,0.000000,#            my $name = $info->{name};
0.000000,0,0.000000,#            $info->{name} = $event_to_method{ $name } . '_end_event';
0.000000,0,0.000000,#            $self->$type($name, $info);
0.000000,0,0.000000,#            push @send_events, $info;
0.000000,0,0.000000,#            if (@$event_types) {
0.000000,0,0.000000,#                $event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,#            }
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#        elsif ($type eq 'alias') {
0.000000,0,0.000000,#            if ($properties) {
0.000000,0,0.000000,#                $self->exception("Parse error: Alias not allowed in this context");
0.000000,0,0.000000,#            }
0.000000,0,0.000000,#            $info->{name} = 'alias_event';
0.000000,0,0.000000,#            $event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,#            push @send_events, $info;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#    @$event_stack = ();
0.000000,0,0.000000,#    for my $info (@send_events) {
0.000000,0,0.000000,#        DEBUG and $self->debug_event( $info );
0.000000,0,0.000000,#        $self->callback->($self, $info->{name}, $info);
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#}
0.000000,0,0.000000,
0.000002,1,0.000002,my %fetch_method = (
0.000000,0,0.000000,'"' => 'fetch_quoted',
0.000000,0,0.000000,"'" => 'fetch_quoted',
0.000000,0,0.000000,'|' => 'fetch_block',
0.000000,0,0.000000,'>' => 'fetch_block',
0.000000,0,0.000000,''  => 'fetch_plain',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_tokens {
0.000000,1,0.000000,my ($self) = @_;
0.000002,1,0.000002,my $event_types = $self->events;
0.000001,1,0.000001,my $offsets = $self->offset;
0.000001,1,0.000001,my $tokens = $self->tokens;
0.000002,1,0.000002,my $next_tokens = $self->lexer->next_tokens;
0.000000,0,0.000000,
0.000002,1,0.000002,unless ($self->lex_next_tokens) {
0.000000,0,0.000000,$self->end_document(1);
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000003,1,0.000003,unless ($self->new_node) {
0.000002,1,0.000002,if ($self->level > 0) {
0.000000,0,0.000000,my $new_rule = $nodetypes{ $event_types->[-1] }
0.000000,0,0.000000,or die "Did not find '$event_types->[-1]'";
0.000000,0,0.000000,$self->set_rule( $new_rule );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,my $rule_name = $self->rule;
0.000000,0,0.000000,DEBUG and $self->info("----------------> parse_tokens($rule_name)");
0.000002,1,0.000002,my $rule = $GRAMMAR->{ $rule_name }
0.000000,0,0.000000,or die "Could not find rule $rule_name";
0.000000,0,0.000000,
0.000000,0,0.000000,TRACE and $self->debug_rules($rule);
0.000000,0,0.000000,TRACE and $self->debug_yaml;
0.000000,0,0.000000,DEBUG and $self->debug_next_line;
0.000000,0,0.000000,
0.009348,1,0.009348,RULE: while ($rule_name) {
0.000000,0,0.000000,DEBUG and $self->info("RULE: $rule_name");
0.000000,0,0.000000,TRACE and $self->debug_tokens($next_tokens);
0.000000,0,0.000000,
0.016005,110985,0.000000,unless (@$next_tokens) {
0.000000,0,0.000000,$self->exception("No more tokens");
0.000000,0,0.000000,}
0.000000,0,0.000000,TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$next_tokens->[0]], ['next_token']);
0.032221,110985,0.000000,my $got = $next_tokens->[0]->{name};
0.017182,110985,0.000000,if ($got eq 'CONTEXT') {
0.005385,20941,0.000000,my $context = shift @$next_tokens;
0.004057,20941,0.000000,my $indent = $offsets->[-1];
0.035319,20941,0.000002,$indent++ unless $self->lexer->flowcontext;
0.011019,20941,0.000001,my $method = $fetch_method{ $context->{value} };
0.039118,20941,0.000002,my $partial = $self->lexer->$method($indent, $context->{value});
0.028928,20941,0.000001,next RULE;
0.000000,0,0.000000,}
0.035918,90044,0.000000,my $def = $rule->{ $got };
0.038672,90044,0.000000,if ($def) {
0.000000,0,0.000000,push @$tokens, shift @$next_tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($def = $rule->{DEFAULT}) {
0.000000,0,0.000000,$got = 'DEFAULT';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->expected(
0.000000,0,0.000000,expected => [keys %$rule],
0.000000,0,0.000000,got => $next_tokens->[0],
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and $self->got("---got $got");
0.042792,90044,0.000000,if (my $sub = $def->{match}) {
0.000000,0,0.000000,DEBUG and $self->info("CALLBACK $sub");
0.066726,43770,0.000002,$self->$sub(@$tokens ? $tokens->[-1] : ());
0.000000,0,0.000000,}
0.019684,90044,0.000000,my $eol = $got eq 'EOL';
0.026232,90044,0.000000,my $new = $def->{new};
0.027286,90044,0.000000,if ($new) {
0.000000,0,0.000000,DEBUG and $self->got("NEW: $new");
0.008138,46809,0.000000,$rule_name = $new;
0.038487,46809,0.000001,$self->set_rule($rule_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($eol) {
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($def->{return}) {
0.001031,1275,0.000001,$rule_name = $nodetypes{ $event_types->[-1] }
0.000000,0,0.000000,or die "Unexpected event type $event_types->[-1]";
0.001034,1275,0.000001,$self->set_rule($rule_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.019344,34967,0.000001,$rule_name .= " - $got"; # for debugging
0.005121,34967,0.000000,$rule = $def;
0.012839,34967,0.000000,next RULE;
0.000000,0,0.000000,}
0.010505,55077,0.000000,if ($eol) {
0.016063,13450,0.000001,unless ($self->lex_next_tokens) {
0.000000,1,0.000000,if ($rule_name eq 'DIRECTIVE') {
0.000000,0,0.000000,$self->exception("Directive needs document start");
0.000000,0,0.000000,}
0.000002,1,0.000002,$self->end_document(1);
0.000005,1,0.000005,return 0;
0.000000,0,0.000000,}
0.011349,13449,0.000001,unless ($self->new_node) {
0.010433,6992,0.000001,if ($self->level > 0) {
0.005791,6992,0.000001,$rule_name = $nodetypes{ $event_types->[-1] }
0.000000,0,0.000000,or die "Did not find '$event_types->[-1]'";
0.005527,6992,0.000001,$self->set_rule( $rule_name );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.017259,13449,0.000001,$rule_name = $self->rule;
0.000000,0,0.000000,}
0.052994,55076,0.000001,$rule = $GRAMMAR->{ $rule_name }
0.000000,0,0.000000,or die "Unexpected rule $rule_name";
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,die "Unexpected";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_sequence {
0.000124,262,0.000000,my ($self) = @_;
0.000261,262,0.000001,my $event_types = $self->events;
0.000106,262,0.000000,pop @{ $event_types };
0.000249,262,0.000001,pop @{ $self->offset };
0.000415,262,0.000002,my $info = { name => 'sequence_end_event' };
0.000429,262,0.000002,$self->callback->($self, $info->{name} => $info );
0.000861,262,0.000003,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove_nodes {
0.001185,2816,0.000000,my ($self, $space) = @_;
0.002883,2816,0.000001,my $offset = $self->offset;
0.002459,2816,0.000001,my $event_types = $self->events;
0.000000,0,0.000000,
0.001252,2816,0.000000,my $exp = $event_types->[-1];
0.001156,2816,0.000000,while (@$offset) {
0.003030,9587,0.000000,if ($offset->[ -1 ] <= $space) {
0.001167,2816,0.000000,last;
0.000000,0,0.000000,}
0.001729,6771,0.000000,if ($exp eq 'MAPVALUE') {
0.000000,0,0.000000,$self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
0.000000,0,0.000000,$exp = 'MAP';
0.000000,0,0.000000,}
0.005415,6771,0.000001,my $info = { name => $exp };
0.004864,6771,0.000001,$info->{name} = $event_to_method{ $exp } . '_end_event';
0.002255,6771,0.000000,pop @{ $event_types };
0.001417,6771,0.000000,pop @{ $offset };
0.011221,6771,0.000002,$self->callback->($self, $info->{name} => $info );
0.004738,6771,0.000001,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.006530,6771,0.000001,$exp = $event_types->[-1];
0.000000,0,0.000000,}
0.005716,2816,0.000002,return $exp;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_stream {
0.000000,1,0.000000,my ($self) = @_;
0.000003,1,0.000003,push @{ $self->events }, 'STR';
0.000002,1,0.000002,push @{ $self->offset }, -1;
0.000006,1,0.000006,$self->callback->($self, 'stream_start_event', {
0.000000,0,0.000000,name => 'stream_start_event',
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_document {
0.000000,1,0.000000,my ($self, $implicit) = @_;
0.000003,1,0.000003,push @{ $self->events }, 'DOC';
0.000001,1,0.000001,push @{ $self->offset }, -1;
0.000001,1,0.000001,my $directive = $self->yaml_version_directive;
0.000001,1,0.000001,my %directive;
0.000000,1,0.000000,if ($directive) {
0.000000,0,0.000000,my ($major, $minor) = split m/\./, $self->yaml_version;
0.000000,0,0.000000,%directive = ( version_directive => { major => $major, minor => $minor } );
0.000000,0,0.000000,}
0.000004,1,0.000004,$self->callback->($self, 'document_start_event', {
0.000000,0,0.000000,name => 'document_start_event',
0.000000,0,0.000000,implicit => $implicit,
0.000000,0,0.000000,%directive,
0.000000,0,0.000000,});
0.000001,1,0.000001,$self->set_yaml_version_directive(undef);
0.000001,1,0.000001,$self->set_rule( 'FULLNODE' );
0.000006,1,0.000006,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_sequence {
0.000142,308,0.000000,my ($self, $offset) = @_;
0.000363,308,0.000001,my $offsets = $self->offset;
0.000633,308,0.000002,if ($offsets->[-1] == $offset) {
0.000000,0,0.000000,push @{ $self->events }, 'SEQ0';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @{ $self->events }, 'SEQ';
0.000000,0,0.000000,}
0.000151,308,0.000000,push @{ $offsets }, $offset;
0.000378,308,0.000001,my $event_stack = $self->event_stack;
0.000305,308,0.000001,my $info = { name => 'sequence_start_event' };
0.000080,308,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,my $properties = pop @$event_stack;
0.000000,0,0.000000,$self->node_properties($properties->[1], $info);
0.000000,0,0.000000,}
0.001055,308,0.000003,$self->callback->($self, 'sequence_start_event', $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_flow_sequence {
0.000116,337,0.000000,my ($self, $offset) = @_;
0.000361,337,0.000001,my $offsets = $self->offset;
0.000135,337,0.000000,my $new_offset = $offsets->[-1];
0.000341,337,0.000001,my $event_types = $self->events;
0.000615,337,0.000002,if ($new_offset < 0) {
0.000000,0,0.000000,$new_offset = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->new_node) {
0.000880,337,0.000003,if ($event_types->[-1] !~ m/^FLOW/) {
0.000000,0,0.000000,$new_offset++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000432,337,0.000001,push @{ $self->events }, 'FLOWSEQ';
0.000147,337,0.000000,push @{ $offsets }, $new_offset;
0.000000,0,0.000000,
0.000332,337,0.000001,my $event_stack = $self->event_stack;
0.000492,337,0.000001,my $info = { style => YAML_FLOW_SEQUENCE_STYLE, name => 'sequence_start_event'  };
0.000191,337,0.000001,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($event_stack, $info);
0.000000,0,0.000000,}
0.001106,337,0.000003,$self->callback->($self, 'sequence_start_event', $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_flow_mapping {
0.000102,214,0.000000,my ($self, $offset, $implicit_flowseq_map) = @_;
0.000225,214,0.000001,my $offsets = $self->offset;
0.000146,214,0.000001,my $new_offset = $offsets->[-1];
0.000265,214,0.000001,my $event_types = $self->events;
0.000349,214,0.000002,if ($new_offset < 0) {
0.000000,0,0.000000,$new_offset = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->new_node) {
0.000520,214,0.000002,if ($event_types->[-1] !~ m/^FLOW/) {
0.000000,0,0.000000,$new_offset++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000403,214,0.000002,push @{ $self->events }, $implicit_flowseq_map ? 'IMAP' : 'FLOWMAP';
0.000079,214,0.000000,push @{ $offsets }, $new_offset;
0.000000,0,0.000000,
0.000172,214,0.000001,my $event_stack = $self->event_stack;
0.000261,214,0.000001,my $info = { name => 'mapping_start_event', style => YAML_FLOW_MAPPING_STYLE };
0.000066,214,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($event_stack, $info);
0.000000,0,0.000000,}
0.001032,214,0.000005,$self->callback->($self, 'mapping_start_event', $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_flow_sequence {
0.000178,337,0.000001,my ($self) = @_;
0.000301,337,0.000001,my $event_types = $self->events;
0.000219,337,0.000001,pop @{ $event_types };
0.000528,337,0.000002,pop @{ $self->offset };
0.000319,337,0.000001,my $info = { name => 'sequence_end_event' };
0.000621,337,0.000002,$self->callback->($self, $info->{name}, $info);
0.002181,337,0.000006,if ($event_types->[-1] =~ m/^FLOW|^IMAP/) {
0.000000,0,0.000000,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000201,314,0.000001,push @$event_types, 'END_FLOW';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_flow_mapping {
0.000076,214,0.000000,my ($self) = @_;
0.000232,214,0.000001,my $event_types = $self->events;
0.000105,214,0.000000,pop @{ $event_types };
0.000237,214,0.000001,pop @{ $self->offset };
0.000209,214,0.000001,my $info = { name => 'mapping_end_event' };
0.000437,214,0.000002,$self->callback->($self, $info->{name}, $info);
0.001553,214,0.000007,if ($event_types->[-1] =~ m/^FLOW|^IMAP/) {
0.000000,0,0.000000,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000104,214,0.000000,push @$event_types, 'END_FLOW';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_outer_flow {
0.000192,528,0.000000,my ($self) = @_;
0.000627,528,0.000001,my $event_types = $self->events;
0.000220,528,0.000000,pop @$event_types;
0.001165,528,0.000002,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_mapping {
0.001892,6725,0.000000,my ($self, $offset) = @_;
0.006836,6725,0.000001,my $offsets = $self->offset;
0.008456,6725,0.000001,push @{ $self->events }, 'MAP';
0.002112,6725,0.000000,push @{ $offsets }, $offset;
0.004797,6725,0.000001,my $event_stack = $self->event_stack;
0.005732,6725,0.000001,my $info = { name => 'mapping_start_event' };
0.002049,6725,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,my $properties = pop @$event_stack;
0.000000,0,0.000000,$self->node_properties($properties->[1], $info);
0.000000,0,0.000000,}
0.022830,6725,0.000003,$self->callback->($self, 'mapping_start_event', $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_document {
0.000000,1,0.000000,my ($self, $implicit) = @_;
0.000000,0,0.000000,
0.000001,1,0.000001,my $event_types = $self->events;
0.000002,1,0.000002,if ($event_types->[-1] =~ m/FLOW/) {
0.000000,0,0.000000,die "Unexpected end of flow context";
0.000000,0,0.000000,}
0.000002,1,0.000002,if ($self->new_node) {
0.000000,0,0.000000,$self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
0.000000,0,0.000000,}
0.000002,1,0.000002,$self->remove_nodes(-1);
0.000000,0,0.000000,
0.000001,1,0.000001,if ($event_types->[-1] eq 'STR') {
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000001,1,0.000001,my $last = pop @{ $event_types };
0.000001,1,0.000001,if ($last ne 'DOC' and $last ne 'DOC_END') {
0.000000,0,0.000000,$self->exception("Unexpected event type $last");
0.000000,0,0.000000,}
0.000002,1,0.000002,pop @{ $self->offset };
0.000003,1,0.000003,$self->callback->($self, 'document_end_event', {
0.000000,0,0.000000,name => 'document_end_event',
0.000000,0,0.000000,implicit => $implicit,
0.000000,0,0.000000,});
0.000003,1,0.000003,if ($self->yaml_version eq '1.2') {
0.000000,0,0.000000,# In YAML 1.2, directives are only for the following
0.000000,0,0.000000,# document. In YAML 1.1, they are global
0.000000,0,0.000000,$self->set_tagmap({ '!!' => "tag:yaml.org,2002:" });
0.000000,0,0.000000,}
0.000001,1,0.000001,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000004,1,0.000004,$self->set_rule('STREAM');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_stream {
0.000001,1,0.000001,my ($self) = @_;
0.000002,1,0.000002,my $last = pop @{ $self->events };
0.000000,1,0.000000,$self->exception("Unexpected event type $last") unless $last eq 'STR';
0.000001,1,0.000001,pop @{ $self->offset };
0.000008,1,0.000008,$self->callback->($self, 'stream_end_event', {
0.000000,0,0.000000,name => 'stream_end_event',
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetch_inline_properties {
0.000000,0,0.000000,my ($self, $stack, $info) = @_;
0.000000,0,0.000000,my $properties = $stack->[-1];
0.000000,0,0.000000,
0.000000,0,0.000000,$properties = $properties->[1];
0.000000,0,0.000000,my $property_offset;
0.000000,0,0.000000,if ($properties) {
0.000000,0,0.000000,for my $p (@{ $properties->{inline} }) {
0.000000,0,0.000000,my $type = $p->{type};
0.000000,0,0.000000,if (exists $info->{ $type }) {
0.000000,0,0.000000,$self->exception("A node can only have one $type");
0.000000,0,0.000000,}
0.000000,0,0.000000,$info->{ $type } = $p->{value};
0.000000,0,0.000000,unless (defined $property_offset) {
0.000000,0,0.000000,$property_offset = $p->{offset};
0.000000,0,0.000000,$info->{offset} = $p->{offset};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,delete $properties->{inline};
0.000000,0,0.000000,undef $properties unless $properties->{newline};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless ($properties) {
0.000000,0,0.000000,pop @$stack;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub node_properties {
0.000000,0,0.000000,my ($self, $properties, $info) = @_;
0.000000,0,0.000000,if ($properties) {
0.000000,0,0.000000,for my $p (@{ $properties->{newline} }) {
0.000000,0,0.000000,my $type = $p->{type};
0.000000,0,0.000000,if (exists $info->{ $type }) {
0.000000,0,0.000000,$self->exception("A node can only have one $type");
0.000000,0,0.000000,}
0.000000,0,0.000000,$info->{ $type } = $p->{value};
0.000000,0,0.000000,}
0.000000,0,0.000000,undef $properties;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub scalar_event {
0.004391,20941,0.000000,my ($self, $info) = @_;
0.017811,20941,0.000001,my $event_types = $self->events;
0.015523,20941,0.000001,my $event_stack = $self->event_stack;
0.004472,20941,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,my $properties = pop @$event_stack;
0.000000,0,0.000000,$properties = $self->node_properties($properties->[1], $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.008922,20941,0.000000,$info->{name} = 'scalar_event';
0.033063,20941,0.000002,$self->callback->($self, 'scalar_event', $info);
0.019102,20941,0.000001,$self->set_new_node(0);
0.056849,20941,0.000003,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub alias_event {
0.000000,0,0.000000,my ($self, $info) = @_;
0.000000,0,0.000000,my $event_stack = $self->event_stack;
0.000000,0,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->exception("Parse error: Alias not allowed in this context");
0.000000,0,0.000000,}
0.000000,0,0.000000,my $event_types = $self->events;
0.000000,0,0.000000,$info->{name} = 'alias_event';
0.000000,0,0.000000,$self->callback->($self, 'alias_event', $info);
0.000000,0,0.000000,$self->set_new_node(0);
0.000000,0,0.000000,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub yaml_to_tokens {
0.000000,0,0.000000,my ($class, $type, $input) = @_;
0.000000,0,0.000000,my $yp = YAML::PP::Parser->new( receiver => sub {} );
0.000000,0,0.000000,my @docs = eval {
0.000000,0,0.000000,$type eq 'string' ? $yp->parse_string($input) : $yp->parse_file($input);
0.000000,0,0.000000,};
0.000000,0,0.000000,my $error = $@;
0.000000,0,0.000000,
0.000000,0,0.000000,my $tokens = $yp->tokens;
0.000000,0,0.000000,if ($error) {
0.000000,0,0.000000,my $remaining_tokens = $yp->_remaining_tokens;
0.000000,0,0.000000,push @$tokens, map { +{ %$_, name => 'ERROR' } } @$remaining_tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $error, $tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _remaining_tokens {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my @tokens;
0.000000,0,0.000000,my $next = $self->lexer->next_tokens;
0.000000,0,0.000000,push @tokens, @$next;
0.000000,0,0.000000,my $next_line = $self->lexer->next_line;
0.000000,0,0.000000,my $remaining = '';
0.000000,0,0.000000,if ($next_line) {
0.000000,0,0.000000,if ($self->lexer->offset > 0) {
0.000000,0,0.000000,$remaining = $next_line->[1] . $next_line->[2];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$remaining = join '', @$next_line;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$remaining .= $self->reader->read;
0.000000,0,0.000000,$remaining = '' unless defined $remaining;
0.000000,0,0.000000,push @tokens, { name => "ERROR", value => $remaining };
0.000000,0,0.000000,return \@tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# deprecated
0.000000,0,0.000000,sub event_to_test_suite {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self, $event) = @_; # uncoverable statement
0.000000,0,0.000000,if (ref $event eq 'ARRAY') { # uncoverable statement
0.000000,0,0.000000,return YAML::PP::Common::event_to_test_suite($event->[1]); # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,return YAML::PP::Common::event_to_test_suite($event); # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_events {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self) = @_; # uncoverable statement
0.000000,0,0.000000,$self->note("EVENTS: (" # uncoverable statement
0.000000,0,0.000000,. join (' | ', @{ $_[0]->events }) . ')' # uncoverable statement
0.000000,0,0.000000,);
0.000000,0,0.000000,$self->debug_offset; # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_offset {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self) = @_; # uncoverable statement
0.000000,0,0.000000,$self->note(
0.000000,0,0.000000,qq{OFFSET: (}
0.000000,0,0.000000,# uncoverable statement count:1
0.000000,0,0.000000,# uncoverable statement count:2
0.000000,0,0.000000,# uncoverable statement count:3
0.000000,0,0.000000,. join (' | ', map { defined $_ ? sprintf "%-3d", $_ : '?' } @{ $_[0]->offset })
0.000000,0,0.000000,# uncoverable statement
0.000000,0,0.000000,. qq/) level=@{[ $_[0]->level ]}]}/
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_yaml {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self) = @_; # uncoverable statement
0.000000,0,0.000000,my $line = $self->lexer->line; # uncoverable statement
0.000000,0,0.000000,$self->note("LINE NUMBER: $line"); # uncoverable statement
0.000000,0,0.000000,my $next_tokens = $self->lexer->next_tokens; # uncoverable statement
0.000000,0,0.000000,if (@$next_tokens) { # uncoverable statement
0.000000,0,0.000000,$self->debug_tokens($next_tokens); # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_next_line {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my $next_line = $self->lexer->next_line || [];
0.000000,0,0.000000,my $line = $next_line->[0];
0.000000,0,0.000000,$line = '' unless defined $line;
0.000000,0,0.000000,$line =~ s/( +)$/'·' x length $1/e;
0.000000,0,0.000000,$line =~ s/\t/▸/g;
0.000000,0,0.000000,$self->note("NEXT LINE: >>$line<<");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub note {
0.000000,0,0.000000,my ($self, $msg) = @_;
0.000000,0,0.000000,$self->_colorize_warn(["yellow"], "============ $msg");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub info {
0.000000,0,0.000000,my ($self, $msg) = @_;
0.000000,0,0.000000,$self->_colorize_warn(["cyan"], "============ $msg");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub got {
0.000000,0,0.000000,my ($self, $msg) = @_;
0.000000,0,0.000000,$self->_colorize_warn(["green"], "============ $msg");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _colorize_warn {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self, $colors, $text) = @_; # uncoverable statement
0.000000,0,0.000000,require Term::ANSIColor; # uncoverable statement
0.000000,0,0.000000,warn Term::ANSIColor::colored($colors, $text), "\n"; # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_event {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self, $event) = @_; # uncoverable statement
0.000000,0,0.000000,my $str = YAML::PP::Common::event_to_test_suite($event); # uncoverable statement
0.000000,0,0.000000,require Term::ANSIColor; # uncoverable statement
0.000000,0,0.000000,warn Term::ANSIColor::colored(["magenta"], "============ $str"), "\n"; # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_rules {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self, $rules) = @_; # uncoverable statement
0.000000,0,0.000000,local $Data::Dumper::Maxdepth = 2; # uncoverable statement
0.000000,0,0.000000,$self->note("RULES:"); # uncoverable statement
0.000000,0,0.000000,for my $rule ($rules) { # uncoverable statement
0.000000,0,0.000000,if (ref $rule eq 'ARRAY') { # uncoverable statement
0.000000,0,0.000000,my $first = $rule->[0]; # uncoverable statement
0.000000,0,0.000000,if (ref $first eq 'SCALAR') { # uncoverable statement
0.000000,0,0.000000,$self->info("-> $$first"); # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,else { # uncoverable statement
0.000000,0,0.000000,if (ref $first eq 'ARRAY') { # uncoverable statement
0.000000,0,0.000000,$first = $first->[0]; # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->info("TYPE $first"); # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else { # uncoverable statement
0.000000,0,0.000000,eval { # uncoverable statement
0.000000,0,0.000000,my @keys = sort keys %$rule; # uncoverable statement
0.000000,0,0.000000,$self->info("@keys"); # uncoverable statement
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_tokens {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self, $tokens) = @_; # uncoverable statement
0.000000,0,0.000000,$tokens ||= $self->tokens; # uncoverable statement
0.000000,0,0.000000,require Term::ANSIColor; # uncoverable statement
0.000000,0,0.000000,for my $token (@$tokens) { # uncoverable statement
0.000000,0,0.000000,my $type = Term::ANSIColor::colored(["green"], # uncoverable statement
0.000000,0,0.000000,sprintf "%-22s L %2d C %2d ", # uncoverable statement
0.000000,0,0.000000,$token->{name}, $token->{line}, $token->{column} + 1 # uncoverable statement
0.000000,0,0.000000,);
0.000000,0,0.000000,local $Data::Dumper::Useqq = 1; # uncoverable statement
0.000000,0,0.000000,local $Data::Dumper::Terse = 1; # uncoverable statement
0.000000,0,0.000000,require Data::Dumper; # uncoverable statement
0.000000,0,0.000000,my $str = Data::Dumper->Dump([$token->{value}], ['str']); # uncoverable statement
0.000000,0,0.000000,chomp $str; # uncoverable statement
0.000000,0,0.000000,$str =~ s/(^.|.$)/Term::ANSIColor::colored(['blue'], $1)/ge; # uncoverable statement
0.000000,0,0.000000,warn "$type$str\n"; # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub highlight_yaml {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,require YAML::PP::Highlight;
0.000000,0,0.000000,my $tokens = $self->tokens;
0.000000,0,0.000000,my $highlighted = YAML::PP::Highlight->ansicolored($tokens);
0.000000,0,0.000000,warn $highlighted;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub exception {
0.000000,0,0.000000,my ($self, $msg, %args) = @_;
0.000000,0,0.000000,my $next = $self->lexer->next_tokens;
0.000000,0,0.000000,my $line = @$next ? $next->[0]->{line} : $self->lexer->line;
0.000000,0,0.000000,my $offset = @$next ? $next->[0]->{column} : $self->lexer->offset;
0.000000,0,0.000000,$offset++;
0.000000,0,0.000000,my $next_line = $self->lexer->next_line;
0.000000,0,0.000000,my $remaining = '';
0.000000,0,0.000000,if ($next_line) {
0.000000,0,0.000000,if ($self->lexer->offset > 0) {
0.000000,0,0.000000,$remaining = $next_line->[1] . $next_line->[2];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$remaining = join '', @$next_line;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my $caller = $args{caller} || [ caller(0) ];
0.000000,0,0.000000,my $e = YAML::PP::Exception->new(
0.000000,0,0.000000,got => $args{got},
0.000000,0,0.000000,expected => $args{expected},
0.000000,0,0.000000,line => $line,
0.000000,0,0.000000,column => $offset,
0.000000,0,0.000000,msg => $msg,
0.000000,0,0.000000,next => $next,
0.000000,0,0.000000,where => $caller->[1] . ' line ' . $caller->[2],
0.000000,0,0.000000,yaml => $remaining,
0.000000,0,0.000000,);
0.000000,0,0.000000,croak $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub expected {
0.000000,0,0.000000,my ($self, %args) = @_;
0.000000,0,0.000000,my $expected = $args{expected};
0.000000,0,0.000000,@$expected = sort grep { m/^[A-Z_]+$/ } @$expected;
0.000000,0,0.000000,my $got = $args{got}->{name};
0.000000,0,0.000000,my @caller = caller(0);
0.000000,0,0.000000,$self->exception("Expected (@$expected), but got $got",
0.000000,0,0.000000,caller => \@caller,
0.000000,0,0.000000,expected => $expected,
0.000000,0,0.000000,got => $args{got},
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_tag {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,if (! @$stack or $stack->[-1]->[0] ne 'properties') {
0.000000,0,0.000000,push @$stack, [ properties => {} ];
0.000000,0,0.000000,}
0.000000,0,0.000000,my $last = $stack->[-1]->[1];
0.000000,0,0.000000,my $tag = $self->_read_tag($token->{value}, $self->tagmap);
0.000000,0,0.000000,$last->{inline} ||= [];
0.000000,0,0.000000,push @{ $last->{inline} }, {
0.000000,0,0.000000,type => 'tag',
0.000000,0,0.000000,value => $tag,
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _read_tag {
0.000000,0,0.000000,my ($self, $tag, $map) = @_;
0.000000,0,0.000000,if ($tag eq '!') {
0.000000,0,0.000000,return "!";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($tag =~ m/^!<(.*)>/) {
0.000000,0,0.000000,return $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($tag =~ m/^(![^!]*!|!)(.+)/) {
0.000000,0,0.000000,my $alias = $1;
0.000000,0,0.000000,my $name = $2;
0.000000,0,0.000000,$name =~ s/%([0-9a-fA-F]{2})/chr hex $1/eg;
0.000000,0,0.000000,if (exists $map->{ $alias }) {
0.000000,0,0.000000,$tag = $map->{ $alias }. $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($alias ne '!' and $alias ne '!!') {
0.000000,0,0.000000,die "Found undefined tag handle '$alias'";
0.000000,0,0.000000,}
0.000000,0,0.000000,$tag = "!$name";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die "Invalid tag";
0.000000,0,0.000000,}
0.000000,0,0.000000,return $tag;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_anchor {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $anchor = $token->{value};
0.000000,0,0.000000,$anchor = substr($anchor, 1);
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,if (! @$stack or $stack->[-1]->[0] ne 'properties') {
0.000000,0,0.000000,push @$stack, [ properties => {} ];
0.000000,0,0.000000,}
0.000000,0,0.000000,my $last = $stack->[-1]->[1];
0.000000,0,0.000000,$last->{inline} ||= [];
0.000000,0,0.000000,push @{ $last->{inline} }, {
0.000000,0,0.000000,type => 'anchor',
0.000000,0,0.000000,value => $anchor,
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_property_eol {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $last = $stack->[-1]->[1];
0.000000,0,0.000000,my $inline = delete $last->{inline} or return;
0.000000,0,0.000000,my $newline = $last->{newline} ||= [];
0.000000,0,0.000000,push @$newline, @$inline;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_mapkey {
0.001960,6675,0.000000,my ($self, $token) = @_;
0.006702,6675,0.000001,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.012602,6675,0.000002,};
0.002163,6675,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.017506,6675,0.000003,push @{ $stack }, [ scalar => $info ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_mapkey {
0.001401,6690,0.000000,my ($self, $res) = @_;
0.006139,6690,0.000001,my $last = pop @{ $self->event_stack };
0.006488,6690,0.000001,$self->scalar_event($last->[1]);
0.020655,6690,0.000003,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_scalar {
0.002160,7497,0.000000,my ($self, $res) = @_;
0.007889,7497,0.000001,my $last = pop @{ $self->event_stack };
0.001664,7497,0.000000,return unless $last;
0.008651,7497,0.000001,$self->scalar_event($last->[1]);
0.007304,7497,0.000001,my $e = $self->events;
0.025588,7497,0.000003,if ($e->[-1] eq 'IMAP') {
0.000000,0,0.000000,$self->end_flow_mapping;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_mapkey {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => '',
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_flow_alias {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $alias = substr($token->{value}, 1);
0.000000,0,0.000000,$self->alias_event({ value => $alias });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_alias {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $alias = substr($token->{value}, 1);
0.000000,0,0.000000,$self->alias_event({ value => $alias });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_alias_key {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $alias = substr($token->{value}, 1);
0.000000,0,0.000000,$self->alias_event({ value => $alias });
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_alias_from_stack {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $last = pop @{ $self->event_stack };
0.000000,0,0.000000,$self->alias_event($last->[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_alias {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $alias = substr($token->{value}, 1);
0.000000,0,0.000000,push @{ $self->event_stack }, [ alias => {
0.000000,0,0.000000,value => $alias,
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,}];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_question {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_flow_question {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,$self->set_new_node(2);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_complexvalue {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,$self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_questionstart {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->start_mapping($token->{column});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_complexcolon {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_seqstart {
0.000128,308,0.000000,my ($self, $token) = @_;
0.000175,308,0.000001,my $column = $token->{column};
0.000555,308,0.000002,$self->start_sequence($column);
0.000744,308,0.000002,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_seqitem {
0.000105,302,0.000000,my ($self, $res) = @_;
0.000932,302,0.000003,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_take_quoted {
0.000824,2056,0.000000,my ($self, $token) = @_;
0.000843,2056,0.000000,my $subtokens = $token->{subtokens};
0.002131,2056,0.000001,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => $subtokens->[0]->{value} eq '"'
0.000000,0,0.000000,? YAML_DOUBLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,: YAML_SINGLE_QUOTED_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.005000,2056,0.000002,};
0.000874,2056,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.004990,2056,0.000002,push @{ $stack }, [ scalar => $info ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_quoted_multiline {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $subtokens = $token->{subtokens};
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => $subtokens->[0]->{value} eq '"'
0.000000,0,0.000000,? YAML_DOUBLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,: YAML_SINGLE_QUOTED_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,push @{ $stack }, [ scalar => $info ];
0.000000,0,0.000000,$self->cb_send_scalar;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_take_quoted_key {
0.000007,15,0.000000,my ($self, $token) = @_;
0.000020,15,0.000001,$self->cb_take_quoted($token);
0.000055,15,0.000004,$self->cb_send_mapkey;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_plain_multi {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,push @{ $stack }, [ scalar => $info ];
0.000000,0,0.000000,$self->cb_send_scalar;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_start_plain {
0.002771,12180,0.000000,my ($self, $token) = @_;
0.011255,12180,0.000001,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.020345,12180,0.000002,};
0.003200,12180,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.023696,12180,0.000002,push @{ $stack }, [ scalar => $info ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_start_flowseq {
0.000127,337,0.000000,my ($self, $token) = @_;
0.001191,337,0.000004,$self->start_flow_sequence($token->{column});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_start_flowmap {
0.000109,214,0.000001,my ($self, $token) = @_;
0.000810,214,0.000004,$self->start_flow_mapping($token->{column});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_flowseq {
0.000107,337,0.000000,my ($self, $res) = @_;
0.000420,337,0.000001,$self->cb_send_scalar;
0.000646,337,0.000002,$self->end_flow_sequence;
0.000892,337,0.000003,$self->set_new_node(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_flow_comma {
0.000227,689,0.000000,my ($self) = @_;
0.000647,689,0.000001,my $event_types = $self->events;
0.000511,689,0.000001,$self->set_new_node(0);
0.002721,689,0.000004,if ($event_types->[-1] =~ m/^FLOWSEQ/) {
0.000669,689,0.000001,$self->cb_send_scalar;
0.000378,689,0.000001,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_flow_colon {
0.000019,29,0.000001,my ($self) = @_;
0.000064,29,0.000002,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_flow_mapkey {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => '',
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_flowmap {
0.000093,214,0.000000,my ($self, $res) = @_;
0.000415,214,0.000002,$self->end_flow_mapping;
0.000582,214,0.000003,$self->set_new_node(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_flowmap_empty {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,$self->cb_empty_flowmap_value;
0.000000,0,0.000000,$self->end_flow_mapping;
0.000000,0,0.000000,$self->set_new_node(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_flowkey_plain {
0.000015,29,0.000001,my ($self, $token) = @_;
0.000040,29,0.000001,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.000091,29,0.000003,};
0.000031,29,0.000001,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000190,29,0.000007,$self->scalar_event($info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_flowkey_quoted {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $subtokens = $token->{subtokens};
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => $subtokens->[0]->{value} eq '"'
0.000000,0,0.000000,? YAML_DOUBLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,: YAML_SINGLE_QUOTED_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_flowmap_key_value {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->cb_empty_flow_mapkey($token);
0.000000,0,0.000000,$self->cb_empty_flowmap_value;
0.000000,0,0.000000,$self->cb_flow_comma;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_empty_flowmap_key_value {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->cb_empty_flow_mapkey($token);
0.000000,0,0.000000,$self->cb_empty_flowmap_value;
0.000000,0,0.000000,$self->cb_flow_comma;
0.000000,0,0.000000,$self->cb_end_flowmap;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_flowmap_value {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => '',
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_flowseq_comma {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->cb_empty_flowmap_value($token);
0.000000,0,0.000000,$self->cb_flow_comma;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_flowseq_end {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->cb_empty_flowmap_value($token);
0.000000,0,0.000000,$self->cb_end_flowseq;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_insert_map_alias {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $scalar = pop @$stack;
0.000000,0,0.000000,my $info = $scalar->[1];
0.000000,0,0.000000,$self->start_mapping($info->{offset});
0.000000,0,0.000000,$self->alias_event($info);
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_insert_map {
0.001912,6725,0.000000,my ($self, $res) = @_;
0.005297,6725,0.000001,my $stack = $self->event_stack;
0.002909,6725,0.000000,my $scalar = pop @$stack;
0.001927,6725,0.000000,my $info = $scalar->[1];
0.010465,6725,0.000002,$self->start_mapping($info->{offset});
0.007304,6725,0.000001,$self->scalar_event($info);
0.024449,6725,0.000004,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_insert_implicit_flowseq_map {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $scalar = pop @$stack;
0.000000,0,0.000000,my $info = $scalar->[1];
0.000000,0,0.000000,$self->start_flow_mapping($info->{offset}, 1);
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_insert_empty_implicit_flowseq_map {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $scalar = pop @$stack;
0.000000,0,0.000000,my $info = $scalar->[1];
0.000000,0,0.000000,$self->start_flow_mapping($info->{offset}, 1);
0.000000,0,0.000000,$self->cb_empty_flowmap_value;
0.000000,0,0.000000,$self->set_new_node(2);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_insert_empty_map {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => '',
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->start_mapping($info->{offset});
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_block_scalar {
0.000000,1,0.000000,my ($self, $token) = @_;
0.000000,1,0.000000,my $type = $token->{subtokens}->[0]->{value};
0.000001,1,0.000001,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => $type eq '|'
0.000000,0,0.000000,? YAML_LITERAL_SCALAR_STYLE
0.000000,0,0.000000,: YAML_FOLDED_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.000003,1,0.000003,};
0.000000,1,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000002,1,0.000002,push @{ $self->event_stack }, [ scalar => $info ];
0.000007,1,0.000007,$self->cb_send_scalar;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_document {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->end_document(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_document_empty {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->end_document(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_doc_start_implicit {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->start_document(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_doc_start_explicit {
0.000000,1,0.000000,my ($self, $token) = @_;
0.000004,1,0.000004,$self->start_document(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_doc_start_document {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->end_document(1);
0.000000,0,0.000000,$self->start_document(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_tag_directive {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my ($name, $tag_alias, $tag_url) = split ' ', $token->{value};
0.000000,0,0.000000,$self->tagmap->{ $tag_alias } = $tag_url;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_reserved_directive {
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_set_yaml_version_directive {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,if ($self->yaml_version_directive) {
0.000000,0,0.000000,croak "Found duplicate YAML directive";
0.000000,0,0.000000,}
0.000000,0,0.000000,my ($version) = $token->{value} =~ m/^%YAML[ \t]+(1\.[12])/;
0.000000,0,0.000000,$self->set_yaml_version($version || '1.2');
0.000000,0,0.000000,$self->set_yaml_version_directive(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000010,1,0.000010,1;
