# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000024,2,0.000012,use strict;
0.000037,2,0.000018,use warnings;
0.000000,0,0.000000,package Class::Method::Modifiers; # git description: v2.12-17-gbc38636
0.000000,0,0.000000,# ABSTRACT: Provides Moose-like method modifiers
0.000000,0,0.000000,# KEYWORDS: method wrap modification patch
0.000000,0,0.000000,# vim: set ts=8 sts=4 sw=4 tw=115 et :
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '2.13';
0.000000,0,0.000000,
0.000071,2,0.000036,use base 'Exporter';
0.000000,0,0.000000,
0.000001,1,0.000001,our @EXPORT = qw(before after around);
0.000000,1,0.000000,our @EXPORT_OK = (@EXPORT, qw(fresh install_modifier));
0.000002,1,0.000002,our %EXPORT_TAGS = (
0.000000,0,0.000000,moose => [qw(before after around)],
0.000000,0,0.000000,all   => \@EXPORT_OK,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000002,1,0.000002,*_HAS_READONLY = $] >= 5.008 ? sub(){1} : sub(){0};
0.000107,1,0.000107,}
0.000000,0,0.000000,
0.000000,0,0.000000,our %MODIFIER_CACHE;
0.000000,0,0.000000,
0.000000,0,0.000000,# for backward compatibility
0.000000,0,0.000000,sub _install_modifier; # -w
0.000001,1,0.000001,*_install_modifier = \&install_modifier;
0.000000,0,0.000000,
0.000000,0,0.000000,sub install_modifier {
0.000007,18,0.000000,my $into  = shift;
0.000009,18,0.000000,my $type  = shift;
0.000005,18,0.000000,my $code  = pop;
0.000011,18,0.000001,my @names = @_;
0.000000,0,0.000000,
0.000023,18,0.000001,@names = @{ $names[0] } if ref($names[0]) eq 'ARRAY';
0.000000,0,0.000000,
0.000010,18,0.000001,return _fresh($into, $code, @names) if $type eq 'fresh';
0.000000,0,0.000000,
0.000064,18,0.000004,for my $name (@names) {
0.000144,34,0.000004,my $hit = $into->can($name) or do {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::confess("The method '$name' is not found in the inheritance hierarchy for class $into");
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000023,34,0.000001,my $qualified = $into.'::'.$name;
0.000115,34,0.000003,my $cache = $MODIFIER_CACHE{$into}{$name} ||= {
0.000000,0,0.000000,before => [],
0.000000,0,0.000000,after  => [],
0.000000,0,0.000000,around => [],
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,# this must be the first modifier we're installing
0.000032,34,0.000001,if (!exists($cache->{"orig"})) {
0.000146,2,0.000073,no strict 'refs';
0.000000,0,0.000000,
0.000000,0,0.000000,# grab the original method (or undef if the method is inherited)
0.000063,34,0.000002,$cache->{"orig"} = *{$qualified}{CODE};
0.000000,0,0.000000,
0.000000,0,0.000000,# the "innermost" method, the one that "around" will ultimately wrap
0.000016,34,0.000000,$cache->{"wrapped"} = $cache->{"orig"} || $hit; #sub {
0.000000,0,0.000000,#    # we can't cache this, because new methods or modifiers may be
0.000000,0,0.000000,#    # added between now and when this method is called
0.000000,0,0.000000,#    for my $package (@{ mro::get_linear_isa($into) }) {
0.000000,0,0.000000,#        next if $package eq $into;
0.000000,0,0.000000,#        my $code = *{$package.'::'.$name}{CODE};
0.000000,0,0.000000,#        goto $code if $code;
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#    require Carp;
0.000000,0,0.000000,#    Carp::confess("$qualified\::$name disappeared?");
0.000000,0,0.000000,#};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# keep these lists in the order the modifiers are called
0.000053,34,0.000002,if ($type eq 'after') {
0.000000,0,0.000000,push @{ $cache->{$type} }, $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000034,34,0.000001,unshift @{ $cache->{$type} }, $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# wrap the method with another layer of around. much simpler than
0.000000,0,0.000000,# the Moose equivalent. :)
0.000013,34,0.000000,if ($type eq 'around') {
0.000004,11,0.000000,my $method = $cache->{wrapped};
0.000027,11,0.000002,my $attrs = _sub_attrs($code);
0.000000,0,0.000000,# a bare "sub :lvalue {...}" will be parsed as a label and an
0.000000,0,0.000000,# indirect method call. force it to be treated as an expression
0.000000,0,0.000000,# using +
0.234726,11,0.021339,$cache->{wrapped} = eval "package $into; +sub $attrs { \$code->(\$method, \@_); };";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# install our new method which dispatches the modifiers, but only
0.000000,0,0.000000,# if a new type was added
0.000051,34,0.000001,if (@{ $cache->{$type} } == 1) {
0.000000,0,0.000000,
0.000000,0,0.000000,# avoid these hash lookups every method invocation
0.000021,34,0.000001,my $before  = $cache->{"before"};
0.000009,34,0.000000,my $after   = $cache->{"after"};
0.000000,0,0.000000,
0.000000,0,0.000000,# this is a coderef that changes every new "around". so we need
0.000000,0,0.000000,# to take a reference to it. better a deref than a hash lookup
0.000020,34,0.000001,my $wrapped = \$cache->{"wrapped"};
0.000000,0,0.000000,
0.000083,34,0.000002,my $attrs = _sub_attrs($cache->{wrapped});
0.000000,0,0.000000,
0.000015,34,0.000000,my $generated = "package $into;\n";
0.000015,34,0.000000,$generated .= "sub $name $attrs {";
0.000000,0,0.000000,
0.000000,0,0.000000,# before is easy, it doesn't affect the return value(s)
0.000013,34,0.000000,if (@$before) {
0.000000,0,0.000000,$generated .= '
0.000000,0,0.000000,for my $method (@$before) {
0.000000,0,0.000000,$method->(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000012,34,0.000000,if (@$after) {
0.000000,0,0.000000,$generated .= '
0.000000,0,0.000000,my $ret;
0.000000,0,0.000000,if (wantarray) {
0.000000,0,0.000000,$ret = [$$wrapped->(@_)];
0.000000,0,0.000000,'.(_HAS_READONLY ? 'Internals::SvREADONLY(@$ret, 1);' : '').'
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (defined wantarray) {
0.000000,0,0.000000,$ret = \($$wrapped->(@_));
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$$wrapped->(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for my $method (@$after) {
0.000000,0,0.000000,$method->(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,wantarray ? @$ret : $ret ? $$ret : ();
0.000000,0,0.000000,'
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000008,34,0.000000,$generated .= '$$wrapped->(@_);';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,34,0.000000,$generated .= '}';
0.000000,0,0.000000,
0.000018,2,0.000009,no strict 'refs';
0.000013,2,0.000007,no warnings 'redefine';
0.000197,2,0.000098,no warnings 'closure';
0.227719,34,0.006698,eval $generated;
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub before {
0.000000,0,0.000000,_install_modifier(scalar(caller), 'before', @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub after {
0.000000,0,0.000000,_install_modifier(scalar(caller), 'after', @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub around {
0.000011,2,0.000005,_install_modifier(scalar(caller), 'around', @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fresh {
0.000000,0,0.000000,my $code = pop;
0.000000,0,0.000000,my @names = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,@names = @{ $names[0] } if ref($names[0]) eq 'ARRAY';
0.000000,0,0.000000,
0.000000,0,0.000000,_fresh(scalar(caller), $code, @names);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fresh {
0.000000,0,0.000000,my ($into, $code, @names) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $name (@names) {
0.000000,0,0.000000,if ($name !~ /\A [a-zA-Z_] [a-zA-Z0-9_]* \z/xms) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::confess("Invalid method name '$name'");
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($into->can($name)) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::confess("Class $into already has a method named '$name'");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# We need to make sure that the installed method has its CvNAME in
0.000000,0,0.000000,# the appropriate package; otherwise, it would be subject to
0.000000,0,0.000000,# deletion if callers use namespace::autoclean.  If $code was
0.000000,0,0.000000,# compiled in the target package, we can just install it directly;
0.000000,0,0.000000,# otherwise, we'll need a different approach.  Using Sub::Name would
0.000000,0,0.000000,# be fine in all cases, at the cost of introducing a dependency on
0.000000,0,0.000000,# an XS-using, non-core module.  So instead we'll use string-eval to
0.000000,0,0.000000,# create a new subroutine that wraps $code.
0.000000,0,0.000000,if (_is_in_package($code, $into)) {
0.000024,2,0.000012,no strict 'refs';
0.000000,0,0.000000,*{"$into\::$name"} = $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000137,2,0.000068,no warnings 'closure'; # for 5.8.x
0.000000,0,0.000000,my $attrs = _sub_attrs($code);
0.000000,0,0.000000,eval "package $into; sub $name $attrs { \$code->(\@_) }";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _sub_attrs {
0.000016,45,0.000000,my ($coderef) = @_;
0.000037,45,0.000001,local *_sub = $coderef;
0.000008,45,0.000000,local $@;
0.000000,0,0.000000,# this assignment will fail to compile if it isn't an lvalue sub.  we
0.000000,0,0.000000,# never want to actually call the sub though, so we return early.
0.001767,45,0.000039,(eval 'return 1; &_sub = 1') ? ':lvalue' : '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _is_in_package {
0.000000,0,0.000000,my ($coderef, $package) = @_;
0.000000,0,0.000000,require B;
0.000000,0,0.000000,my $cv = B::svref_2object($coderef);
0.000000,0,0.000000,return $cv->GV->STASH->NAME eq $package;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
