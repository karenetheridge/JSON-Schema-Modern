# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package attributes;
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = 0.34;
0.000000,0,0.000000,
0.000002,1,0.000002,@EXPORT_OK = qw(get reftype);
0.000000,1,0.000000,@EXPORT = ();
0.000003,1,0.000003,%EXPORT_TAGS = (ALL => [@EXPORT, @EXPORT_OK]);
0.000000,0,0.000000,
0.000688,2,0.000344,use strict;
0.000000,0,0.000000,
0.000000,0,0.000000,sub croak {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,goto &Carp::croak;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub carp {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,goto &Carp::carp;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Hash of SV type (CODE, SCALAR, etc.) to regex matching deprecated
0.000000,0,0.000000,# attributes for that type.
0.000001,1,0.000001,my %deprecated;
0.000000,0,0.000000,
0.000002,1,0.000002,my %msg = (
0.000000,0,0.000000,lvalue => 'lvalue attribute applied to already-defined subroutine',
0.000000,0,0.000000,-lvalue => 'lvalue attribute removed from already-defined subroutine',
0.000000,0,0.000000,const  => 'Useless use of attribute "const"',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub _modify_attrs_and_deprecate {
0.000001,1,0.000001,my $svtype = shift;
0.000000,0,0.000000,# After we've removed a deprecated attribute from the XS code, we need to
0.000000,0,0.000000,# remove it here, else it ends up in @badattrs. (If we do the deprecation in
0.000000,0,0.000000,# XS, we can't control the warning based on *our* caller's lexical settings,
0.000000,0,0.000000,# and the warned line is in this package)
0.000000,0,0.000000,grep {
0.000008,1,0.000008,$deprecated{$svtype} && /$deprecated{$svtype}/ ? do {
0.000000,0,0.000000,require warnings;
0.000000,0,0.000000,warnings::warnif('deprecated', "Attribute \"$1\" is deprecated, " .
0.000000,0,0.000000,"and will disappear in Perl 5.28");
0.000000,0,0.000000,0;
0.000000,0,0.000000,} : $svtype eq 'CODE' && exists $msg{$_} ? do {
0.000000,0,0.000000,require warnings;
0.000000,0,0.000000,warnings::warnif(
0.000000,0,0.000000,'misc',
0.000000,0,0.000000,$msg{$_}
0.000000,0,0.000000,);
0.000000,0,0.000000,0;
0.000000,0,0.000000,} : 1
0.000000,0,0.000000,} _modify_attrs(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000001,1,0.000001,@_ > 2 && ref $_[2] or do {
0.000000,0,0.000000,require Exporter;
0.000000,0,0.000000,goto &Exporter::import;
0.000000,0,0.000000,};
0.000002,1,0.000002,my (undef,$home_stash,$svref,@attrs) = @_;
0.000000,0,0.000000,
0.000010,1,0.000010,my $svtype = uc reftype($svref);
0.000000,1,0.000000,my $pkgmeth;
0.000011,1,0.000011,$pkgmeth = UNIVERSAL::can($home_stash, "MODIFY_${svtype}_ATTRIBUTES")
0.000000,0,0.000000,if defined $home_stash && $home_stash ne '';
0.000000,1,0.000000,my @badattrs;
0.000000,1,0.000000,if ($pkgmeth) {
0.000000,0,0.000000,my @pkgattrs = _modify_attrs_and_deprecate($svtype, $svref, @attrs);
0.000000,0,0.000000,@badattrs = $pkgmeth->($home_stash, $svref, @pkgattrs);
0.000000,0,0.000000,if (!@badattrs && @pkgattrs) {
0.000000,0,0.000000,require warnings;
0.000000,0,0.000000,return unless warnings::enabled('reserved');
0.000000,0,0.000000,@pkgattrs = grep { m/\A[[:lower:]]+(?:\z|\()/ } @pkgattrs;
0.000000,0,0.000000,if (@pkgattrs) {
0.000000,0,0.000000,for my $attr (@pkgattrs) {
0.000000,0,0.000000,$attr =~ s/\(.+\z//s;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $s = ((@pkgattrs == 1) ? '' : 's');
0.000000,0,0.000000,carp "$svtype package attribute$s " .
0.000000,0,0.000000,"may clash with future reserved word$s: " .
0.000000,0,0.000000,join(' : ' , @pkgattrs);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000002,1,0.000002,@badattrs = _modify_attrs_and_deprecate($svtype, $svref, @attrs);
0.000000,0,0.000000,}
0.000003,1,0.000003,if (@badattrs) {
0.000000,0,0.000000,croak "Invalid $svtype attribute" .
0.000000,0,0.000000,(( @badattrs == 1 ) ? '' : 's') .
0.000000,0,0.000000,": " .
0.000000,0,0.000000,join(' : ', @badattrs);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get ($) {
0.000000,0,0.000000,@_ == 1  && ref $_[0] or
0.000000,0,0.000000,croak 'Usage: '.__PACKAGE__.'::get $ref';
0.000000,0,0.000000,my $svref = shift;
0.000000,0,0.000000,my $svtype = uc reftype($svref);
0.000000,0,0.000000,my $stash = _guess_stash($svref);
0.000000,0,0.000000,$stash = caller unless defined $stash;
0.000000,0,0.000000,my $pkgmeth;
0.000000,0,0.000000,$pkgmeth = UNIVERSAL::can($stash, "FETCH_${svtype}_ATTRIBUTES")
0.000000,0,0.000000,if defined $stash && $stash ne '';
0.000000,0,0.000000,return $pkgmeth ?
0.000000,0,0.000000,(_fetch_attrs($svref), $pkgmeth->($stash, $svref)) :
0.000000,0,0.000000,(_fetch_attrs($svref))
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub require_version { goto &UNIVERSAL::VERSION }
0.000000,0,0.000000,
0.000001,1,0.000001,require XSLoader;
0.000746,1,0.000746,XSLoader::load();
0.000000,0,0.000000,
0.000013,1,0.000013,1;
0.000000,0,0.000000,__END__
