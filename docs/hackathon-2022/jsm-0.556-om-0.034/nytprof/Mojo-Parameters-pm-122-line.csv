# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Mojo::Parameters;
0.000150,2,0.000075,use Mojo::Base -base;
1.076823,632183,0.000002,use overload '@{}' => sub { shift->pairs }, bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
0.000000,0,0.000000,
0.002004,2,0.001002,use Mojo::Util qw(decode encode url_escape url_unescape);
0.000000,0,0.000000,
0.000002,1,0.000002,has charset => 'UTF-8';
0.000000,0,0.000000,
0.000000,0,0.000000,sub append {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $old = $self->pairs;
0.000000,0,0.000000,my @new = @_ == 1 ? @{shift->pairs} : @_;
0.000000,0,0.000000,while (my ($name, $value) = splice @new, 0, 2) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Multiple values
0.000000,0,0.000000,if (ref $value eq 'ARRAY') { push @$old, $name => $_ // '' for @$value }
0.000000,0,0.000000,
0.000000,0,0.000000,# Single value
0.000000,0,0.000000,elsif (defined $value) { push @$old, $name => $value }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone {
0.049393,335145,0.000000,my $self = shift;
0.000000,0,0.000000,
0.260245,335145,0.000001,my $clone = $self->new;
0.281298,335145,0.000001,if   (exists $self->{charset}) { $clone->{charset} = $self->{charset} }
0.149130,335145,0.000000,if   (defined $self->{string}) { $clone->{string}  = $self->{string} }
0.431712,335145,0.000001,else                           { $clone->{pairs}   = [@{$self->pairs}] }
0.000000,0,0.000000,
0.427133,335145,0.000001,return $clone;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub every_param {
0.000000,0,0.000000,my ($self, $name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @values;
0.000000,0,0.000000,my $pairs = $self->pairs;
0.000000,0,0.000000,for (my $i = 0; $i < @$pairs; $i += 2) {
0.000000,0,0.000000,push @values, $pairs->[$i + 1] if $pairs->[$i] eq $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return \@values;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub merge {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $merge = @_ == 1 ? shift->to_hash : {@_};
0.000000,0,0.000000,for my $name (sort keys %$merge) {
0.000000,0,0.000000,my $value = $merge->{$name};
0.000000,0,0.000000,defined $value ? $self->param($name => $value) : $self->remove($name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub names { [sort keys %{shift->to_hash}] }
0.000000,0,0.000000,
0.754422,381772,0.000002,sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
0.000000,0,0.000000,
0.000000,0,0.000000,sub pairs {
0.094549,662947,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Replace parameters
0.083640,662947,0.000000,if (@_) {
0.000000,0,0.000000,$self->{pairs} = shift;
0.000000,0,0.000000,delete $self->{string};
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Parse string
0.204523,662947,0.000000,if (defined(my $str = delete $self->{string})) {
0.000000,0,0.000000,my $pairs = $self->{pairs} = [];
0.000000,0,0.000000,return $pairs unless length $str;
0.000000,0,0.000000,
0.000000,0,0.000000,my $charset = $self->charset;
0.000000,0,0.000000,for my $pair (split /&/, $str) {
0.000000,0,0.000000,next unless $pair =~ /^([^=]+)(?:=(.*))?$/;
0.000000,0,0.000000,my ($name, $value) = ($1, $2 // '');
0.000000,0,0.000000,
0.000000,0,0.000000,# Replace "+" with whitespace, unescape and decode
0.000000,0,0.000000,s/\+/ /g for $name, $value;
0.000000,0,0.000000,$name  = url_unescape $name;
0.000000,0,0.000000,$name  = decode($charset, $name) // $name if $charset;
0.000000,0,0.000000,$value = url_unescape $value;
0.000000,0,0.000000,$value = decode($charset, $value) // $value if $charset;
0.000000,0,0.000000,
0.000000,0,0.000000,push @$pairs, $name, $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.942662,662947,0.000001,return $self->{pairs} //= [];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub param {
0.000000,0,0.000000,my ($self, $name) = (shift, shift);
0.000000,0,0.000000,return $self->every_param($name)->[-1] unless @_;
0.000000,0,0.000000,$self->remove($name);
0.000000,0,0.000000,return $self->append($name => ref $_[0] eq 'ARRAY' ? $_[0] : [@_]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Pairs
0.000000,0,0.000000,return $self->append(@_) if @_ > 1;
0.000000,0,0.000000,
0.000000,0,0.000000,# String
0.000000,0,0.000000,$self->{string} = shift;
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove {
0.000000,0,0.000000,my ($self, $name) = @_;
0.000000,0,0.000000,my $pairs = $self->pairs;
0.000000,0,0.000000,my $i     = 0;
0.000000,0,0.000000,$pairs->[$i] eq $name ? splice @$pairs, $i, 2 : ($i += 2) while $i < @$pairs;
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub to_hash {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my %hash;
0.000000,0,0.000000,my $pairs = $self->pairs;
0.000000,0,0.000000,for (my $i = 0; $i < @$pairs; $i += 2) {
0.000000,0,0.000000,my ($name, $value) = @{$pairs}[$i, $i + 1];
0.000000,0,0.000000,
0.000000,0,0.000000,# Array
0.000000,0,0.000000,if (exists $hash{$name}) {
0.000000,0,0.000000,$hash{$name} = [$hash{$name}] if ref $hash{$name} ne 'ARRAY';
0.000000,0,0.000000,push @{$hash{$name}}, $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# String
0.000000,0,0.000000,else { $hash{$name} = $value }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return \%hash;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub to_string {
0.050227,327802,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# String (RFC 3986)
0.315474,327802,0.000001,my $charset = $self->charset;
0.116622,327802,0.000000,if (defined(my $str = $self->{string})) {
0.000000,0,0.000000,$str = encode $charset, $str if $charset;
0.000000,0,0.000000,return url_escape $str, '^A-Za-z0-9\-._~%!$&\'()*+,;=:@/?';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Build pairs (HTML Living Standard)
0.246460,327802,0.000001,my $pairs = $self->pairs;
0.569007,327802,0.000002,return '' unless @$pairs;
0.000000,0,0.000000,my @pairs;
0.000000,0,0.000000,for (my $i = 0; $i < @$pairs; $i += 2) {
0.000000,0,0.000000,my ($name, $value) = @{$pairs}[$i, $i + 1];
0.000000,0,0.000000,
0.000000,0,0.000000,# Escape and replace whitespace with "+"
0.000000,0,0.000000,$name  = encode $charset,   $name if $charset;
0.000000,0,0.000000,$name  = url_escape $name,  '^*\-.0-9A-Z_a-z';
0.000000,0,0.000000,$value = encode $charset,   $value if $charset;
0.000000,0,0.000000,$value = url_escape $value, '^*\-.0-9A-Z_a-z';
0.000000,0,0.000000,s/\%20/\+/g for $name, $value;
0.000000,0,0.000000,
0.000000,0,0.000000,push @pairs, "$name=$value";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return join '&', @pairs;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,1;
0.000000,0,0.000000,
0.000000,0,0.000000,=encoding utf8
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,Mojo::Parameters - Parameters
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use Mojo::Parameters;
0.000000,0,0.000000,
0.000000,0,0.000000,# Parse
0.000000,0,0.000000,my $params = Mojo::Parameters->new('foo=bar&baz=23');
0.000000,0,0.000000,say $params->param('baz');
0.000000,0,0.000000,
0.000000,0,0.000000,# Build
0.000000,0,0.000000,my $params = Mojo::Parameters->new(foo => 'bar', baz => 23);
0.000000,0,0.000000,push @$params, i => 'â™¥ mojolicious';
0.000000,0,0.000000,say "$params";
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,L<Mojo::Parameters> is a container for form parameters used by L<Mojo::URL>, based on L<RFC
0.000000,0,0.000000,3986|https://tools.ietf.org/html/rfc3986> and the L<HTML Living Standard|https://html.spec.whatwg.org>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 ATTRIBUTES
0.000000,0,0.000000,
0.000000,0,0.000000,L<Mojo::Parameters> implements the following attributes.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 charset
0.000000,0,0.000000,
0.000000,0,0.000000,my $charset = $params->charset;
0.000000,0,0.000000,$params     = $params->charset('UTF-8');
0.000000,0,0.000000,
0.000000,0,0.000000,Charset used for encoding and decoding parameters, defaults to C<UTF-8>.
0.000000,0,0.000000,
0.000000,0,0.000000,# Disable encoding and decoding
0.000000,0,0.000000,$params->charset(undef);
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 METHODS
0.000000,0,0.000000,
0.000000,0,0.000000,L<Mojo::Parameters> inherits all methods from L<Mojo::Base> and implements the following new ones.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 append
0.000000,0,0.000000,
0.000000,0,0.000000,$params = $params->append(foo => 'ba&r');
0.000000,0,0.000000,$params = $params->append(foo => ['ba&r', 'baz']);
0.000000,0,0.000000,$params = $params->append(foo => ['bar', 'baz'], bar => 23);
0.000000,0,0.000000,$params = $params->append(Mojo::Parameters->new);
0.000000,0,0.000000,
0.000000,0,0.000000,Append parameters. Note that this method will normalize the parameters.
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo=bar&foo=baz"
0.000000,0,0.000000,Mojo::Parameters->new('foo=bar')->append(Mojo::Parameters->new('foo=baz'));
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo=bar&foo=baz"
0.000000,0,0.000000,Mojo::Parameters->new('foo=bar')->append(foo => 'baz');
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo=bar&foo=baz&foo=yada"
0.000000,0,0.000000,Mojo::Parameters->new('foo=bar')->append(foo => ['baz', 'yada']);
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo=bar&foo=baz&foo=yada&bar=23"
0.000000,0,0.000000,Mojo::Parameters->new('foo=bar')->append(foo => ['baz', 'yada'], bar => 23);
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 clone
0.000000,0,0.000000,
0.000000,0,0.000000,my $params2 = $params->clone;
0.000000,0,0.000000,
0.000000,0,0.000000,Return a new L<Mojo::Parameters> object cloned from these parameters.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 every_param
0.000000,0,0.000000,
0.000000,0,0.000000,my $values = $params->every_param('foo');
0.000000,0,0.000000,
0.000000,0,0.000000,Similar to L</"param">, but returns all values sharing the same name as an array reference. Note that this method will
0.000000,0,0.000000,normalize the parameters.
0.000000,0,0.000000,
0.000000,0,0.000000,# Get first value
0.000000,0,0.000000,say $params->every_param('foo')->[0];
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 merge
0.000000,0,0.000000,
0.000000,0,0.000000,$params = $params->merge(foo => 'ba&r');
0.000000,0,0.000000,$params = $params->merge(foo => ['ba&r', 'baz']);
0.000000,0,0.000000,$params = $params->merge(foo => ['bar', 'baz'], bar => 23);
0.000000,0,0.000000,$params = $params->merge(Mojo::Parameters->new);
0.000000,0,0.000000,
0.000000,0,0.000000,Merge parameters. Note that this method will normalize the parameters.
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo=baz"
0.000000,0,0.000000,Mojo::Parameters->new('foo=bar')->merge(Mojo::Parameters->new('foo=baz'));
0.000000,0,0.000000,
0.000000,0,0.000000,# "yada=yada&foo=baz"
0.000000,0,0.000000,Mojo::Parameters->new('foo=bar&yada=yada')->merge(foo => 'baz');
0.000000,0,0.000000,
0.000000,0,0.000000,# "yada=yada"
0.000000,0,0.000000,Mojo::Parameters->new('foo=bar&yada=yada')->merge(foo => undef);
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 names
0.000000,0,0.000000,
0.000000,0,0.000000,my $names = $params->names;
0.000000,0,0.000000,
0.000000,0,0.000000,Return an array reference with all parameter names.
0.000000,0,0.000000,
0.000000,0,0.000000,# Names of all parameters
0.000000,0,0.000000,say for @{$params->names};
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 new
0.000000,0,0.000000,
0.000000,0,0.000000,my $params = Mojo::Parameters->new;
0.000000,0,0.000000,my $params = Mojo::Parameters->new('foo=b%3Bar&baz=23');
0.000000,0,0.000000,my $params = Mojo::Parameters->new(foo => 'b&ar');
0.000000,0,0.000000,my $params = Mojo::Parameters->new(foo => ['ba&r', 'baz']);
0.000000,0,0.000000,my $params = Mojo::Parameters->new(foo => ['bar', 'baz'], bar => 23);
0.000000,0,0.000000,
0.000000,0,0.000000,Construct a new L<Mojo::Parameters> object and L</"parse"> parameters if necessary.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 pairs
0.000000,0,0.000000,
0.000000,0,0.000000,my $array = $params->pairs;
0.000000,0,0.000000,$params   = $params->pairs([foo => 'b&ar', baz => 23]);
0.000000,0,0.000000,
0.000000,0,0.000000,Parsed parameter pairs. Note that this method will normalize the parameters.
0.000000,0,0.000000,
0.000000,0,0.000000,# Remove all parameters
0.000000,0,0.000000,$params->pairs([]);
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 param
0.000000,0,0.000000,
0.000000,0,0.000000,my $value = $params->param('foo');
0.000000,0,0.000000,$params   = $params->param(foo => 'ba&r');
0.000000,0,0.000000,$params   = $params->param(foo => qw(ba&r baz));
0.000000,0,0.000000,$params   = $params->param(foo => ['ba;r', 'baz']);
0.000000,0,0.000000,
0.000000,0,0.000000,Access parameter values. If there are multiple values sharing the same name, and you want to access more than just the
0.000000,0,0.000000,last one, you can use L</"every_param">. Note that this method will normalize the parameters.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 parse
0.000000,0,0.000000,
0.000000,0,0.000000,$params = $params->parse('foo=b%3Bar&baz=23');
0.000000,0,0.000000,
0.000000,0,0.000000,Parse parameters.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 remove
0.000000,0,0.000000,
0.000000,0,0.000000,$params = $params->remove('foo');
0.000000,0,0.000000,
0.000000,0,0.000000,Remove parameters. Note that this method will normalize the parameters.
0.000000,0,0.000000,
0.000000,0,0.000000,# "bar=yada"
0.000000,0,0.000000,Mojo::Parameters->new('foo=bar&foo=baz&bar=yada')->remove('foo');
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 to_hash
0.000000,0,0.000000,
0.000000,0,0.000000,my $hash = $params->to_hash;
0.000000,0,0.000000,
0.000000,0,0.000000,Turn parameters into a hash reference. Note that this method will normalize the parameters.
0.000000,0,0.000000,
0.000000,0,0.000000,# "baz"
0.000000,0,0.000000,Mojo::Parameters->new('foo=bar&foo=baz')->to_hash->{foo}[1];
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 to_string
0.000000,0,0.000000,
0.000000,0,0.000000,my $str = $params->to_string;
0.000000,0,0.000000,
0.000000,0,0.000000,Turn parameters into a string.
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo=bar&baz=23"
0.000000,0,0.000000,Mojo::Parameters->new->pairs([foo => 'bar', baz => 23])->to_string;
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 OPERATORS
0.000000,0,0.000000,
0.000000,0,0.000000,L<Mojo::Parameters> overloads the following operators.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 array
0.000000,0,0.000000,
0.000000,0,0.000000,my @pairs = @$params;
0.000000,0,0.000000,
0.000000,0,0.000000,Alias for L</"pairs">. Note that this will normalize the parameters.
0.000000,0,0.000000,
0.000000,0,0.000000,say $params->[0];
0.000000,0,0.000000,say for @$params;
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 bool
0.000000,0,0.000000,
0.000000,0,0.000000,my $bool = !!$params;
0.000000,0,0.000000,
0.000000,0,0.000000,Always true.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 stringify
0.000000,0,0.000000,
0.000000,0,0.000000,my $str = "$params";
0.000000,0,0.000000,
0.000000,0,0.000000,Alias for L</"to_string">.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
