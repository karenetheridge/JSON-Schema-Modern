# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000066,2,0.000033,use strict;
0.000072,2,0.000036,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Utilities;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Internal utilities for JSON::Schema::Modern
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.556';
0.000000,0,0.000000,
0.000098,2,0.000049,use 5.020;
0.000134,3,0.000045,use strictures 2;
0.000051,2,0.000025,use experimental qw(signatures postderef);
0.000037,2,0.000018,use if "$]" >= 5.022, experimental => 're_strict';
0.000041,2,0.000021,no if "$]" >= 5.031009, feature => 'indirect';
0.000028,2,0.000014,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000022,2,0.000011,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000021,2,0.000011,use B;
0.000032,2,0.000016,use Carp 'croak';
0.000050,3,0.000017,use JSON::MaybeXS 1.004001 'is_bool';
0.000034,3,0.000011,use Ref::Util 0.100 qw(is_ref is_plain_arrayref is_plain_hashref);
0.000024,2,0.000012,use Scalar::Util 'blessed';
0.000021,2,0.000011,use Storable 'dclone';
0.000021,2,0.000010,use Feature::Compat::Try;
0.000048,2,0.000024,use JSON::Schema::Modern::Error;
0.000030,2,0.000015,use JSON::Schema::Modern::Annotation;
0.000060,2,0.000030,use namespace::clean;
0.000000,0,0.000000,
0.000072,2,0.000036,use Exporter 'import';
0.000000,0,0.000000,
0.000003,1,0.000003,our @EXPORT_OK = qw(
0.000000,0,0.000000,is_type
0.000000,0,0.000000,get_type
0.000000,0,0.000000,is_equal
0.000000,0,0.000000,is_elements_unique
0.000000,0,0.000000,jsonp
0.000000,0,0.000000,unjsonp
0.000000,0,0.000000,local_annotations
0.000000,0,0.000000,canonical_uri
0.000000,0,0.000000,E
0.000000,0,0.000000,A
0.000000,0,0.000000,abort
0.000000,0,0.000000,assert_keyword_exists
0.000000,0,0.000000,assert_keyword_type
0.000000,0,0.000000,assert_pattern
0.000000,0,0.000000,assert_uri_reference
0.000000,0,0.000000,assert_uri
0.000000,0,0.000000,annotate_self
0.000000,0,0.000000,sprintf_num
0.000000,0,0.000000,true
0.000000,0,0.000000,false
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000048,2,0.000024,use JSON::PP ();
0.003317,2,0.001659,use constant { true => JSON::PP::true, false => JSON::PP::false };
0.000000,0,0.000000,
0.050950,216930,0.000000,sub is_type ($type, $value) {
0.023745,72310,0.000000,if ($type eq 'null') {
0.000000,0,0.000000,return !(defined $value);
0.000000,0,0.000000,}
0.080339,72310,0.000001,if ($type eq 'boolean') {
0.000000,0,0.000000,return is_bool($value);
0.000000,0,0.000000,}
0.185696,55803,0.000003,if ($type eq 'object') {
0.000000,0,0.000000,return is_plain_hashref($value);
0.000000,0,0.000000,}
0.013759,8565,0.000002,if ($type eq 'array') {
0.000000,0,0.000000,return is_plain_arrayref($value);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001419,3748,0.000000,if ($type eq 'string' or $type eq 'number' or $type eq 'integer') {
0.000696,3748,0.000000,return 0 if not defined $value;
0.021899,3748,0.000006,my $flags = B::svref_2object(\$value)->FLAGS;
0.000000,0,0.000000,
0.010031,3748,0.000003,if ($type eq 'string') {
0.000000,0,0.000000,return !is_ref($value) && $flags & B::SVf_POK && !($flags & (B::SVf_IOK | B::SVf_NOK));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000080,196,0.000000,if ($type eq 'number') {
0.000547,109,0.000005,return ref($value) =~ /^Math::Big(?:Int|Float)$/
0.000000,0,0.000000,|| !($flags & B::SVf_POK) && ($flags & (B::SVf_IOK | B::SVf_NOK));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000033,87,0.000000,if ($type eq 'integer') {
0.000458,87,0.000005,return ref($value) =~ /^Math::Big(?:Int|Float)$/ && $value->is_int
0.000000,0,0.000000,|| !($flags & B::SVf_POK) && ($flags & (B::SVf_IOK | B::SVf_NOK)) && int($value) == $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($type =~ /^reference to (.+)$/) {
0.000000,0,0.000000,return !blessed($value) && ref($value) eq $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ref($value) eq $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.048636,323998,0.000000,sub get_type ($value) {
0.291104,161999,0.000002,return 'object' if is_plain_hashref($value);
0.047470,41632,0.000001,return 'boolean' if is_bool($value);
0.005725,36846,0.000000,return 'null' if not defined $value;
0.007476,36846,0.000000,return 'array' if is_plain_arrayref($value);
0.000000,0,0.000000,
0.004338,35741,0.000000,return ref($value) =~ /^Math::Big(?:Int|Float)$/ ? ($value->is_int ? 'integer' : 'number')
0.000000,0,0.000000,: (blessed($value) ? '' : 'reference to ').ref($value)
0.000000,0,0.000000,if is_ref($value);
0.000000,0,0.000000,
0.140429,35741,0.000004,my $flags = B::svref_2object(\$value)->FLAGS;
0.062051,35741,0.000002,return 'string' if $flags & B::SVf_POK && !($flags & (B::SVf_IOK | B::SVf_NOK));
0.000384,107,0.000004,return int($value) == $value ? 'integer' : 'number'
0.000000,0,0.000000,if !($flags & B::SVf_POK) && ($flags & (B::SVf_IOK | B::SVf_NOK));
0.000000,0,0.000000,
0.000000,0,0.000000,croak sprintf('ambiguous type for %s',
0.000000,0,0.000000,JSON::MaybeXS->new(allow_nonref => 1, canonical => 1, utf8 => 0, allow_bignum => 1, convert_blessed => 1)->encode($value));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# compares two arbitrary data payloads for equality, as per
0.000000,0,0.000000,# https://json-schema.org/draft/2020-12/json-schema-core.html#rfc.section.4.2.2
0.000000,0,0.000000,# if provided with a state hashref with a 'path' key, any differences are recorded within
0.012133,63784,0.000000,sub is_equal ($x, $y, $state = undef) {
0.005853,15946,0.000000,$state->{path} //= '';
0.000000,0,0.000000,
0.025340,15946,0.000002,my @types = map get_type($_), $x, $y;
0.000000,0,0.000000,
0.004244,15946,0.000000,if ($state->{scalarref_booleans}) {
0.001028,7244,0.000000,($x, $types[0]) = (0+!!$$x, 'boolean') if $types[0] eq 'reference to SCALAR';
0.000823,7244,0.000000,($y, $types[1]) = (0+!!$$y, 'boolean') if $types[1] eq 'reference to SCALAR';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.003487,15946,0.000000,return 0 if $types[0] ne $types[1];
0.001974,15484,0.000000,return 1 if $types[0] eq 'null';
0.026401,15484,0.000002,return $x eq $y if $types[0] eq 'string';
0.001162,173,0.000007,return $x == $y if grep $types[0] eq $_, qw(boolean number integer);
0.000000,0,0.000000,
0.000000,0,0.000000,my $path = $state->{path};
0.000000,0,0.000000,if ($types[0] eq 'object') {
0.000000,0,0.000000,return 0 if keys %$x != keys %$y;
0.000000,0,0.000000,return 0 if not is_equal([ sort keys %$x ], [ sort keys %$y ]);
0.000000,0,0.000000,foreach my $property (sort keys %$x) {
0.000000,0,0.000000,$state->{path} = jsonp($path, $property);
0.000000,0,0.000000,return 0 if not is_equal($x->{$property}, $y->{$property}, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($types[0] eq 'array') {
0.000000,0,0.000000,return 0 if @$x != @$y;
0.000000,0,0.000000,foreach my $idx (0 .. $x->$#*) {
0.000000,0,0.000000,$state->{path} = $path.'/'.$idx;
0.000000,0,0.000000,return 0 if not is_equal($x->[$idx], $y->[$idx], $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 0; # should never get here
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# checks array elements for uniqueness. short-circuits on first pair of matching elements
0.000000,0,0.000000,# if second arrayref is provided, it is populated with the indices of identical items
0.000460,1920,0.000000,sub is_elements_unique ($array, $equal_indices = undef) {
0.001189,640,0.000002,foreach my $idx0 (0 .. $array->$#*-1) {
0.001619,1141,0.000001,foreach my $idx1 ($idx0+1 .. $array->$#*) {
0.011076,7244,0.000002,if (is_equal($array->[$idx0], $array->[$idx1], { scalarref_booleans => 1 })) {
0.000000,0,0.000000,push @$equal_indices, $idx0, $idx1 if defined $equal_indices;
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.001739,640,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# shorthand for creating and appending json pointers
0.000000,0,0.000000,# the first argument is a a json pointer; remaining arguments are path segments to be encoded and
0.000000,0,0.000000,# appended
0.000000,0,0.000000,sub jsonp {
1.585517,221215,0.000007,return join('/', shift, map s/~/~0/gr =~ s!/!~1!gr, map +(is_plain_arrayref($_) ? @$_ : $_), grep defined, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# splits a json pointer apart into its path segments
0.000000,0,0.000000,sub unjsonp ($path) {
0.000000,0,0.000000,return map s!~0!~!gr =~ s!~1!/!gr, split m!/!, $path;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# get all annotations produced for the current instance data location (that are visible to this
0.000000,0,0.000000,# schema location)
0.001562,7494,0.000000,sub local_annotations ($state) {
0.260823,3747,0.000070,grep $_->instance_location eq $state->{data_path}, $state->{annotations}->@*;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# shorthand for finding the canonical uri of the present schema location
0.000000,0,0.000000,# last argument can be an arrayref, usually coming from $state->{_schema_path_suffix}
0.120578,505032,0.000000,sub canonical_uri ($state, @extra_path) {
0.157160,168344,0.000001,return $state->{initial_schema_uri} if not length($state->{schema_path}) and not @extra_path;
0.046902,126625,0.000000,splice(@extra_path, -1, 1, $extra_path[-1]->@*) if @extra_path and is_plain_arrayref($extra_path[-1]);
0.188637,126625,0.000001,my $uri = $state->{initial_schema_uri}->clone;
0.309788,126625,0.000002,my $fragment = ($uri->fragment//'').(@extra_path ? jsonp($state->{schema_path}, @extra_path) : $state->{schema_path});
0.030518,126625,0.000000,undef $fragment if not length($fragment);
0.077807,126625,0.000001,$uri->fragment($fragment);
0.237117,126625,0.000002,$uri;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# shorthand for creating error objects
0.000000,0,0.000000,# uses these keys from $state:
0.000000,0,0.000000,# - initial_schema_uri
0.000000,0,0.000000,# - keyword
0.000000,0,0.000000,# - data_path
0.000000,0,0.000000,# - traversed_schema_path
0.000000,0,0.000000,# - schema_path
0.000000,0,0.000000,# - _schema_path_suffix
0.000000,0,0.000000,# - errors
0.004845,16868,0.000000,sub E ($state, $error_string, @args) {
0.001510,4217,0.000000,croak 'E called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,# sometimes the keyword shouldn't be at the very end of the schema path
0.000000,0,0.000000,my $uri = canonical_uri($state, $state->{keyword}, $state->{_schema_path_suffix})
0.024601,4217,0.000006,->to_abs($state->{effective_base_uri});
0.000000,0,0.000000,
0.000000,0,0.000000,my $keyword_location = $state->{traversed_schema_path}
0.008103,4217,0.000002,.jsonp($state->{schema_path}, $state->{keyword}, delete $state->{_schema_path_suffix});
0.000000,0,0.000000,
0.014571,4217,0.000003,undef $uri if $uri eq '' and $keyword_location eq ''
0.000000,0,0.000000,or ($uri->fragment // '') eq $keyword_location and $uri->clone->fragment(undef) eq '';
0.000000,0,0.000000,
0.000000,0,0.000000,push $state->{errors}->@*, JSON::Schema::Modern::Error->new(
0.000000,0,0.000000,keyword => $state->{keyword},
0.000000,0,0.000000,instance_location => $state->{data_path},
0.000000,0,0.000000,keyword_location => $keyword_location,
0.000000,0,0.000000,defined $uri ? ( absolute_keyword_location => $uri ) : (),
0.000000,0,0.000000,error => @args ? sprintf($error_string, @args) : $error_string,
0.028748,4217,0.000007,$state->{exception} ? ( exception => $state->{exception} ) : (),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.013669,4217,0.000003,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# shorthand for creating annotations
0.000000,0,0.000000,# uses these keys from $state:
0.000000,0,0.000000,# - initial_schema_uri
0.000000,0,0.000000,# - keyword
0.000000,0,0.000000,# - data_path
0.000000,0,0.000000,# - traversed_schema_path
0.000000,0,0.000000,# - schema_path
0.000000,0,0.000000,# - _schema_path_suffix
0.000000,0,0.000000,# - annotations
0.000000,0,0.000000,# - collect_annotations
0.043869,215376,0.000000,sub A ($state, $annotation) {
0.052733,71792,0.000001,return 1 if not $state->{collect_annotations} or $state->{spec_version} eq 'draft7';
0.000000,0,0.000000,
0.000000,0,0.000000,my $uri = canonical_uri($state, $state->{keyword}, $state->{_schema_path_suffix})
0.365905,71790,0.000005,->to_abs($state->{effective_base_uri});
0.000000,0,0.000000,
0.000000,0,0.000000,my $keyword_location = $state->{traversed_schema_path}
0.145687,71790,0.000002,.jsonp($state->{schema_path}, $state->{keyword}, delete $state->{_schema_path_suffix});
0.000000,0,0.000000,
0.221979,71790,0.000003,undef $uri if $uri eq '' and $keyword_location eq ''
0.000000,0,0.000000,or ($uri->fragment // '') eq $keyword_location and $uri->clone->fragment(undef) eq '';
0.000000,0,0.000000,
0.000000,0,0.000000,push $state->{annotations}->@*, JSON::Schema::Modern::Annotation->new(
0.000000,0,0.000000,keyword => $state->{keyword},
0.000000,0,0.000000,instance_location => $state->{data_path},
0.000000,0,0.000000,keyword_location => $keyword_location,
0.000000,0,0.000000,defined $uri ? ( absolute_keyword_location => $uri ) : (),
0.000000,0,0.000000,annotation => $annotation,
0.253675,71790,0.000004,$state->{_unknown} ? ( unknown => 1 ) : (),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.224158,71790,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# creates an error object, but also aborts evaluation immediately
0.000000,0,0.000000,# only this error is returned, because other errors on the stack might not actually be "real"
0.000000,0,0.000000,# errors (consider if we were in the middle of evaluating a "not" or "if").
0.000000,0,0.000000,# Therefore this is only appropriate during the evaluation phase, not the traverse phase.
0.000000,0,0.000000,sub abort ($state, $error_string, @args) {
0.000000,0,0.000000,()= E({ %$state, exception => 1 }, $error_string, @args);
0.000000,0,0.000000,croak 'abort() called during traverse' if $state->{traverse};
0.000000,0,0.000000,die pop $state->{errors}->@*;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,3,0.000000,sub assert_keyword_exists ($state, $schema) {
0.000000,1,0.000000,croak 'assert_keyword_exists called in void context' if not defined wantarray;
0.000001,1,0.000001,return E($state, '%s keyword is required', $state->{keyword}) if not exists $schema->{$state->{keyword}};
0.000003,1,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002162,14360,0.000000,sub assert_keyword_type ($state, $schema, $type) {
0.000860,3590,0.000000,croak 'assert_keyword_type called in void context' if not defined wantarray;
0.002832,3590,0.000001,my $value = $schema->{$state->{keyword}};
0.000747,3590,0.000000,my $thing = 'value';
0.000000,0,0.000000,($value, $thing) = is_plain_hashref($value) ? ($value->{$state->{_schema_path_suffix}}, 'value at "'.$state->{_schema_path_suffix}.'"')
0.000000,0,0.000000,: is_plain_arrayref($value) ? ($value->[$state->{_schema_path_suffix}], 'item '.$state->{_schema_path_suffix})
0.000000,0,0.000000,: die 'unknown type'
0.000816,3590,0.000000,if exists $state->{_schema_path_suffix};
0.011733,3590,0.000003,return 1 if is_type($type, $value);
0.000000,0,0.000000,E($state, '%s %s is not a%s %s', $state->{keyword}, $thing, ($type =~ /^[aeiou]/ ? 'n' : ''), $type);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000051,225,0.000000,sub assert_pattern ($state, $pattern) {
0.000024,75,0.000000,croak 'assert_pattern called in void context' if not defined wantarray;
0.000079,75,0.000001,try {
0.000418,75,0.000006,local $SIG{__WARN__} = sub { die @_ };
0.002963,75,0.000040,qr/$pattern/;
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) { return E($state, $e); };
0.000141,75,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# this is only suitable for checking URIs within schemas themselves
0.000394,2238,0.000000,sub assert_uri_reference ($state, $schema) {
0.000274,746,0.000000,croak 'assert_uri_reference called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000489,746,0.000001,my $string = $schema->{$state->{keyword}};
0.000000,0,0.000000,return E($state, '%s value is not a valid URI reference', $state->{keyword})
0.000000,0,0.000000,# see also uri-reference format sub
0.015417,746,0.000021,if fc(Mojo::URL->new($string)->to_unsafe_string) ne fc($string)
0.000000,0,0.000000,or $string =~ /[^[:ascii:]]/
0.000000,0,0.000000,or $string =~ /#/
0.000000,0,0.000000,and $string !~ m{#$}                          # empty fragment
0.000000,0,0.000000,and $string !~ m{#[A-Za-z][A-Za-z0-9_:.-]*$}  # plain-name fragment
0.000000,0,0.000000,and $string !~ m{#/(?:[^~]|~[01])*$};         # json pointer fragment
0.000000,0,0.000000,
0.001872,746,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# this is only suitable for checking URIs within schemas themselves
0.000046,184,0.000000,sub assert_uri ($state, $schema, $override = undef) {
0.000014,46,0.000000,croak 'assert_uri called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000023,46,0.000001,my $string = $override // $schema->{$state->{keyword}};
0.000093,46,0.000002,my $uri = Mojo::URL->new($string);
0.000000,0,0.000000,
0.000341,46,0.000007,return E($state, '"%s" is not a valid URI', $string)
0.000000,0,0.000000,# see also uri format sub
0.000000,0,0.000000,if fc($uri->to_unsafe_string) ne fc($string)
0.000000,0,0.000000,or $string =~ /[^[:ascii:]]/
0.000000,0,0.000000,or not $uri->is_abs
0.000000,0,0.000000,or $string =~ /#/
0.000000,0,0.000000,and $string !~ m{#$}                          # empty fragment
0.000000,0,0.000000,and $string !~ m{#[A-Za-z][A-Za-z0-9_:.-]*$}  # plain-name fragment
0.000000,0,0.000000,and $string !~ m{#/(?:[^~]|~[01])*$};         # json pointer fragment
0.000000,0,0.000000,
0.000198,46,0.000004,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# produces an annotation whose value is the same as that of the current keyword
0.016386,96642,0.000000,sub annotate_self ($state, $schema) {
0.000000,0,0.000000,A($state, is_ref($schema->{$state->{keyword}}) ? dclone($schema->{$state->{keyword}})
0.186353,32214,0.000006,: $schema->{$state->{keyword}});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sprintf_num ($value) {
0.000000,0,0.000000,# use original value as stored in the NV, without losing precision
0.000000,0,0.000000,ref($value) =~ /^Math::Big(?:Int|Float)$/ ? $value->bstr : sprintf('%s', $value);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,1;
0.000000,0,0.000000,
0.000054,1,0.000054,__END__
