# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000034,2,0.000017,use strict;
0.000039,2,0.000019,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Vocabulary::Applicator;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Implementation of the JSON Schema Applicator vocabulary
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.556';
0.000000,0,0.000000,
0.000027,2,0.000013,use 5.020;
0.000022,2,0.000011,use Moo;
0.000095,3,0.000032,use strictures 2;
0.000069,2,0.000034,use experimental qw(signatures postderef);
0.000056,2,0.000028,use if "$]" >= 5.022, experimental => 're_strict';
0.000041,2,0.000020,no if "$]" >= 5.031009, feature => 'indirect';
0.000077,2,0.000039,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000052,2,0.000026,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000076,3,0.000025,use List::Util 1.45 qw(any uniqstr);
0.000052,3,0.000017,use Ref::Util 0.100 'is_plain_arrayref';
0.000731,2,0.000365,use Sub::Install;
0.000029,2,0.000015,use JSON::Schema::Modern::Utilities qw(is_type jsonp E A assert_keyword_type assert_pattern true is_elements_unique);
0.000429,2,0.000215,use JSON::Schema::Modern::Vocabulary::Unevaluated;
0.003699,2,0.001849,use namespace::clean;
0.000000,0,0.000000,
0.000002,1,0.000002,with 'JSON::Schema::Modern::Vocabulary';
0.000000,0,0.000000,
0.000000,0,0.000000,sub vocabulary {
0.000003,1,0.000003,'https://json-schema.org/draft/2019-09/vocab/applicator' => 'draft2019-09',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/vocab/applicator' => 'draft2020-12';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,4,0.000002,sub evaluation_order { 1 }
0.000000,0,0.000000,
0.000000,0,0.000000,# the keyword order is arbitrary, except:
0.000000,0,0.000000,# - if must be evaluated before then, else
0.000000,0,0.000000,# - items must be evaluated before additionalItems
0.000000,0,0.000000,# - in-place applicators (allOf, anyOf, oneOf, not, if/then/else, dependentSchemas) and items,
0.000000,0,0.000000,#   additionalItems must be evaluated before unevaluatedItems (in the Unevaluated vocabulary)
0.000000,0,0.000000,# - properties and patternProperties must be evaluated before additionalProperties
0.000000,0,0.000000,# - in-place applicators and properties, patternProperties, additionalProperties must be evaluated
0.000000,0,0.000000,#   before unevaluatedProperties (in the Unevaluated vocabulary)
0.000000,0,0.000000,# - contains must be evaluated before maxContains, minContains (in the Validator vocabulary)
0.000001,6,0.000000,sub keywords ($self, $spec_version) {
0.000000,0,0.000000,return (
0.000068,2,0.000034,qw(allOf anyOf oneOf not if then else),
0.000000,0,0.000000,$spec_version eq 'draft7' ? 'dependencies' : 'dependentSchemas',
0.000000,0,0.000000,$spec_version !~ qr/^draft(7|2019-09)$/ ? 'prefixItems' : (),
0.000000,0,0.000000,'items',
0.000000,0,0.000000,$spec_version =~ qr/^draft(7|2019-09)$/ ? 'additionalItems' : (),
0.000000,0,0.000000,qw(contains properties patternProperties additionalProperties propertyNames),
0.000000,0,0.000000,$spec_version eq 'draft2019-09' ? qw(unevaluatedItems unevaluatedProperties) : (),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# in draft2019-09, the unevaluated keywords were part of the Applicator vocabulary
0.000000,1,0.000000,foreach my $phase (qw(traverse eval)) {
0.000002,2,0.000001,foreach my $type (qw(Items Properties)) {
0.000003,4,0.000001,my $method = '_'.$phase.'_keyword_unevaluated'.$type;
0.000000,0,0.000000,Sub::Install::install_sub({
0.000000,0,0.000000,as   => $method,
0.000000,0,0.000000,code => sub {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,JSON::Schema::Modern::Vocabulary::Unevaluated->$method(@_);
0.000000,0,0.000000,}
0.000011,4,0.000003,}),
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000131,23,0.000006,sub _traverse_keyword_allOf { shift->traverse_array_schemas(@_) }
0.000000,0,0.000000,
0.007059,30010,0.000000,sub _eval_keyword_allOf ($self, $data, $schema, $state) {
0.001212,6002,0.000000,my @invalid;
0.012623,6002,0.000002,foreach my $idx (0 .. $schema->{allOf}->$#*) {
0.402387,25750,0.000016,if ($self->eval($data, $schema->{allOf}[$idx], +{ %$state,
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/allOf/'.$idx })) {
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @invalid, $idx;
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.020804,6002,0.000003,return 1 if @invalid == 0;
0.000000,0,0.000000,
0.000000,0,0.000000,my $pl = @invalid > 1;
0.000000,0,0.000000,return E($state, 'subschema%s %s %s not valid', $pl?'s':'', join(', ', @invalid), $pl?'are':'is');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000170,32,0.000005,sub _traverse_keyword_anyOf { shift->traverse_array_schemas(@_) }
0.000000,0,0.000000,
0.010763,5910,0.000002,sub _eval_keyword_anyOf ($self, $data, $schema, $state) {
0.000392,1182,0.000000,my $valid = 0;
0.000295,1182,0.000000,my @errors;
0.003328,1182,0.000003,foreach my $idx (0 .. $schema->{anyOf}->$#*) {
0.000000,0,0.000000,next if not $self->eval($data, $schema->{anyOf}[$idx],
0.032713,2365,0.000014,+{ %$state, errors => \@errors, schema_path => $state->{schema_path}.'/anyOf/'.$idx });
0.000530,1183,0.000000,++$valid;
0.001275,1183,0.000001,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.007277,1182,0.000006,return 1 if $valid;
0.000000,0,0.000000,push $state->{errors}->@*, @errors;
0.000000,0,0.000000,return E($state, 'no subschemas are valid');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000077,21,0.000004,sub _traverse_keyword_oneOf { shift->traverse_array_schemas(@_) }
0.000000,0,0.000000,
0.000331,1525,0.000000,sub _eval_keyword_oneOf ($self, $data, $schema, $state) {
0.000085,305,0.000000,my (@valid, @errors);
0.000956,305,0.000003,foreach my $idx (0 .. $schema->{oneOf}->$#*) {
0.000000,0,0.000000,next if not $self->eval($data, $schema->{oneOf}[$idx],
0.007795,610,0.000013,+{ %$state, errors => \@errors, schema_path => $state->{schema_path}.'/oneOf/'.$idx });
0.000243,305,0.000001,push @valid, $idx;
0.000271,305,0.000001,last if @valid > 1 and $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001953,305,0.000006,return 1 if @valid == 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if (not @valid) {
0.000000,0,0.000000,push $state->{errors}->@*, @errors;
0.000000,0,0.000000,return E($state, 'no subschemas are valid');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return E($state, 'multiple subschemas are valid: '.join(', ', @valid));
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000069,15,0.000005,sub _traverse_keyword_not { shift->traverse_subschema(@_) }
0.000000,0,0.000000,
0.000004,20,0.000000,sub _eval_keyword_not ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not $self->eval($data, $schema->{not},
0.000000,0,0.000000,+{ %$state, schema_path => $state->{schema_path}.'/not',
0.000000,0,0.000000,short_circuit => $state->{short_circuit} || !$state->{collect_annotations},
0.000070,4,0.000017,errors => [] });
0.000000,0,0.000000,
0.000000,0,0.000000,return E($state, 'subschema is valid');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000320,65,0.000005,sub _traverse_keyword_if { shift->traverse_subschema(@_) }
0.000253,65,0.000004,sub _traverse_keyword_then { shift->traverse_subschema(@_) }
0.000081,15,0.000005,sub _traverse_keyword_else { shift->traverse_subschema(@_) }
0.000000,0,0.000000,
0.003295,15065,0.000000,sub _eval_keyword_if ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not exists $schema->{then} and not exists $schema->{else}
0.001486,3013,0.000000,and not $state->{collect_annotations};
0.000000,0,0.000000,my $keyword = $self->eval($data, $schema->{if},
0.000000,0,0.000000,+{ %$state, schema_path => $state->{schema_path}.'/if',
0.000000,0,0.000000,short_circuit => $state->{short_circuit} || !$state->{collect_annotations},
0.049633,3013,0.000016,errors => [],
0.000000,0,0.000000,})
0.000000,0,0.000000,? 'then' : 'else';
0.000000,0,0.000000,
0.003971,3013,0.000001,return 1 if not exists $schema->{$keyword};
0.000000,0,0.000000,return 1 if $self->eval($data, $schema->{$keyword},
0.028772,2214,0.000013,+{ %$state, schema_path => $state->{schema_path}.'/'.$keyword });
0.000000,0,0.000000,return E({ %$state, keyword => $keyword }, 'subschema is not valid');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000015,3,0.000005,sub _traverse_keyword_dependentSchemas { shift->traverse_object_schemas(@_) }
0.000000,0,0.000000,
0.000292,1525,0.000000,sub _eval_keyword_dependentSchemas ($self, $data, $schema, $state) {
0.000471,305,0.000002,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.000170,305,0.000001,my $valid = 1;
0.001423,305,0.000005,foreach my $property (sort keys $schema->{dependentSchemas}->%*) {
0.000106,305,0.000000,next if not exists $data->{$property};
0.000000,0,0.000000,
0.003022,290,0.000010,if ($self->eval($data, $schema->{dependentSchemas}{$property},
0.000000,0,0.000000,+{ %$state, schema_path => jsonp($state->{schema_path}, 'dependentSchemas', $property) })) {
0.002672,290,0.000009,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000133,305,0.000000,return E($state, 'not all dependencies are satisfied') if not $valid;
0.000868,305,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_dependencies ($self, $schema, $state) {
0.000000,0,0.000000,return if not assert_keyword_type($state, $schema, 'object');
0.000000,0,0.000000,
0.000000,0,0.000000,my $valid = 1;
0.000000,0,0.000000,foreach my $property (sort keys $schema->{dependencies}->%*) {
0.000000,0,0.000000,if (is_type('array', $schema->{dependencies}{$property})) {
0.000000,0,0.000000,# as in dependentRequired
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $index (0..$schema->{dependencies}{$property}->$#*) {
0.000000,0,0.000000,$valid = E({ %$state, _schema_path_suffix => [ $property, $index ] }, 'element #%d is not a string', $index)
0.000000,0,0.000000,if not is_type('string', $schema->{dependencies}{$property}[$index]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = E({ %$state, _schema_path_suffix => $property }, 'elements are not unique')
0.000000,0,0.000000,if not is_elements_unique($schema->{dependencies}{$property});
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# as in dependentSchemas
0.000000,0,0.000000,$valid = 0 if not $self->traverse_property_schema($schema, $state, $property);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_dependencies ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,my $valid = 1;
0.000000,0,0.000000,foreach my $property (sort keys $schema->{dependencies}->%*) {
0.000000,0,0.000000,next if not exists $data->{$property};
0.000000,0,0.000000,
0.000000,0,0.000000,if (is_type('array', $schema->{dependencies}{$property})) {
0.000000,0,0.000000,# as in dependentRequired
0.000000,0,0.000000,if (my @missing = grep !exists($data->{$_}), $schema->{dependencies}{$property}->@*) {
0.000000,0,0.000000,$valid = E({ %$state, _schema_path_suffix => $property },
0.000000,0,0.000000,'missing propert%s: %s', @missing > 1 ? 'ies' : 'y', join(', ', @missing));
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# as in dependentSchemas
0.000000,0,0.000000,if ($self->eval($data, $schema->{dependencies}{$property},
0.000000,0,0.000000,+{ %$state, schema_path => jsonp($state->{schema_path}, 'dependencies', $property) })) {
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return E($state, 'not all dependencies are satisfied') if not $valid;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_prefixItems { shift->traverse_array_schemas(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_prefixItems { shift->_eval_keyword__items_array_schemas(@_) }
0.000000,0,0.000000,
0.000082,392,0.000000,sub _traverse_keyword_items ($self, $schema, $state) {
0.000085,98,0.000001,if (is_plain_arrayref($schema->{items})) {
0.000000,0,0.000000,return E($state, 'array form of "items" not supported in %s', $state->{spec_version})
0.000000,0,0.000000,if $state->{spec_version} !~ /^draft(?:7|2019-09)$/;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->traverse_array_schemas($schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000639,98,0.000007,$self->traverse_subschema($schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002699,8790,0.000000,sub _eval_keyword_items ($self, $data, $schema, $state) {
0.000000,0,0.000000,return $self->_eval_keyword__items_array_schemas($data, $schema, $state)
0.001264,1758,0.000001,if is_plain_arrayref($schema->{items});
0.000000,0,0.000000,
0.008775,1758,0.000005,return $self->_eval_keyword__items_schema($data, $schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_additionalItems { shift->traverse_subschema(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_additionalItems ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not exists $state->{_last_items_index};
0.000000,0,0.000000,return $self->_eval_keyword__items_schema($data, $schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# prefixItems (draft 2020-12), array-based items (all drafts)
0.000000,0,0.000000,sub _eval_keyword__items_array_schemas ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not is_type('array', $data);
0.000000,0,0.000000,return 1 if ($state->{_last_items_index}//-1) == $data->$#*;
0.000000,0,0.000000,
0.000000,0,0.000000,my $valid = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $idx (0 .. $data->$#*) {
0.000000,0,0.000000,last if $idx > $schema->{$state->{keyword}}->$#*;
0.000000,0,0.000000,$state->{_last_items_index} = $idx;
0.000000,0,0.000000,
0.000000,0,0.000000,if (is_type('boolean', $schema->{$state->{keyword}}[$idx])) {
0.000000,0,0.000000,next if $schema->{$state->{keyword}}[$idx];
0.000000,0,0.000000,$valid = E({ %$state, data_path => $state->{data_path}.'/'.$idx,
0.000000,0,0.000000,_schema_path_suffix => $idx }, 'item not permitted');
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->eval($data->[$idx], $schema->{$state->{keyword}}[$idx],
0.000000,0,0.000000,+{ %$state, data_path => $state->{data_path}.'/'.$idx,
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/'.$state->{keyword}.'/'.$idx })) {
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,last if $state->{short_circuit} and not exists $schema->{
0.000000,0,0.000000,$state->{keyword} eq 'prefixItems' ? 'items'
0.000000,0,0.000000,: $state->{keyword} eq 'items' ? 'additionalItems' : die
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,A($state, $state->{_last_items_index} == $data->$#* ? true : $state->{_last_items_index});
0.000000,0,0.000000,return E($state, 'not all items are valid') if not $valid;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# schema-based items (all drafts), and additionalItems (up to and including draft2019-09)
0.002202,8790,0.000000,sub _eval_keyword__items_schema ($self, $data, $schema, $state) {
0.006792,1758,0.000004,return 1 if not is_type('array', $data);
0.000800,643,0.000001,return 1 if ($state->{_last_items_index}//-1) == $data->$#*;
0.000000,0,0.000000,
0.000170,643,0.000000,my $valid = 1;
0.000000,0,0.000000,
0.002515,643,0.000004,foreach my $idx (($state->{_last_items_index}//-1)+1 .. $data->$#*) {
0.003129,1632,0.000002,if (is_type('boolean', $schema->{$state->{keyword}})) {
0.000381,189,0.000002,next if $schema->{$state->{keyword}};
0.000000,0,0.000000,$valid = E({ %$state, data_path => $state->{data_path}.'/'.$idx },
0.000000,0,0.000000,'%sitem not permitted',
0.000000,0,0.000000,exists $schema->{prefixItems} || $state->{keyword} eq 'additionalItems' ? 'additional ' : '');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.018975,1443,0.000013,if ($self->eval($data->[$idx], $schema->{$state->{keyword}},
0.000000,0,0.000000,+{ %$state, data_path => $state->{data_path}.'/'.$idx,
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/'.$state->{keyword} })) {
0.006909,1443,0.000005,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000899,643,0.000001,$state->{_last_items_index} = $data->$#*;
0.000000,0,0.000000,
0.001132,643,0.000002,A($state, true);
0.000000,0,0.000000,return E($state, 'subschema is not valid against all %sitems',
0.000231,643,0.000000,$state->{keyword} eq 'additionalItems' ? 'additional ' : '') if not $valid;
0.002486,643,0.000004,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000017,3,0.000006,sub _traverse_keyword_contains { shift->traverse_subschema(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_contains ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not is_type('array', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,$state->{_num_contains} = 0;
0.000000,0,0.000000,my (@errors, @valid);
0.000000,0,0.000000,foreach my $idx (0 .. $data->$#*) {
0.000000,0,0.000000,if ($self->eval($data->[$idx], $schema->{contains},
0.000000,0,0.000000,+{ %$state, errors => \@errors,
0.000000,0,0.000000,data_path => $state->{data_path}.'/'.$idx,
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/contains' })) {
0.000000,0,0.000000,++$state->{_num_contains};
0.000000,0,0.000000,push @valid, $idx;
0.000000,0,0.000000,
0.000000,0,0.000000,last if $state->{short_circuit}
0.000000,0,0.000000,and (not exists $schema->{maxContains} or $state->{_num_contains} > $schema->{maxContains})
0.000000,0,0.000000,and ($state->{_num_contains} >= ($schema->{minContains}//1));
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# note: no items contained is only valid when minContains is explicitly 0
0.000000,0,0.000000,if (not $state->{_num_contains}
0.000000,0,0.000000,and (($schema->{minContains}//1) > 0 or $state->{spec_version} eq 'draft7')) {
0.000000,0,0.000000,push $state->{errors}->@*, @errors;
0.000000,0,0.000000,return E($state, 'subschema is not valid against any item');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $state->{spec_version} =~ /^draft(?:7|2019-09)$/ ? 1
0.000000,0,0.000000,: A($state, @valid == @$data ? true : \@valid);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001861,387,0.000005,sub _traverse_keyword_properties { shift->traverse_object_schemas(@_) }
0.000000,0,0.000000,
0.035624,162460,0.000000,sub _eval_keyword_properties ($self, $data, $schema, $state) {
0.097584,32492,0.000003,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.008850,28612,0.000000,my $valid = 1;
0.005118,28612,0.000000,my @properties;
0.231212,28612,0.000008,foreach my $property (sort keys $schema->{properties}->%*) {
0.045657,166967,0.000000,next if not exists $data->{$property};
0.006433,11057,0.000001,push @properties, $property;
0.000000,0,0.000000,
0.017276,11057,0.000002,if (is_type('boolean', $schema->{properties}{$property})) {
0.000459,145,0.000003,next if $schema->{properties}{$property};
0.000000,0,0.000000,$valid = E({ %$state, data_path => jsonp($state->{data_path}, $property),
0.000000,0,0.000000,_schema_path_suffix => $property }, 'property not permitted');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.149432,10912,0.000014,if ($self->eval($data->{$property}, $schema->{properties}{$property},
0.000000,0,0.000000,+{ %$state, data_path => jsonp($state->{data_path}, $property),
0.000000,0,0.000000,schema_path => jsonp($state->{schema_path}, 'properties', $property) })) {
0.051943,10113,0.000005,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000482,799,0.000001,$valid = 0;
0.000000,0,0.000000,}
0.000596,799,0.000001,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.051371,28612,0.000002,A($state, \@properties);
0.012304,28612,0.000000,return E($state, 'not all properties are valid') if not $valid;
0.070982,27813,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000013,24,0.000001,sub _traverse_keyword_patternProperties ($self, $schema, $state) {
0.000013,6,0.000002,return if not assert_keyword_type($state, $schema, 'object');
0.000000,0,0.000000,
0.000001,6,0.000000,my $valid = 1;
0.000024,6,0.000004,foreach my $property (sort keys $schema->{patternProperties}->%*) {
0.000041,6,0.000007,$valid = 0 if not assert_pattern({ %$state, _schema_path_suffix => $property }, $property);
0.000026,6,0.000004,$valid = 0 if not $self->traverse_property_schema($schema, $state, $property);
0.000000,0,0.000000,}
0.000029,6,0.000005,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.004786,16845,0.000000,sub _eval_keyword_patternProperties ($self, $data, $schema, $state) {
0.007017,3369,0.000002,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.001114,3369,0.000000,my $valid = 1;
0.000698,3369,0.000000,my @properties;
0.014652,3369,0.000004,foreach my $property_pattern (sort keys $schema->{patternProperties}->%*) {
0.086418,3369,0.000026,foreach my $property (sort grep m/$property_pattern/, keys %$data) {
0.001135,1799,0.000001,push @properties, $property;
0.002649,1799,0.000001,if (is_type('boolean', $schema->{patternProperties}{$property_pattern})) {
0.002084,1061,0.000002,next if $schema->{patternProperties}{$property_pattern};
0.000000,0,0.000000,$valid = E({ %$state, data_path => jsonp($state->{data_path}, $property),
0.000000,0,0.000000,_schema_path_suffix => $property_pattern }, 'property not permitted');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.012430,738,0.000017,if ($self->eval($data->{$property}, $schema->{patternProperties}{$property_pattern},
0.000000,0,0.000000,+{ %$state, data_path => jsonp($state->{data_path}, $property),
0.000000,0,0.000000,schema_path => jsonp($state->{schema_path}, 'patternProperties', $property_pattern) })) {
0.005990,738,0.000008,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.020081,3369,0.000006,A($state, [ uniqstr @properties ]);
0.001231,3369,0.000000,return E($state, 'not all properties are valid') if not $valid;
0.009886,3369,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000772,130,0.000006,sub _traverse_keyword_additionalProperties { shift->traverse_subschema(@_) }
0.000000,0,0.000000,
0.001589,4885,0.000000,sub _eval_keyword_additionalProperties ($self, $data, $schema, $state) {
0.001789,977,0.000002,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.000255,977,0.000000,my $valid = 1;
0.000218,977,0.000000,my @properties;
0.007250,977,0.000007,foreach my $property (sort keys %$data) {
0.001423,1835,0.000001,next if exists $schema->{properties} and exists $schema->{properties}{$property};
0.000000,0,0.000000,next if exists $schema->{patternProperties}
0.000709,1835,0.000000,and any { $property =~ /$_/ } keys $schema->{patternProperties}->%*;
0.000000,0,0.000000,
0.001599,1835,0.000001,push @properties, $property;
0.003086,1835,0.000002,if (is_type('boolean', $schema->{additionalProperties})) {
0.000000,0,0.000000,next if $schema->{additionalProperties};
0.000000,0,0.000000,$valid = E({ %$state, data_path => jsonp($state->{data_path}, $property) },
0.000000,0,0.000000,'additional property not permitted');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.027112,1835,0.000015,if ($self->eval($data->{$property}, $schema->{additionalProperties},
0.000000,0,0.000000,+{ %$state, data_path => jsonp($state->{data_path}, $property),
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/additionalProperties' })) {
0.009805,1835,0.000005,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001845,977,0.000002,A($state, \@properties);
0.000361,977,0.000000,return E($state, 'not all additional properties are valid') if not $valid;
0.003483,977,0.000004,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000090,14,0.000006,sub _traverse_keyword_propertyNames { shift->traverse_subschema(@_) }
0.000000,0,0.000000,
0.000972,3135,0.000000,sub _eval_keyword_propertyNames ($self, $data, $schema, $state) {
0.001032,627,0.000002,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.000227,627,0.000000,my $valid = 1;
0.003298,627,0.000005,foreach my $property (sort keys %$data) {
0.009177,713,0.000013,if ($self->eval($property, $schema->{propertyNames},
0.000000,0,0.000000,+{ %$state, data_path => jsonp($state->{data_path}, $property),
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/propertyNames' })) {
0.002650,713,0.000004,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000222,627,0.000000,return E($state, 'not all property names are valid') if not $valid;
0.002226,627,0.000004,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,1;
0.000000,0,0.000000,
0.000040,1,0.000040,__END__
