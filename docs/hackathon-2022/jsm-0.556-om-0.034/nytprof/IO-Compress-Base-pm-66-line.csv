# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package IO::Compress::Base ;
0.000000,0,0.000000,
0.000012,1,0.000012,require 5.006 ;
0.000000,0,0.000000,
0.000069,2,0.000034,use strict ;
0.000025,2,0.000012,use warnings;
0.000000,0,0.000000,
0.000575,3,0.000192,use IO::Compress::Base::Common 2.106 ;
0.000000,0,0.000000,
0.000356,2,0.000178,use IO::File (); ;
0.000030,2,0.000015,use Scalar::Util ();
0.000000,0,0.000000,
0.000000,0,0.000000,#use File::Glob;
0.000000,0,0.000000,#require Exporter ;
0.000015,2,0.000008,use Carp() ;
0.001016,2,0.000508,use Symbol();
0.000000,0,0.000000,#use bytes;
0.000000,0,0.000000,
0.000000,0,0.000000,our (@ISA, $VERSION);
0.000012,1,0.000012,@ISA    = qw(IO::File Exporter);
0.000000,0,0.000000,
0.000001,1,0.000001,$VERSION = '2.106';
0.000000,0,0.000000,
0.000000,0,0.000000,#Can't locate object method "SWASHNEW" via package "utf8" (perhaps you forgot to load "utf8"?) at .../ext/Compress-Zlib/Gzip/blib/lib/Compress/Zlib/Common.pm line 16.
0.000000,0,0.000000,
0.000000,0,0.000000,sub saveStatus
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,${ *$self->{ErrorNo} } = shift() + 0 ;
0.000000,0,0.000000,${ *$self->{Error} } = '' ;
0.000000,0,0.000000,
0.000000,0,0.000000,return ${ *$self->{ErrorNo} } ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub saveErrorString
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,my $retval = shift ;
0.000000,0,0.000000,${ *$self->{Error} } = shift ;
0.000000,0,0.000000,${ *$self->{ErrorNo} } = shift() + 0 if @_ ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $retval;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub croakError
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,$self->saveErrorString(0, $_[0]);
0.000000,0,0.000000,Carp::croak $_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub closeError
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $retval = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $errno = *$self->{ErrorNo};
0.000000,0,0.000000,my $error = ${ *$self->{Error} };
0.000000,0,0.000000,
0.000000,0,0.000000,$self->close();
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{ErrorNo} = $errno ;
0.000000,0,0.000000,${ *$self->{Error} } = $error ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $retval;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub error
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,return ${ *$self->{Error} } ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub errorNo
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,return ${ *$self->{ErrorNo} } ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub writeAt
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $offset = shift;
0.000000,0,0.000000,my $data = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined *$self->{FH}) {
0.000000,0,0.000000,my $here = tell(*$self->{FH});
0.000000,0,0.000000,return $self->saveErrorString(undef, "Cannot seek to end of output filehandle: $!", $!)
0.000000,0,0.000000,if $here < 0 ;
0.000000,0,0.000000,seek(*$self->{FH}, $offset, IO::Handle::SEEK_SET)
0.000000,0,0.000000,or return $self->saveErrorString(undef, "Cannot seek to end of output filehandle: $!", $!) ;
0.000000,0,0.000000,defined *$self->{FH}->write($data, length $data)
0.000000,0,0.000000,or return $self->saveErrorString(undef, $!, $!) ;
0.000000,0,0.000000,seek(*$self->{FH}, $here, IO::Handle::SEEK_SET)
0.000000,0,0.000000,or return $self->saveErrorString(undef, "Cannot seek to end of output filehandle: $!", $!) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,substr(${ *$self->{Buffer} }, $offset, length($data)) = $data ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub outputPayload
0.000000,0,0.000000,{
0.000000,0,0.000000,
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,return $self->output(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub output
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $data = shift ;
0.000000,0,0.000000,my $last = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1
0.000000,0,0.000000,if length $data == 0 && ! $last ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( *$self->{FilterContainer} ) {
0.000000,0,0.000000,*_ = \$data;
0.000000,0,0.000000,&{ *$self->{FilterContainer} }();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (length $data) {
0.000000,0,0.000000,if ( defined *$self->{FH} ) {
0.000000,0,0.000000,defined *$self->{FH}->write( $data, length $data )
0.000000,0,0.000000,or return $self->saveErrorString(0, $!, $!);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,${ *$self->{Buffer} } .= $data ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getOneShotParams
0.000000,0,0.000000,{
0.000000,0,0.000000,return ( 'multistream' => [IO::Compress::Base::Common::Parse_boolean,   1],
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,our %PARAMS = (
0.000000,0,0.000000,# Generic Parameters
0.000000,0,0.000000,'autoclose' => [IO::Compress::Base::Common::Parse_boolean,   0],
0.000000,0,0.000000,'encode'    => [IO::Compress::Base::Common::Parse_any,       undef],
0.000000,0,0.000000,'strict'    => [IO::Compress::Base::Common::Parse_boolean,   1],
0.000000,0,0.000000,'append'    => [IO::Compress::Base::Common::Parse_boolean,   0],
0.000000,0,0.000000,'binmodein' => [IO::Compress::Base::Common::Parse_boolean,   0],
0.000000,0,0.000000,
0.000000,0,0.000000,'filtercontainer' => [IO::Compress::Base::Common::Parse_code,  undef],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub checkParams
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $class = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $got = shift || IO::Compress::Base::Parameters::new();
0.000000,0,0.000000,
0.000000,0,0.000000,$got->parse(
0.000000,0,0.000000,{
0.000000,0,0.000000,%PARAMS,
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,$self->getExtraParams(),
0.000000,0,0.000000,*$self->{OneShot} ? $self->getOneShotParams()
0.000000,0,0.000000,: (),
0.000000,0,0.000000,},
0.000000,0,0.000000,@_) or $self->croakError("${class}: " . $got->getError())  ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $got ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _create
0.000000,0,0.000000,{
0.000000,0,0.000000,my $obj = shift;
0.000000,0,0.000000,my $got = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,*$obj->{Closed} = 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $class = ref $obj;
0.000000,0,0.000000,$obj->croakError("$class: Missing Output parameter")
0.000000,0,0.000000,if ! @_ && ! $got ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $outValue = shift ;
0.000000,0,0.000000,my $oneShot = 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (! $got)
0.000000,0,0.000000,{
0.000000,0,0.000000,$oneShot = 0 ;
0.000000,0,0.000000,$got = $obj->checkParams($class, undef, @_)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $lax = ! $got->getValue('strict') ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $outType = IO::Compress::Base::Common::whatIsOutput($outValue);
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->ckOutputParam($class, $outValue)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($outType eq 'buffer') {
0.000000,0,0.000000,*$obj->{Buffer} = $outValue;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $buff = "" ;
0.000000,0,0.000000,*$obj->{Buffer} = \$buff ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Merge implies Append
0.000000,0,0.000000,my $merge = $got->getValue('merge') ;
0.000000,0,0.000000,my $appendOutput = $got->getValue('append') || $merge ;
0.000000,0,0.000000,*$obj->{Append} = $appendOutput;
0.000000,0,0.000000,*$obj->{FilterContainer} = $got->getValue('filtercontainer') ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($merge)
0.000000,0,0.000000,{
0.000000,0,0.000000,# Switch off Merge mode if output file/buffer is empty/doesn't exist
0.000000,0,0.000000,if (($outType eq 'buffer' && length $$outValue == 0 ) ||
0.000000,0,0.000000,($outType ne 'buffer' && (! -e $outValue || (-w _ && -z _))) )
0.000000,0,0.000000,{ $merge = 0 }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# If output is a file, check that it is writable
0.000000,0,0.000000,#no warnings;
0.000000,0,0.000000,#if ($outType eq 'filename' && -e $outValue && ! -w _)
0.000000,0,0.000000,#  { return $obj->saveErrorString(undef, "Output file '$outValue' is not writable" ) }
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->ckParams($got)
0.000000,0,0.000000,or $obj->croakError("${class}: " . $obj->error());
0.000000,0,0.000000,
0.000000,0,0.000000,if ($got->getValue('encode')) {
0.000000,0,0.000000,my $want_encoding = $got->getValue('encode');
0.000000,0,0.000000,*$obj->{Encoding} = IO::Compress::Base::Common::getEncoding($obj, $class, $want_encoding);
0.000000,0,0.000000,my $x = *$obj->{Encoding};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,*$obj->{Encoding} = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->saveStatus(STATUS_OK) ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $status ;
0.000000,0,0.000000,if (! $merge)
0.000000,0,0.000000,{
0.000000,0,0.000000,*$obj->{Compress} = $obj->mkComp($got)
0.000000,0,0.000000,or return undef;
0.000000,0,0.000000,
0.000000,0,0.000000,*$obj->{UnCompSize} = U64->new;
0.000000,0,0.000000,*$obj->{CompSize} = U64->new;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $outType eq 'buffer') {
0.000000,0,0.000000,${ *$obj->{Buffer} }  = ''
0.000000,0,0.000000,unless $appendOutput ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($outType eq 'handle') {
0.000000,0,0.000000,*$obj->{FH} = $outValue ;
0.000000,0,0.000000,setBinModeOutput(*$obj->{FH}) ;
0.000000,0,0.000000,#$outValue->flush() ;
0.000000,0,0.000000,*$obj->{Handle} = 1 ;
0.000000,0,0.000000,if ($appendOutput)
0.000000,0,0.000000,{
0.000000,0,0.000000,seek(*$obj->{FH}, 0, IO::Handle::SEEK_END)
0.000000,0,0.000000,or return $obj->saveErrorString(undef, "Cannot seek to end of output filehandle: $!", $!) ;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($outType eq 'filename') {
0.002792,2,0.001396,no warnings;
0.000000,0,0.000000,my $mode = '>' ;
0.000000,0,0.000000,$mode = '>>'
0.000000,0,0.000000,if $appendOutput;
0.000000,0,0.000000,*$obj->{FH} = IO::File->new( "$mode $outValue" )
0.000000,0,0.000000,or return $obj->saveErrorString(undef, "cannot open file '$outValue': $!", $!) ;
0.000000,0,0.000000,*$obj->{StdIO} = ($outValue eq '-');
0.000000,0,0.000000,setBinModeOutput(*$obj->{FH}) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,*$obj->{Header} = $obj->mkHeader($got) ;
0.000000,0,0.000000,$obj->output( *$obj->{Header} )
0.000000,0,0.000000,or return undef;
0.000000,0,0.000000,$obj->beforePayload();
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,*$obj->{Compress} = $obj->createMerge($outValue, $outType)
0.000000,0,0.000000,or return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,*$obj->{Closed} = 0 ;
0.000000,0,0.000000,*$obj->{AutoClose} = $got->getValue('autoclose') ;
0.000000,0,0.000000,*$obj->{Output} = $outValue;
0.000000,0,0.000000,*$obj->{ClassName} = $class;
0.000000,0,0.000000,*$obj->{Got} = $got;
0.000000,0,0.000000,*$obj->{OneShot} = 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $obj ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ckOutputParam
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $from = shift ;
0.000000,0,0.000000,my $outType = IO::Compress::Base::Common::whatIsOutput($_[0]);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->croakError("$from: output parameter not a filename, filehandle or scalar ref")
0.000000,0,0.000000,if ! $outType ;
0.000000,0,0.000000,
0.000000,0,0.000000,#$self->croakError("$from: output filename is undef or null string")
0.000000,0,0.000000,#if $outType eq 'filename' && (! defined $_[0] || $_[0] eq '')  ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->croakError("$from: output buffer is read-only")
0.000000,0,0.000000,if $outType eq 'buffer' && Scalar::Util::readonly(${ $_[0] });
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _def
0.000000,0,0.000000,{
0.000000,0,0.000000,my $obj = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $class= (caller)[0] ;
0.000000,0,0.000000,my $name = (caller(1))[3] ;
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->croakError("$name: expected at least 1 parameters\n")
0.000000,0,0.000000,unless @_ >= 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $input = shift ;
0.000000,0,0.000000,my $haveOut = @_ ;
0.000000,0,0.000000,my $output = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $x = IO::Compress::Base::Validator->new($class, *$obj->{Error}, $name, $input, $output)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,push @_, $output if $haveOut && $x->{Hash};
0.000000,0,0.000000,
0.000000,0,0.000000,*$obj->{OneShot} = 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $got = $obj->checkParams($name, undef, @_)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,$x->{Got} = $got ;
0.000000,0,0.000000,
0.000000,0,0.000000,#    if ($x->{Hash})
0.000000,0,0.000000,#    {
0.000000,0,0.000000,#        while (my($k, $v) = each %$input)
0.000000,0,0.000000,#        {
0.000000,0,0.000000,#            $v = \$input->{$k}
0.000000,0,0.000000,#                unless defined $v ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#            $obj->_singleTarget($x, 1, $k, $v, @_)
0.000000,0,0.000000,#                or return undef ;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#
0.000000,0,0.000000,#        return keys %$input ;
0.000000,0,0.000000,#    }
0.000000,0,0.000000,
0.000000,0,0.000000,if ($x->{GlobMap})
0.000000,0,0.000000,{
0.000000,0,0.000000,$x->{oneInput} = 1 ;
0.000000,0,0.000000,foreach my $pair (@{ $x->{Pairs} })
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($from, $to) = @$pair ;
0.000000,0,0.000000,$obj->_singleTarget($x, 1, $from, $to, @_)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return scalar @{ $x->{Pairs} } ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (! $x->{oneOutput} )
0.000000,0,0.000000,{
0.000000,0,0.000000,my $inFile = ($x->{inType} eq 'filenames'
0.000000,0,0.000000,|| $x->{inType} eq 'filename');
0.000000,0,0.000000,
0.000000,0,0.000000,$x->{inType} = $inFile ? 'filename' : 'buffer';
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $in ($x->{oneInput} ? $input : @$input)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $out ;
0.000000,0,0.000000,$x->{oneInput} = 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->_singleTarget($x, $inFile, $in, \$out, @_)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,push @$output, \$out ;
0.000000,0,0.000000,#if ($x->{outType} eq 'array')
0.000000,0,0.000000,#  { push @$output, \$out }
0.000000,0,0.000000,#else
0.000000,0,0.000000,#  { $output->{$in} = \$out }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# finally the 1 to 1 and n to 1
0.000000,0,0.000000,return $obj->_singleTarget($x, 1, $input, $output, @_);
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak "should not be here" ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _singleTarget
0.000000,0,0.000000,{
0.000000,0,0.000000,my $obj             = shift ;
0.000000,0,0.000000,my $x               = shift ;
0.000000,0,0.000000,my $inputIsFilename = shift;
0.000000,0,0.000000,my $input           = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($x->{oneInput})
0.000000,0,0.000000,{
0.000000,0,0.000000,$obj->getFileInfo($x->{Got}, $input)
0.000000,0,0.000000,if isaScalar($input) || (isaFilename($input) and $inputIsFilename) ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $z = $obj->_create($x->{Got}, @_)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,defined $z->_wr2($input, $inputIsFilename)
0.000000,0,0.000000,or return $z->closeError(undef) ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $z->close() ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,my $afterFirst = 0 ;
0.000000,0,0.000000,my $inputIsFilename = ($x->{inType} ne 'array');
0.000000,0,0.000000,my $keep = $x->{Got}->clone();
0.000000,0,0.000000,
0.000000,0,0.000000,#for my $element ( ($x->{inType} eq 'hash') ? keys %$input : @$input)
0.000000,0,0.000000,for my $element ( @$input)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $isFilename = isaFilename($element);
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $afterFirst ++ )
0.000000,0,0.000000,{
0.000000,0,0.000000,defined addInterStream($obj, $element, $isFilename)
0.000000,0,0.000000,or return $obj->closeError(undef) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,$obj->getFileInfo($x->{Got}, $element)
0.000000,0,0.000000,if isaScalar($element) || $isFilename;
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->_create($x->{Got}, @_)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,defined $obj->_wr2($element, $isFilename)
0.000000,0,0.000000,or return $obj->closeError(undef) ;
0.000000,0,0.000000,
0.000000,0,0.000000,*$obj->{Got} = $keep->clone();
0.000000,0,0.000000,}
0.000000,0,0.000000,return $obj->close() ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _wr2
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $source = shift ;
0.000000,0,0.000000,my $inputIsFilename = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $input = $source ;
0.000000,0,0.000000,if (! $inputIsFilename)
0.000000,0,0.000000,{
0.000000,0,0.000000,$input = \$source
0.000000,0,0.000000,if ! ref $source;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ref $input && ref $input eq 'SCALAR' )
0.000000,0,0.000000,{
0.000000,0,0.000000,return $self->syswrite($input, @_) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ! ref $input  || isaFilehandle($input))
0.000000,0,0.000000,{
0.000000,0,0.000000,my $isFilehandle = isaFilehandle($input) ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $fh = $input ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ! $isFilehandle )
0.000000,0,0.000000,{
0.000000,0,0.000000,$fh = IO::File->new( "<$input" )
0.000000,0,0.000000,or return $self->saveErrorString(undef, "cannot open file '$input': $!", $!) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,binmode $fh ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $status ;
0.000000,0,0.000000,my $buff ;
0.000000,0,0.000000,my $count = 0 ;
0.000000,0,0.000000,while ($status = read($fh, $buff, 16 * 1024)) {
0.000000,0,0.000000,$count += length $buff;
0.000000,0,0.000000,defined $self->syswrite($buff, @_)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->saveErrorString(undef, $!, $!)
0.000000,0,0.000000,if ! defined $status ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( (!$isFilehandle || *$self->{AutoClose}) && $input ne '-')
0.000000,0,0.000000,{
0.000000,0,0.000000,$fh->close()
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $count ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak "Should not be here";
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub addInterStream
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $input = shift ;
0.000000,0,0.000000,my $inputIsFilename = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (*$self->{Got}->getValue('multistream'))
0.000000,0,0.000000,{
0.000000,0,0.000000,$self->getFileInfo(*$self->{Got}, $input)
0.000000,0,0.000000,#if isaFilename($input) and $inputIsFilename ;
0.000000,0,0.000000,if isaScalar($input) || isaFilename($input) ;
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO -- newStream needs to allow gzip/zip header to be modified
0.000000,0,0.000000,return $self->newStream();
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (*$self->{Got}->getValue('autoflush'))
0.000000,0,0.000000,{
0.000000,0,0.000000,#return $self->flush(Z_FULL_FLUSH);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getFileInfo
0.000000,0,0.000000,{
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub TIEHANDLE
0.000000,0,0.000000,{
0.000000,0,0.000000,return $_[0] if ref($_[0]);
0.000000,0,0.000000,die "OOPS\n" ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub UNTIE
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub DESTROY
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,local ($., $@, $!, $^E, $?);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->close() ;
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO - memory leak with 5.8.0 - this isn't called until
0.000000,0,0.000000,#        global destruction
0.000000,0,0.000000,#
0.000000,0,0.000000,%{ *$self } = () ;
0.000000,0,0.000000,undef $self ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub filterUncompressed
0.000000,0,0.000000,{
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub syswrite
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $buffer ;
0.000000,0,0.000000,if (ref $_[0] ) {
0.000000,0,0.000000,$self->croakError( *$self->{ClassName} . "::write: not a scalar reference" )
0.000000,0,0.000000,unless ref $_[0] eq 'SCALAR' ;
0.000000,0,0.000000,$buffer = $_[0] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$buffer = \$_[0] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (@_ > 1) {
0.000000,0,0.000000,my $slen = defined $$buffer ? length($$buffer) : 0;
0.000000,0,0.000000,my $len = $slen;
0.000000,0,0.000000,my $offset = 0;
0.000000,0,0.000000,$len = $_[1] if $_[1] < $len;
0.000000,0,0.000000,
0.000000,0,0.000000,if (@_ > 2) {
0.000000,0,0.000000,$offset = $_[2] || 0;
0.000000,0,0.000000,$self->croakError(*$self->{ClassName} . "::write: offset outside string")
0.000000,0,0.000000,if $offset > $slen;
0.000000,0,0.000000,if ($offset < 0) {
0.000000,0,0.000000,$offset += $slen;
0.000000,0,0.000000,$self->croakError( *$self->{ClassName} . "::write: offset outside string") if $offset < 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $rem = $slen - $offset;
0.000000,0,0.000000,$len = $rem if $rem < $len;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$buffer = \substr($$buffer, $offset, $len) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 0 if (! defined $$buffer || length $$buffer == 0) && ! *$self->{FlushPending};
0.000000,0,0.000000,
0.000000,0,0.000000,#    *$self->{Pending} .= $$buffer ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#    return length $$buffer
0.000000,0,0.000000,#        if (length *$self->{Pending} < 1024 * 16 && ! *$self->{FlushPending}) ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#    $$buffer = *$self->{Pending} ;
0.000000,0,0.000000,#    *$self->{Pending} = '';
0.000000,0,0.000000,
0.000000,0,0.000000,if (*$self->{Encoding}) {
0.000000,0,0.000000,$$buffer = *$self->{Encoding}->encode($$buffer);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$] >= 5.008 and ( utf8::downgrade($$buffer, 1)
0.000000,0,0.000000,or Carp::croak "Wide character in " .  *$self->{ClassName} . "::write:");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->filterUncompressed($buffer);
0.000000,0,0.000000,
0.000000,0,0.000000,my $buffer_length = defined $$buffer ? length($$buffer) : 0 ;
0.000000,0,0.000000,*$self->{UnCompSize}->add($buffer_length) ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $outBuffer='';
0.000000,0,0.000000,my $status = *$self->{Compress}->compr($buffer, $outBuffer) ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->saveErrorString(undef, *$self->{Compress}{Error},
0.000000,0,0.000000,*$self->{Compress}{ErrorNo})
0.000000,0,0.000000,if $status == STATUS_ERROR;
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{CompSize}->add(length $outBuffer) ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->outputPayload($outBuffer)
0.000000,0,0.000000,or return undef;
0.000000,0,0.000000,
0.000000,0,0.000000,return $buffer_length;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub print
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,#if (ref $self) {
0.000000,0,0.000000,#    $self = *$self{GLOB} ;
0.000000,0,0.000000,#}
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined $\) {
0.000000,0,0.000000,if (defined $,) {
0.000000,0,0.000000,defined $self->syswrite(join($,, @_) . $\);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,defined $self->syswrite(join("", @_) . $\);
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,if (defined $,) {
0.000000,0,0.000000,defined $self->syswrite(join($,, @_));
0.000000,0,0.000000,} else {
0.000000,0,0.000000,defined $self->syswrite(join("", @_));
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub printf
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $fmt = shift;
0.000000,0,0.000000,defined $self->syswrite(sprintf($fmt, @_));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _flushCompressed
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $outBuffer='';
0.000000,0,0.000000,my $status = *$self->{Compress}->flush($outBuffer, @_) ;
0.000000,0,0.000000,return $self->saveErrorString(0, *$self->{Compress}{Error},
0.000000,0,0.000000,*$self->{Compress}{ErrorNo})
0.000000,0,0.000000,if $status == STATUS_ERROR;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( defined *$self->{FH} ) {
0.000000,0,0.000000,*$self->{FH}->clearerr();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{CompSize}->add(length $outBuffer) ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->outputPayload($outBuffer)
0.000000,0,0.000000,or return 0;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub flush
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_flushCompressed(@_)
0.000000,0,0.000000,or return 0;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( defined *$self->{FH} ) {
0.000000,0,0.000000,defined *$self->{FH}->flush()
0.000000,0,0.000000,or return $self->saveErrorString(0, $!, $!);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub beforePayload
0.000000,0,0.000000,{
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _newStream
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $got  = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $class = ref $self;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_writeTrailer()
0.000000,0,0.000000,or return 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->ckParams($got)
0.000000,0,0.000000,or $self->croakError("newStream: $self->{Error}");
0.000000,0,0.000000,
0.000000,0,0.000000,if ($got->getValue('encode')) {
0.000000,0,0.000000,my $want_encoding = $got->getValue('encode');
0.000000,0,0.000000,*$self->{Encoding} = IO::Compress::Base::Common::getEncoding($self, $class, $want_encoding);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,*$self->{Encoding} = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{Compress} = $self->mkComp($got)
0.000000,0,0.000000,or return 0;
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{Header} = $self->mkHeader($got) ;
0.000000,0,0.000000,$self->output(*$self->{Header} )
0.000000,0,0.000000,or return 0;
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{UnCompSize}->reset();
0.000000,0,0.000000,*$self->{CompSize}->reset();
0.000000,0,0.000000,
0.000000,0,0.000000,$self->beforePayload();
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub newStream
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $got = $self->checkParams('newStream', *$self->{Got}, @_)
0.000000,0,0.000000,or return 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_newStream($got);
0.000000,0,0.000000,
0.000000,0,0.000000,#    *$self->{Compress} = $self->mkComp($got)
0.000000,0,0.000000,#        or return 0;
0.000000,0,0.000000,#
0.000000,0,0.000000,#    *$self->{Header} = $self->mkHeader($got) ;
0.000000,0,0.000000,#    $self->output(*$self->{Header} )
0.000000,0,0.000000,#        or return 0;
0.000000,0,0.000000,#
0.000000,0,0.000000,#    *$self->{UnCompSize}->reset();
0.000000,0,0.000000,#    *$self->{CompSize}->reset();
0.000000,0,0.000000,#
0.000000,0,0.000000,#    $self->beforePayload();
0.000000,0,0.000000,#
0.000000,0,0.000000,#    return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub reset
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,return *$self->{Compress}->reset() ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _writeTrailer
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $trailer = '';
0.000000,0,0.000000,
0.000000,0,0.000000,my $status = *$self->{Compress}->close($trailer) ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->saveErrorString(0, *$self->{Compress}{Error}, *$self->{Compress}{ErrorNo})
0.000000,0,0.000000,if $status == STATUS_ERROR;
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{CompSize}->add(length $trailer) ;
0.000000,0,0.000000,
0.000000,0,0.000000,$trailer .= $self->mkTrailer();
0.000000,0,0.000000,defined $trailer
0.000000,0,0.000000,or return 0;
0.000000,0,0.000000,return $self->output($trailer);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _writeFinalTrailer
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->output($self->mkFinalTrailer());
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub close
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,return 1 if *$self->{Closed} || ! *$self->{Compress} ;
0.000000,0,0.000000,*$self->{Closed} = 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,untie *$self
0.000000,0,0.000000,if $] >= 5.008 ;
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{FlushPending} = 1 ;
0.000000,0,0.000000,$self->_writeTrailer()
0.000000,0,0.000000,or return 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_writeFinalTrailer()
0.000000,0,0.000000,or return 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->output( "", 1 )
0.000000,0,0.000000,or return 0;
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined *$self->{FH}) {
0.000000,0,0.000000,
0.000000,0,0.000000,if ((! *$self->{Handle} || *$self->{AutoClose}) && ! *$self->{StdIO}) {
0.000000,0,0.000000,$! = 0 ;
0.000000,0,0.000000,*$self->{FH}->close()
0.000000,0,0.000000,or return $self->saveErrorString(0, $!, $!);
0.000000,0,0.000000,}
0.000000,0,0.000000,delete *$self->{FH} ;
0.000000,0,0.000000,# This delete can set $! in older Perls, so reset the errno
0.000000,0,0.000000,$! = 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#sub total_in
0.000000,0,0.000000,#sub total_out
0.000000,0,0.000000,#sub msg
0.000000,0,0.000000,#
0.000000,0,0.000000,#sub crc
0.000000,0,0.000000,#{
0.000000,0,0.000000,#    my $self = shift ;
0.000000,0,0.000000,#    return *$self->{Compress}->crc32() ;
0.000000,0,0.000000,#}
0.000000,0,0.000000,#
0.000000,0,0.000000,#sub msg
0.000000,0,0.000000,#{
0.000000,0,0.000000,#    my $self = shift ;
0.000000,0,0.000000,#    return *$self->{Compress}->msg() ;
0.000000,0,0.000000,#}
0.000000,0,0.000000,#
0.000000,0,0.000000,#sub dict_adler
0.000000,0,0.000000,#{
0.000000,0,0.000000,#    my $self = shift ;
0.000000,0,0.000000,#    return *$self->{Compress}->dict_adler() ;
0.000000,0,0.000000,#}
0.000000,0,0.000000,#
0.000000,0,0.000000,#sub get_Level
0.000000,0,0.000000,#{
0.000000,0,0.000000,#    my $self = shift ;
0.000000,0,0.000000,#    return *$self->{Compress}->get_Level() ;
0.000000,0,0.000000,#}
0.000000,0,0.000000,#
0.000000,0,0.000000,#sub get_Strategy
0.000000,0,0.000000,#{
0.000000,0,0.000000,#    my $self = shift ;
0.000000,0,0.000000,#    return *$self->{Compress}->get_Strategy() ;
0.000000,0,0.000000,#}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub tell
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return *$self->{UnCompSize}->get32bit() ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub eof
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return *$self->{Closed} ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub seek
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self     = shift ;
0.000000,0,0.000000,my $position = shift;
0.000000,0,0.000000,my $whence   = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $here = $self->tell() ;
0.000000,0,0.000000,my $target = 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,#use IO::Handle qw(SEEK_SET SEEK_CUR SEEK_END);
0.000414,2,0.000207,use IO::Handle ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($whence == IO::Handle::SEEK_SET) {
0.000000,0,0.000000,$target = $position ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($whence == IO::Handle::SEEK_CUR || $whence == IO::Handle::SEEK_END) {
0.000000,0,0.000000,$target = $here + $position ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->croakError(*$self->{ClassName} . "::seek: unknown value, $whence, for whence parameter");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# short circuit if seeking to current offset
0.000000,0,0.000000,return 1 if $target == $here ;
0.000000,0,0.000000,
0.000000,0,0.000000,# Outlaw any attempt to seek backwards
0.000000,0,0.000000,$self->croakError(*$self->{ClassName} . "::seek: cannot seek backwards")
0.000000,0,0.000000,if $target < $here ;
0.000000,0,0.000000,
0.000000,0,0.000000,# Walk the file to the new offset
0.000000,0,0.000000,my $offset = $target - $here ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $buffer ;
0.000000,0,0.000000,defined $self->syswrite("\x00" x $offset)
0.000000,0,0.000000,or return 0;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub binmode
0.000000,0,0.000000,{
0.000000,0,0.000000,1;
0.000000,0,0.000000,#    my $self     = shift ;
0.000000,0,0.000000,#    return defined *$self->{FH}
0.000000,0,0.000000,#            ? binmode *$self->{FH}
0.000000,0,0.000000,#            : 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fileno
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self     = shift ;
0.000000,0,0.000000,return defined *$self->{FH}
0.000000,0,0.000000,? *$self->{FH}->fileno()
0.000000,0,0.000000,: undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub opened
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self     = shift ;
0.000000,0,0.000000,return ! *$self->{Closed} ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub autoflush
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self     = shift ;
0.000000,0,0.000000,return defined *$self->{FH}
0.000000,0,0.000000,? *$self->{FH}->autoflush(@_)
0.000000,0,0.000000,: undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub input_line_number
0.000000,0,0.000000,{
0.000000,0,0.000000,return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _notAvailable
0.000000,0,0.000000,{
0.000000,6,0.000000,my $name = shift ;
0.000016,6,0.000003,return sub { Carp::croak "$name Not Available: File opened only for output" ; } ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000218,3,0.000073,no warnings 'once';
0.000000,0,0.000000,
0.000003,1,0.000003,*read     = _notAvailable('read');
0.000001,1,0.000001,*READ     = _notAvailable('read');
0.000000,1,0.000000,*readline = _notAvailable('readline');
0.000001,1,0.000001,*READLINE = _notAvailable('readline');
0.000002,1,0.000002,*getc     = _notAvailable('getc');
0.000000,1,0.000000,*GETC     = _notAvailable('getc');
0.000000,0,0.000000,
0.000001,1,0.000001,*FILENO   = \&fileno;
0.000000,1,0.000000,*PRINT    = \&print;
0.000001,1,0.000001,*PRINTF   = \&printf;
0.000000,1,0.000000,*WRITE    = \&syswrite;
0.000001,1,0.000001,*write    = \&syswrite;
0.000000,1,0.000000,*SEEK     = \&seek;
0.000001,1,0.000001,*TELL     = \&tell;
0.000000,1,0.000000,*EOF      = \&eof;
0.000001,1,0.000001,*CLOSE    = \&close;
0.000001,1,0.000001,*BINMODE  = \&binmode;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#*sysread  = \&_notAvailable;
0.000000,0,0.000000,#*syswrite = \&_write;
0.000000,0,0.000000,
0.000016,1,0.000016,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
