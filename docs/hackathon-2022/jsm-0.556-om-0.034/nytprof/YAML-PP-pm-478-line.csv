# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# ABSTRACT: YAML 1.2 Processor
0.000037,2,0.000018,use strict;
0.000050,2,0.000025,use warnings;
0.000000,0,0.000000,package YAML::PP;
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000561,2,0.000281,use YAML::PP::Schema;
0.000629,2,0.000315,use YAML::PP::Schema::JSON;
0.000619,2,0.000309,use YAML::PP::Loader;
0.000412,2,0.000206,use YAML::PP::Dumper;
0.000037,2,0.000018,use Scalar::Util qw/ blessed /;
0.000022,2,0.000011,use Carp qw/ croak /;
0.000000,0,0.000000,
0.001154,2,0.000577,use base 'Exporter';
0.000002,1,0.000002,our @EXPORT_OK = qw/ Load LoadFile Dump DumpFile /;
0.000000,0,0.000000,
0.000003,1,0.000003,my %YAML_VERSIONS = ('1.1' => 1, '1.2' => 1);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000003,1,0.000003,my ($class, %args) = @_;
0.000000,0,0.000000,
0.000002,1,0.000002,my $bool = delete $args{boolean};
0.000000,1,0.000000,$bool = 'perl' unless defined $bool;
0.000001,1,0.000001,my $schemas = delete $args{schema} || ['+'];
0.000000,1,0.000000,my $cyclic_refs = delete $args{cyclic_refs} || 'allow';
0.000000,1,0.000000,my $indent = delete $args{indent};
0.000001,1,0.000001,my $width = delete $args{width};
0.000000,1,0.000000,my $writer = delete $args{writer};
0.000001,1,0.000001,my $header = delete $args{header};
0.000000,1,0.000000,my $footer = delete $args{footer};
0.000001,1,0.000001,my $duplicate_keys = delete $args{duplicate_keys};
0.000002,1,0.000002,my $yaml_version = $class->_arg_yaml_version(delete $args{yaml_version});
0.000000,1,0.000000,my $default_yaml_version = $yaml_version->[0];
0.000001,1,0.000001,my $version_directive = delete $args{version_directive};
0.000000,1,0.000000,my $preserve = delete $args{preserve};
0.000000,1,0.000000,my $parser = delete $args{parser};
0.000000,0,0.000000,my $emitter = delete $args{emitter} || {
0.000003,1,0.000003,indent => $indent,
0.000000,0,0.000000,width => $width,
0.000000,0,0.000000,writer => $writer,
0.000000,0,0.000000,};
0.000001,1,0.000001,if (keys %args) {
0.000000,0,0.000000,die "Unexpected arguments: " . join ', ', sort keys %args;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my %schemas;
0.000002,1,0.000002,for my $v (@$yaml_version) {
0.000001,1,0.000001,my $schema;
0.000007,1,0.000007,if (blessed($schemas) and $schemas->isa('YAML::PP::Schema')) {
0.000000,0,0.000000,$schema = $schemas;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000004,1,0.000004,$schema = YAML::PP::Schema->new(
0.000000,0,0.000000,boolean => $bool,
0.000000,0,0.000000,yaml_version => $v,
0.000000,0,0.000000,);
0.000003,1,0.000003,$schema->load_subschemas(@$schemas);
0.000000,0,0.000000,}
0.000003,1,0.000003,$schemas{ $v } = $schema;
0.000000,0,0.000000,}
0.000000,1,0.000000,my $default_schema = $schemas{ $default_yaml_version };
0.000000,0,0.000000,
0.000004,1,0.000004,my $loader = YAML::PP::Loader->new(
0.000000,0,0.000000,schemas => \%schemas,
0.000000,0,0.000000,cyclic_refs => $cyclic_refs,
0.000000,0,0.000000,parser => $parser,
0.000000,0,0.000000,default_yaml_version => $default_yaml_version,
0.000000,0,0.000000,preserve => $preserve,
0.000000,0,0.000000,duplicate_keys => $duplicate_keys,
0.000000,0,0.000000,);
0.000005,1,0.000005,my $dumper = YAML::PP::Dumper->new(
0.000000,0,0.000000,schema => $default_schema,
0.000000,0,0.000000,emitter => $emitter,
0.000000,0,0.000000,header => $header,
0.000000,0,0.000000,footer => $footer,
0.000000,0,0.000000,version_directive => $version_directive,
0.000000,0,0.000000,preserve => $preserve,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000003,1,0.000003,my $self = bless {
0.000000,0,0.000000,schema => \%schemas,
0.000000,0,0.000000,loader => $loader,
0.000000,0,0.000000,dumper => $dumper,
0.000000,0,0.000000,}, $class;
0.000008,1,0.000008,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my $clone = {
0.000000,0,0.000000,schema => $self->schema,
0.000000,0,0.000000,loader => $self->loader->clone,
0.000000,0,0.000000,dumper => $self->dumper->clone,
0.000000,0,0.000000,};
0.000000,0,0.000000,return bless $clone, ref $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _arg_yaml_version {
0.000000,1,0.000000,my ($class, $version) = @_;
0.000001,1,0.000001,my @versions = ('1.2');
0.000001,1,0.000001,if (defined $version) {
0.000000,0,0.000000,@versions = ();
0.000000,0,0.000000,if (not ref $version) {
0.000000,0,0.000000,$version = [$version];
0.000000,0,0.000000,}
0.000000,0,0.000000,for my $v (@$version) {
0.000000,0,0.000000,unless ($YAML_VERSIONS{ $v }) {
0.000000,0,0.000000,croak "YAML Version '$v' not supported";
0.000000,0,0.000000,}
0.000000,0,0.000000,push @versions, $v;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000012,1,0.000012,return \@versions;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub loader {
0.000001,1,0.000001,if (@_ > 1) {
0.000000,0,0.000000,$_[0]->{loader} = $_[1]
0.000000,0,0.000000,}
0.000005,1,0.000005,return $_[0]->{loader};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub dumper {
0.000000,0,0.000000,if (@_ > 1) {
0.000000,0,0.000000,$_[0]->{dumper} = $_[1]
0.000000,0,0.000000,}
0.000000,0,0.000000,return $_[0]->{dumper};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub schema {
0.000000,0,0.000000,if (@_ > 1) { $_[0]->{schema}->{'1.2'} = $_[1] }
0.000000,0,0.000000,return $_[0]->{schema}->{'1.2'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub default_schema {
0.000000,0,0.000000,my ($self, %args) = @_;
0.000000,0,0.000000,my $schema = YAML::PP::Schema->new(
0.000000,0,0.000000,boolean => $args{boolean},
0.000000,0,0.000000,);
0.000000,0,0.000000,$schema->load_subschemas(qw/ Core /);
0.000000,0,0.000000,return $schema;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub load_string {
0.000000,0,0.000000,my ($self, $yaml) = @_;
0.000000,0,0.000000,return $self->loader->load_string($yaml);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub load_file {
0.000001,1,0.000001,my ($self, $file) = @_;
0.000011,1,0.000011,return $self->loader->load_file($file);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub dump {
0.000000,0,0.000000,my ($self, @data) = @_;
0.000000,0,0.000000,return $self->dumper->dump(@data);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub dump_string {
0.000000,0,0.000000,my ($self, @data) = @_;
0.000000,0,0.000000,return $self->dumper->dump_string(@data);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub dump_file {
0.000000,0,0.000000,my ($self, $file, @data) = @_;
0.000000,0,0.000000,return $self->dumper->dump_file($file, @data);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# legagy interface
0.000000,0,0.000000,sub Load {
0.000000,0,0.000000,my ($yaml) = @_;
0.000000,0,0.000000,YAML::PP->new->load_string($yaml);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub LoadFile {
0.000000,0,0.000000,my ($file) = @_;
0.000000,0,0.000000,YAML::PP->new->load_file($file);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Dump {
0.000000,0,0.000000,my (@data) = @_;
0.000000,0,0.000000,YAML::PP->new->dump_string(@data);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub DumpFile {
0.000000,0,0.000000,my ($file, @data) = @_;
0.000000,0,0.000000,YAML::PP->new->dump_file($file, @data);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub preserved_scalar {
0.000000,0,0.000000,my ($self, $value, %args) = @_;
0.000000,0,0.000000,my $scalar = YAML::PP::Preserve::Scalar->new(
0.000000,0,0.000000,value => $value,
0.000000,0,0.000000,%args,
0.000000,0,0.000000,);
0.000000,0,0.000000,return $scalar;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub preserved_mapping {
0.000000,0,0.000000,my ($self, $hash, %args) = @_;
0.000000,0,0.000000,my $data = {};
0.000000,0,0.000000,tie %$data, 'YAML::PP::Preserve::Hash';
0.000000,0,0.000000,%$data = %$hash;
0.000000,0,0.000000,my $t = tied %$data;
0.000000,0,0.000000,$t->{style} = $args{style};
0.000000,0,0.000000,$t->{alias} = $args{alias};
0.000000,0,0.000000,return $data;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub preserved_sequence {
0.000000,0,0.000000,my ($self, $array, %args) = @_;
0.000000,0,0.000000,my $data = [];
0.000000,0,0.000000,tie @$data, 'YAML::PP::Preserve::Array';
0.000000,0,0.000000,push @$data, @$array;
0.000000,0,0.000000,my $t = tied @$data;
0.000000,0,0.000000,$t->{style} = $args{style};
0.000000,0,0.000000,$t->{alias} = $args{alias};
0.000000,0,0.000000,return $data;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,package YAML::PP::Preserve::Hash;
0.000000,0,0.000000,# experimental
0.000504,2,0.000252,use Tie::Hash;
0.000063,2,0.000031,use base qw/ Tie::StdHash /;
0.000479,2,0.000240,use Scalar::Util qw/ reftype blessed /;
0.000000,0,0.000000,
0.000000,0,0.000000,sub TIEHASH {
0.000000,0,0.000000,my ($class, %args) = @_;
0.000000,0,0.000000,my $self = bless {
0.000000,0,0.000000,keys => [keys %args],
0.000000,0,0.000000,data => { %args },
0.000000,0,0.000000,}, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub STORE {
0.000000,0,0.000000,my ($self, $key, $val) = @_;
0.000000,0,0.000000,my $keys = $self->{keys};
0.000000,0,0.000000,unless (exists $self->{data}->{ $key }) {
0.000000,0,0.000000,push @$keys, $key;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (ref $val and not blessed($val)) {
0.000000,0,0.000000,if (reftype($val) eq 'HASH' and not tied %$val) {
0.000000,0,0.000000,tie %$val, 'YAML::PP::Preserve::Hash', %$val;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (reftype($val) eq 'ARRAY' and not tied @$val) {
0.000000,0,0.000000,tie @$val, 'YAML::PP::Preserve::Array', @$val;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->{data}->{ $key } = $val;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub FIRSTKEY {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,return $self->{keys}->[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub NEXTKEY {
0.000000,0,0.000000,my ($self, $last) = @_;
0.000000,0,0.000000,my $keys = $self->{keys};
0.000000,0,0.000000,for my $i (0 .. $#$keys) {
0.000000,0,0.000000,if ("$keys->[ $i ]" eq "$last") {
0.000000,0,0.000000,return $keys->[ $i + 1 ];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub FETCH {
0.000000,0,0.000000,my ($self, $key) = @_;
0.000000,0,0.000000,my $val = $self->{data}->{ $key };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub DELETE {
0.000000,0,0.000000,my ($self, $key) = @_;
0.000000,0,0.000000,@{ $self->{keys} } = grep { "$_" ne "$key" } @{ $self->{keys} };
0.000000,0,0.000000,delete $self->{data}->{ $key };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub EXISTS {
0.000000,0,0.000000,my ($self, $key) = @_;
0.000000,0,0.000000,return exists $self->{data}->{ $key };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub CLEAR {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,$self->{keys} = [];
0.000000,0,0.000000,$self->{data} = {};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub SCALAR {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,return scalar %{ $self->{data} };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,package YAML::PP::Preserve::Array;
0.000000,0,0.000000,# experimental
0.000799,2,0.000400,use Tie::Array;
0.000080,2,0.000040,use base qw/ Tie::StdArray /;
0.001206,2,0.000603,use Scalar::Util qw/ reftype blessed /;
0.000000,0,0.000000,
0.000000,0,0.000000,sub TIEARRAY {
0.000000,0,0.000000,my ($class, @items) = @_;
0.000000,0,0.000000,my $self = bless {
0.000000,0,0.000000,data => [@items],
0.000000,0,0.000000,}, $class;
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub FETCH {
0.000000,0,0.000000,my ($self, $i) = @_;
0.000000,0,0.000000,return $self->{data}->[ $i ];
0.000000,0,0.000000,}
0.000000,0,0.000000,sub FETCHSIZE {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,return $#{ $self->{data} } + 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _preserve {
0.000000,0,0.000000,my ($val) = @_;
0.000000,0,0.000000,if (ref $val and not blessed($val)) {
0.000000,0,0.000000,if (reftype($val) eq 'HASH' and not tied %$val) {
0.000000,0,0.000000,tie %$val, 'YAML::PP::Preserve::Hash', %$val;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (reftype($val) eq 'ARRAY' and not tied @$val) {
0.000000,0,0.000000,tie @$val, 'YAML::PP::Preserve::Array', @$val;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return $val;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub STORE {
0.000000,0,0.000000,my ($self, $i, $val) = @_;
0.000000,0,0.000000,_preserve($val);
0.000000,0,0.000000,$self->{data}->[ $i ] = $val;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub PUSH {
0.000000,0,0.000000,my ($self, @args) = @_;
0.000000,0,0.000000,push @{ $self->{data} }, map { _preserve $_ } @args;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub STORESIZE {
0.000000,0,0.000000,my ($self, $i) = @_;
0.000000,0,0.000000,$#{ $self->{data} } = $i - 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub DELETE {
0.000000,0,0.000000,my ($self, $i) = @_;
0.000000,0,0.000000,delete $self->{data}->[ $i ];
0.000000,0,0.000000,}
0.000000,0,0.000000,sub EXISTS {
0.000000,0,0.000000,my ($self, $i) = @_;
0.000000,0,0.000000,return exists $self->{data}->[ $i ];
0.000000,0,0.000000,}
0.000000,0,0.000000,sub CLEAR {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,$self->{data} = [];
0.000000,0,0.000000,}
0.000000,0,0.000000,sub SHIFT {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,shift @{ $self->{data} };
0.000000,0,0.000000,}
0.000000,0,0.000000,sub UNSHIFT {
0.000000,0,0.000000,my ($self, @args) = @_;
0.000000,0,0.000000,unshift @{ $self->{data} }, map { _preserve $_ } @args;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub SPLICE {
0.000000,0,0.000000,my ($self, $offset, $length, @args) = @_;
0.000000,0,0.000000,splice @{ $self->{data} }, $offset, $length, map { _preserve $_ } @args;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub EXTEND {}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,package YAML::PP::Preserve::Scalar;
0.000000,0,0.000000,
0.000000,0,0.000000,use overload
0.000001,1,0.000001,fallback => 1,
0.000000,0,0.000000,'+' => \&value,
0.000000,0,0.000000,'""' => \&value,
0.000000,0,0.000000,'bool' => \&value,
0.000279,1,0.000279,;
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my ($class, %args) = @_;
0.000000,0,0.000000,my $self = {
0.000000,0,0.000000,%args,
0.000000,0,0.000000,};
0.000000,0,0.000000,bless $self, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub value { $_[0]->{value} }
0.000000,0,0.000000,sub tag { $_[0]->{tag} }
0.000000,0,0.000000,sub style { $_[0]->{style} || 0 }
0.000000,0,0.000000,sub alias { $_[0]->{alias} }
0.000000,0,0.000000,
0.000008,1,0.000008,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
