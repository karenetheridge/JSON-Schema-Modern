# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000022,2,0.000011,use strict;
0.000040,2,0.000020,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern; # git description: v0.555-12-g5cd1dee9
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Validate data against a schema
0.000000,0,0.000000,# KEYWORDS: JSON Schema validator data validation structure specification
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.556';
0.000000,0,0.000000,
0.000027,2,0.000013,use 5.020;  # for fc, unicode_strings features
0.000025,2,0.000013,use Moo;
0.000041,3,0.000014,use strictures 2;
0.000060,2,0.000030,use experimental qw(signatures postderef);
0.000030,2,0.000015,use if "$]" >= 5.022, experimental => 're_strict';
0.000020,2,0.000010,no if "$]" >= 5.031009, feature => 'indirect';
0.000016,2,0.000008,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000013,2,0.000006,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000265,2,0.000133,use JSON::MaybeXS;
0.000077,2,0.000039,use Carp qw(croak carp);
0.000058,3,0.000019,use List::Util 1.55 qw(pairs first uniqint pairmap uniq any);
0.000047,3,0.000016,use Ref::Util 0.100 qw(is_ref is_plain_hashref);
0.000023,2,0.000012,use Scalar::Util 'refaddr';
0.000658,2,0.000329,use Mojo::URL;
0.000021,2,0.000011,use Safe::Isa;
0.000495,2,0.000247,use Path::Tiny;
0.000019,2,0.000010,use Storable 'dclone';
0.000609,2,0.000305,use File::ShareDir 'dist_dir';
0.000777,2,0.000388,use Module::Runtime qw(use_module require_module);
0.000493,3,0.000164,use MooX::TypeTiny 0.002002;
0.000558,2,0.000279,use MooX::HandlesVia;
0.000520,3,0.000173,use Types::Standard 1.016003 qw(Bool Int Str HasMethods Enum InstanceOf HashRef Dict CodeRef Optional Slurpy ArrayRef Undef ClassName Tuple Map);
0.000051,2,0.000025,use Feature::Compat::Try;
0.000639,2,0.000320,use JSON::Schema::Modern::Error;
0.000632,2,0.000316,use JSON::Schema::Modern::Result;
0.000704,2,0.000352,use JSON::Schema::Modern::Document;
0.000748,2,0.000374,use JSON::Schema::Modern::Utilities qw(get_type canonical_uri E abort annotate_self);
0.000094,2,0.000047,use namespace::clean;
0.000000,0,0.000000,
0.000002,1,0.000002,our @CARP_NOT = qw(
0.000000,0,0.000000,JSON::Schema::Modern::Document
0.000000,0,0.000000,JSON::Schema::Modern::Vocabulary
0.000000,0,0.000000,JSON::Schema::Modern::Vocabulary::Applicator
0.000000,0,0.000000,OpenAPI::Modern
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000071,2,0.000035,use constant SPECIFICATION_VERSION_DEFAULT => 'draft2020-12';
0.005016,2,0.002508,use constant SPECIFICATION_VERSIONS_SUPPORTED => [qw(draft7 draft2019-09 draft2020-12)];
0.000000,0,0.000000,
0.000000,0,0.000000,has specification_version => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Enum(SPECIFICATION_VERSIONS_SUPPORTED),
0.000000,0,0.000000,coerce => sub {
0.000000,0,0.000000,return $_[0] if any { $_[0] eq $_ } SPECIFICATION_VERSIONS_SUPPORTED->@*;
0.000000,0,0.000000,my $real = 'draft'.($_[0]//'');
0.000000,0,0.000000,(any { $real eq $_ } SPECIFICATION_VERSIONS_SUPPORTED->@*) ? $real : $_[0];
0.000000,0,0.000000,},
0.000014,1,0.000014,);
0.000000,0,0.000000,
0.000027,1,0.000027,has output_format => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Enum(JSON::Schema::Modern::Result->OUTPUT_FORMATS),
0.000000,0,0.000000,default => 'basic',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,has short_circuit => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Bool,
0.000000,0,0.000000,lazy => 1,
0.000007,1,0.000007,default => sub { $_[0]->output_format eq 'flag' && !$_[0]->collect_annotations },
0.000006,1,0.000006,);
0.000000,0,0.000000,
0.000004,1,0.000004,has max_traversal_depth => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Int,
0.000000,0,0.000000,default => 50,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000015,1,0.000015,has validate_formats => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Bool,
0.000000,0,0.000000,default => 0, # as specified by https://json-schema.org/draft/<version>/schema#/$vocabulary
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,has validate_content_schemas => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Bool,
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,# defaults to false in latest versions, as specified by
0.000000,0,0.000000,# https://json-schema.org/draft/2020-12/json-schema-validation.html#rfc.section.8.2
0.000006,1,0.000006,default => sub { ($_[0]->specification_version//'') eq 'draft7' },
0.000004,1,0.000004,);
0.000000,0,0.000000,
0.000002,1,0.000002,has collect_annotations => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Bool,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000003,1,0.000003,has scalarref_booleans => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Bool,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000002,1,0.000002,has strict => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Bool,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,has _format_validations => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => my $format_type = Dict[
0.000000,0,0.000000,(map +($_ => Optional[CodeRef]), qw(date-time date time duration email idn-email hostname idn-hostname ipv4 ipv6 uri uri-reference iri iri-reference uuid uri-template json-pointer relative-json-pointer regex)),
0.000000,0,0.000000,Slurpy[HashRef[Dict[type => Enum[qw(null object array boolean string number integer)], sub => CodeRef]]],
0.000000,0,0.000000,],
0.000000,0,0.000000,init_arg => 'format_validations',
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,_get_format_validation => 'get',
0.000000,0,0.000000,add_format_validation => 'set',
0.000000,0,0.000000,},
0.000000,0,0.000000,lazy => 1,
0.000002,1,0.000002,default => sub { {} },
0.000074,1,0.000074,);
0.000000,0,0.000000,
0.000053,5,0.000011,before add_format_validation => sub ($self, @kvs) { $format_type->({ @$_ }) foreach pairs @kvs };
0.000000,0,0.000000,
0.000001,4,0.000000,around BUILDARGS => sub ($orig, $class, @args) {
0.000002,1,0.000002,my $args = $class->$orig(@args);
0.000000,0,0.000000,croak 'output_format: strict_basic can only be used with specification_version: draft2019-09'
0.000000,0,0.000000,if ($args->{output_format}//'') eq 'strict_basic'
0.000001,1,0.000001,and ($args->{specification_version}//'') ne 'draft2019-09';
0.000000,0,0.000000,
0.000005,1,0.000005,return $args;
0.000005,1,0.000005,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_schema {
0.000009,9,0.000001,croak 'insufficient arguments' if @_ < 2;
0.000009,9,0.000001,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: resolve $uri against $self->base_uri
0.000062,9,0.000007,my $uri = !is_ref($_[0]) ? Mojo::URL->new(shift)
0.000000,0,0.000000,: $_[0]->$_isa('Mojo::URL') ? shift : Mojo::URL->new;
0.000000,0,0.000000,
0.000018,9,0.000002,croak 'cannot add a schema with a uri with a fragment' if defined $uri->fragment;
0.000000,0,0.000000,
0.000002,9,0.000000,if (not @_) {
0.000000,0,0.000000,my $schema_info = $self->_fetch_from_uri($uri);
0.000000,0,0.000000,return if not $schema_info or not defined wantarray;
0.000000,0,0.000000,return $schema_info->{document};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# document BUILD will trigger $self->traverse($schema)
0.000188,9,0.000021,my $document = $_[0]->$_isa('JSON::Schema::Modern::Document') ? shift
0.000000,0,0.000000,: JSON::Schema::Modern::Document->new(
0.000000,0,0.000000,schema => shift,
0.000000,0,0.000000,$uri ? (canonical_uri => $uri) : (),
0.000000,0,0.000000,evaluator => $self,  # used mainly for traversal during document construction
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000025,9,0.000003,if ($document->has_errors) {
0.000000,0,0.000000,my $result = JSON::Schema::Modern::Result->new(
0.000000,0,0.000000,output_format => $self->output_format,
0.000000,0,0.000000,valid => 0,
0.000000,0,0.000000,errors => [ $document->errors ],
0.000000,0,0.000000,exception => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,die $result;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000314,9,0.000035,if (not grep refaddr($_->{document}) == refaddr($document), $self->_canonical_resources) {
0.008871,7,0.001267,my $schema_content = $document->_serialized_schema
0.000000,0,0.000000,// $document->_serialized_schema($self->_json_decoder->encode($document->schema));
0.000000,0,0.000000,
0.000159,7,0.000023,if (my $existing_doc = first {
0.000155,29,0.000005,my $existing_content = $_->_serialized_schema
0.000000,0,0.000000,// $_->_serialized_schema($self->_json_decoder->encode($_->schema));
0.000018,29,0.000001,$existing_content eq $schema_content
0.000000,0,0.000000,} uniqint map $_->{document}, $self->_canonical_resources) {
0.000000,0,0.000000,# we already have this schema content in another document object.
0.000000,0,0.000000,$document = $existing_doc;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000083,7,0.000012,$self->_add_resources(map +($_->[0] => +{ $_->[1]->%*, document => $document }),
0.000000,0,0.000000,$document->resource_pairs);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000042,9,0.000005,if ("$uri") {
0.000029,8,0.000004,my $resource = $document->_get_resource($document->canonical_uri);
0.000000,0,0.000000,$self->_add_resources($uri => {
0.000000,0,0.000000,path => '',
0.000000,0,0.000000,canonical_uri => $document->canonical_uri,
0.000000,0,0.000000,specification_version => $resource->{specification_version},
0.000000,0,0.000000,vocabularies => $resource->{vocabularies},  # reference, not copy
0.000000,0,0.000000,document => $document,
0.000000,0,0.000000,configs => $resource->{configs},
0.000052,8,0.000006,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000039,9,0.000004,return $document;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub evaluate_json_string ($self, $json_data, $schema, $config_override = {}) {
0.000000,0,0.000000,croak 'evaluate_json_string called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,my $data;
0.000000,0,0.000000,try {
0.000000,0,0.000000,$data = $self->_json_decoder->decode($json_data)
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,return JSON::Schema::Modern::Result->new(
0.000000,0,0.000000,output_format => $self->output_format,
0.000000,0,0.000000,valid => 0,
0.000000,0,0.000000,exception => 1,
0.000000,0,0.000000,errors => [
0.000000,0,0.000000,JSON::Schema::Modern::Error->new(
0.000000,0,0.000000,keyword => undef,
0.000000,0,0.000000,instance_location => '',
0.000000,0,0.000000,keyword_location => '',
0.000000,0,0.000000,error => $e,
0.000000,0,0.000000,)
0.000000,0,0.000000,],
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->evaluate($data, $schema, $config_override);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# this is called whenever we need to walk a document for something.
0.000000,0,0.000000,# for now it is just called when a ::Document object is created, to verify the integrity of the
0.000000,0,0.000000,# schema structure, to identify the metaschema (via the $schema keyword), and to extract all
0.000000,0,0.000000,# embedded resources via $id and $anchor keywords within.
0.000000,0,0.000000,# Returns the internal $state object accumulated during the traversal.
0.000846,2972,0.000000,sub traverse ($self, $schema_reference, $config_override = {}) {
0.000000,0,0.000000,# Note: the starting position is not guaranteed to be at the root of the $document.
0.001687,743,0.000002,my $initial_uri = Mojo::URL->new($config_override->{initial_schema_uri} // '');
0.000801,743,0.000001,my $initial_path = $config_override->{traversed_schema_path} // '';
0.002672,743,0.000004,my $spec_version = $self->specification_version//SPECIFICATION_VERSION_DEFAULT;
0.000000,0,0.000000,
0.000000,0,0.000000,my $state = {
0.000000,0,0.000000,depth => 0,
0.000000,0,0.000000,data_path => '',                        # this never changes since we don't have an instance yet
0.000000,0,0.000000,initial_schema_uri => $initial_uri,     # the canonical URI as of the start of this method, or last $id
0.000000,0,0.000000,traversed_schema_path => $initial_path, # the accumulated traversal path as of the start, or last $id
0.000000,0,0.000000,schema_path => '',                      # the rest of the path, since the start of this method, or last $id
0.000000,0,0.000000,effective_base_uri => Mojo::URL->new(''),
0.000000,0,0.000000,errors => [],
0.000000,0,0.000000,identifiers => [],
0.000000,0,0.000000,configs => {},
0.000000,0,0.000000,callbacks => $config_override->{callbacks} // {},
0.007461,743,0.000010,evaluator => $self,
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000470,743,0.000001,try {
0.000000,0,0.000000,my $for_canonical_uri = Mojo::URL->new(
0.000000,0,0.000000,(is_plain_hashref($schema_reference) && exists $schema_reference->{'$id'}
0.000000,0,0.000000,? Mojo::URL->new($schema_reference->{'$id'}) : undef)
0.002274,743,0.000003,// $state->{initial_schema_uri});
0.000945,743,0.000001,$for_canonical_uri->fragment(undef) if not length $for_canonical_uri->fragment;
0.000000,0,0.000000,
0.000000,0,0.000000,# a subsequent "$schema" keyword can still change these values
0.000000,0,0.000000,$state->@{qw(spec_version vocabularies)} = $self->_get_metaschema_info(
0.006604,743,0.000009,$config_override->{metaschema_uri} // $self->METASCHEMA_URIS->{$spec_version},
0.000000,0,0.000000,$for_canonical_uri,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,if ($e->$_isa('JSON::Schema::Modern::Result')) {
0.000000,0,0.000000,push $state->{errors}->@*, $e->errors;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($e->$_isa('JSON::Schema::Modern::Error')) {
0.000000,0,0.000000,push $state->{errors}->@*, $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,()= E({ %$state, exception => 1 }, 'EXCEPTION: '.$e);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000383,743,0.000001,try {
0.002699,743,0.000004,$self->_traverse_subschema($schema_reference, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,if ($e->$_isa('JSON::Schema::Modern::Error')) {
0.000000,0,0.000000,# note: we should never be here, since traversal subs are no longer be fatal
0.000000,0,0.000000,push $state->{errors}->@*, $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,E({ %$state, exception => 1 }, 'EXCEPTION: '.$e);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000351,743,0.000000,delete $state->{traverse};
0.003024,743,0.000004,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# the actual runtime evaluation of the schema against input data.
0.000002,5,0.000000,sub evaluate ($self, $data, $schema_reference, $config_override = {}) {
0.000000,1,0.000000,croak 'evaluate called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000001,1,0.000001,my $initial_path = $config_override->{traversed_schema_path} // '';
0.000002,1,0.000002,my $effective_base_uri = Mojo::URL->new($config_override->{effective_base_uri}//'');
0.000000,0,0.000000,
0.000000,0,0.000000,my $state = {
0.000005,1,0.000005,data_path => $config_override->{data_path} // '',
0.000000,0,0.000000,traversed_schema_path => $initial_path, # the accumulated path as of the start of evaluation, or last $id or $ref
0.000000,0,0.000000,initial_schema_uri => Mojo::URL->new,   # the canonical URI as of the start of evaluation, or last $id or $ref
0.000000,0,0.000000,schema_path => '',                  # the rest of the path, since the start of evaluation, or last $id or $ref
0.000000,0,0.000000,effective_base_uri => $effective_base_uri, # resolve locations against this for errors and annotations
0.000000,0,0.000000,errors => [],
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000001,1,0.000001,my $valid;
0.000000,1,0.000000,try {
0.000000,1,0.000000,my $schema_info;
0.000000,0,0.000000,
0.000003,1,0.000003,if (not is_ref($schema_reference) or $schema_reference->$_isa('Mojo::URL')) {
0.000002,1,0.000002,$schema_info = $self->_fetch_from_uri($schema_reference);
0.000002,1,0.000002,$state->{initial_schema_uri} = Mojo::URL->new($config_override->{initial_schema_uri} // '');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# traverse is called via add_schema -> ::Document->new -> ::Document->BUILD
0.000000,0,0.000000,my $document = $self->add_schema('', $schema_reference);
0.000000,0,0.000000,my $base_resource = $document->_get_resource($document->canonical_uri)
0.000000,0,0.000000,|| croak "couldn't get resource: document parse error";
0.000000,0,0.000000,
0.000000,0,0.000000,$schema_info = {
0.000000,0,0.000000,schema => $document->schema,
0.000000,0,0.000000,document => $document,
0.000000,0,0.000000,document_path => '',
0.000000,0,0.000000,$base_resource->%{qw(canonical_uri specification_version vocabularies configs)},
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,abort($state, 'EXCEPTION: unable to find resource %s', $schema_reference)
0.000000,0,0.000000,if not $schema_info;
0.000000,0,0.000000,
0.000000,0,0.000000,$state = +{
0.000000,0,0.000000,%$state,
0.000000,0,0.000000,depth => 0,
0.000000,0,0.000000,initial_schema_uri => $schema_info->{canonical_uri}, # the canonical URI as of the start of evaluation, or last $id or $ref
0.000000,0,0.000000,document => $schema_info->{document},   # the ::Document object containing this schema
0.000000,0,0.000000,document_path => $schema_info->{document_path}, # the path within the document of this schema, as of the start of evaluation, or last $id or $ref
0.000000,0,0.000000,dynamic_scope => [ $schema_info->{canonical_uri} ],
0.000000,0,0.000000,annotations => [],
0.000000,0,0.000000,seen => {},
0.000000,0,0.000000,spec_version => $schema_info->{specification_version},
0.000000,0,0.000000,vocabularies => $schema_info->{vocabularies},
0.000000,0,0.000000,callbacks => $config_override->{callbacks} // {},
0.000000,0,0.000000,evaluator => $self,
0.000000,0,0.000000,$schema_info->{configs}->%*,
0.000000,0,0.000000,(map {
0.000037,7,0.000005,my $val = $config_override->{$_} // $self->$_;
0.000003,6,0.000000,defined $val ? ( $_ => $val ) : ()
0.000000,0,0.000000,} qw(validate_formats validate_content_schemas short_circuit collect_annotations scalarref_booleans strict)),
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,1,0.000000,if ($state->{validate_formats}) {
0.000000,0,0.000000,$state->{vocabularies} = [
0.000000,0,0.000000,map s/^JSON::Schema::Modern::Vocabulary::Format\KAnnotation$/Assertion/r, $state->{vocabularies}->@*
0.000014,1,0.000014,];
0.000001,1,0.000001,require JSON::Schema::Modern::Vocabulary::FormatAssertion;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,$valid = $self->_eval_subschema($data, $schema_info->{schema}, $state);
0.000022,1,0.000022,warn 'result is false but there are no errors' if not $valid and not $state->{errors}->@*;
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,if ($e->$_isa('JSON::Schema::Modern::Result')) {
0.000000,0,0.000000,return $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($e->$_isa('JSON::Schema::Modern::Error')) {
0.000000,0,0.000000,push $state->{errors}->@*, $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$valid = E({ %$state, exception => 1 }, 'EXCEPTION: '.$e);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,die 'evaluate validity inconstent with error count' if $valid xor !$state->{errors}->@*;
0.000000,0,0.000000,
0.000000,0,0.000000,return JSON::Schema::Modern::Result->new(
0.000000,0,0.000000,output_format => $self->output_format,
0.000000,0,0.000000,valid => $valid,
0.000000,0,0.000000,$valid
0.000000,0,0.000000,# strip annotations from result if user didn't explicitly ask for them
0.000000,0,0.000000,? ($config_override->{collect_annotations} // $self->collect_annotations
0.000000,0,0.000000,? (annotations => $state->{annotations}) : ())
0.326774,1,0.326774,: (errors => $state->{errors}),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub validate_schema ($self, $schema, $config_override = {}) {
0.000000,0,0.000000,croak 'validate_schema called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,my $metaschema_uri = is_plain_hashref($schema) && $schema->{'$schema'} ? $schema->{'$schema'}
0.000000,0,0.000000,: $self->METASCHEMA_URIS->{$self->specification_version // $self->SPECIFICATION_VERSION_DEFAULT};
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->evaluate($schema, $metaschema_uri, $config_override);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get ($self, $uri) {
0.000000,0,0.000000,my $schema_info = $self->_fetch_from_uri($uri);
0.000000,0,0.000000,return if not $schema_info;
0.000000,0,0.000000,my $subschema = is_ref($schema_info->{schema}) ? dclone($schema_info->{schema}) : $schema_info->{schema};
0.000000,0,0.000000,return wantarray ? ($subschema, $schema_info->{canonical_uri}) : $subschema;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# defined lower down:
0.000000,0,0.000000,# sub add_vocabulary { ... }
0.000000,0,0.000000,# sub add_encoding { ... }
0.000000,0,0.000000,# sub add_media_type { ... }
0.000000,0,0.000000,
0.000000,0,0.000000,######## NO PUBLIC INTERFACES FOLLOW THIS POINT ########
0.000000,0,0.000000,
0.000000,0,0.000000,# current spec version => { keyword => undef, or arrayref of alternatives }
0.000014,1,0.000014,my %removed_keywords = (
0.000000,0,0.000000,'draft7' => {
0.000000,0,0.000000,id => [ '$id' ],
0.000000,0,0.000000,},
0.000000,0,0.000000,'draft2019-09' => {
0.000000,0,0.000000,id => [ '$id' ],
0.000000,0,0.000000,definitions => [ '$defs' ],
0.000000,0,0.000000,dependencies => [ qw(dependentSchemas dependentRequired) ],
0.000000,0,0.000000,},
0.000000,0,0.000000,'draft2020-12' => {
0.000000,0,0.000000,id => [ '$id' ],
0.000000,0,0.000000,definitions => [ '$defs' ],
0.000000,0,0.000000,dependencies => [ qw(dependentSchemas dependentRequired) ],
0.000000,0,0.000000,'$recursiveAnchor' => [ '$dynamicAnchor' ],
0.000000,0,0.000000,'$recursiveRef' => [ '$dynamicRef' ],
0.000000,0,0.000000,additionalItems => [ 'items' ],
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# {
0.000000,0,0.000000,#   $spec_version => {
0.000000,0,0.000000,#     $vocabulary_class => {
0.000000,0,0.000000,#       traverse => [ [ $keyword => $subref ], [ ... ] ],
0.000000,0,0.000000,#       evaluate => [ [ $keyword => $subref ], [ ... ] ],
0.000000,0,0.000000,#     }
0.000000,0,0.000000,#   }
0.000000,0,0.000000,# }
0.000000,0,0.000000,# If we could serialize coderefs, this could be an object attribute;
0.000000,0,0.000000,# otherwise, we might as well persist this for the lifetime of the process.
0.000001,1,0.000001,our $vocabulary_cache = {};
0.000000,0,0.000000,
0.002199,11452,0.000000,sub _traverse_subschema ($self, $schema, $state) {
0.001251,2863,0.000000,delete $state->{keyword};
0.000000,0,0.000000,
0.000000,0,0.000000,return E($state, 'EXCEPTION: maximum traversal depth exceeded')
0.005120,2863,0.000002,if $state->{depth}++ > $self->max_traversal_depth;
0.000000,0,0.000000,
0.004170,2863,0.000001,my $schema_type = get_type($schema);
0.001588,2863,0.000001,return 1 if $schema_type eq 'boolean';
0.000000,0,0.000000,
0.000710,2491,0.000000,return E($state, 'invalid schema type: %s', $schema_type) if $schema_type ne 'object';
0.000000,0,0.000000,
0.001363,2491,0.000001,return 1 if not keys %$schema;
0.000000,0,0.000000,
0.000368,2488,0.000000,my $valid = 1;
0.009867,2488,0.000004,my %unknown_keywords = map +($_ => undef), keys %$schema;
0.000000,0,0.000000,# we must check the array length on every iteration because some keywords can change it!
0.011789,2488,0.000005,for (my $idx = 0; $idx <= $state->{vocabularies}->$#*; ++$idx) {
0.006980,19434,0.000000,my $vocabulary = $state->{vocabularies}[$idx];
0.000000,0,0.000000,
0.000000,0,0.000000,# [ [ $keyword => $subref ], [ ... ] ]
0.000000,0,0.000000,my $keyword_list = $vocabulary_cache->{$state->{spec_version}}{$vocabulary}{traverse} //= [
0.000000,0,0.000000,map [ $_ => $vocabulary->can('_traverse_keyword_'.($_ =~ s/^\$//r)) ],
0.000000,0,0.000000,$vocabulary->keywords($state->{spec_version})
0.013732,19434,0.000001,];
0.000000,0,0.000000,
0.028024,19434,0.000001,foreach my $keyword_tuple ($keyword_list->@*) {
0.038940,149888,0.000000,my ($keyword, $sub) = $keyword_tuple->@*;
0.028478,149888,0.000000,next if not exists $schema->{$keyword};
0.000000,0,0.000000,
0.000000,0,0.000000,# keywords adjacent to $ref are not evaluated before draft2019-09
0.002083,4388,0.000000,next if $keyword ne '$ref' and exists $schema->{'$ref'} and $state->{spec_version} eq 'draft7';
0.000000,0,0.000000,
0.001530,4388,0.000000,delete $unknown_keywords{$keyword};
0.001677,4388,0.000000,$state->{keyword} = $keyword;
0.000000,0,0.000000,
0.008214,4388,0.000002,if (not $sub->($vocabulary, $schema, $state)) {
0.000000,0,0.000000,die 'traverse returned false but we have no errors' if not $state->{errors}->@*;
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.004042,4388,0.000001,if (my $callback = $state->{callbacks}{$keyword}) {
0.000000,0,0.000000,$callback->($schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001320,2488,0.000001,delete $state->{keyword};
0.000000,0,0.000000,
0.004818,2488,0.000002,if ($self->strict and keys %unknown_keywords) {
0.000000,0,0.000000,()= E($state, 'unknown keyword%s found: %s', keys %unknown_keywords > 1 ? 's' : '',
0.000000,0,0.000000,join(', ', sort keys %unknown_keywords));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# check for previously-supported but now removed keywords
0.014377,2488,0.000006,foreach my $keyword (sort keys $removed_keywords{$state->{spec_version}}->%*) {
0.001879,14928,0.000000,next if not exists $schema->{$keyword};
0.000000,0,0.000000,my $message ='no-longer-supported "'.$keyword.'" keyword present (at location "'
0.000000,0,0.000000,.canonical_uri($state).'")';
0.000000,0,0.000000,if (my $alternates = $removed_keywords{$state->{spec_version}}->{$keyword}) {
0.000000,0,0.000000,my @list = map '"'.$_.'"', @$alternates;
0.000000,0,0.000000,@list = ((map $_.',', @list[0..$#list-1]), $list[-1]) if @list > 2;
0.000000,0,0.000000,splice(@list, -1, 0, 'or') if @list > 1;
0.000000,0,0.000000,$message .= ': this should be rewritten as '.join(' ', @list);
0.000000,0,0.000000,}
0.000000,0,0.000000,carp $message;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.006982,2488,0.000003,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.083157,457975,0.000000,sub _eval_subschema ($self, $data, $schema, $state) {
0.036301,91595,0.000000,croak '_eval_subschema called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,# callers created a new $state for us, so we do not propagate upwards changes to depth, traversed
0.000000,0,0.000000,# paths; but annotations, errors are arrayrefs so their contents will be shared
0.114823,91595,0.000001,$state->{dynamic_scope} = [ ($state->{dynamic_scope}//[])->@* ];
2.445988,91595,0.000027,delete $state->@{'keyword', grep /^_/, keys %$state};
0.000000,0,0.000000,
0.000000,0,0.000000,abort($state, 'EXCEPTION: maximum evaluation depth exceeded')
0.206854,91595,0.000002,if $state->{depth}++ > $self->max_traversal_depth;
0.000000,0,0.000000,
0.131395,91595,0.000001,my $schema_type = get_type($schema);
0.036424,91595,0.000000,return $schema || E($state, 'subschema is false') if $schema_type eq 'boolean';
0.000000,0,0.000000,
0.000000,0,0.000000,# this should never happen, due to checks in traverse
0.027674,91595,0.000000,abort($state, 'invalid schema type: %s', $schema_type) if $schema_type ne 'object';
0.000000,0,0.000000,
0.036331,91595,0.000000,return 1 if not keys %$schema;
0.000000,0,0.000000,
0.000000,0,0.000000,# find all schema locations in effect at this data path + canonical_uri combination
0.000000,0,0.000000,# if any of them are absolute prefix of this schema location, we are in a loop.
0.099516,91595,0.000001,my $canonical_uri = canonical_uri($state);
0.056097,91595,0.000001,my $schema_location = $state->{traversed_schema_path}.$state->{schema_path};
0.000000,0,0.000000,abort($state, 'EXCEPTION: infinite loop detected (same location evaluated twice)')
0.000000,0,0.000000,if grep substr($schema_location, 0, length) eq $_,
0.479594,91595,0.000005,keys $state->{seen}{$state->{data_path}}{$canonical_uri}->%*;
0.335967,91595,0.000004,$state->{seen}{$state->{data_path}}{$canonical_uri}{$schema_location}++;
0.000000,0,0.000000,
0.029189,91595,0.000000,my $valid = 1;
0.348017,91595,0.000004,my %unknown_keywords = map +($_ => undef), keys %$schema;
0.036390,91595,0.000000,my $orig_annotations = $state->{annotations};
0.049010,91595,0.000001,$state->{annotations} = [];
0.020270,91595,0.000000,my @new_annotations;
0.000000,0,0.000000,
0.000000,0,0.000000,ALL_KEYWORDS:
0.084023,91595,0.000001,foreach my $vocabulary ($state->{vocabularies}->@*) {
0.000000,0,0.000000,# [ [ $keyword => $subref|undef ], [ ... ] ]
0.000000,0,0.000000,my $keyword_list = $vocabulary_cache->{$state->{spec_version}}{$vocabulary}{evaluate} //= [
0.000000,0,0.000000,map [ $_ => $vocabulary->can('_eval_keyword_'.($_ =~ s/^\$//r)) ],
0.000000,0,0.000000,$vocabulary->keywords($state->{spec_version})
0.557447,641165,0.000001,];
0.000000,0,0.000000,
0.955143,641165,0.000001,foreach my $keyword_tuple ($keyword_list->@*) {
1.397679,5.22092e+06,0.000000,my ($keyword, $sub) = $keyword_tuple->@*;
1.000495,5.22092e+06,0.000000,next if not exists $schema->{$keyword};
0.000000,0,0.000000,
0.000000,0,0.000000,# keywords adjacent to $ref are not evaluated before draft2019-09
0.108351,308026,0.000000,next if $keyword ne '$ref' and exists $schema->{'$ref'} and $state->{spec_version} eq 'draft7';
0.000000,0,0.000000,
0.099169,308026,0.000000,delete $unknown_keywords{$keyword};
0.087689,308026,0.000000,$state->{keyword} = $keyword;
0.000000,0,0.000000,
0.086767,308026,0.000000,if ($sub) {
0.070873,202471,0.000000,my $error_count = $state->{errors}->@*;
0.000000,0,0.000000,
0.433341,202471,0.000002,if (not $sub->($vocabulary, $data, $schema, $state)) {
0.000000,0,0.000000,warn 'result is false but there are no errors (keyword: '.$keyword.')'
0.002545,4283,0.000001,if $error_count == $state->{errors}->@*;
0.001076,4283,0.000000,$valid = 0;
0.000000,0,0.000000,
0.001285,4283,0.000000,last ALL_KEYWORDS if $state->{short_circuit};
0.003563,4283,0.000001,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.241847,303743,0.000001,if (my $callback = $state->{callbacks}{$keyword}) {
0.000000,0,0.000000,$callback->($data, $schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.488735,303743,0.000002,push @new_annotations, $state->{annotations}->@[$#new_annotations+1 .. $state->{annotations}->$#*];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.050993,91595,0.000001,delete $state->{keyword};
0.000000,0,0.000000,
0.023885,91595,0.000000,if ($state->{strict} and keys %unknown_keywords) {
0.000000,0,0.000000,abort($state, 'unknown keyword%s found: %s', keys %unknown_keywords > 1 ? 's' : '',
0.000000,0,0.000000,join(', ', sort keys %unknown_keywords));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.103084,91595,0.000001,$state->{annotations} = $orig_annotations;
0.000000,0,0.000000,
0.079209,91595,0.000001,if ($valid) {
0.176086,87312,0.000002,push $state->{annotations}->@*, @new_annotations;
0.961696,87312,0.000011,if ($state->{collect_annotations} and $state->{spec_version} !~ qr/^draft(7|2019-09)$/) {
0.000000,0,0.000000,annotate_self(+{ %$state, keyword => $_, _unknown => 1 }, $schema)
0.000000,0,0.000000,foreach sort keys %unknown_keywords;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.419303,91595,0.000005,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,has _resource_index => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => HashRef[my $resource_type = Dict[
0.000000,0,0.000000,canonical_uri => InstanceOf['Mojo::URL'],
0.000000,0,0.000000,path => Str,
0.000000,0,0.000000,specification_version => my $spec_version_type = Enum(SPECIFICATION_VERSIONS_SUPPORTED),
0.000000,0,0.000000,document => InstanceOf['JSON::Schema::Modern::Document'],
0.000000,0,0.000000,# the vocabularies used when evaluating instance data against schema
0.000000,0,0.000000,vocabularies => ArrayRef[my $vocabulary_class_type = ClassName->where(q{$_->DOES('JSON::Schema::Modern::Vocabulary')})],
0.000000,0,0.000000,configs => HashRef,
0.000000,0,0.000000,Slurpy[HashRef[Undef]],  # no other fields allowed
0.000000,0,0.000000,]],
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,_add_resources => 'set',
0.000000,0,0.000000,_get_resource => 'get',
0.000000,0,0.000000,_remove_resource => 'delete',
0.000000,0,0.000000,_resource_index => 'elements',
0.000000,0,0.000000,_resource_keys => 'keys',
0.000000,0,0.000000,_add_resources_unsafe => 'set',
0.000000,0,0.000000,_canonical_resources => 'values',
0.000000,0,0.000000,_resource_exists => 'exists',
0.000000,0,0.000000,},
0.000000,0,0.000000,lazy => 1,
0.000010,1,0.000010,default => sub { {} },
0.000052,1,0.000052,);
0.000000,0,0.000000,
0.000000,0,0.000000,around _add_resources => sub {
0.000008,15,0.000001,my ($orig, $self) = (shift, shift);
0.000000,0,0.000000,
0.000005,15,0.000000,my @resources;
0.000274,15,0.000018,foreach my $pair (sort { $a->[0] cmp $b->[0] } pairs @_) {
0.000010,24,0.000000,my ($key, $value) = @$pair;
0.000000,0,0.000000,
0.000119,24,0.000005,$resource_type->($value); # check type of hash value against Dict
0.000000,0,0.000000,
0.000093,24,0.000004,if (my $existing = $self->_get_resource($key)) {
0.000000,0,0.000000,# we allow overwriting canonical_uri = '' to allow for ad hoc evaluation of schemas that
0.000000,0,0.000000,# lack all identifiers altogether, but preserve other resources from the original document
0.000013,6,0.000002,if ($key ne '') {
0.000000,0,0.000000,next if $existing->{path} eq $value->{path}
0.000000,0,0.000000,and $existing->{canonical_uri} eq $value->{canonical_uri}
0.000000,0,0.000000,and $existing->{specification_version} eq $value->{specification_version}
0.000088,6,0.000015,and refaddr($existing->{document}) == refaddr($value->{document});
0.000000,0,0.000000,croak 'uri "'.$key.'" conflicts with an existing schema resource';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->CACHED_METASCHEMAS->{$key}) {
0.000000,0,0.000000,croak 'uri "'.$key.'" conflicts with an existing meta-schema resource';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000047,18,0.000003,my $fragment = $value->{canonical_uri}->fragment;
0.000000,0,0.000000,croak sprintf('canonical_uri cannot contain an empty fragment (%s)', $value->{canonical_uri})
0.000008,18,0.000000,if defined $fragment and $fragment eq '';
0.000000,0,0.000000,
0.000000,0,0.000000,croak sprintf('canonical_uri cannot contain a plain-name fragment (%s)', $value->{canonical_uri})
0.000028,18,0.000002,if ($fragment // '') =~ m{^[^/]};
0.000000,0,0.000000,
0.000027,18,0.000002,$self->$orig($key, $value);
0.000000,0,0.000000,}
0.000005,1,0.000005,};
0.000000,0,0.000000,
0.000000,0,0.000000,# $vocabulary uri (not its $id!) => [ spec_version, class ]
0.000000,0,0.000000,has _vocabulary_classes => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => HashRef[
0.000000,0,0.000000,Tuple[
0.000000,0,0.000000,$spec_version_type,
0.000000,0,0.000000,$vocabulary_class_type,
0.000000,0,0.000000,]
0.000000,0,0.000000,],
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,_get_vocabulary_class => 'get',
0.000000,0,0.000000,_set_vocabulary_class => 'set',
0.000000,0,0.000000,_get_vocabulary_values => 'values',
0.000000,0,0.000000,},
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,default => sub {
0.000000,0,0.000000,+{
0.000091,31,0.000003,map { my $class = $_; pairmap { $a => [ $b, $class ] } $class->vocabulary }
0.000000,0,0.000000,map use_module('JSON::Schema::Modern::Vocabulary::'.$_),
0.000000,0,0.000000,qw(Core Applicator Validation FormatAssertion FormatAnnotation Content MetaData Unevaluated)
0.000000,0,0.000000,}
0.000000,0,0.000000,},
0.000021,1,0.000021,);
0.000000,0,0.000000,
0.000002,3,0.000001,sub add_vocabulary ($self, $classname) {
0.000006,1,0.000006,return if grep $_->[1] eq $classname, $self->_get_vocabulary_values;
0.000000,0,0.000000,
0.000008,1,0.000008,$vocabulary_class_type->(use_module($classname));
0.000000,0,0.000000,
0.000000,0,0.000000,# uri => version, uri => version
0.000030,1,0.000030,foreach my $pair (pairs $classname->vocabulary) {
0.000009,1,0.000009,my ($uri_string, $spec_version) = @$pair;
0.000011,1,0.000011,Str->where(q{my $uri = Mojo::URL->new($_); $uri->is_abs && !defined $uri->fragment})->($uri_string);
0.000039,1,0.000039,$spec_version_type->($spec_version);
0.000005,1,0.000005,$self->_set_vocabulary_class($uri_string => [ $spec_version, $classname ])
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# $schema uri => [ spec_version, [ vocab classes ] ].
0.000000,0,0.000000,has _metaschema_vocabulary_classes => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => HashRef[
0.000000,0,0.000000,Tuple[
0.000000,0,0.000000,$spec_version_type,
0.000000,0,0.000000,ArrayRef[$vocabulary_class_type],
0.000000,0,0.000000,]
0.000000,0,0.000000,],
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,_get_metaschema_vocabulary_classes => 'get',
0.000000,0,0.000000,_set_metaschema_vocabulary_classes => 'set',
0.000000,0,0.000000,__all_metaschema_vocabulary_classes => 'values',
0.000000,0,0.000000,},
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,default => sub {
0.000015,1,0.000015,my @modules = map use_module('JSON::Schema::Modern::Vocabulary::'.$_),
0.000000,0,0.000000,qw(Core Applicator Validation FormatAnnotation Content MetaData Unevaluated);
0.000000,0,0.000000,+{
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/schema' => [ 'draft2020-12', [ @modules ] ],
0.000026,3,0.000009,do { pop @modules; () },
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/schema' => [ 'draft2019-09', \@modules ],
0.000000,0,0.000000,'http://json-schema.org/draft-07/schema#' => [ 'draft7', \@modules ],
0.000000,0,0.000000,},
0.000000,0,0.000000,},
0.000023,1,0.000023,);
0.000000,0,0.000000,
0.000000,0,0.000000,# retrieves metaschema info either from cache or by parsing the schema for vocabularies
0.000000,0,0.000000,# throws a JSON::Schema::Modern::Result on error
0.001065,2972,0.000000,sub _get_metaschema_info ($self, $metaschema_uri, $for_canonical_uri) {
0.000000,0,0.000000,# check the cache
0.002545,743,0.000003,my $metaschema_info = $self->_get_metaschema_vocabulary_classes($metaschema_uri);
0.002304,743,0.000003,return @$metaschema_info if $metaschema_info;
0.000000,0,0.000000,
0.000000,0,0.000000,# otherwise, fetch the metaschema and parse its $vocabulary keyword.
0.000000,0,0.000000,# we do this by traversing a baby schema with just the $schema keyword.
0.000010,1,0.000010,my $state = $self->traverse({ '$schema' => $metaschema_uri.'' });
0.000000,0,0.000000,die JSON::Schema::Modern::Result->new(
0.000000,0,0.000000,output_format => $self->output_format,
0.000000,0,0.000000,valid => JSON::PP::false,
0.000000,0,0.000000,errors => [
0.000000,0,0.000000,map {
0.000000,0,0.000000,my $e = $_;
0.000000,0,0.000000,# absolute location is undef iff the location = '/$schema'
0.000000,0,0.000000,my $absolute_location = $e->absolute_keyword_location // $for_canonical_uri;
0.000000,0,0.000000,JSON::Schema::Modern::Error->new(
0.000000,0,0.000000,keyword => $e->keyword eq '$schema' ? '' : $e->keyword,
0.000000,0,0.000000,instance_location => $e->instance_location,
0.000000,0,0.000000,keyword_location => ($for_canonical_uri->fragment//'').($e->keyword_location =~ s{^/\$schema\b}{}r),
0.000000,0,0.000000,length $absolute_location ? ( absolute_keyword_location => $absolute_location ) : (),
0.000000,0,0.000000,error => $e->error,
0.000000,0,0.000000,)
0.000000,0,0.000000,}
0.000000,0,0.000000,$state->{errors}->@* ],
0.000000,0,0.000000,exception => 1,
0.000001,1,0.000001,) if $state->{errors}->@*;
0.000008,1,0.000008,return ($state->{spec_version}, $state->{vocabularies});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# used for determining a default '$schema' keyword where there is none
0.000002,1,0.000002,use constant METASCHEMA_URIS => {
0.000000,0,0.000000,'draft2020-12' => 'https://json-schema.org/draft/2020-12/schema',
0.000000,0,0.000000,'draft2019-09' => 'https://json-schema.org/draft/2019-09/schema',
0.000000,0,0.000000,'draft7' => 'http://json-schema.org/draft-07/schema#',
0.000120,1,0.000120,};
0.000000,0,0.000000,
0.000001,1,0.000001,use constant CACHED_METASCHEMAS => {
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/applicator'     => 'draft2020-12/meta/applicator.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/content'        => 'draft2020-12/meta/content.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/core'           => 'draft2020-12/meta/core.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/format-annotation' => 'draft2020-12/meta/format-annotation.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/format-assertion'  => 'draft2020-12/meta/format-assertion.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/meta-data'      => 'draft2020-12/meta/meta-data.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/unevaluated'    => 'draft2020-12/meta/unevaluated.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/validation'     => 'draft2020-12/meta/validation.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/output/schema'       => 'draft2020-12/output/schema.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/schema'              => 'draft2020-12/schema.json',
0.000000,0,0.000000,
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/meta/applicator'     => 'draft2019-09/meta/applicator.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/meta/content'        => 'draft2019-09/meta/content.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/meta/core'           => 'draft2019-09/meta/core.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/meta/format'         => 'draft2019-09/meta/format.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/meta/meta-data'      => 'draft2019-09/meta/meta-data.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/meta/validation'     => 'draft2019-09/meta/validation.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/output/schema'       => 'draft2019-09/output/schema.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/schema'              => 'draft2019-09/schema.json',
0.000000,0,0.000000,
0.000000,0,0.000000,# trailing # is omitted because we always cache documents by its canonical (fragmentless) URI
0.000000,0,0.000000,'http://json-schema.org/draft-07/schema' => 'draft7/schema.json',
0.001925,1,0.001925,};
0.000000,0,0.000000,
0.000000,0,0.000000,# returns the same as _get_resource
0.022399,117369,0.000000,sub _get_or_load_resource ($self, $uri) {
0.089731,39123,0.000002,my $resource = $self->_get_resource($uri);
0.076314,39123,0.000002,return $resource if $resource;
0.000000,0,0.000000,
0.000060,8,0.000008,if (my $local_filename = $self->CACHED_METASCHEMAS->{$uri}) {
0.000036,8,0.000005,my $file = path(dist_dir('JSON-Schema-Modern'), $local_filename);
0.000323,8,0.000040,my $schema = $self->_json_decoder->decode($file->slurp_raw);
0.000065,8,0.000008,my $document = JSON::Schema::Modern::Document->new(schema => $schema, evaluator => $self);
0.000000,0,0.000000,
0.000000,0,0.000000,# this should be caught by the try/catch in evaluate()
0.000024,8,0.000003,die JSON::Schema::Modern::Result->new(
0.000000,0,0.000000,output_format => $self->output_format,
0.000000,0,0.000000,valid => 0,
0.000000,0,0.000000,errors => [ $document->errors ],
0.000000,0,0.000000,exception => 1,
0.000000,0,0.000000,) if $document->has_errors;
0.000000,0,0.000000,
0.000000,0,0.000000,# we have already performed the appropriate collision checks, so we bypass them here
0.000096,8,0.000012,$self->_add_resources_unsafe(
0.000000,0,0.000000,map +($_->[0] => +{ $_->[1]->%*, document => $document }),
0.000000,0,0.000000,$document->resource_pairs
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000066,8,0.000008,return $self->_get_resource($uri);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO:
0.000000,0,0.000000,# - load from network or disk
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,# returns information necessary to use a schema found at a particular URI:
0.000000,0,0.000000,# - a schema (which may not be at a document root)
0.000000,0,0.000000,# - the canonical uri for that schema,
0.000000,0,0.000000,# - the JSON::Schema::Modern::Document object that holds that schema
0.000000,0,0.000000,# - the path relative to the document root for this schema
0.000000,0,0.000000,# - the specification version that applies to this schema
0.000000,0,0.000000,# - the vocabularies to use when considering schema keywords
0.000000,0,0.000000,# - the config overrides to set when considering schema keywords
0.000000,0,0.000000,# creates a Document and adds it to the resource index, if not already present.
0.028731,140643,0.000000,sub _fetch_from_uri ($self, $uri) {
0.021404,46881,0.000000,$uri = Mojo::URL->new($uri) if not is_ref($uri);
0.057443,46881,0.000001,my $fragment = $uri->fragment;
0.000000,0,0.000000,
0.064981,46881,0.000001,if (not length($fragment) or $fragment =~ m{^/}) {
0.074944,39123,0.000002,my $base = $uri->clone->fragment(undef);
0.074345,39123,0.000002,if (my $resource = $self->_get_or_load_resource($base)) {
0.133421,39123,0.000003,my $subschema = $resource->{document}->get(my $document_path = $resource->{path}.($fragment//''));
0.014649,39123,0.000000,return if not defined $subschema;
0.017660,39123,0.000000,my $document = $resource->{document};
0.000000,0,0.000000,my $closest_resource = first { !length($_->[1]{path})       # document root
0.218634,39123,0.000006,|| length($document_path)
0.000000,0,0.000000,&& $document_path =~ m{^\Q$_->[1]{path}\E(?:/|\z)} }  # path is above present location
0.000000,0,0.000000,sort { length($b->[1]{path}) <=> length($a->[1]{path}) }  # sort by length, descending
0.699894,39123,0.000018,grep { not length Mojo::URL->new($_->[0])->fragment }     # omit anchors
0.000000,0,0.000000,$document->resource_pairs;
0.000000,0,0.000000,
0.000000,0,0.000000,my $canonical_uri = $closest_resource->[1]{canonical_uri}->clone
0.143581,39123,0.000004,->fragment(substr($document_path, length($closest_resource->[1]{path})));
0.058839,39123,0.000002,$canonical_uri->fragment(undef) if not length($canonical_uri->fragment);
0.000000,0,0.000000,return {
0.000000,0,0.000000,schema => $subschema,
0.000000,0,0.000000,canonical_uri => $canonical_uri,
0.000000,0,0.000000,document => $document,
0.000000,0,0.000000,document_path => $document_path,
0.497185,39123,0.000013,$resource->%{qw(specification_version vocabularies configs)}, # reference, not copy
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {  # we are following a URI with a plain-name fragment
0.014036,7758,0.000002,if (my $resource = $self->_get_resource($uri)) {
0.018417,7758,0.000002,my $subschema = $resource->{document}->get($resource->{path});
0.001858,7758,0.000000,return if not defined $subschema;
0.000000,0,0.000000,return {
0.000000,0,0.000000,schema => $subschema,
0.000000,0,0.000000,canonical_uri => $resource->{canonical_uri}->clone, # this is *not* the anchor-containing URI
0.000000,0,0.000000,document => $resource->{document},
0.000000,0,0.000000,document_path => $resource->{path},
0.062074,7758,0.000008,$resource->%{qw(specification_version vocabularies configs)}, # reference, not copy
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# used for internal encoding as well (when caching serialized schemas)
0.000000,0,0.000000,has _json_decoder => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => HasMethods[qw(encode decode)],
0.000000,0,0.000000,lazy => 1,
0.000005,1,0.000005,default => sub { JSON::MaybeXS->new(allow_nonref => 1, canonical => 1, utf8 => 1, allow_bignum => 1, convert_blessed => 1) },
0.000017,1,0.000017,);
0.000000,0,0.000000,
0.000000,0,0.000000,# since media types are case-insensitive, all type names must be foldcased on insertion.
0.000000,0,0.000000,has _media_type => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => my $media_type_type = Map[Str->where(q{$_ eq CORE::fc($_)}), CodeRef],
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,get_media_type => 'get',
0.000000,0,0.000000,add_media_type => 'set',
0.000000,0,0.000000,_media_types => 'keys',
0.000000,0,0.000000,},
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,default => sub ($self) {
0.000000,0,0.000000,my $_json_media_type = sub ($content_ref) {
0.000000,0,0.000000,\ JSON::MaybeXS->new(allow_nonref => 1, utf8 => 0)->decode($content_ref->$*);
0.000000,0,0.000000,};
0.000000,0,0.000000,+{
0.000000,0,0.000000,# note: utf-8 decoding is NOT done, as we can't be sure that's the correct charset!
0.000000,0,0.000000,'application/json' => $_json_media_type,
0.000000,0,0.000000,'application/schema+json' => $_json_media_type,
0.000000,0,0.000000,'application/schema-instance+json' => $_json_media_type,
0.000000,0,0.000000,map +($_ => sub ($content_ref) { $content_ref }),
0.000000,0,0.000000,qw(text/plain application/octet-stream),
0.000000,0,0.000000,};
0.000000,0,0.000000,},
0.000025,1,0.000025,);
0.000000,0,0.000000,
0.000000,0,0.000000,# get_media_type('TExT/bloop') will match an entry for 'text/*' or '*/*'
0.000000,0,0.000000,# TODO: support queries for application/schema+json to match entry of application/json
0.000000,0,0.000000,around get_media_type => sub ($orig, $self, $type) {
0.000000,0,0.000000,my $mt = $self->$orig(fc $type);
0.000000,0,0.000000,return $mt if $mt;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->$orig((first { m{([^/]+)/\*$} && fc($type) =~ m{^\Q$1\E/[^/]+$} } $self->_media_types)
0.000000,0,0.000000,// '*/*');
0.000006,1,0.000006,};
0.000000,0,0.000000,
0.000003,1,0.000003,before add_media_type => sub ($self, $type, $sub) { $media_type_type->({ $type => $sub }) };
0.000000,0,0.000000,
0.000000,0,0.000000,has _encoding => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => HashRef[CodeRef],
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,get_encoding => 'get',
0.000000,0,0.000000,add_encoding => 'set',
0.000000,0,0.000000,},
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,default => sub ($self) {
0.000000,0,0.000000,+{
0.000000,0,0.000000,identity => sub ($content_ref) { $content_ref },
0.000000,0,0.000000,base64 => sub ($content_ref) {
0.000000,0,0.000000,die "invalid characters in base64 string"
0.000000,0,0.000000,if $content_ref->$* =~ m{[^A-Za-z0-9+/=]} or $content_ref->$* =~ m{=(?=[^=])};
0.000000,0,0.000000,require MIME::Base64; \ MIME::Base64::decode($content_ref->$*);
0.000000,0,0.000000,},
0.000000,0,0.000000,};
0.000000,0,0.000000,},
0.000012,1,0.000012,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub FREEZE ($self, $serializer) {
0.000000,0,0.000000,my $data = +{ %$self };
0.000000,0,0.000000,# Cpanel::JSON::XS doesn't serialize: https://github.com/Sereal/Sereal/issues/266
0.000000,0,0.000000,# coderefs can't serialize cleanly and must be re-added by the user.
0.000000,0,0.000000,delete $data->@{qw(_json_decoder _format_validations _media_type _encoding)};
0.000000,0,0.000000,return $data;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub THAW ($class, $serializer, $data) {
0.000000,0,0.000000,my $self = bless($data, $class);
0.000000,0,0.000000,
0.000000,0,0.000000,# load all vocabulary classes
0.000000,0,0.000000,require_module($_) foreach uniq map $_->{vocabularies}->@*, $self->_canonical_resources;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000071,1,0.000071,1;
0.000000,0,0.000000,
0.000336,1,0.000336,__END__
