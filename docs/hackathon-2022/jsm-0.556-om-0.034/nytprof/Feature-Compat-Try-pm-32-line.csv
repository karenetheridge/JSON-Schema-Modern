# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,#  You may distribute under the terms of either the GNU General Public License
0.000000,0,0.000000,#  or the Artistic License (the same terms as Perl itself)
0.000000,0,0.000000,#
0.000000,0,0.000000,#  (C) Paul Evans, 2021-2022 -- leonerd@leonerd.org.uk
0.000000,0,0.000000,
0.000000,0,0.000000,package Feature::Compat::Try 0.05;
0.000000,0,0.000000,
0.000036,2,0.000018,use v5.14;
0.000017,2,0.000008,use warnings;
0.000019,2,0.000010,use feature ();
0.000000,0,0.000000,
0.000000,0,0.000000,# Core's use feature 'try' only supports 'finally' since 5.35.8
0.000346,2,0.000173,use constant HAVE_FEATURE_TRY => $] >= 5.035008;
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,C<Feature::Compat::Try> - make C<try/catch> syntax available
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use Feature::Compat::Try;
0.000000,0,0.000000,
0.000000,0,0.000000,sub foo
0.000000,0,0.000000,{
0.000000,0,0.000000,try {
0.000000,0,0.000000,attempt_a_thing();
0.000000,0,0.000000,return "success";
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,warn "It failed - $e";
0.000000,0,0.000000,return "failure";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,This module makes syntax support for C<try/catch> control flow easily
0.000000,0,0.000000,available.
0.000000,0,0.000000,
0.000000,0,0.000000,Perl added such syntax at version 5.34.0, and extended it to support optional
0.000000,0,0.000000,C<finally> blocks at 5.35.9, which is enabled by
0.000000,0,0.000000,
0.000000,0,0.000000,use feature 'try';
0.000000,0,0.000000,
0.000000,0,0.000000,On that version of perl or later, this module simply enables the core feature
0.000000,0,0.000000,equivalent to using it directly. On such perls, this module will install with
0.000000,0,0.000000,no non-core dependencies, and requires no C compiler.
0.000000,0,0.000000,
0.000000,0,0.000000,On older versions of perl before such syntax is available, it is currently
0.000000,0,0.000000,provided instead using the L<Syntax::Keyword::Try> module, imported with a
0.000000,0,0.000000,special set of options to configure it to recognise exactly and only the same
0.000000,0,0.000000,syntax as the core perl feature, thus ensuring that any code using it will
0.000000,0,0.000000,still continue to function on that newer perl.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 KEYWORDS
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 try
0.000000,0,0.000000,
0.000000,0,0.000000,try {
0.000000,0,0.000000,STATEMENTS...
0.000000,0,0.000000,}
0.000000,0,0.000000,...
0.000000,0,0.000000,
0.000000,0,0.000000,A C<try> statement provides the main body of code that will be invoked, and
0.000000,0,0.000000,must be followed by a C<catch> statement. It may optionally be followed by
0.000000,0,0.000000,a C<finally> statement.
0.000000,0,0.000000,
0.000000,0,0.000000,Execution of the C<try> statement itself begins from the block given to the
0.000000,0,0.000000,statement and continues until either it throws an exception, or completes
0.000000,0,0.000000,successfully by reaching the end of the block.
0.000000,0,0.000000,
0.000000,0,0.000000,The body of a C<try {}> block may contain a C<return> expression. If executed,
0.000000,0,0.000000,such an expression will cause the entire containing function to return with
0.000000,0,0.000000,the value provided. This is different from a plain C<eval {}> block, in which
0.000000,0,0.000000,circumstance only the C<eval> itself would return, not the entire function.
0.000000,0,0.000000,
0.000000,0,0.000000,The body of a C<try {}> block may contain loop control expressions (C<redo>,
0.000000,0,0.000000,C<next>, C<last>) which will have their usual effect on any loops that the
0.000000,0,0.000000,C<try {}> block is contained by.
0.000000,0,0.000000,
0.000000,0,0.000000,The parsing rules for the set of statements (the C<try> block and its
0.000000,0,0.000000,associated C<catch>) are such that they are parsed as a self-contained
0.000000,0,0.000000,statement. Because of this, there is no need to end with a terminating
0.000000,0,0.000000,semicolon.
0.000000,0,0.000000,
0.000000,0,0.000000,Even though it parses as a statement and not an expression, a C<try> block can
0.000000,0,0.000000,still yield a value if it appears as the final statement in its containing
0.000000,0,0.000000,C<sub> or C<do> block. For example:
0.000000,0,0.000000,
0.000000,0,0.000000,my $result = do {
0.000000,0,0.000000,try { attempt_func() }
0.000000,0,0.000000,catch ($e) { "Fallback Value" }
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 catch
0.000000,0,0.000000,
0.000000,0,0.000000,...
0.000000,0,0.000000,catch ($var) {
0.000000,0,0.000000,STATEMENTS...
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,A C<catch> statement provides a block of code to the preceding C<try>
0.000000,0,0.000000,statement that will be invoked in the case that the main block of code throws
0.000000,0,0.000000,an exception. A new lexical variable is created to store the exception in.
0.000000,0,0.000000,
0.000000,0,0.000000,Presence of this C<catch> statement causes any exception thrown by the
0.000000,0,0.000000,preceding C<try> block to be non-fatal to the surrounding code. If the
0.000000,0,0.000000,C<catch> block wishes to optionally handle some exceptions but not others, it
0.000000,0,0.000000,can re-raise it (or another exception) by calling C<die> in the usual manner.
0.000000,0,0.000000,
0.000000,0,0.000000,As with C<try>, the body of a C<catch {}> block may also contain a C<return>
0.000000,0,0.000000,expression, which as before, has its usual meaning, causing the entire
0.000000,0,0.000000,containing function to return with the given value. The body may also contain
0.000000,0,0.000000,loop control expressions (C<redo>, C<next> or C<last>) which also have their
0.000000,0,0.000000,usual effect.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 finally
0.000000,0,0.000000,
0.000000,0,0.000000,...
0.000000,0,0.000000,finally {
0.000000,0,0.000000,STATEMENTS...
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,A C<finally> statement provides an optional block of code to the preceding
0.000000,0,0.000000,C<try>/C<catch> pair which is executed afterwards, both in the case of a
0.000000,0,0.000000,normal execution or a thrown exception. This code block may be used to
0.000000,0,0.000000,provide whatever clean-up operations might be required by preceding code.
0.000000,0,0.000000,
0.000000,0,0.000000,Because it is executed during a stack cleanup operation, a C<finally {}> block
0.000000,0,0.000000,may not cause the containing function to return, or to alter the return value
0.000000,0,0.000000,of it. It also cannot see the containing function's C<@_> arguments array
0.000000,0,0.000000,(though as it is block scoped within the function, it will continue to share
0.000000,0,0.000000,any normal lexical variables declared up until that point). It is protected
0.000000,0,0.000000,from disturbing the value of C<$@>. If the C<finally {}> block code throws an
0.000000,0,0.000000,exception, this will be printed as a warning and discarded, leaving C<$@>
0.000000,0,0.000000,containing the original exception, if one existed.
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub import
0.000000,0,0.000000,{
0.000063,6,0.000010,if( HAVE_FEATURE_TRY ) {
0.000011,6,0.000002,feature->import(qw( try ));
0.000004,6,0.000001,require warnings;
0.000009,6,0.000002,warnings->unimport(qw( experimental::try ));
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,require Syntax::Keyword::Try;
0.000000,0,0.000000,Syntax::Keyword::Try->VERSION( '0.27' );
0.000000,0,0.000000,Syntax::Keyword::Try->import(qw( try -require_catch -require_var ));
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COMPATIBILITY NOTES
0.000000,0,0.000000,
0.000000,0,0.000000,This module may use either L<Syntax::Keyword::Try> or the perl core C<try>
0.000000,0,0.000000,feature to implement its syntax. While the two behave very similarly, and both
0.000000,0,0.000000,conform to the description given above, the following differences should be
0.000000,0,0.000000,noted.
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Visibility to C<caller()>
0.000000,0,0.000000,
0.000000,0,0.000000,The C<Syntax::Keyword::Try> module implements C<try> blocks by using C<eval>
0.000000,0,0.000000,frames. As a result, they are visible to the C<caller()> function and hence to
0.000000,0,0.000000,things like C<Carp::longmess> when viewed as stack traces.
0.000000,0,0.000000,
0.000000,0,0.000000,By comparison, core's C<feature 'try'> creates a new kind of context stack
0.000000,0,0.000000,entry that is ignored by C<caller()> and hence these blocks do not show up in
0.000000,0,0.000000,stack traces.
0.000000,0,0.000000,
0.000000,0,0.000000,This should not matter to most use-cases - e.g. even C<Carp::croak> will be
0.000000,0,0.000000,fine here. But if you are using C<caller()> with calculated indexes to inspect
0.000000,0,0.000000,the state of callers to your code and there may be C<try> frames in the way,
0.000000,0,0.000000,you will need to somehow account for the difference in stack height.
0.000000,0,0.000000,
0.000000,0,0.000000,=item * C<B::Deparse>
0.000000,0,0.000000,
0.000000,0,0.000000,The core C<feature 'try'> is implemented by emitting real opcodes that
0.000000,0,0.000000,represent its behaviour, which is recognised by the version of L<B::Deparse>
0.000000,0,0.000000,that ships with core perl. As a result, any code using this implementation
0.000000,0,0.000000,will deparse currently with tools like C<perl -MO=Deparse ...>, or others
0.000000,0,0.000000,related to it such as coverage checkers.
0.000000,0,0.000000,
0.000000,0,0.000000,By comparison, since C<Syntax::Keyword::Try> uses C<OP_CUSTOM> it is not
0.000000,0,0.000000,recognised by C<B::Deparse> and so attempts to deparse this will result in
0.000000,0,0.000000,error messages like
0.000000,0,0.000000,
0.000000,0,0.000000,unexpected OP_CUSTOM (catch) at ...
0.000000,0,0.000000,
0.000000,0,0.000000,This is rather unavoidable due to the way that C<B::Deparse> is implemented
0.000000,0,0.000000,and does not easily support custom operators.
0.000000,0,0.000000,
0.000000,0,0.000000,See also L<https://rt.cpan.org/Ticket/Display.html?id=134812>.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHOR
0.000000,0,0.000000,
0.000000,0,0.000000,Paul Evans <leonerd@leonerd.org.uk>
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000004,1,0.000004,0x55AA;
