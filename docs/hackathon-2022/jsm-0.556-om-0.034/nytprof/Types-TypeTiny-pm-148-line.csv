# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Types::TypeTiny;
0.000000,0,0.000000,
0.000070,2,0.000035,use 5.008001;
0.000023,2,0.000012,use strict;
0.000044,2,0.000022,use warnings;
0.000000,0,0.000000,
0.000001,1,0.000001,our $AUTHORITY = 'cpan:TOBYINK';
0.000000,1,0.000000,our $VERSION   = '2.000001';
0.000000,0,0.000000,
0.000002,1,0.000002,$VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000068,2,0.000034,use Scalar::Util qw< blessed refaddr weaken >;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,*__XS = eval {
0.000084,1,0.000084,require Type::Tiny::XS;
0.000000,0,0.000000,'Type::Tiny::XS'->VERSION( '0.022' );
0.000000,0,0.000000,1;
0.000000,0,0.000000,}
0.000000,0,0.000000,? sub () { !!1 }
0.000000,1,0.000000,: sub () { !!0 };
0.000089,1,0.000089,}
0.000000,0,0.000000,
0.000000,0,0.000000,our @EXPORT_OK = (
0.000009,1,0.000009,map( @{ [ $_, "is_$_", "assert_$_" ] }, __PACKAGE__->type_names ),
0.000000,0,0.000000,qw/to_TypeTiny/
0.000000,0,0.000000,);
0.000005,1,0.000005,our %EXPORT_TAGS = (
0.000000,0,0.000000,types  => [ __PACKAGE__->type_names ],
0.000000,0,0.000000,is     => [ map "is_$_",     __PACKAGE__->type_names ],
0.000000,0,0.000000,assert => [ map "assert_$_", __PACKAGE__->type_names ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,1,0.000000,my %cache;
0.000000,0,0.000000,
0.000000,0,0.000000,# This `import` method is designed to avoid loading Exporter::Tiny.
0.000000,0,0.000000,# This is so that if you stick to only using the purely OO parts of
0.000000,0,0.000000,# Type::Tiny, you can skip loading the exporter.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub import {
0.000000,0,0.000000,
0.000000,0,0.000000,# If this sub succeeds, it will replace itself.
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,return unless @_ > 1;                               # uncoverable statement
0.000111,2,0.000056,no warnings "redefine";                             # uncoverable statement
0.000000,0,0.000000,our @ISA = qw( Exporter::Tiny );                    # uncoverable statement
0.000000,0,0.000000,require Exporter::Tiny;                             # uncoverable statement
0.000000,0,0.000000,my $next = \&Exporter::Tiny::import;                # uncoverable statement
0.000000,0,0.000000,*import = $next;                                    # uncoverable statement
0.000000,0,0.000000,my $class = shift;                                  # uncoverable statement
0.000000,0,0.000000,my $opts  = { ref( $_[0] ) ? %{ +shift } : () };    # uncoverable statement
0.000000,0,0.000000,$opts->{into} ||= scalar( caller );                 # uncoverable statement
0.000000,0,0.000000,_mkall();                                           # uncoverable statement
0.000000,0,0.000000,return $class->$next( $opts, @_ );                  # uncoverable statement
0.000000,0,0.000000,} #/ sub import
0.000000,0,0.000000,
0.000001,1,0.000001,for ( __PACKAGE__->type_names ) {    # uncoverable statement
0.001307,6,0.000218,eval qq{                                          # uncoverable statement
0.000000,0,0.000000,sub is_$_     { $_()->check(shift) }           # uncoverable statement
0.000000,0,0.000000,sub assert_$_ { $_()->assert_return(shift) }   # uncoverable statement
0.000000,0,0.000000,};                                  # uncoverable statement
0.000000,0,0.000000,}    # uncoverable statement
0.000000,0,0.000000,
0.000000,0,0.000000,sub _reinstall_subs {
0.000000,0,0.000000,
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my $type = shift;                                        # uncoverable statement
0.000022,2,0.000011,no strict 'refs';                                        # uncoverable statement
0.000110,2,0.000055,no warnings 'redefine';                                  # uncoverable statement
0.000000,0,0.000000,*{ 'is_' . $type->name }     = $type->compiled_check;    # uncoverable statement
0.000000,0,0.000000,*{ 'assert_' . $type->name } = \&$type;                  # uncoverable statement
0.000000,0,0.000000,$type;                                                   # uncoverable statement
0.000000,0,0.000000,}    # uncoverable statement
0.000000,0,0.000000,
0.000000,0,0.000000,sub _mkall {
0.000000,0,0.000000,
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,return unless $INC{'Type/Tiny.pm'};                         # uncoverable statement
0.000000,0,0.000000,__PACKAGE__->get_type( $_ ) for __PACKAGE__->type_names;    # uncoverable statement
0.000000,0,0.000000,}    # uncoverable statement
0.000000,0,0.000000,
0.000000,0,0.000000,sub meta {
0.000000,0,0.000000,return $_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub type_names {
0.000008,5,0.000002,qw( CodeLike StringLike TypeTiny HashLike ArrayLike _ForeignTypeConstraint );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_type {
0.000000,0,0.000000,my %has = map +( $_ => 1 ), shift->type_names;
0.000000,0,0.000000,!!$has{ $_[0] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return unless $self->has_type( @_ );
0.000058,2,0.000029,no strict qw(refs);
0.000000,0,0.000000,&{ $_[0] }();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub coercion_names {
0.000000,0,0.000000,qw();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_coercion {
0.000000,0,0.000000,my %has = map +( $_ => 1 ), shift->coercion_names;
0.000000,0,0.000000,!!$has{ $_[0] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_coercion {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return unless $self->has_coercion( @_ );
0.000055,2,0.000028,no strict qw(refs);
0.000000,0,0.000000,&{ $_[0] }();    # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my ( $__get_linear_isa_dfs, $tried_mro );
0.000000,0,0.000000,$__get_linear_isa_dfs = sub {
0.000000,0,0.000000,if ( !$tried_mro && eval { require mro } ) {
0.000000,0,0.000000,$__get_linear_isa_dfs = \&mro::get_linear_isa;
0.000000,0,0.000000,goto $__get_linear_isa_dfs;
0.000000,0,0.000000,}
0.002336,2,0.001168,no strict 'refs';
0.000000,0,0.000000,my $classname = shift;
0.000000,0,0.000000,my @lin       = ( $classname );
0.000000,0,0.000000,my %stored;
0.000000,0,0.000000,foreach my $parent ( @{"$classname\::ISA"} ) {
0.000000,0,0.000000,my $plin = $__get_linear_isa_dfs->( $parent );
0.000000,0,0.000000,foreach ( @$plin ) {
0.000000,0,0.000000,next if exists $stored{$_};
0.000000,0,0.000000,push( @lin, $_ );
0.000000,0,0.000000,$stored{$_} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return \@lin;
0.000002,1,0.000002,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub _check_overload {
0.000000,0,0.000000,my $package = shift;
0.000000,0,0.000000,if ( ref $package ) {
0.000000,0,0.000000,$package = blessed( $package );
0.000000,0,0.000000,return !!0 if !defined $package;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $op  = shift;
0.000000,0,0.000000,my $mro = $__get_linear_isa_dfs->( $package );
0.000000,0,0.000000,foreach my $p ( @$mro ) {
0.000000,0,0.000000,my $fqmeth = $p . q{::(} . $op;
0.000000,0,0.000000,return !!1 if defined &{$fqmeth};
0.000000,0,0.000000,}
0.000000,0,0.000000,!!0;
0.000000,0,0.000000,} #/ sub _check_overload
0.000000,0,0.000000,
0.000000,0,0.000000,sub _get_check_overload_sub {
0.000000,1,0.000000,if ( $Type::Tiny::AvoidCallbacks ) {
0.000000,0,0.000000,return
0.000000,0,0.000000,'(sub { require overload; overload::Overloaded(ref $_[0] or $_[0]) and overload::Method((ref $_[0] or $_[0]), $_[1]) })->';
0.000000,0,0.000000,}
0.000002,1,0.000002,return 'Types::TypeTiny::_check_overload';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub StringLike () {
0.000075,38,0.000002,return $cache{StringLike} if defined $cache{StringLike};
0.000000,1,0.000000,require Type::Tiny;
0.000000,0,0.000000,my %common = (
0.000000,0,0.000000,name       => "StringLike",
0.000000,0,0.000000,library    => __PACKAGE__,
0.000000,0,0.000000,constraint => sub {
0.000000,0,0.000000,defined( $_ ) && !ref( $_ )
0.000000,0,0.000000,or blessed( $_ ) && _check_overload( $_, q[""] );
0.000000,0,0.000000,},
0.000000,0,0.000000,inlined => sub {
0.000005,1,0.000005,qq/defined($_[1]) && !ref($_[1]) or Scalar::Util::blessed($_[1]) && ${\ +_get_check_overload_sub() }($_[1], q[""])/;
0.000000,0,0.000000,},
0.000000,0,0.000000,type_default => sub { return '' },
0.000005,1,0.000005,);
0.000003,1,0.000003,if ( __XS ) {
0.000000,0,0.000000,my $xsub     = Type::Tiny::XS::get_coderef_for( 'StringLike' );
0.000000,0,0.000000,my $xsubname = Type::Tiny::XS::get_subname_for( 'StringLike' );
0.000000,0,0.000000,my $inlined  = $common{inlined};
0.000000,0,0.000000,$cache{StringLike} = "Type::Tiny"->new(
0.000000,0,0.000000,%common,
0.000000,0,0.000000,compiled_type_constraint => $xsub,
0.000000,0,0.000000,inlined                  => sub {
0.000000,0,0.000000,
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,( $Type::Tiny::AvoidCallbacks or not $xsubname )
0.000000,0,0.000000,? goto( $inlined )
0.000000,0,0.000000,: qq/$xsubname($_[1])/    # uncoverable statement
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,_reinstall_subs $cache{StringLike};
0.000000,0,0.000000,} #/ if ( __XS )
0.000000,0,0.000000,else {
0.000003,1,0.000003,$cache{StringLike} = "Type::Tiny"->new( %common );
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ sub StringLike
0.000000,0,0.000000,
0.000000,0,0.000000,sub HashLike (;@) {
0.000000,0,0.000000,return $cache{HashLike} if defined( $cache{HashLike} ) && !@_;
0.000000,0,0.000000,require Type::Tiny;
0.000000,0,0.000000,my %common = (
0.000000,0,0.000000,name       => "HashLike",
0.000000,0,0.000000,library    => __PACKAGE__,
0.000000,0,0.000000,constraint => sub {
0.000000,0,0.000000,ref( $_ ) eq q[HASH]
0.000000,0,0.000000,or blessed( $_ ) && _check_overload( $_, q[%{}] );
0.000000,0,0.000000,},
0.000000,0,0.000000,inlined => sub {
0.000000,0,0.000000,qq/ref($_[1]) eq q[HASH] or Scalar::Util::blessed($_[1]) && ${\ +_get_check_overload_sub() }($_[1], q[\%{}])/;
0.000000,0,0.000000,},
0.000000,0,0.000000,type_default => sub { return {} },
0.000000,0,0.000000,constraint_generator => sub {
0.000000,0,0.000000,my $param = TypeTiny()->assert_coerce( shift );
0.000000,0,0.000000,my $check = $param->compiled_check;
0.000000,0,0.000000,sub {
0.000000,0,0.000000,my %hash = %$_;
0.000000,0,0.000000,for my $key ( sort keys %hash ) {
0.000000,0,0.000000,$check->( $hash{$key} ) or return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,};
0.000000,0,0.000000,},
0.000000,0,0.000000,inline_generator => sub {
0.000000,0,0.000000,my $param = TypeTiny()->assert_coerce( shift );
0.000000,0,0.000000,return unless $param->can_be_inlined;
0.000000,0,0.000000,sub {
0.000000,0,0.000000,my $var  = pop;
0.000000,0,0.000000,my $code = sprintf(
0.000000,0,0.000000,'do { my $ok=1; my %%h = %%{%s}; for my $k (sort keys %%h) { ($ok=0,next) unless (%s) }; $ok }',
0.000000,0,0.000000,$var,
0.000000,0,0.000000,$param->inline_check( '$h{$k}' ),
0.000000,0,0.000000,);
0.000000,0,0.000000,return ( undef, $code );
0.000000,0,0.000000,};
0.000000,0,0.000000,},
0.000000,0,0.000000,coercion_generator => sub {
0.000000,0,0.000000,my ( $parent, $child, $param ) = @_;
0.000000,0,0.000000,return unless $param->has_coercion;
0.000000,0,0.000000,my $coercible = $param->coercion->_source_type_union->compiled_check;
0.000000,0,0.000000,my $C         = "Type::Coercion"->new( type_constraint => $child );
0.000000,0,0.000000,$C->add_type_coercions(
0.000000,0,0.000000,$parent => sub {
0.000000,0,0.000000,my $origref = @_ ? $_[0] : $_;
0.000000,0,0.000000,my %orig    = %$origref;
0.000000,0,0.000000,my %new;
0.000000,0,0.000000,for my $k ( sort keys %orig ) {
0.000000,0,0.000000,return $origref unless $coercible->( $orig{$k} );
0.000000,0,0.000000,$new{$k} = $param->coerce( $orig{$k} );
0.000000,0,0.000000,}
0.000000,0,0.000000,\%new;
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,return $C;
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,if ( __XS ) {
0.000000,0,0.000000,my $xsub     = Type::Tiny::XS::get_coderef_for( 'HashLike' );
0.000000,0,0.000000,my $xsubname = Type::Tiny::XS::get_subname_for( 'HashLike' );
0.000000,0,0.000000,my $inlined  = $common{inlined};
0.000000,0,0.000000,$cache{HashLike} = "Type::Tiny"->new(
0.000000,0,0.000000,%common,
0.000000,0,0.000000,compiled_type_constraint => $xsub,
0.000000,0,0.000000,inlined                  => sub {
0.000000,0,0.000000,
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,( $Type::Tiny::AvoidCallbacks or not $xsubname )
0.000000,0,0.000000,? goto( $inlined )
0.000000,0,0.000000,: qq/$xsubname($_[1])/    # uncoverable statement
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,_reinstall_subs $cache{HashLike};
0.000000,0,0.000000,} #/ if ( __XS )
0.000000,0,0.000000,else {
0.000000,0,0.000000,$cache{HashLike} = "Type::Tiny"->new( %common );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,@_ ? $cache{HashLike}->parameterize( @{ $_[0] } ) : $cache{HashLike};
0.000000,0,0.000000,} #/ sub HashLike (;@)
0.000000,0,0.000000,
0.000000,0,0.000000,sub ArrayLike (;@) {
0.000000,0,0.000000,return $cache{ArrayLike} if defined( $cache{ArrayLike} ) && !@_;
0.000000,0,0.000000,require Type::Tiny;
0.000000,0,0.000000,my %common = (
0.000000,0,0.000000,name       => "ArrayLike",
0.000000,0,0.000000,library    => __PACKAGE__,
0.000000,0,0.000000,constraint => sub {
0.000000,0,0.000000,ref( $_ ) eq q[ARRAY]
0.000000,0,0.000000,or blessed( $_ ) && _check_overload( $_, q[@{}] );
0.000000,0,0.000000,},
0.000000,0,0.000000,inlined => sub {
0.000000,0,0.000000,qq/ref($_[1]) eq q[ARRAY] or Scalar::Util::blessed($_[1]) && ${\ +_get_check_overload_sub() }($_[1], q[\@{}])/;
0.000000,0,0.000000,},
0.000000,0,0.000000,type_default => sub { return [] },
0.000000,0,0.000000,constraint_generator => sub {
0.000000,0,0.000000,my $param = TypeTiny()->assert_coerce( shift );
0.000000,0,0.000000,my $check = $param->compiled_check;
0.000000,0,0.000000,sub {
0.000000,0,0.000000,my @arr = @$_;
0.000000,0,0.000000,for my $val ( @arr ) {
0.000000,0,0.000000,$check->( $val ) or return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,};
0.000000,0,0.000000,},
0.000000,0,0.000000,inline_generator => sub {
0.000000,0,0.000000,my $param = TypeTiny()->assert_coerce( shift );
0.000000,0,0.000000,return unless $param->can_be_inlined;
0.000000,0,0.000000,sub {
0.000000,0,0.000000,my $var  = pop;
0.000000,0,0.000000,my $code = sprintf(
0.000000,0,0.000000,'do { my $ok=1; for my $v (@{%s}) { ($ok=0,next) unless (%s) }; $ok }',
0.000000,0,0.000000,$var,
0.000000,0,0.000000,$param->inline_check( '$v' ),
0.000000,0,0.000000,);
0.000000,0,0.000000,return ( undef, $code );
0.000000,0,0.000000,};
0.000000,0,0.000000,},
0.000000,0,0.000000,coercion_generator => sub {
0.000000,0,0.000000,my ( $parent, $child, $param ) = @_;
0.000000,0,0.000000,return unless $param->has_coercion;
0.000000,0,0.000000,my $coercible = $param->coercion->_source_type_union->compiled_check;
0.000000,0,0.000000,my $C         = "Type::Coercion"->new( type_constraint => $child );
0.000000,0,0.000000,$C->add_type_coercions(
0.000000,0,0.000000,$parent => sub {
0.000000,0,0.000000,my $origref = @_ ? $_[0] : $_;
0.000000,0,0.000000,my @orig    = @$origref;
0.000000,0,0.000000,my @new;
0.000000,0,0.000000,for my $v ( @orig ) {
0.000000,0,0.000000,return $origref unless $coercible->( $v );
0.000000,0,0.000000,push @new, $param->coerce( $v );
0.000000,0,0.000000,}
0.000000,0,0.000000,\@new;
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,return $C;
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,if ( __XS ) {
0.000000,0,0.000000,my $xsub     = Type::Tiny::XS::get_coderef_for( 'ArrayLike' );
0.000000,0,0.000000,my $xsubname = Type::Tiny::XS::get_subname_for( 'ArrayLike' );
0.000000,0,0.000000,my $inlined  = $common{inlined};
0.000000,0,0.000000,$cache{ArrayLike} = "Type::Tiny"->new(
0.000000,0,0.000000,%common,
0.000000,0,0.000000,compiled_type_constraint => $xsub,
0.000000,0,0.000000,inlined                  => sub {
0.000000,0,0.000000,
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,( $Type::Tiny::AvoidCallbacks or not $xsubname )
0.000000,0,0.000000,? goto( $inlined )
0.000000,0,0.000000,: qq/$xsubname($_[1])/    # uncoverable statement
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,_reinstall_subs $cache{ArrayLike};
0.000000,0,0.000000,} #/ if ( __XS )
0.000000,0,0.000000,else {
0.000000,0,0.000000,$cache{ArrayLike} = "Type::Tiny"->new( %common );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,@_ ? $cache{ArrayLike}->parameterize( @{ $_[0] } ) : $cache{ArrayLike};
0.000000,0,0.000000,} #/ sub ArrayLike (;@)
0.000000,0,0.000000,
0.000001,1,0.000001,if ( $] ge '5.014' ) {
0.000003,1,0.000003,&Scalar::Util::set_prototype( $_, ';$' ) for \&HashLike, \&ArrayLike;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub CodeLike () {
0.000000,0,0.000000,return $cache{CodeLike} if $cache{CodeLike};
0.000000,0,0.000000,require Type::Tiny;
0.000000,0,0.000000,my %common = (
0.000000,0,0.000000,name       => "CodeLike",
0.000000,0,0.000000,constraint => sub {
0.000000,0,0.000000,ref( $_ ) eq q[CODE]
0.000000,0,0.000000,or blessed( $_ ) && _check_overload( $_, q[&{}] );
0.000000,0,0.000000,},
0.000000,0,0.000000,inlined => sub {
0.000000,0,0.000000,qq/ref($_[1]) eq q[CODE] or Scalar::Util::blessed($_[1]) && ${\ +_get_check_overload_sub() }($_[1], q[\&{}])/;
0.000000,0,0.000000,},
0.000000,0,0.000000,type_default => sub { return sub {} },
0.000000,0,0.000000,library => __PACKAGE__,
0.000000,0,0.000000,);
0.000000,0,0.000000,if ( __XS ) {
0.000000,0,0.000000,my $xsub     = Type::Tiny::XS::get_coderef_for( 'CodeLike' );
0.000000,0,0.000000,my $xsubname = Type::Tiny::XS::get_subname_for( 'CodeLike' );
0.000000,0,0.000000,my $inlined  = $common{inlined};
0.000000,0,0.000000,$cache{CodeLike} = "Type::Tiny"->new(
0.000000,0,0.000000,%common,
0.000000,0,0.000000,compiled_type_constraint => $xsub,
0.000000,0,0.000000,inlined                  => sub {
0.000000,0,0.000000,
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,( $Type::Tiny::AvoidCallbacks or not $xsubname )
0.000000,0,0.000000,? goto( $inlined )
0.000000,0,0.000000,: qq/$xsubname($_[1])/    # uncoverable statement
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,_reinstall_subs $cache{CodeLike};
0.000000,0,0.000000,} #/ if ( __XS )
0.000000,0,0.000000,else {
0.000000,0,0.000000,$cache{CodeLike} = "Type::Tiny"->new( %common );
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ sub CodeLike
0.000000,0,0.000000,
0.000000,0,0.000000,sub TypeTiny () {
0.000578,343,0.000002,return $cache{TypeTiny} if defined $cache{TypeTiny};
0.000001,1,0.000001,require Type::Tiny;
0.000000,0,0.000000,$cache{TypeTiny} = "Type::Tiny"->new(
0.000000,0,0.000000,name       => "TypeTiny",
0.000000,0,0.000000,constraint => sub { blessed( $_ ) && $_->isa( q[Type::Tiny] ) },
0.000000,0,0.000000,inlined    => sub {
0.000000,1,0.000000,my $var = $_[1];
0.000004,1,0.000004,"Scalar::Util::blessed($var) && $var\->isa(q[Type::Tiny])";
0.000000,0,0.000000,},
0.000000,0,0.000000,type_default => sub { require Types::Standard; return Types::Standard::Any() },
0.000000,0,0.000000,library         => __PACKAGE__,
0.000000,0,0.000000,_build_coercion => sub {
0.000000,0,0.000000,my $c = shift;
0.000000,0,0.000000,$c->add_type_coercions( _ForeignTypeConstraint(), \&to_TypeTiny );
0.000000,0,0.000000,$c->freeze;
0.000000,0,0.000000,},
0.000009,1,0.000009,);
0.000000,0,0.000000,} #/ sub TypeTiny
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ForeignTypeConstraint () {
0.000000,0,0.000000,return $cache{_ForeignTypeConstraint} if defined $cache{_ForeignTypeConstraint};
0.000000,0,0.000000,require Type::Tiny;
0.000000,0,0.000000,$cache{_ForeignTypeConstraint} = "Type::Tiny"->new(
0.000000,0,0.000000,name       => "_ForeignTypeConstraint",
0.000000,0,0.000000,constraint => \&_is_ForeignTypeConstraint,
0.000000,0,0.000000,inlined    => sub {
0.000000,0,0.000000,qq/ref($_[1]) && do { require Types::TypeTiny; Types::TypeTiny::_is_ForeignTypeConstraint($_[1]) }/;
0.000000,0,0.000000,},
0.000000,0,0.000000,library => __PACKAGE__,
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ sub _ForeignTypeConstraint
0.000000,0,0.000000,
0.000000,1,0.000000,my %ttt_cache;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _is_ForeignTypeConstraint {
0.000000,0,0.000000,my $t = @_ ? $_[0] : $_;
0.000000,0,0.000000,return !!1 if ref $t eq 'CODE';
0.000000,0,0.000000,if ( my $class = blessed $t ) {
0.000000,0,0.000000,return !!0 if $class->isa( "Type::Tiny" );
0.000000,0,0.000000,return !!1 if $class->isa( "Moose::Meta::TypeConstraint" );
0.000000,0,0.000000,return !!1 if $class->isa( "MooseX::Types::TypeDecorator" );
0.000000,0,0.000000,return !!1 if $class->isa( "Validation::Class::Simple" );
0.000000,0,0.000000,return !!1 if $class->isa( "Validation::Class" );
0.000000,0,0.000000,return !!1 if $t->can( "check" );
0.000000,0,0.000000,}
0.000000,0,0.000000,!!0;
0.000000,0,0.000000,} #/ sub _is_ForeignTypeConstraint
0.000000,0,0.000000,
0.000000,0,0.000000,sub to_TypeTiny {
0.000576,3550,0.000000,my $t = @_ ? $_[0] : $_;
0.000000,0,0.000000,
0.001037,3550,0.000000,return $t unless ( my $ref = ref $t );
0.009853,3470,0.000003,return $t if $ref =~ /^Type::Tiny\b/;
0.000000,0,0.000000,
0.000000,0,0.000000,return $ttt_cache{ refaddr( $t ) } if $ttt_cache{ refaddr( $t ) };
0.000000,0,0.000000,
0.000000,0,0.000000,#<<<
0.000000,0,0.000000,if ( my $class = blessed $t) {
0.000000,0,0.000000,return $t                                 if $class->isa( "Type::Tiny" );
0.000000,0,0.000000,return _TypeTinyFromMoose( $t )           if $class eq "MooseX::Types::TypeDecorator";      # needed before MooseX::Types 0.35.
0.000000,0,0.000000,return _TypeTinyFromMoose( $t )           if $class->isa( "Moose::Meta::TypeConstraint" );
0.000000,0,0.000000,return _TypeTinyFromMoose( $t )           if $class->isa( "MooseX::Types::TypeDecorator" );
0.000000,0,0.000000,return _TypeTinyFromMouse( $t )           if $class->isa( "Mouse::Meta::TypeConstraint" );
0.000000,0,0.000000,return _TypeTinyFromValidationClass( $t ) if $class->isa( "Validation::Class::Simple" );
0.000000,0,0.000000,return _TypeTinyFromValidationClass( $t ) if $class->isa( "Validation::Class" );
0.000000,0,0.000000,return $t->to_TypeTiny                    if $t->can( "DOES" ) && $t->DOES( "Type::Library::Compiler::TypeConstraint" ) && $t->can( "to_TypeTiny" );
0.000000,0,0.000000,return _TypeTinyFromGeneric( $t )         if $t->can( "check" );                            # i.e. Type::API::Constraint
0.000000,0,0.000000,} #/ if ( my $class = blessed...)
0.000000,0,0.000000,#>>>
0.000000,0,0.000000,
0.000000,0,0.000000,return _TypeTinyFromCodeRef( $t ) if $ref eq q(CODE);
0.000000,0,0.000000,
0.000000,0,0.000000,$t;
0.000000,0,0.000000,} #/ sub to_TypeTiny
0.000000,0,0.000000,
0.000000,0,0.000000,sub _TypeTinyFromMoose {
0.000000,0,0.000000,my $t = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ref $t->{"Types::TypeTiny::to_TypeTiny"} ) {
0.000000,0,0.000000,return $t->{"Types::TypeTiny::to_TypeTiny"};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $t->name ne '__ANON__' ) {
0.000000,0,0.000000,require Types::Standard;
0.000000,0,0.000000,my $ts = 'Types::Standard'->get_type( $t->name );
0.000000,0,0.000000,return $ts if $ts->{_is_core};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#<<<
0.000000,0,0.000000,my ( $tt_class, $tt_opts ) =
0.000000,0,0.000000,$t->can( 'parameterize' )                          ? _TypeTinyFromMoose_parameterizable( $t ) :
0.000000,0,0.000000,$t->isa( 'Moose::Meta::TypeConstraint::Enum' )     ? _TypeTinyFromMoose_enum( $t ) :
0.000000,0,0.000000,$t->isa( 'Moose::Meta::TypeConstraint::Class' )    ? _TypeTinyFromMoose_class( $t ) :
0.000000,0,0.000000,$t->isa( 'Moose::Meta::TypeConstraint::Role' )     ? _TypeTinyFromMoose_role( $t ) :
0.000000,0,0.000000,$t->isa( 'Moose::Meta::TypeConstraint::Union' )    ? _TypeTinyFromMoose_union( $t ) :
0.000000,0,0.000000,$t->isa( 'Moose::Meta::TypeConstraint::DuckType' ) ? _TypeTinyFromMoose_ducktype( $t ) :
0.000000,0,0.000000,_TypeTinyFromMoose_baseclass( $t );
0.000000,0,0.000000,#>>>
0.000000,0,0.000000,
0.000000,0,0.000000,# Standard stuff to do with all type constraints from Moose,
0.000000,0,0.000000,# regardless of variety.
0.000000,0,0.000000,$tt_opts->{moose_type}   = $t;
0.000000,0,0.000000,$tt_opts->{display_name} = $t->name;
0.000000,0,0.000000,$tt_opts->{message}      = sub { $t->get_message( $_ ) }
0.000000,0,0.000000,if $t->has_message;
0.000000,0,0.000000,
0.000000,0,0.000000,my $new = $tt_class->new( %$tt_opts );
0.000000,0,0.000000,$ttt_cache{ refaddr( $t ) } = $new;
0.000000,0,0.000000,weaken( $ttt_cache{ refaddr( $t ) } );
0.000000,0,0.000000,
0.000000,0,0.000000,$new->{coercion} = do {
0.000000,0,0.000000,require Type::Coercion::FromMoose;
0.000000,0,0.000000,'Type::Coercion::FromMoose'->new(
0.000000,0,0.000000,type_constraint => $new,
0.000000,0,0.000000,moose_coercion  => $t->coercion,
0.000000,0,0.000000,);
0.000000,0,0.000000,} if $t->has_coercion;
0.000000,0,0.000000,
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,} #/ sub _TypeTinyFromMoose
0.000000,0,0.000000,
0.000000,0,0.000000,sub _TypeTinyFromMoose_baseclass {
0.000000,0,0.000000,my $t = shift;
0.000000,0,0.000000,my %opts;
0.000000,0,0.000000,$opts{parent}     = to_TypeTiny( $t->parent ) if $t->has_parent;
0.000000,0,0.000000,$opts{constraint} = $t->constraint;
0.000000,0,0.000000,$opts{inlined}    = sub { shift; $t->_inline_check( @_ ) }
0.000000,0,0.000000,if $t->can( "can_be_inlined" ) && $t->can_be_inlined;
0.000000,0,0.000000,
0.000000,0,0.000000,# Cowardly refuse to inline types that need to close over stuff
0.000000,0,0.000000,if ( $opts{inlined} ) {
0.000000,0,0.000000,my %env = %{ $t->inline_environment || {} };
0.000000,0,0.000000,delete( $opts{inlined} ) if keys %env;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,require Type::Tiny;
0.000000,0,0.000000,return 'Type::Tiny' => \%opts;
0.000000,0,0.000000,} #/ sub _TypeTinyFromMoose_baseclass
0.000000,0,0.000000,
0.000000,0,0.000000,sub _TypeTinyFromMoose_union {
0.000000,0,0.000000,my $t = shift;
0.000000,0,0.000000,my @mapped = map _TypeTinyFromMoose( $_ ), @{ $t->type_constraints };
0.000000,0,0.000000,require Type::Tiny::Union;
0.000000,0,0.000000,return 'Type::Tiny::Union' => { type_constraints => \@mapped };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _TypeTinyFromMoose_enum {
0.000000,0,0.000000,my $t = shift;
0.000000,0,0.000000,require Type::Tiny::Enum;
0.000000,0,0.000000,return 'Type::Tiny::Enum' => { values => [ @{ $t->values } ] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _TypeTinyFromMoose_class {
0.000000,0,0.000000,my $t = shift;
0.000000,0,0.000000,require Type::Tiny::Class;
0.000000,0,0.000000,return 'Type::Tiny::Class' => { class => $t->class };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _TypeTinyFromMoose_role {
0.000000,0,0.000000,my $t = shift;
0.000000,0,0.000000,require Type::Tiny::Role;
0.000000,0,0.000000,return 'Type::Tiny::Role' => { role => $t->role };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _TypeTinyFromMoose_ducktype {
0.000000,0,0.000000,my $t = shift;
0.000000,0,0.000000,require Type::Tiny::Duck;
0.000000,0,0.000000,return 'Type::Tiny::Duck' => { methods => [ @{ $t->methods } ] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _TypeTinyFromMoose_parameterizable {
0.000000,0,0.000000,my $t = shift;
0.000000,0,0.000000,my ( $class, $opts ) = _TypeTinyFromMoose_baseclass( $t );
0.000000,0,0.000000,$opts->{constraint_generator} = sub {
0.000000,0,0.000000,
0.000000,0,0.000000,# convert args into Moose native types; not strictly necessary
0.000000,0,0.000000,my @args = map { is_TypeTiny( $_ ) ? $_->moose_type : $_ } @_;
0.000000,0,0.000000,_TypeTinyFromMoose( $t->parameterize( @args ) );
0.000000,0,0.000000,};
0.000000,0,0.000000,return ( $class, $opts );
0.000000,0,0.000000,} #/ sub _TypeTinyFromMoose_parameterizable
0.000000,0,0.000000,
0.000000,0,0.000000,sub _TypeTinyFromValidationClass {
0.000000,0,0.000000,my $t = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,require Type::Tiny;
0.000000,0,0.000000,require Types::Standard;
0.000000,0,0.000000,
0.000000,0,0.000000,my %opts = (
0.000000,0,0.000000,parent            => Types::Standard::HashRef(),
0.000000,0,0.000000,_validation_class => $t,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $t->VERSION >= "7.900048" ) {
0.000000,0,0.000000,$opts{constraint} = sub {
0.000000,0,0.000000,$t->params->clear;
0.000000,0,0.000000,$t->params->add( %$_ );
0.000000,0,0.000000,my $f = $t->filtering;
0.000000,0,0.000000,$t->filtering( 'off' );
0.000000,0,0.000000,my $r = eval { $t->validate };
0.000000,0,0.000000,$t->filtering( $f || 'pre' );
0.000000,0,0.000000,return $r;
0.000000,0,0.000000,};
0.000000,0,0.000000,$opts{message} = sub {
0.000000,0,0.000000,$t->params->clear;
0.000000,0,0.000000,$t->params->add( %$_ );
0.000000,0,0.000000,my $f = $t->filtering;
0.000000,0,0.000000,$t->filtering( 'off' );
0.000000,0,0.000000,my $r = ( eval { $t->validate } ? "OK" : $t->errors_to_string );
0.000000,0,0.000000,$t->filtering( $f || 'pre' );
0.000000,0,0.000000,return $r;
0.000000,0,0.000000,};
0.000000,0,0.000000,} #/ if ( $t->VERSION >= "7.900048")
0.000000,0,0.000000,else    # need to use hackish method
0.000000,0,0.000000,{
0.000000,0,0.000000,$opts{constraint} = sub {
0.000000,0,0.000000,$t->params->clear;
0.000000,0,0.000000,$t->params->add( %$_ );
0.000074,2,0.000037,no warnings "redefine";
0.000000,0,0.000000,local *Validation::Class::Directive::Filters::execute_filtering = sub { $_[0] };
0.000000,0,0.000000,eval { $t->validate };
0.000000,0,0.000000,};
0.000000,0,0.000000,$opts{message} = sub {
0.000000,0,0.000000,$t->params->clear;
0.000000,0,0.000000,$t->params->add( %$_ );
0.000610,2,0.000305,no warnings "redefine";
0.000000,0,0.000000,local *Validation::Class::Directive::Filters::execute_filtering = sub { $_[0] };
0.000000,0,0.000000,eval { $t->validate } ? "OK" : $t->errors_to_string;
0.000000,0,0.000000,};
0.000000,0,0.000000,} #/ else [ if ( $t->VERSION >= "7.900048")]
0.000000,0,0.000000,
0.000000,0,0.000000,require Type::Tiny;
0.000000,0,0.000000,my $new = "Type::Tiny"->new( %opts );
0.000000,0,0.000000,
0.000000,0,0.000000,$new->coercion->add_type_coercions(
0.000000,0,0.000000,Types::Standard::HashRef() => sub {
0.000000,0,0.000000,my %params = %$_;
0.000000,0,0.000000,for my $k ( keys %params ) { delete $params{$_} unless $t->get_fields( $k ) }
0.000000,0,0.000000,$t->params->clear;
0.000000,0,0.000000,$t->params->add( %params );
0.000000,0,0.000000,eval { $t->validate };
0.000000,0,0.000000,$t->get_hash;
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$ttt_cache{ refaddr( $t ) } = $new;
0.000000,0,0.000000,weaken( $ttt_cache{ refaddr( $t ) } );
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,} #/ sub _TypeTinyFromValidationClass
0.000000,0,0.000000,
0.000000,0,0.000000,sub _TypeTinyFromGeneric {
0.000000,0,0.000000,my $t = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,my %opts = (
0.000000,0,0.000000,constraint => sub { $t->check( @_ ? @_ : $_ ) },
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$opts{message} = sub { $t->get_message( @_ ? @_ : $_ ) }
0.000000,0,0.000000,if $t->can( "get_message" );
0.000000,0,0.000000,
0.000000,0,0.000000,$opts{display_name} = $t->name if $t->can( "name" );
0.000000,0,0.000000,
0.000000,0,0.000000,$opts{coercion} = sub { $t->coerce( @_ ? @_ : $_ ) }
0.000000,0,0.000000,if $t->can( "has_coercion" )
0.000000,0,0.000000,&& $t->has_coercion
0.000000,0,0.000000,&& $t->can( "coerce" );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $t->can( 'can_be_inlined' )
0.000000,0,0.000000,&& $t->can_be_inlined
0.000000,0,0.000000,&& $t->can( 'inline_check' ) )
0.000000,0,0.000000,{
0.000000,0,0.000000,$opts{inlined} = sub { $t->inline_check( $_[1] ) };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,require Type::Tiny;
0.000000,0,0.000000,my $new = "Type::Tiny"->new( %opts );
0.000000,0,0.000000,$ttt_cache{ refaddr( $t ) } = $new;
0.000000,0,0.000000,weaken( $ttt_cache{ refaddr( $t ) } );
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,} #/ sub _TypeTinyFromGeneric
0.000000,0,0.000000,
0.000000,0,0.000000,sub _TypeTinyFromMouse {
0.000000,0,0.000000,my $t = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,my %opts = (
0.000000,0,0.000000,constraint => sub { $t->check( @_       ? @_ : $_ ) },
0.000000,0,0.000000,message    => sub { $t->get_message( @_ ? @_ : $_ ) },
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$opts{display_name} = $t->name if $t->can( "name" );
0.000000,0,0.000000,
0.000000,0,0.000000,$opts{coercion} = sub { $t->coerce( @_ ? @_ : $_ ) }
0.000000,0,0.000000,if $t->can( "has_coercion" )
0.000000,0,0.000000,&& $t->has_coercion
0.000000,0,0.000000,&& $t->can( "coerce" );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $t->{'constraint_generator'} ) {
0.000000,0,0.000000,$opts{constraint_generator} = sub {
0.000000,0,0.000000,
0.000000,0,0.000000,# convert args into Moose native types; not strictly necessary
0.000000,0,0.000000,my @args = map { is_TypeTiny( $_ ) ? $_->mouse_type : $_ } @_;
0.000000,0,0.000000,_TypeTinyFromMouse( $t->parameterize( @args ) );
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,require Type::Tiny;
0.000000,0,0.000000,my $new = "Type::Tiny"->new( %opts );
0.000000,0,0.000000,$ttt_cache{ refaddr( $t ) } = $new;
0.000000,0,0.000000,weaken( $ttt_cache{ refaddr( $t ) } );
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,} #/ sub _TypeTinyFromMouse
0.000000,0,0.000000,
0.000000,0,0.000000,my $QFS;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _TypeTinyFromCodeRef {
0.000000,0,0.000000,my $t = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,my %opts = (
0.000000,0,0.000000,constraint => sub {
0.000000,0,0.000000,return !!eval { $t->( $_ ) };
0.000000,0,0.000000,},
0.000000,0,0.000000,message => sub {
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,eval { $t->( $_ ); 1 } or do { chomp $@; return $@ if $@ };
0.000000,0,0.000000,return sprintf( '%s did not pass type constraint', Type::Tiny::_dd( $_ ) );
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $QFS ||= "Sub::Quote"->can( "quoted_from_sub" ) ) {
0.000000,0,0.000000,my ( undef, $perlstring, $captures ) = @{ $QFS->( $t ) || [] };
0.000000,0,0.000000,if ( $perlstring ) {
0.000000,0,0.000000,$perlstring = "!!eval{ $perlstring }";
0.000000,0,0.000000,$opts{inlined} = sub {
0.000000,0,0.000000,my $var = $_[1];
0.000000,0,0.000000,Sub::Quote::inlinify(
0.000000,0,0.000000,$perlstring,
0.000000,0,0.000000,$var,
0.000000,0,0.000000,$var eq q($_) ? '' : "local \$_ = $var;",
0.000000,0,0.000000,1,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,if $perlstring && !$captures;
0.000000,0,0.000000,} #/ if ( $perlstring )
0.000000,0,0.000000,} #/ if ( $QFS ||= "Sub::Quote"...)
0.000000,0,0.000000,
0.000000,0,0.000000,require Type::Tiny;
0.000000,0,0.000000,my $new = "Type::Tiny"->new( %opts );
0.000000,0,0.000000,$ttt_cache{ refaddr( $t ) } = $new;
0.000000,0,0.000000,weaken( $ttt_cache{ refaddr( $t ) } );
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,} #/ sub _TypeTinyFromCodeRef
0.000000,0,0.000000,
0.000010,1,0.000010,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
