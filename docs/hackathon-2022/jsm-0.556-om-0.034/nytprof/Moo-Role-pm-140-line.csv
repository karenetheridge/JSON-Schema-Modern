# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Moo::Role;
0.000025,2,0.000013,use strict;
0.000026,2,0.000013,use warnings;
0.000000,0,0.000000,
0.000000,1,0.000000,use Moo::_Utils qw(
0.000000,0,0.000000,_check_tracked
0.000000,0,0.000000,_getglob
0.000000,0,0.000000,_getstash
0.000000,0,0.000000,_install_coderef
0.000000,0,0.000000,_install_modifier
0.000000,0,0.000000,_install_tracked
0.000000,0,0.000000,_load_module
0.000000,0,0.000000,_name_coderef
0.000000,0,0.000000,_set_loaded
0.000000,0,0.000000,_unimport_coderefs
0.000019,1,0.000019,);
0.000011,2,0.000005,use Carp qw(croak);
0.000020,2,0.000010,use Role::Tiny ();
0.000027,1,0.000027,BEGIN { our @ISA = qw(Role::Tiny) }
0.000000,0,0.000000,BEGIN {
0.000002,1,0.000002,our @CARP_NOT = qw(
0.000000,0,0.000000,Method::Generate::Accessor
0.000000,0,0.000000,Method::Generate::Constructor
0.000000,0,0.000000,Moo::sification
0.000000,0,0.000000,Moo::_Utils
0.000000,0,0.000000,Role::Tiny
0.000000,0,0.000000,);
0.000058,1,0.000058,}
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '2.005004';
0.000000,1,0.000000,$VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000001,1,0.000001,require Moo::sification;
0.000002,1,0.000002,Moo::sification->import;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,*INFO = \%Role::Tiny::INFO;
0.000000,1,0.000000,*APPLIED_TO = \%Role::Tiny::APPLIED_TO;
0.000000,1,0.000000,*COMPOSED = \%Role::Tiny::COMPOSED;
0.000002,1,0.000002,*ON_ROLE_CREATE = \@Role::Tiny::ON_ROLE_CREATE;
0.001280,1,0.001280,}
0.000000,0,0.000000,
0.000000,0,0.000000,our %INFO;
0.000000,0,0.000000,our %APPLIED_TO;
0.000000,0,0.000000,our %APPLY_DEFAULTS;
0.000000,0,0.000000,our %COMPOSED;
0.000000,0,0.000000,our @ON_ROLE_CREATE;
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000002,2,0.000001,my $target = caller;
0.000002,2,0.000001,if ($Moo::MAKERS{$target} and $Moo::MAKERS{$target}{is_class}) {
0.000000,0,0.000000,croak "Cannot import Moo::Role into a Moo class";
0.000000,0,0.000000,}
0.000010,2,0.000005,_set_loaded(caller);
0.000012,2,0.000006,goto &Role::Tiny::import;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _accessor_maker_for {
0.000000,0,0.000000,my ($class, $target) = @_;
0.000000,0,0.000000,($INFO{$target}{accessor_maker} ||= do {
0.000000,0,0.000000,require Method::Generate::Accessor;
0.000000,0,0.000000,Method::Generate::Accessor->new
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_subs {
0.000000,2,0.000000,my ($me, $target) = @_;
0.000009,2,0.000005,my %install = $me->_gen_subs($target);
0.000000,0,0.000000,_install_tracked $target => $_ => $install{$_}
0.000053,2,0.000027,for sort keys %install;
0.000014,2,0.000007,*{_getglob("${target}::meta")} = $me->can('meta');
0.000006,2,0.000003,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _require_module {
0.000102,24,0.000004,_load_module($_[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _gen_subs {
0.000001,2,0.000000,my ($me, $target) = @_;
0.000000,0,0.000000,return (
0.000000,0,0.000000,has => sub {
0.000000,0,0.000000,my $name_proto = shift;
0.000000,0,0.000000,my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
0.000000,0,0.000000,if (@_ % 2 != 0) {
0.000000,0,0.000000,croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
0.000000,0,0.000000,. " attribute(s): even number of arguments expected, got " . scalar @_)
0.000000,0,0.000000,}
0.000000,0,0.000000,my %spec = @_;
0.000000,0,0.000000,foreach my $name (@name_proto) {
0.000000,0,0.000000,my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
0.000000,0,0.000000,$me->_accessor_maker_for($target)
0.000000,0,0.000000,->generate_method($target, $name, $spec_ref);
0.000000,0,0.000000,push @{$INFO{$target}{attributes}||=[]}, $name, $spec_ref;
0.000000,0,0.000000,$me->_maybe_reset_handlemoose($target);
0.000000,0,0.000000,}
0.000000,0,0.000000,},
0.000000,0,0.000000,(map {
0.000002,6,0.000000,my $type = $_;
0.000000,0,0.000000,(
0.000000,0,0.000000,$type => sub {
0.000003,2,0.000002,push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
0.000007,2,0.000003,$me->_maybe_reset_handlemoose($target);
0.000000,0,0.000000,},
0.000000,0,0.000000,)
0.000016,6,0.000003,} qw(before after around)),
0.000000,0,0.000000,requires => sub {
0.000003,1,0.000003,push @{$INFO{$target}{requires}||=[]}, @_;
0.000005,1,0.000005,$me->_maybe_reset_handlemoose($target);
0.000000,0,0.000000,},
0.000000,0,0.000000,with => sub {
0.000000,0,0.000000,$me->apply_roles_to_package($target, @_);
0.000000,0,0.000000,$me->_maybe_reset_handlemoose($target);
0.000000,0,0.000000,},
0.000043,2,0.000022,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @ON_ROLE_CREATE, sub {
0.000000,4,0.000000,my $target = shift;
0.000018,4,0.000004,if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
0.000000,0,0.000000,Moo::HandleMoose::inject_fake_metaclass_for($target);
0.000000,0,0.000000,}
0.000002,1,0.000002,};
0.000000,0,0.000000,
0.000000,0,0.000000,# duplicate from Moo::Object
0.000000,0,0.000000,sub meta {
0.000000,0,0.000000,require Moo::HandleMoose::FakeMetaClass;
0.000000,0,0.000000,my $class = ref($_[0])||$_[0];
0.000000,0,0.000000,bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unimport {
0.000000,0,0.000000,my $target = caller;
0.000000,0,0.000000,_unimport_coderefs($target);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _maybe_reset_handlemoose {
0.000001,3,0.000000,my ($class, $target) = @_;
0.000010,3,0.000003,if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
0.000000,0,0.000000,Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _non_methods {
0.000003,4,0.000001,my $self = shift;
0.000000,4,0.000000,my ($role) = @_;
0.000000,0,0.000000,
0.000011,4,0.000003,my $non_methods = $self->SUPER::_non_methods(@_);
0.000000,0,0.000000,
0.000008,4,0.000002,my $all_subs = $self->_all_subs($role);
0.000000,0,0.000000,$non_methods->{$_} = $all_subs->{$_}
0.000014,4,0.000003,for _check_tracked($role, [ keys %$all_subs ]);
0.000000,0,0.000000,
0.000012,4,0.000003,return $non_methods;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_role {
0.000012,34,0.000000,my ($self, $role) = @_;
0.000052,34,0.000002,$self->_inhale_if_moose($role);
0.000085,34,0.000002,$self->SUPER::is_role($role);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inhale_if_moose {
0.000015,34,0.000000,my ($self, $role) = @_;
0.000007,34,0.000000,my $meta;
0.000407,34,0.000012,if (!$self->SUPER::is_role($role)
0.000000,0,0.000000,and (
0.000000,0,0.000000,$INC{"Moose.pm"}
0.000000,0,0.000000,and $meta = Class::MOP::class_of($role)
0.000000,0,0.000000,and ref $meta ne 'Moo::HandleMoose::FakeMetaClass'
0.000000,0,0.000000,and $meta->isa('Moose::Meta::Role')
0.000000,0,0.000000,)
0.000000,0,0.000000,or (
0.000000,0,0.000000,Mouse::Util->can('find_meta')
0.000000,0,0.000000,and $meta = Mouse::Util::find_meta($role)
0.000000,0,0.000000,and $meta->isa('Mouse::Meta::Role')
0.000000,0,0.000000,)
0.000000,0,0.000000,) {
0.000000,0,0.000000,my $is_mouse = $meta->isa('Mouse::Meta::Role');
0.000000,0,0.000000,$INFO{$role}{methods} = {
0.000000,0,0.000000,map +($_ => $role->can($_)),
0.000000,0,0.000000,grep $role->can($_),
0.000000,0,0.000000,grep !($is_mouse && $_ eq 'meta'),
0.000000,0,0.000000,grep !$meta->get_method($_)->isa('Class::MOP::Method::Meta'),
0.000000,0,0.000000,$meta->get_method_list
0.000000,0,0.000000,};
0.000000,0,0.000000,$APPLIED_TO{$role} = {
0.000000,0,0.000000,map +($_->name => 1), $meta->calculate_all_roles
0.000000,0,0.000000,};
0.000000,0,0.000000,$INFO{$role}{requires} = [ $meta->get_required_method_list ];
0.000000,0,0.000000,$INFO{$role}{attributes} = [
0.000000,0,0.000000,map +($_ => do {
0.000000,0,0.000000,my $attr = $meta->get_attribute($_);
0.000000,0,0.000000,my $spec = { %{ $is_mouse ? $attr : $attr->original_options } };
0.000000,0,0.000000,
0.000000,0,0.000000,if ($spec->{isa}) {
0.000000,0,0.000000,require Sub::Quote;
0.000000,0,0.000000,
0.000000,0,0.000000,my $get_constraint = do {
0.000000,0,0.000000,my $pkg = $is_mouse
0.000000,0,0.000000,? 'Mouse::Util::TypeConstraints'
0.000000,0,0.000000,: 'Moose::Util::TypeConstraints';
0.000000,0,0.000000,_load_module($pkg);
0.000000,0,0.000000,$pkg->can('find_or_create_isa_type_constraint');
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,my $tc = $get_constraint->($spec->{isa});
0.000000,0,0.000000,my $check = $tc->_compiled_type_constraint;
0.000000,0,0.000000,my $tc_var = '$_check_for_'.Sub::Quote::sanitize_identifier($tc->name);
0.000000,0,0.000000,
0.000000,0,0.000000,$spec->{isa} = Sub::Quote::quote_sub(
0.000000,0,0.000000,qq{
0.000000,0,0.000000,&${tc_var} or Carp::croak "Type constraint failed for \$_[0]"
0.000000,0,0.000000,},
0.000000,0,0.000000,{ $tc_var => \$check },
0.000000,0,0.000000,{
0.000000,0,0.000000,package => $role,
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($spec->{coerce}) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Mouse has _compiled_type_coercion straight on the TC object
0.000000,0,0.000000,$spec->{coerce} = $tc->${\(
0.000000,0,0.000000,$tc->can('coercion')||sub { $_[0] }
0.000000,0,0.000000,)}->_compiled_type_coercion;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$spec;
0.000000,0,0.000000,}), $meta->get_attribute_list
0.000000,0,0.000000,];
0.000000,0,0.000000,my $mods = $INFO{$role}{modifiers} = [];
0.000000,0,0.000000,foreach my $type (qw(before after around)) {
0.000000,0,0.000000,# Mouse pokes its own internals so we have to fall back to doing
0.000000,0,0.000000,# the same thing in the absence of the Moose API method
0.000000,0,0.000000,my $map = $meta->${\(
0.000000,0,0.000000,$meta->can("get_${type}_method_modifiers_map")
0.000000,0,0.000000,or sub { shift->{"${type}_method_modifiers"} }
0.000000,0,0.000000,)};
0.000000,0,0.000000,foreach my $method (keys %$map) {
0.000000,0,0.000000,foreach my $mod (@{$map->{$method}}) {
0.000000,0,0.000000,push @$mods, [ $type => $method => $mod ];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$INFO{$role}{inhaled_from_moose} = 1;
0.000000,0,0.000000,$INFO{$role}{is_role} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _maybe_make_accessors {
0.000006,10,0.000001,my ($self, $target, $role) = @_;
0.000002,10,0.000000,my $m;
0.000070,10,0.000007,if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}
0.000000,0,0.000000,or $INC{"Moo.pm"}
0.000000,0,0.000000,and $m = Moo->_accessor_maker_for($target)
0.000000,0,0.000000,and ref($m) ne 'Method::Generate::Accessor') {
0.000000,0,0.000000,$self->_make_accessors($target, $role);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_accessors_if_moose {
0.000000,0,0.000000,my ($self, $target, $role) = @_;
0.000000,0,0.000000,if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}) {
0.000000,0,0.000000,$self->_make_accessors($target, $role);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_accessors {
0.000000,0,0.000000,my ($self, $target, $role) = @_;
0.000000,0,0.000000,my $acc_gen = ($Moo::MAKERS{$target}{accessor} ||= do {
0.000000,0,0.000000,require Method::Generate::Accessor;
0.000000,0,0.000000,Method::Generate::Accessor->new
0.000000,0,0.000000,});
0.000000,0,0.000000,my $con_gen = $Moo::MAKERS{$target}{constructor};
0.000000,0,0.000000,my @attrs = @{$INFO{$role}{attributes}||[]};
0.000000,0,0.000000,while (my ($name, $spec) = splice @attrs, 0, 2) {
0.000000,0,0.000000,# needed to ensure we got an index for an arrayref based generator
0.000000,0,0.000000,if ($con_gen) {
0.000000,0,0.000000,$spec = $con_gen->all_attribute_specs->{$name};
0.000000,0,0.000000,}
0.000000,0,0.000000,$acc_gen->generate_method($target, $name, $spec);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _undefer_subs {
0.000001,10,0.000000,my ($self, $target, $role) = @_;
0.000039,10,0.000004,if ($INC{'Sub/Defer.pm'}) {
0.000000,0,0.000000,Sub::Defer::undefer_package($role);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub role_application_steps {
0.000036,10,0.000004,qw(_handle_constructor _undefer_subs _maybe_make_accessors),
0.000000,0,0.000000,$_[0]->SUPER::role_application_steps;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_class_with_roles {
0.000001,1,0.000001,my ($me, $new_name, $superclass, @roles) = @_;
0.000002,1,0.000002,$Moo::MAKERS{$new_name} = {is_class => 1};
0.000002,1,0.000002,$me->SUPER::_build_class_with_roles($new_name, $superclass, @roles);
0.000000,0,0.000000,
0.000000,1,0.000000,if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
0.000000,0,0.000000,Moo::HandleMoose::inject_fake_metaclass_for($new_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my $lvl = 0;
0.000000,1,0.000000,my $file;
0.000030,1,0.000030,while ((my $pack, $file) = caller($lvl++)) {
0.000011,4,0.000003,if ($pack ne __PACKAGE__ && $pack ne 'Role::Tiny' && !$pack->isa($me)) {
0.000001,1,0.000001,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000002,1,0.000002,_set_loaded($new_name, $file || (caller)[1]);
0.000000,0,0.000000,
0.000003,1,0.000003,return $new_name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _gen_apply_defaults_for {
0.000001,1,0.000001,my ($me, $class, @roles) = @_;
0.000000,0,0.000000,
0.000002,1,0.000002,my @attrs = map @{$INFO{$_}{attributes}||[]}, @roles;
0.000000,0,0.000000,
0.000000,1,0.000000,my $con_gen;
0.000000,0,0.000000,my $m;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef
0.000003,1,0.000003,unless $INC{'Moo.pm'}
0.000000,0,0.000000,and @attrs
0.000000,0,0.000000,and $con_gen = Moo->_constructor_maker_for($class)
0.000000,0,0.000000,and $m = Moo->_accessor_maker_for($class);
0.000000,0,0.000000,
0.000000,0,0.000000,my $specs = $con_gen->all_attribute_specs;
0.000000,0,0.000000,
0.000000,0,0.000000,my %seen;
0.000000,0,0.000000,my %captures;
0.000000,0,0.000000,my @set;
0.000000,0,0.000000,while (my ($name, $spec) = splice @attrs, 0, 2) {
0.000000,0,0.000000,next
0.000000,0,0.000000,if $seen{$name}++;
0.000000,0,0.000000,
0.000000,0,0.000000,next
0.000000,0,0.000000,unless $m->has_eager_default($name, $spec);
0.000000,0,0.000000,
0.000000,0,0.000000,my ($has, $has_cap)
0.000000,0,0.000000,= $m->generate_simple_has('$_[0]', $name, $spec);
0.000000,0,0.000000,my ($set, $pop_cap)
0.000000,0,0.000000,= $m->generate_use_default('$_[0]', $name, $spec, $has);
0.000000,0,0.000000,
0.000000,0,0.000000,@captures{keys %$has_cap, keys %$pop_cap}
0.000000,0,0.000000,= (values %$has_cap, values %$pop_cap);
0.000000,0,0.000000,
0.000000,0,0.000000,push @set, $set;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return undef
0.000000,0,0.000000,if !@set;
0.000000,0,0.000000,
0.000000,0,0.000000,my $code = join '', map "($_),", @set;
0.000409,2,0.000204,no warnings 'void';
0.000000,0,0.000000,require Sub::Quote;
0.000000,0,0.000000,return Sub::Quote::quote_sub(
0.000000,0,0.000000,"${class}::_apply_defaults",
0.000000,0,0.000000,$code,
0.000000,0,0.000000,\%captures,
0.000000,0,0.000000,{
0.000000,0,0.000000,package => $class,
0.000000,0,0.000000,no_install => 1,
0.000000,0,0.000000,no_defer => 1,
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply_roles_to_object {
0.000005,7,0.000001,my ($me, $object, @roles) = @_;
0.000026,7,0.000004,my $new = $me->SUPER::apply_roles_to_object($object, @roles);
0.000007,7,0.000001,my $class = ref $new;
0.000049,7,0.000007,_set_loaded($class, (caller)[1]);
0.000000,0,0.000000,
0.000013,7,0.000002,if (!exists $APPLY_DEFAULTS{$class}) {
0.000000,0,0.000000,$APPLY_DEFAULTS{$class} = $me->_gen_apply_defaults_for($class, @roles);
0.000000,0,0.000000,}
0.000004,7,0.000001,if (my $apply_defaults = $APPLY_DEFAULTS{$class}) {
0.000000,0,0.000000,local $Carp::Internal{+__PACKAGE__} = 1;
0.000000,0,0.000000,local $Carp::Internal{$class} = 1;
0.000000,0,0.000000,$new->$apply_defaults;
0.000000,0,0.000000,}
0.000016,7,0.000002,return $new;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_single_modifier {
0.000002,2,0.000001,my ($me, @args) = @_;
0.000007,2,0.000003,_install_modifier(@args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_does {
0.000006,10,0.000001,my ($me, $to) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# If Role::Tiny actually installed the DOES, give it a name
0.000028,10,0.000003,my $new = $me->SUPER::_install_does($to) or return;
0.000040,10,0.000004,return _name_coderef("${to}::DOES", $new);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub does_role {
0.000124,603,0.000000,my ($proto, $role) = @_;
0.001542,603,0.000003,return 1
0.000000,0,0.000000,if Role::Tiny::does_role($proto, $role);
0.000002,7,0.000000,my $meta;
0.000005,7,0.000001,if ($INC{'Moose.pm'}
0.000000,0,0.000000,and $meta = Class::MOP::class_of($proto)
0.000000,0,0.000000,and ref $meta ne 'Moo::HandleMoose::FakeMetaClass'
0.000000,0,0.000000,and $meta->can('does_role')
0.000000,0,0.000000,) {
0.000000,0,0.000000,return $meta->does_role($role);
0.000000,0,0.000000,}
0.000019,7,0.000003,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _handle_constructor {
0.000005,10,0.000000,my ($me, $to, $role) = @_;
0.000009,10,0.000001,my $attr_info = $INFO{$role} && $INFO{$role}{attributes};
0.000014,10,0.000001,return unless $attr_info && @$attr_info;
0.000000,0,0.000000,my $info = $INFO{$to};
0.000000,0,0.000000,my $con = $INC{"Moo.pm"} && Moo->_constructor_maker_for($to);
0.000000,0,0.000000,my %existing
0.000000,0,0.000000,= $info ? @{$info->{attributes} || []}
0.000000,0,0.000000,: $con  ? %{$con->all_attribute_specs || {}}
0.000000,0,0.000000,: ();
0.000000,0,0.000000,
0.000000,0,0.000000,my @attr_info =
0.000000,0,0.000000,map { @{$attr_info}[$_, $_+1] }
0.000000,0,0.000000,grep { ! $existing{$attr_info->[$_]} }
0.000000,0,0.000000,map { 2 * $_ } 0..@$attr_info/2-1;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($info) {
0.000000,0,0.000000,push @{$info->{attributes}||=[]}, @attr_info;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($con) {
0.000000,0,0.000000,# shallow copy of the specs since the constructor will assign an index
0.000000,0,0.000000,$con->register_attribute_specs(map ref() ? { %$_ } : $_, @attr_info);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,__END__
