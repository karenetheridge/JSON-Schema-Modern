# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,#
0.000000,0,0.000000,# Data/Dumper.pm
0.000000,0,0.000000,#
0.000000,0,0.000000,# convert perl data structures into perl syntax suitable for both printing
0.000000,0,0.000000,# and eval
0.000000,0,0.000000,#
0.000000,0,0.000000,# Documentation at the __END__
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,0,0.000000,package Data::Dumper;
0.000000,0,0.000000,
0.000033,2,0.000017,use strict;
0.000030,2,0.000015,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,#$| = 1;
0.000000,0,0.000000,
0.000092,2,0.000046,use 5.008_001;
0.000001,1,0.000001,require Exporter;
0.000000,0,0.000000,
0.000026,2,0.000013,use constant IS_PRE_516_PERL => $] < 5.016;
0.000000,0,0.000000,
0.000231,2,0.000116,use Carp ();
0.000000,0,0.000000,
0.000000,0,0.000000,# Globals people alter.
0.000000,0,0.000000,our ( $Indent, $Trailingcomma, $Purity, $Pad, $Varname, $Useqq, $Terse, $Freezer,
0.000000,0,0.000000,$Toaster, $Deepcopy, $Quotekeys, $Bless, $Maxdepth, $Pair, $Sortkeys,
0.000000,0,0.000000,$Deparse, $Sparseseen, $Maxrecurse, $Useperl );
0.000000,0,0.000000,
0.000000,0,0.000000,our ( @ISA, @EXPORT, @EXPORT_OK, $VERSION );
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000001,1,0.000001,$VERSION = '2.184'; # Don't forget to set version and release
0.000000,0,0.000000,# date in POD below!
0.000000,0,0.000000,
0.000018,1,0.000018,@ISA = qw(Exporter);
0.000001,1,0.000001,@EXPORT = qw(Dumper);
0.000000,1,0.000000,@EXPORT_OK = qw(DumperX);
0.000000,0,0.000000,
0.000000,0,0.000000,# if run under miniperl, or otherwise lacking dynamic loading,
0.000000,0,0.000000,# XSLoader should be attempted to load, or the pure perl flag
0.000000,0,0.000000,# toggled on load failure.
0.000004,1,0.000004,eval {
0.000000,1,0.000000,require XSLoader;
0.000646,1,0.000646,XSLoader::load( 'Data::Dumper' );
0.000003,1,0.000003,1
0.000000,0,0.000000,}
0.000000,0,0.000000,or $Useperl = 1;
0.001399,1,0.001399,}
0.000000,0,0.000000,
0.000001,1,0.000001,my $IS_ASCII  = ord 'A' ==  65;
0.000000,0,0.000000,
0.000000,0,0.000000,# module vars and their defaults
0.000001,1,0.000001,$Indent     = 2         unless defined $Indent;
0.000000,1,0.000000,$Trailingcomma = 0      unless defined $Trailingcomma;
0.000000,1,0.000000,$Purity     = 0         unless defined $Purity;
0.000001,1,0.000001,$Pad        = ""        unless defined $Pad;
0.000000,1,0.000000,$Varname    = "VAR"     unless defined $Varname;
0.000000,1,0.000000,$Useqq      = 0         unless defined $Useqq;
0.000000,1,0.000000,$Terse      = 0         unless defined $Terse;
0.000001,1,0.000001,$Freezer    = ""        unless defined $Freezer;
0.000000,1,0.000000,$Toaster    = ""        unless defined $Toaster;
0.000000,1,0.000000,$Deepcopy   = 0         unless defined $Deepcopy;
0.000000,1,0.000000,$Quotekeys  = 1         unless defined $Quotekeys;
0.000000,1,0.000000,$Bless      = "bless"   unless defined $Bless;
0.000000,0,0.000000,#$Expdepth   = 0         unless defined $Expdepth;
0.000000,1,0.000000,$Maxdepth   = 0         unless defined $Maxdepth;
0.000000,1,0.000000,$Pair       = ' => '    unless defined $Pair;
0.000000,1,0.000000,$Useperl    = 0         unless defined $Useperl;
0.000000,1,0.000000,$Sortkeys   = 0         unless defined $Sortkeys;
0.000000,1,0.000000,$Deparse    = 0         unless defined $Deparse;
0.000000,1,0.000000,$Sparseseen = 0         unless defined $Sparseseen;
0.000000,1,0.000000,$Maxrecurse = 1000      unless defined $Maxrecurse;
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# expects an arrayref of values to be dumped.
0.000000,0,0.000000,# can optionally pass an arrayref of names for the values.
0.000000,0,0.000000,# names must have leading $ sign stripped. begin the name with *
0.000000,0,0.000000,# to cause output of arrays and hashes rather than refs.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my($c, $v, $n) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak("Usage:  PACKAGE->new(ARRAYREF, [ARRAYREF])")
0.000000,0,0.000000,unless (defined($v) && (ref($v) eq 'ARRAY'));
0.000000,0,0.000000,$n = [] unless (defined($n) && (ref($n) eq 'ARRAY'));
0.000000,0,0.000000,
0.000000,0,0.000000,my($s) = {
0.000000,0,0.000000,level      => 0,           # current recursive depth
0.000000,0,0.000000,indent     => $Indent,     # various styles of indenting
0.000000,0,0.000000,trailingcomma => $Trailingcomma, # whether to add comma after last elem
0.000000,0,0.000000,pad        => $Pad,        # all lines prefixed by this string
0.000000,0,0.000000,xpad       => "",          # padding-per-level
0.000000,0,0.000000,apad       => "",          # added padding for hash keys n such
0.000000,0,0.000000,sep        => "",          # list separator
0.000000,0,0.000000,pair       => $Pair,    # hash key/value separator: defaults to ' => '
0.000000,0,0.000000,seen       => {},          # local (nested) refs (id => [name, val])
0.000000,0,0.000000,todump     => $v,          # values to dump []
0.000000,0,0.000000,names      => $n,          # optional names for values []
0.000000,0,0.000000,varname    => $Varname,    # prefix to use for tagging nameless ones
0.000000,0,0.000000,purity     => $Purity,     # degree to which output is evalable
0.000000,0,0.000000,useqq      => $Useqq,      # use "" for strings (backslashitis ensues)
0.000000,0,0.000000,terse      => $Terse,      # avoid name output (where feasible)
0.000000,0,0.000000,freezer    => $Freezer,    # name of Freezer method for objects
0.000000,0,0.000000,toaster    => $Toaster,    # name of method to revive objects
0.000000,0,0.000000,deepcopy   => $Deepcopy,   # do not cross-ref, except to stop recursion
0.000000,0,0.000000,quotekeys  => $Quotekeys,  # quote hash keys
0.000000,0,0.000000,'bless'    => $Bless,    # keyword to use for "bless"
0.000000,0,0.000000,#        expdepth   => $Expdepth,   # cutoff depth for explicit dumping
0.000000,0,0.000000,maxdepth   => $Maxdepth,   # depth beyond which we give up
0.000000,0,0.000000,maxrecurse => $Maxrecurse, # depth beyond which we abort
0.000000,0,0.000000,useperl    => $Useperl,    # use the pure Perl implementation
0.000000,0,0.000000,sortkeys   => $Sortkeys,   # flag or filter for sorting hash keys
0.000000,0,0.000000,deparse    => $Deparse,    # use B::Deparse for coderefs
0.000000,0,0.000000,noseen     => $Sparseseen, # do not populate the seen hash unless necessary
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,if ($Indent > 0) {
0.000000,0,0.000000,$s->{xpad} = "  ";
0.000000,0,0.000000,$s->{sep} = "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,return bless($s, $c);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Packed numeric addresses take less memory. Plus pack is faster than sprintf
0.000000,0,0.000000,
0.000000,0,0.000000,sub format_refaddr {
0.000000,0,0.000000,require Scalar::Util;
0.000000,0,0.000000,pack "J", Scalar::Util::refaddr(shift);
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# add-to or query the table of already seen references
0.000000,0,0.000000,#
0.000000,0,0.000000,sub Seen {
0.000000,0,0.000000,my($s, $g) = @_;
0.000000,0,0.000000,if (defined($g) && (ref($g) eq 'HASH'))  {
0.000000,0,0.000000,my($k, $v, $id);
0.000000,0,0.000000,while (($k, $v) = each %$g) {
0.000000,0,0.000000,if (defined $v) {
0.000000,0,0.000000,if (ref $v) {
0.000000,0,0.000000,$id = format_refaddr($v);
0.000000,0,0.000000,if ($k =~ /^[*](.*)$/) {
0.000000,0,0.000000,$k = (ref $v eq 'ARRAY') ? ( "\\\@" . $1 ) :
0.000000,0,0.000000,(ref $v eq 'HASH')  ? ( "\\\%" . $1 ) :
0.000000,0,0.000000,(ref $v eq 'CODE')  ? ( "\\\&" . $1 ) :
0.000000,0,0.000000,(   "\$" . $1 ) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($k !~ /^\$/) {
0.000000,0,0.000000,$k = "\$" . $k;
0.000000,0,0.000000,}
0.000000,0,0.000000,$s->{seen}{$id} = [$k, $v];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Carp::carp("Only refs supported, ignoring non-ref item \$$k");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Carp::carp("Value of ref must be defined; ignoring undefined item \$$k");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return $s;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return map { @$_ } values %{$s->{seen}};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# set or query the values to be dumped
0.000000,0,0.000000,#
0.000000,0,0.000000,sub Values {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,if (defined($v)) {
0.000000,0,0.000000,if (ref($v) eq 'ARRAY')  {
0.000000,0,0.000000,$s->{todump} = [@$v];        # make a copy
0.000000,0,0.000000,return $s;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Carp::croak("Argument to Values, if provided, must be array ref");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return @{$s->{todump}};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# set or query the names of the values to be dumped
0.000000,0,0.000000,#
0.000000,0,0.000000,sub Names {
0.000000,0,0.000000,my($s, $n) = @_;
0.000000,0,0.000000,if (defined($n)) {
0.000000,0,0.000000,if (ref($n) eq 'ARRAY') {
0.000000,0,0.000000,$s->{names} = [@$n];         # make a copy
0.000000,0,0.000000,return $s;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Carp::croak("Argument to Names, if provided, must be array ref");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return @{$s->{names}};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub DESTROY {}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Dump {
0.000000,0,0.000000,return &Dumpxs
0.000000,0,0.000000,unless $Data::Dumper::Useperl || (ref($_[0]) && $_[0]->{useperl})
0.000000,0,0.000000,# Use pure perl version on earlier releases on EBCDIC platforms
0.000000,0,0.000000,|| (! $IS_ASCII && $] lt 5.021_010);
0.000000,0,0.000000,return &Dumpperl;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# dump the refs in the current dumper object.
0.000000,0,0.000000,# expects same args as new() if called via package name.
0.000000,0,0.000000,#
0.000000,0,0.000000,our @post;
0.000000,0,0.000000,sub Dumpperl {
0.000000,0,0.000000,my($s) = shift;
0.000000,0,0.000000,my(@out, $val, $name);
0.000000,0,0.000000,my($i) = 0;
0.000000,0,0.000000,local(@post);
0.000000,0,0.000000,
0.000000,0,0.000000,$s = $s->new(@_) unless ref $s;
0.000000,0,0.000000,
0.000000,0,0.000000,for $val (@{$s->{todump}}) {
0.000000,0,0.000000,@post = ();
0.000000,0,0.000000,$name = $s->{names}[$i++];
0.000000,0,0.000000,$name = $s->_refine_name($name, $val, $i);
0.000000,0,0.000000,
0.000000,0,0.000000,my $valstr;
0.000000,0,0.000000,{
0.000000,0,0.000000,local($s->{apad}) = $s->{apad};
0.000000,0,0.000000,$s->{apad} .= ' ' x (length($name) + 3) if $s->{indent} >= 2 and !$s->{terse};
0.000000,0,0.000000,$valstr = $s->_dump($val, $name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valstr = "$name = " . $valstr . ';' if @post or !$s->{terse};
0.000000,0,0.000000,my $out = $s->_compose_out($valstr, \@post);
0.000000,0,0.000000,
0.000000,0,0.000000,push @out, $out;
0.000000,0,0.000000,}
0.000000,0,0.000000,return wantarray ? @out : join('', @out);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# wrap string in single quotes (escaping if needed)
0.000000,0,0.000000,sub _quote {
0.000000,0,0.000000,my $val = shift;
0.000000,0,0.000000,$val =~ s/([\\\'])/\\$1/g;
0.000000,0,0.000000,return  "'" . $val .  "'";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Old Perls (5.14-) have trouble resetting vstring magic when it is no
0.000000,0,0.000000,# longer valid.
0.002725,2,0.001362,use constant _bad_vsmg => defined &_vstring && (_vstring(~v0)||'') eq "v0";
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# twist, toil and turn;
0.000000,0,0.000000,# and recurse, of course.
0.000000,0,0.000000,# sometimes sordidly;
0.000000,0,0.000000,# and curse if no recourse.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub _dump {
0.000000,0,0.000000,my($s, $val, $name) = @_;
0.000000,0,0.000000,my($out, $type, $id, $sname);
0.000000,0,0.000000,
0.000000,0,0.000000,$type = ref $val;
0.000000,0,0.000000,$out = "";
0.000000,0,0.000000,
0.000000,0,0.000000,if ($type) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Call the freezer method if it's specified and the object has the
0.000000,0,0.000000,# method.  Trap errors and warn() instead of die()ing, like the XS
0.000000,0,0.000000,# implementation.
0.000000,0,0.000000,my $freezer = $s->{freezer};
0.000000,0,0.000000,if ($freezer and UNIVERSAL::can($val, $freezer)) {
0.000000,0,0.000000,eval { $val->$freezer() };
0.000000,0,0.000000,warn "WARNING(Freezer method call failed): $@" if $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,require Scalar::Util;
0.000000,0,0.000000,my $realpack = Scalar::Util::blessed($val);
0.000000,0,0.000000,my $realtype = $realpack ? Scalar::Util::reftype($val) : ref $val;
0.000000,0,0.000000,$id = format_refaddr($val);
0.000000,0,0.000000,
0.000000,0,0.000000,# Note: By this point $name is always defined and of non-zero length.
0.000000,0,0.000000,# Keep a tab on it so that we do not fall into recursive pit.
0.000000,0,0.000000,if (exists $s->{seen}{$id}) {
0.000000,0,0.000000,if ($s->{purity} and $s->{level} > 0) {
0.000000,0,0.000000,$out = ($realtype eq 'HASH')  ? '{}' :
0.000000,0,0.000000,($realtype eq 'ARRAY') ? '[]' :
0.000000,0,0.000000,'do{my $o}' ;
0.000000,0,0.000000,push @post, $name . " = " . $s->{seen}{$id}[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$out = $s->{seen}{$id}[0];
0.000000,0,0.000000,if ($name =~ /^([\@\%])/) {
0.000000,0,0.000000,my $start = $1;
0.000000,0,0.000000,if ($out =~ /^\\$start/) {
0.000000,0,0.000000,$out = substr($out, 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$out = $start . '{' . $out . '}';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return $out;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# store our name
0.000000,0,0.000000,$s->{seen}{$id} = [ (
0.000000,0,0.000000,($name =~ /^[@%]/)
0.000000,0,0.000000,? ('\\' . $name )
0.000000,0,0.000000,: ($realtype eq 'CODE' and $name =~ /^[*](.*)$/)
0.000000,0,0.000000,? ('\\&' . $1 )
0.000000,0,0.000000,: $name
0.000000,0,0.000000,), $val ];
0.000000,0,0.000000,}
0.000000,0,0.000000,my $no_bless = 0;
0.000000,0,0.000000,my $is_regex = 0;
0.000000,0,0.000000,if ( $realpack and ($] >= 5.009005 ? re::is_regexp($val) : $realpack eq 'Regexp') ) {
0.000000,0,0.000000,$is_regex = 1;
0.000000,0,0.000000,$no_bless = $realpack eq 'Regexp';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# If purity is not set and maxdepth is set, then check depth:
0.000000,0,0.000000,# if we have reached maximum depth, return the string
0.000000,0,0.000000,# representation of the thing we are currently examining
0.000000,0,0.000000,# at this depth (i.e., 'Foo=ARRAY(0xdeadbeef)').
0.000000,0,0.000000,if (!$s->{purity}
0.000000,0,0.000000,and defined($s->{maxdepth})
0.000000,0,0.000000,and $s->{maxdepth} > 0
0.000000,0,0.000000,and $s->{level} >= $s->{maxdepth})
0.000000,0,0.000000,{
0.000000,0,0.000000,return qq['$val'];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# avoid recursing infinitely [perl #122111]
0.000000,0,0.000000,if ($s->{maxrecurse} > 0
0.000000,0,0.000000,and $s->{level} >= $s->{maxrecurse}) {
0.000000,0,0.000000,die "Recursion limit of $s->{maxrecurse} exceeded";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# we have a blessed ref
0.000000,0,0.000000,my ($blesspad);
0.000000,0,0.000000,if ($realpack and !$no_bless) {
0.000000,0,0.000000,$out = $s->{'bless'} . '( ';
0.000000,0,0.000000,$blesspad = $s->{apad};
0.000000,0,0.000000,$s->{apad} .= '       ' if ($s->{indent} >= 2);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$s->{level}++;
0.000000,0,0.000000,my $ipad = $s->{xpad} x $s->{level};
0.000000,0,0.000000,
0.000000,0,0.000000,if ($is_regex) {
0.000000,0,0.000000,my $pat;
0.000000,0,0.000000,my $flags = "";
0.000000,0,0.000000,if (defined(*re::regexp_pattern{CODE})) {
0.000000,0,0.000000,($pat, $flags) = re::regexp_pattern($val);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$pat = "$val";
0.000000,0,0.000000,}
0.000000,0,0.000000,$pat =~ s <
0.000000,0,0.000000,{
0.000000,0,0.000000,$1 ? $1
0.000000,0,0.000000,: $2 ? '${\q($)}'
0.000000,0,0.000000,: '\\/'
0.000000,0,0.000000,}gex;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,$out .= "qr/$pat/$flags";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($realtype eq 'SCALAR' || $realtype eq 'REF'
0.000000,0,0.000000,|| $realtype eq 'VSTRING') {
0.000000,0,0.000000,if ($realpack) {
0.000000,0,0.000000,$out .= 'do{\\(my $o = ' . $s->_dump($$val, "\${$name}") . ')}';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$out .= '\\' . $s->_dump($$val, "\${$name}");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($realtype eq 'GLOB') {
0.000000,0,0.000000,$out .= '\\' . $s->_dump($$val, "*{$name}");
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($realtype eq 'ARRAY') {
0.000000,0,0.000000,my($pad, $mname);
0.000000,0,0.000000,my($i) = 0;
0.000000,0,0.000000,$out .= ($name =~ /^\@/) ? '(' : '[';
0.000000,0,0.000000,$pad = $s->{sep} . $s->{pad} . $s->{apad};
0.000000,0,0.000000,($name =~ /^\@(.*)$/) ? ($mname = "\$" . $1) :
0.000000,0,0.000000,# omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
0.000000,0,0.000000,($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
0.000000,0,0.000000,($mname = $name . '->');
0.000000,0,0.000000,$mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
0.000000,0,0.000000,for my $v (@$val) {
0.000000,0,0.000000,$sname = $mname . '[' . $i . ']';
0.000000,0,0.000000,$out .= $pad . $ipad . '#' . $i
0.000000,0,0.000000,if $s->{indent} >= 3;
0.000000,0,0.000000,$out .= $pad . $ipad . $s->_dump($v, $sname);
0.000000,0,0.000000,$out .= ","
0.000000,0,0.000000,if $i++ < $#$val
0.000000,0,0.000000,|| ($s->{trailingcomma} && $s->{indent} >= 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,$out .= $pad . ($s->{xpad} x ($s->{level} - 1)) if $i;
0.000000,0,0.000000,$out .= ($name =~ /^\@/) ? ')' : ']';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($realtype eq 'HASH') {
0.000000,0,0.000000,my ($k, $v, $pad, $lpad, $mname, $pair);
0.000000,0,0.000000,$out .= ($name =~ /^\%/) ? '(' : '{';
0.000000,0,0.000000,$pad = $s->{sep} . $s->{pad} . $s->{apad};
0.000000,0,0.000000,$lpad = $s->{apad};
0.000000,0,0.000000,$pair = $s->{pair};
0.000000,0,0.000000,($name =~ /^\%(.*)$/) ? ($mname = "\$" . $1) :
0.000000,0,0.000000,# omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
0.000000,0,0.000000,($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
0.000000,0,0.000000,($mname = $name . '->');
0.000000,0,0.000000,$mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
0.000000,0,0.000000,my $sortkeys = defined($s->{sortkeys}) ? $s->{sortkeys} : '';
0.000000,0,0.000000,my $keys = [];
0.000000,0,0.000000,if ($sortkeys) {
0.000000,0,0.000000,if (ref($s->{sortkeys}) eq 'CODE') {
0.000000,0,0.000000,$keys = $s->{sortkeys}($val);
0.000000,0,0.000000,unless (ref($keys) eq 'ARRAY') {
0.000000,0,0.000000,Carp::carp("Sortkeys subroutine did not return ARRAYREF");
0.000000,0,0.000000,$keys = [];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$keys = [ sort keys %$val ];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Ensure hash iterator is reset
0.000000,0,0.000000,keys(%$val);
0.000000,0,0.000000,
0.000000,0,0.000000,my $key;
0.000000,0,0.000000,while (($k, $v) = ! $sortkeys ? (each %$val) :
0.000000,0,0.000000,@$keys ? ($key = shift(@$keys), $val->{$key}) :
0.000000,0,0.000000,() )
0.000000,0,0.000000,{
0.000000,0,0.000000,my $nk = $s->_dump($k, "");
0.000000,0,0.000000,
0.000000,0,0.000000,# _dump doesn't quote numbers of this form
0.000000,0,0.000000,if ($s->{quotekeys} && $nk =~ /^(?:0|-?[1-9][0-9]{0,8})\z/) {
0.000000,0,0.000000,$nk = $s->{useqq} ? qq("$nk") : qq('$nk');
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (!$s->{quotekeys} and $nk =~ /^[\"\']([A-Za-z_]\w*)[\"\']$/) {
0.000000,0,0.000000,$nk = $1
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$sname = $mname . '{' . $nk . '}';
0.000000,0,0.000000,$out .= $pad . $ipad . $nk . $pair;
0.000000,0,0.000000,
0.000000,0,0.000000,# temporarily alter apad
0.000000,0,0.000000,$s->{apad} .= (" " x (length($nk) + 4))
0.000000,0,0.000000,if $s->{indent} >= 2;
0.000000,0,0.000000,$out .= $s->_dump($val->{$k}, $sname) . ",";
0.000000,0,0.000000,$s->{apad} = $lpad
0.000000,0,0.000000,if $s->{indent} >= 2;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (substr($out, -1) eq ',') {
0.000000,0,0.000000,chop $out if !$s->{trailingcomma} || !$s->{indent};
0.000000,0,0.000000,$out .= $pad . ($s->{xpad} x ($s->{level} - 1));
0.000000,0,0.000000,}
0.000000,0,0.000000,$out .= ($name =~ /^\%/) ? ')' : '}';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($realtype eq 'CODE') {
0.000000,0,0.000000,if ($s->{deparse}) {
0.000000,0,0.000000,require B::Deparse;
0.000000,0,0.000000,my $sub =  'sub ' . (B::Deparse->new)->coderef2text($val);
0.000000,0,0.000000,my $pad =  $s->{sep} . $s->{pad} . $s->{apad} . $s->{xpad} x ($s->{level} - 1);
0.000000,0,0.000000,$sub    =~ s/\n/$pad/gs;
0.000000,0,0.000000,$out   .=  $sub;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$out .= 'sub { "DUMMY" }';
0.000000,0,0.000000,Carp::carp("Encountered CODE ref, using dummy placeholder") if $s->{purity};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Carp::croak("Can't handle '$realtype' type");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($realpack and !$no_bless) { # we have a blessed ref
0.000000,0,0.000000,$out .= ', ' . _quote($realpack) . ' )';
0.000000,0,0.000000,$out .= '->' . $s->{toaster} . '()'
0.000000,0,0.000000,if $s->{toaster} ne '';
0.000000,0,0.000000,$s->{apad} = $blesspad;
0.000000,0,0.000000,}
0.000000,0,0.000000,$s->{level}--;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {                                 # simple scalar
0.000000,0,0.000000,
0.000000,0,0.000000,my $ref = \$_[1];
0.000000,0,0.000000,my $v;
0.000000,0,0.000000,# first, catalog the scalar
0.000000,0,0.000000,if ($name ne '') {
0.000000,0,0.000000,$id = format_refaddr($ref);
0.000000,0,0.000000,if (exists $s->{seen}{$id}) {
0.000000,0,0.000000,if ($s->{seen}{$id}[2]) {
0.000000,0,0.000000,$out = $s->{seen}{$id}[0];
0.000000,0,0.000000,#warn "[<$out]\n";
0.000000,0,0.000000,return "\${$out}";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,#warn "[>\\$name]\n";
0.000000,0,0.000000,$s->{seen}{$id} = ["\\$name", $ref];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$ref = \$val;
0.000000,0,0.000000,if (ref($ref) eq 'GLOB') {  # glob
0.000000,0,0.000000,my $name = substr($val, 1);
0.000000,0,0.000000,$name =~ s/^main::(?!\z)/::/;
0.000000,0,0.000000,if ($name =~ /\A(?:[A-Z_a-z][0-9A-Z_a-z]*)?::(?:[0-9A-Z_a-z]+::)*[0-9A-Z_a-z]*\z/ && $name ne 'main::') {
0.000000,0,0.000000,$sname = $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,local $s->{useqq} = IS_PRE_516_PERL && ($s->{useqq} || $name =~ /[^\x00-\x7f]/) ? 1 : $s->{useqq};
0.000000,0,0.000000,$sname = $s->_dump(
0.000000,0,0.000000,$name eq 'main::'
0.000000,0,0.000000,? ''
0.000000,0,0.000000,: $name,
0.000000,0,0.000000,"",
0.000000,0,0.000000,);
0.000000,0,0.000000,$sname = '{' . $sname . '}';
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($s->{purity}) {
0.000000,0,0.000000,my $k;
0.000000,0,0.000000,local ($s->{level}) = 0;
0.000000,0,0.000000,for $k (qw(SCALAR ARRAY HASH)) {
0.000000,0,0.000000,my $gval = *$val{$k};
0.000000,0,0.000000,next unless defined $gval;
0.000000,0,0.000000,next if $k eq "SCALAR" && ! defined $$gval;  # always there
0.000000,0,0.000000,
0.000000,0,0.000000,# _dump can push into @post, so we hold our place using $postlen
0.000000,0,0.000000,my $postlen = scalar @post;
0.000000,0,0.000000,$post[$postlen] = "\*$sname = ";
0.000000,0,0.000000,local ($s->{apad}) = " " x length($post[$postlen]) if $s->{indent} >= 2;
0.000000,0,0.000000,$post[$postlen] .= $s->_dump($gval, "\*$sname\{$k\}");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$out .= '*' . $sname;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (!defined($val)) {
0.000000,0,0.000000,$out .= "undef";
0.000000,0,0.000000,}
0.000000,0,0.000000,# This calls the XSUB _vstring (if the XS code is loaded). I'm not *sure* if
0.000000,0,0.000000,# if belongs in the "Pure Perl" implementation. It sort of depends on what
0.000000,0,0.000000,# was meant by "Pure Perl", as this subroutine already relies Scalar::Util
0.000000,0,0.000000,# loading, which means that it has an XS dependency. De facto, it's the
0.000000,0,0.000000,# "Pure Perl" implementation of dumping (which uses XS helper code), as
0.000000,0,0.000000,# opposed to the C implementation (which calls out to Perl helper code).
0.000000,0,0.000000,# So in that sense this is fine - it just happens to be a local XS helper.
0.000000,0,0.000000,elsif (defined &_vstring and $v = _vstring($val)
0.000000,0,0.000000,and !_bad_vsmg || eval $v eq $val) {
0.000000,0,0.000000,$out .= $v;
0.000000,0,0.000000,}
0.000000,0,0.000000,# However the confusion comes here - if we *can't* find our XS helper, we
0.000000,0,0.000000,# fall back to this code, which generates different (worse) results. That's
0.000000,0,0.000000,# better than nothing, *but* it means that if you run the regression tests
0.000000,0,0.000000,# with Dumper.so missing, the test for "vstrings" fails, because this code
0.000000,0,0.000000,# here generates a different result. So there are actually "three" different
0.000000,0,0.000000,# implementations of Data::Dumper (kind of sort of) but we only test two.
0.000000,0,0.000000,elsif (!defined &_vstring
0.000000,0,0.000000,and ref $ref eq 'VSTRING' || eval{Scalar::Util::isvstring($val)}) {
0.000000,0,0.000000,$out .= sprintf "v%vd", $val;
0.000000,0,0.000000,}
0.000000,0,0.000000,# \d here would treat "1\x{660}" as a safe decimal number
0.000000,0,0.000000,elsif ($val =~ /^(?:0|-?[1-9][0-9]{0,8})\z/) { # safe decimal number
0.000000,0,0.000000,$out .= $val;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {                 # string
0.000000,0,0.000000,if ($s->{useqq} or $val =~ tr/\0-\377//c) {
0.000000,0,0.000000,# Fall back to qq if there's Unicode
0.000000,0,0.000000,$out .= qquote($val, $s->{useqq});
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$out .= _quote($val);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($id) {
0.000000,0,0.000000,# if we made it this far, $id was added to seen list at current
0.000000,0,0.000000,# level, so remove it to get deep copies
0.000000,0,0.000000,if ($s->{deepcopy}) {
0.000000,0,0.000000,delete($s->{seen}{$id});
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($name) {
0.000000,0,0.000000,$s->{seen}{$id}[2] = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return $out;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# non-OO style of earlier version
0.000000,0,0.000000,#
0.000000,0,0.000000,sub Dumper {
0.000000,0,0.000000,return Data::Dumper->Dump([@_]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# compat stub
0.000000,0,0.000000,sub DumperX {
0.000000,0,0.000000,return Data::Dumper->Dumpxs([@_], []);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# reset the "seen" cache
0.000000,0,0.000000,#
0.000000,0,0.000000,sub Reset {
0.000000,0,0.000000,my($s) = shift;
0.000000,0,0.000000,$s->{seen} = {};
0.000000,0,0.000000,return $s;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Indent {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,if (@_ >= 2) {
0.000000,0,0.000000,if ($v == 0) {
0.000000,0,0.000000,$s->{xpad} = "";
0.000000,0,0.000000,$s->{sep} = "";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$s->{xpad} = "  ";
0.000000,0,0.000000,$s->{sep} = "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,$s->{indent} = $v;
0.000000,0,0.000000,return $s;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $s->{indent};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Trailingcomma {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{trailingcomma} = $v), return $s) : $s->{trailingcomma};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Pair {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{pair} = $v), return $s) : $s->{pair};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Pad {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{pad} = $v), return $s) : $s->{pad};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Varname {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{varname} = $v), return $s) : $s->{varname};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Purity {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{purity} = $v), return $s) : $s->{purity};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Useqq {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{useqq} = $v), return $s) : $s->{useqq};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Terse {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{terse} = $v), return $s) : $s->{terse};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Freezer {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{freezer} = $v), return $s) : $s->{freezer};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Toaster {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{toaster} = $v), return $s) : $s->{toaster};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Deepcopy {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{deepcopy} = $v), return $s) : $s->{deepcopy};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Quotekeys {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{quotekeys} = $v), return $s) : $s->{quotekeys};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Bless {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{'bless'} = $v), return $s) : $s->{'bless'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Maxdepth {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{'maxdepth'} = $v), return $s) : $s->{'maxdepth'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Maxrecurse {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{'maxrecurse'} = $v), return $s) : $s->{'maxrecurse'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Useperl {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{'useperl'} = $v), return $s) : $s->{'useperl'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Sortkeys {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{'sortkeys'} = $v), return $s) : $s->{'sortkeys'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Deparse {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{'deparse'} = $v), return $s) : $s->{'deparse'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Sparseseen {
0.000000,0,0.000000,my($s, $v) = @_;
0.000000,0,0.000000,@_ >= 2 ? (($s->{'noseen'} = $v), return $s) : $s->{'noseen'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# used by qquote below
0.000004,1,0.000004,my %esc = (
0.000000,0,0.000000,"\a" => "\\a",
0.000000,0,0.000000,"\b" => "\\b",
0.000000,0,0.000000,"\t" => "\\t",
0.000000,0,0.000000,"\n" => "\\n",
0.000000,0,0.000000,"\f" => "\\f",
0.000000,0,0.000000,"\r" => "\\r",
0.000000,0,0.000000,"\e" => "\\e",
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# The low controls are considered to be everything below SPACE, plus the
0.000000,0,0.000000,# outlier \c? control (but that wasn't properly in existence in early perls,
0.000000,0,0.000000,# so reconstruct its value here.  This abandons EBCDIC support for this
0.000000,0,0.000000,# character for perls below 5.8)
0.000017,1,0.000017,my $low_controls = join "", map { quotemeta chr $_ } 0.. (ord(" ") - 1);
0.000001,1,0.000001,$low_controls .= ($] < 5.008 || $IS_ASCII)
0.000000,0,0.000000,? "\x7f"
0.000000,0,0.000000,: chr utf8::unicode_to_native(0x9F);
0.000021,1,0.000021,my $low_controls_re = qr/[$low_controls]/;
0.000000,0,0.000000,
0.000000,0,0.000000,# put a string value in double quotes
0.000000,0,0.000000,sub qquote {
0.000000,0,0.000000,local($_) = shift;
0.000000,0,0.000000,s/([\\\"\@\$])/\\$1/g;
0.000000,0,0.000000,
0.000000,0,0.000000,# This efficiently changes the high ordinal characters to \x{} if the utf8
0.000000,0,0.000000,# flag is on.  On ASCII platforms, the high ordinals are all the
0.000000,0,0.000000,# non-ASCII's.  On EBCDIC platforms, we don't include in these the non-ASCII
0.000000,0,0.000000,# controls.
0.000472,2,0.000236,my $bytes; { use bytes; $bytes = length }
0.000000,0,0.000000,s/([^[:ascii:]$low_controls])/sprintf("\\x{%x}",ord($1))/ge
0.000000,0,0.000000,if $bytes > length;
0.000000,0,0.000000,
0.000000,0,0.000000,return qq("$_") unless /[[:^print:]]/;  # fast exit if only printables
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, there is at least one non-printable to output.  First, translate the
0.000000,0,0.000000,# escapes.
0.000000,0,0.000000,s/([\a\b\t\n\f\r\e])/$esc{$1}/g;
0.000000,0,0.000000,
0.000000,0,0.000000,# no need for 3 digits in escape for octals not followed by a digit.
0.000000,0,0.000000,s/($low_controls_re)(?!\d)/'\\'.sprintf('%o',ord($1))/eg;
0.000000,0,0.000000,
0.000000,0,0.000000,# But otherwise use 3 digits
0.000000,0,0.000000,s/($low_controls_re)/'\\'.sprintf('%03o',ord($1))/eg;
0.000000,0,0.000000,
0.000000,0,0.000000,# all but last branch below not supported --BEHAVIOR SUBJECT TO CHANGE--
0.000000,0,0.000000,my $high = shift || "";
0.000000,0,0.000000,if ($high eq "iso8859") {   # Doesn't escape the Latin1 printables
0.000000,0,0.000000,# Could use /u and [:cntrl:] etc, if khw were confident it worked in
0.000000,0,0.000000,# early early perls
0.000000,0,0.000000,s/([\200-\240])/'\\'.sprintf('%o',ord($1))/eg if $IS_ASCII;
0.000000,0,0.000000,} elsif ($high eq "utf8") {
0.000000,0,0.000000,#     Some discussion of what to do here is in
0.000000,0,0.000000,#       https://rt.perl.org/Ticket/Display.html?id=113088
0.000000,0,0.000000,#     use utf8;
0.000000,0,0.000000,#     $str =~ s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
0.000000,0,0.000000,} elsif ($high eq "8bit") {
0.000000,0,0.000000,# leave it as it is
0.000000,0,0.000000,} else {
0.000000,0,0.000000,s/([[:^ascii:]])/'\\'.sprintf('%03o',ord($1))/eg;
0.000000,0,0.000000,#s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return qq("$_");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _refine_name {
0.000000,0,0.000000,my $s = shift;
0.000000,0,0.000000,my ($name, $val, $i) = @_;
0.000000,0,0.000000,if (defined $name) {
0.000000,0,0.000000,if ($name =~ /^[*](.*)$/) {
0.000000,0,0.000000,if (defined $val) {
0.000000,0,0.000000,$name = (ref $val eq 'ARRAY') ? ( "\@" . $1 ) :
0.000000,0,0.000000,(ref $val eq 'HASH')  ? ( "\%" . $1 ) :
0.000000,0,0.000000,(ref $val eq 'CODE')  ? ( "\*" . $1 ) :
0.000000,0,0.000000,( "\$" . $1 ) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$name = "\$" . $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($name !~ /^\$/) {
0.000000,0,0.000000,$name = "\$" . $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else { # no names provided
0.000000,0,0.000000,$name = "\$" . $s->{varname} . $i;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _compose_out {
0.000000,0,0.000000,my $s = shift;
0.000000,0,0.000000,my ($valstr, $postref) = @_;
0.000000,0,0.000000,my $out = "";
0.000000,0,0.000000,$out .= $s->{pad} . $valstr . $s->{sep};
0.000000,0,0.000000,if (@{$postref}) {
0.000000,0,0.000000,$out .= $s->{pad} .
0.000000,0,0.000000,join(';' . $s->{sep} . $s->{pad}, @{$postref}) .
0.000000,0,0.000000,';' .
0.000000,0,0.000000,$s->{sep};
0.000000,0,0.000000,}
0.000000,0,0.000000,return $out;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000013,1,0.000013,1;
0.000000,0,0.000000,__END__
