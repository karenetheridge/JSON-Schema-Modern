# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package constant;
0.000028,2,0.000014,use 5.008;
0.000018,2,0.000009,use strict;
0.000213,2,0.000107,use warnings::register;
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '1.33';
0.000000,0,0.000000,our %declared;
0.000000,0,0.000000,
0.000000,0,0.000000,#=======================================================================
0.000000,0,0.000000,
0.000000,0,0.000000,# Some names are evil choices.
0.000006,1,0.000006,my %keywords = map +($_, 1), qw{ BEGIN INIT CHECK END DESTROY AUTOLOAD };
0.000001,1,0.000001,$keywords{UNITCHECK}++ if $] > 5.009;
0.000000,0,0.000000,
0.000004,1,0.000004,my %forced_into_main = map +($_, 1),
0.000000,0,0.000000,qw{ STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG };
0.000000,0,0.000000,
0.000002,1,0.000002,my %forbidden = (%keywords, %forced_into_main);
0.000000,0,0.000000,
0.000007,1,0.000007,my $normal_constant_name = qr/^_?[^\W_0-9]\w*\z/;
0.000002,1,0.000002,my $tolerable = qr/^[A-Za-z_]\w*\z/;
0.000002,1,0.000002,my $boolean = qr/^[01]?\z/;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,# We'd like to do use constant _CAN_PCS => $] > 5.009002
0.000000,0,0.000000,# but that's a bit tricky before we load the constant module :-)
0.000000,0,0.000000,# By doing this, we save several run time checks for *every* call
0.000000,0,0.000000,# to import.
0.000000,1,0.000000,my $const = $] > 5.009002;
0.000000,1,0.000000,my $downgrade = $] < 5.015004; # && $] >= 5.008
0.000000,1,0.000000,my $constarray = exists &_make_const;
0.000002,1,0.000002,if ($const) {
0.000005,1,0.000005,Internals::SvREADONLY($const, 1);
0.000002,1,0.000002,Internals::SvREADONLY($downgrade, 1);
0.000000,1,0.000000,$constant::{_CAN_PCS}   = \$const;
0.000000,1,0.000000,$constant::{_DOWNGRADE} = \$downgrade;
0.000000,1,0.000000,$constant::{_CAN_PCS_FOR_ARRAY} = \$constarray;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000079,2,0.000039,no strict 'refs';
0.000000,0,0.000000,*{"_CAN_PCS"}   = sub () {$const};
0.000000,0,0.000000,*{"_DOWNGRADE"} = sub () { $downgrade };
0.000000,0,0.000000,*{"_CAN_PCS_FOR_ARRAY"} = sub () { $constarray };
0.000000,0,0.000000,}
0.000050,1,0.000050,}
0.000000,0,0.000000,
0.000000,0,0.000000,#=======================================================================
0.000000,0,0.000000,# import() - import symbols into user's namespace
0.000000,0,0.000000,#
0.000000,0,0.000000,# What we actually do is define a function in the caller's namespace
0.000000,0,0.000000,# which returns the value. The function we create will normally
0.000000,0,0.000000,# be inlined as a constant, thereby avoiding further sub calling 
0.000000,0,0.000000,# overhead.
0.000000,0,0.000000,#=======================================================================
0.000000,0,0.000000,sub import {
0.000040,159,0.000000,my $class = shift;
0.000041,159,0.000000,return unless @_;			# Ignore 'use constant;'
0.000021,159,0.000000,my $constants;
0.000046,159,0.000000,my $multiple  = ref $_[0];
0.000065,159,0.000000,my $caller = caller;
0.000036,159,0.000000,my $flush_mro;
0.000000,0,0.000000,my $symtab;
0.000000,0,0.000000,
0.000059,159,0.000000,if (_CAN_PCS) {
0.000099,2,0.000049,no strict 'refs';
0.000122,159,0.000001,$symtab = \%{$caller . '::'};
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000041,159,0.000000,if ( $multiple ) {
0.000011,5,0.000002,if (ref $_[0] ne 'HASH') {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Invalid reference type '".ref(shift)."' not 'HASH'");
0.000000,0,0.000000,}
0.000002,5,0.000000,$constants = shift;
0.000000,0,0.000000,} else {
0.000030,154,0.000000,unless (defined $_[0]) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Can't use undef as constant name");
0.000000,0,0.000000,}
0.000148,154,0.000001,$constants->{+shift} = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000136,159,0.000001,foreach my $name ( keys %$constants ) {
0.000018,190,0.000000,my $pkg;
0.000032,190,0.000000,my $symtab = $symtab;
0.000028,190,0.000000,my $orig_name = $name;
0.000837,190,0.000004,if ($name =~ s/(.*)(?:::|')(?=.)//s) {
0.000000,0,0.000000,$pkg = $1;
0.000000,0,0.000000,if (_CAN_PCS && $pkg ne $caller) {
0.000118,2,0.000059,no strict 'refs';
0.000000,0,0.000000,$symtab = \%{$pkg . '::'};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000039,190,0.000000,$pkg = $caller;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Normal constant name
0.001373,190,0.000007,if ($name =~ $normal_constant_name and !$forbidden{$name}) {
0.000000,0,0.000000,# Everything is okay
0.000000,0,0.000000,
0.000000,0,0.000000,# Name forced into main, but we're not in main. Fatal.
0.000000,0,0.000000,} elsif ($forced_into_main{$name} and $pkg ne 'main') {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Constant name '$name' is forced into main::");
0.000000,0,0.000000,
0.000000,0,0.000000,# Starts with double underscore. Fatal.
0.000000,0,0.000000,} elsif ($name =~ /^__/) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Constant name '$name' begins with '__'");
0.000000,0,0.000000,
0.000000,0,0.000000,# Maybe the name is tolerable
0.000000,0,0.000000,} elsif ($name =~ $tolerable) {
0.000000,0,0.000000,# Then we'll warn only if you've asked for warnings
0.000000,0,0.000000,if (warnings::enabled()) {
0.000000,0,0.000000,if ($keywords{$name}) {
0.000000,0,0.000000,warnings::warn("Constant name '$name' is a Perl keyword");
0.000000,0,0.000000,} elsif ($forced_into_main{$name}) {
0.000000,0,0.000000,warnings::warn("Constant name '$name' is " .
0.000000,0,0.000000,"forced into package main::");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Looks like a boolean
0.000000,0,0.000000,# use constant FRED == fred;
0.000000,0,0.000000,} elsif ($name =~ $boolean) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,if (@_) {
0.000000,0,0.000000,Carp::croak("Constant name '$name' is invalid");
0.000000,0,0.000000,} else {
0.000000,0,0.000000,Carp::croak("Constant name looks like boolean value");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# Must have bad characters
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Constant name '$name' has invalid characters");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000415,192,0.000002,no strict 'refs';
0.000056,190,0.000000,my $full_name = "${pkg}::$name";
0.000210,190,0.000001,$declared{$full_name}++;
0.000128,190,0.000001,if ($multiple || @_ == 1) {
0.000033,190,0.000000,my $scalar = $multiple ? $constants->{$orig_name} : $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,if (_DOWNGRADE) { # for 5.8 to 5.14
0.000000,0,0.000000,# Work around perl bug #31991: Sub names (actually glob
0.000000,0,0.000000,# names in general) ignore the UTF8 flag. So we have to
0.000000,0,0.000000,# turn it off to get the "right" symbol table entry.
0.000000,0,0.000000,utf8::is_utf8 $name and utf8::encode $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# The constant serves to optimise this entire block out on
0.000000,0,0.000000,# 5.8 and earlier.
0.000064,190,0.000000,if (_CAN_PCS) {
0.000000,0,0.000000,# Use a reference as a proxy for a constant subroutine.
0.000000,0,0.000000,# If this is not a glob yet, it saves space.  If it is
0.000000,0,0.000000,# a glob, we must still create it this way to get the
0.000000,0,0.000000,# right internal flags set, as constants are distinct
0.000000,0,0.000000,# from subroutines created with sub(){...}.
0.000000,0,0.000000,# The check in Perl_ck_rvconst knows that inlinable
0.000000,0,0.000000,# constants from cv_const_sv are read only. So we have to:
0.000545,190,0.000003,Internals::SvREADONLY($scalar, 1);
0.000098,190,0.000001,if (!exists $symtab->{$name}) {
0.000139,190,0.000001,$symtab->{$name} = \$scalar;
0.000107,190,0.000001,++$flush_mro->{$pkg};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,local $constant::{_dummy} = \$scalar;
0.000000,0,0.000000,*$full_name = \&{"_dummy"};
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,*$full_name = sub () { $scalar };
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif (@_) {
0.000000,0,0.000000,my @list = @_;
0.000000,0,0.000000,if (_CAN_PCS_FOR_ARRAY) {
0.000000,0,0.000000,_make_const($list[$_]) for 0..$#list;
0.000000,0,0.000000,_make_const(@list);
0.000000,0,0.000000,if (!exists $symtab->{$name}) {
0.000000,0,0.000000,$symtab->{$name} = \@list;
0.000000,0,0.000000,$flush_mro->{$pkg}++;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,local $constant::{_dummy} = \@list;
0.000000,0,0.000000,*$full_name = \&{"_dummy"};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else { *$full_name = sub () { @list }; }
0.000000,0,0.000000,} else {
0.000000,0,0.000000,*$full_name = sub () { };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,# Flush the cache exactly once if we make any direct symbol table changes.
0.000625,159,0.000004,if (_CAN_PCS && $flush_mro) {
0.000452,159,0.000003,mro::method_changed_in($_) for keys %$flush_mro;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
