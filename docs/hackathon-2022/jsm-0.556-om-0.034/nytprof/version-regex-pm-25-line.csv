# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package version::regex;
0.000000,0,0.000000,
0.000506,2,0.000253,use strict;
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = 0.9929;
0.000000,0,0.000000,
0.000000,0,0.000000,#--------------------------------------------------------------------------#
0.000000,0,0.000000,# Version regexp components
0.000000,0,0.000000,#--------------------------------------------------------------------------#
0.000000,0,0.000000,
0.000000,0,0.000000,# Fraction part of a decimal version number.  This is a common part of
0.000000,0,0.000000,# both strict and lax decimal versions
0.000000,0,0.000000,
0.000015,1,0.000015,my $FRACTION_PART = qr/\.[0-9]+/;
0.000000,0,0.000000,
0.000000,0,0.000000,# First part of either decimal or dotted-decimal strict version number.
0.000000,0,0.000000,# Unsigned integer with no leading zeroes (except for zero itself) to
0.000000,0,0.000000,# avoid confusion with octal.
0.000000,0,0.000000,
0.000003,1,0.000003,my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
0.000000,0,0.000000,
0.000000,0,0.000000,# First part of either decimal or dotted-decimal lax version number.
0.000000,0,0.000000,# Unsigned integer, but allowing leading zeros.  Always interpreted
0.000000,0,0.000000,# as decimal.  However, some forms of the resulting syntax give odd
0.000000,0,0.000000,# results if used as ordinary Perl expressions, due to how perl treats
0.000000,0,0.000000,# octals.  E.g.
0.000000,0,0.000000,#   version->new("010" ) == 10
0.000000,0,0.000000,#   version->new( 010  ) == 8
0.000000,0,0.000000,#   version->new( 010.2) == 82  # "8" . "2"
0.000000,0,0.000000,
0.000003,1,0.000003,my $LAX_INTEGER_PART = qr/[0-9]+/;
0.000000,0,0.000000,
0.000000,0,0.000000,# Second and subsequent part of a strict dotted-decimal version number.
0.000000,0,0.000000,# Leading zeroes are permitted, and the number is always decimal.
0.000000,0,0.000000,# Limited to three digits to avoid overflow when converting to decimal
0.000000,0,0.000000,# form and also avoid problematic style with excessive leading zeroes.
0.000000,0,0.000000,
0.000002,1,0.000002,my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
0.000000,0,0.000000,
0.000000,0,0.000000,# Second and subsequent part of a lax dotted-decimal version number.
0.000000,0,0.000000,# Leading zeroes are permitted, and the number is always decimal.  No
0.000000,0,0.000000,# limit on the numerical value or number of digits, so there is the
0.000000,0,0.000000,# possibility of overflow when converting to decimal form.
0.000000,0,0.000000,
0.000004,1,0.000004,my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
0.000000,0,0.000000,
0.000000,0,0.000000,# Alpha suffix part of lax version number syntax.  Acts like a
0.000000,0,0.000000,# dotted-decimal part.
0.000000,0,0.000000,
0.000002,1,0.000002,my $LAX_ALPHA_PART = qr/_[0-9]+/;
0.000000,0,0.000000,
0.000000,0,0.000000,#--------------------------------------------------------------------------#
0.000000,0,0.000000,# Strict version regexp definitions
0.000000,0,0.000000,#--------------------------------------------------------------------------#
0.000000,0,0.000000,
0.000000,0,0.000000,# Strict decimal version number.
0.000000,0,0.000000,
0.000068,1,0.000068,our $STRICT_DECIMAL_VERSION =
0.000000,0,0.000000,qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
0.000000,0,0.000000,
0.000000,0,0.000000,# Strict dotted-decimal version number.  Must have both leading "v" and
0.000000,0,0.000000,# at least three parts, to avoid confusion with decimal syntax.
0.000000,0,0.000000,
0.000033,1,0.000033,our $STRICT_DOTTED_DECIMAL_VERSION =
0.000000,0,0.000000,qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
0.000000,0,0.000000,
0.000000,0,0.000000,# Complete strict version number syntax -- should generally be used
0.000000,0,0.000000,# anchored: qr/ \A $STRICT \z /x
0.000000,0,0.000000,
0.000050,1,0.000050,our $STRICT =
0.000000,0,0.000000,qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
0.000000,0,0.000000,
0.000000,0,0.000000,#--------------------------------------------------------------------------#
0.000000,0,0.000000,# Lax version regexp definitions
0.000000,0,0.000000,#--------------------------------------------------------------------------#
0.000000,0,0.000000,
0.000000,0,0.000000,# Lax decimal version number.  Just like the strict one except for
0.000000,0,0.000000,# allowing an alpha suffix or allowing a leading or trailing
0.000000,0,0.000000,# decimal-point
0.000000,0,0.000000,
0.000046,1,0.000046,our $LAX_DECIMAL_VERSION =
0.000000,0,0.000000,qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
0.000000,0,0.000000,|
0.000000,0,0.000000,$FRACTION_PART $LAX_ALPHA_PART?
0.000000,0,0.000000,/x;
0.000000,0,0.000000,
0.000000,0,0.000000,# Lax dotted-decimal version number.  Distinguished by having either
0.000000,0,0.000000,# leading "v" or at least three non-alpha parts.  Alpha part is only
0.000000,0,0.000000,# permitted if there are at least two non-alpha parts. Strangely
0.000000,0,0.000000,# enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
0.000000,0,0.000000,# so when there is no "v", the leading part is optional
0.000000,0,0.000000,
0.000057,1,0.000057,our $LAX_DOTTED_DECIMAL_VERSION =
0.000000,0,0.000000,qr/
0.000000,0,0.000000,v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
0.000000,0,0.000000,|
0.000000,0,0.000000,$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
0.000000,0,0.000000,/x;
0.000000,0,0.000000,
0.000000,0,0.000000,# Complete lax version number syntax -- should generally be used
0.000000,0,0.000000,# anchored: qr/ \A $LAX \z /x
0.000000,0,0.000000,#
0.000000,0,0.000000,# The string 'undef' is a special case to make for easier handling
0.000000,0,0.000000,# of return values from ExtUtils::MM->parse_version
0.000000,0,0.000000,
0.000058,1,0.000058,our $LAX =
0.000000,0,0.000000,qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;
0.000000,0,0.000000,
0.000000,0,0.000000,#--------------------------------------------------------------------------#
0.000000,0,0.000000,
0.000000,0,0.000000,# Preloaded methods go here.
0.000000,0,0.000000,sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
0.000000,0,0.000000,sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
0.000000,0,0.000000,
0.000030,1,0.000030,1;
