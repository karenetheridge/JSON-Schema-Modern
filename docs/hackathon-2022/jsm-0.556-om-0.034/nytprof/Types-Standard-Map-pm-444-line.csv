# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# INTERNAL MODULE: guts for Map type from Types::Standard.
0.000000,0,0.000000,
0.000000,0,0.000000,package Types::Standard::Map;
0.000000,0,0.000000,
0.000162,2,0.000081,use 5.008001;
0.000060,2,0.000030,use strict;
0.000064,2,0.000032,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,$Types::Standard::Map::AUTHORITY = 'cpan:TOBYINK';
0.000005,1,0.000005,$Types::Standard::Map::VERSION   = '2.000001';
0.000053,1,0.000053,}
0.000000,0,0.000000,
0.000001,1,0.000001,$Types::Standard::Map::VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000023,2,0.000012,use Type::Tiny      ();
0.000016,2,0.000008,use Types::Standard ();
0.000077,2,0.000039,use Types::TypeTiny ();
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
0.000000,0,0.000000,
0.000007,1,0.000007,my $meta = Types::Standard->meta;
0.000000,0,0.000000,
0.001547,2,0.000773,no warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,sub __constraint_generator {
0.000000,1,0.000000,return $meta->get_type( 'Map' ) unless @_;
0.000000,0,0.000000,
0.000001,1,0.000001,my ( $keys, $values ) = @_;
0.000003,1,0.000003,Types::TypeTiny::is_TypeTiny( $keys )
0.000000,0,0.000000,or _croak(
0.000000,0,0.000000,"First parameter to Map[`k,`v] expected to be a type constraint; got $keys" );
0.000002,1,0.000002,Types::TypeTiny::is_TypeTiny( $values )
0.000000,0,0.000000,or _croak(
0.000000,0,0.000000,"Second parameter to Map[`k,`v] expected to be a type constraint; got $values"
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,1,0.000000,my @xsub;
0.000000,0,0.000000,if ( Type::Tiny::_USE_XS ) {
0.000000,0,0.000000,my @known = map {
0.000000,0,0.000000,my $known = Type::Tiny::XS::is_known( $_->compiled_check );
0.000000,0,0.000000,defined( $known ) ? $known : ();
0.000000,0,0.000000,} ( $keys, $values );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( @known == 2 ) {
0.000000,0,0.000000,my $xsub = Type::Tiny::XS::get_coderef_for( sprintf "Map[%s,%s]", @known );
0.000000,0,0.000000,push @xsub, $xsub if $xsub;
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( Type::Tiny::_USE_XS)
0.000000,0,0.000000,
0.000000,0,0.000000,sub {
0.000000,0,0.000000,my $hash = shift;
0.000000,0,0.000000,$keys->check( $_ )   || return for keys %$hash;
0.000000,0,0.000000,$values->check( $_ ) || return for values %$hash;
0.000000,0,0.000000,return !!1;
0.000013,1,0.000013,}, @xsub;
0.000000,0,0.000000,} #/ sub __constraint_generator
0.000000,0,0.000000,
0.000000,0,0.000000,sub __inline_generator {
0.000001,1,0.000001,my ( $k, $v ) = @_;
0.000004,1,0.000004,return unless $k->can_be_inlined && $v->can_be_inlined;
0.000000,0,0.000000,
0.000001,1,0.000001,my $xsubname;
0.000000,0,0.000000,if ( Type::Tiny::_USE_XS ) {
0.000000,0,0.000000,my @known = map {
0.000000,0,0.000000,my $known = Type::Tiny::XS::is_known( $_->compiled_check );
0.000000,0,0.000000,defined( $known ) ? $known : ();
0.000000,0,0.000000,} ( $k, $v );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( @known == 2 ) {
0.000000,0,0.000000,$xsubname = Type::Tiny::XS::get_subname_for( sprintf "Map[%s,%s]", @known );
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( Type::Tiny::_USE_XS)
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000002,3,0.000001,my $h = $_[1];
0.000002,3,0.000001,return "$xsubname\($h\)" if $xsubname && !$Type::Tiny::AvoidCallbacks;
0.000010,3,0.000003,my $p       = Types::Standard::HashRef->inline_check( $h );
0.000004,3,0.000001,my $k_check = $k->inline_check( '$k' );
0.000005,3,0.000002,my $v_check = $v->inline_check( '$v' );
0.000016,3,0.000005,"$p and do { "
0.000000,0,0.000000,. "my \$ok = 1; "
0.000000,0,0.000000,. "for my \$v (values \%{$h}) { "
0.000000,0,0.000000,. "(\$ok = 0, last) unless $v_check " . "}; "
0.000000,0,0.000000,. "for my \$k (keys \%{$h}) { "
0.000000,0,0.000000,. "(\$ok = 0, last) unless $k_check " . "}; " . "\$ok " . "}";
0.000006,1,0.000006,};
0.000000,0,0.000000,} #/ sub __inline_generator
0.000000,0,0.000000,
0.000000,0,0.000000,sub __deep_explanation {
0.000000,0,0.000000,require B;
0.000000,0,0.000000,my ( $type, $value, $varname ) = @_;
0.000000,0,0.000000,my ( $kparam, $vparam ) = @{ $type->parameters };
0.000000,0,0.000000,
0.000000,0,0.000000,for my $k ( sort keys %$value ) {
0.000000,0,0.000000,unless ( $kparam->check( $k ) ) {
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf( '"%s" constrains each key in the hash with "%s"', $type, $kparam ),
0.000000,0,0.000000,@{
0.000000,0,0.000000,$kparam->validate_explain(
0.000000,0,0.000000,$k, sprintf( 'key %s->{%s}', $varname, B::perlstring( $k ) )
0.000000,0,0.000000,)
0.000000,0,0.000000,},
0.000000,0,0.000000,];
0.000000,0,0.000000,} #/ unless ( $kparam->check( $k...))
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( $vparam->check( $value->{$k} ) ) {
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf( '"%s" constrains each value in the hash with "%s"', $type, $vparam ),
0.000000,0,0.000000,@{
0.000000,0,0.000000,$vparam->validate_explain(
0.000000,0,0.000000,$value->{$k}, sprintf( '%s->{%s}', $varname, B::perlstring( $k ) )
0.000000,0,0.000000,)
0.000000,0,0.000000,},
0.000000,0,0.000000,];
0.000000,0,0.000000,} #/ unless ( $vparam->check( $value...))
0.000000,0,0.000000,} #/ for my $k ( sort keys %$value)
0.000000,0,0.000000,
0.000000,0,0.000000,# This should never happen...
0.000000,0,0.000000,return;    # uncoverable statement
0.000000,0,0.000000,} #/ sub __deep_explanation
0.000000,0,0.000000,
0.000000,0,0.000000,sub __coercion_generator {
0.000000,0,0.000000,my ( $parent, $child, $kparam, $vparam ) = @_;
0.000000,0,0.000000,return unless $kparam->has_coercion || $vparam->has_coercion;
0.000000,0,0.000000,
0.000000,0,0.000000,my $kcoercable_item =
0.000000,0,0.000000,$kparam->has_coercion
0.000000,0,0.000000,? $kparam->coercion->_source_type_union
0.000000,0,0.000000,: $kparam;
0.000000,0,0.000000,my $vcoercable_item =
0.000000,0,0.000000,$vparam->has_coercion
0.000000,0,0.000000,? $vparam->coercion->_source_type_union
0.000000,0,0.000000,: $vparam;
0.000000,0,0.000000,my $C = "Type::Coercion"->new( type_constraint => $child );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ( !$kparam->has_coercion or $kparam->coercion->can_be_inlined )
0.000000,0,0.000000,and ( !$vparam->has_coercion or $vparam->coercion->can_be_inlined )
0.000000,0,0.000000,and $kcoercable_item->can_be_inlined
0.000000,0,0.000000,and $vcoercable_item->can_be_inlined )
0.000000,0,0.000000,{
0.000000,0,0.000000,$C->add_type_coercions(
0.000000,0,0.000000,$parent => Types::Standard::Stringable {
0.000000,0,0.000000,my @code;
0.000000,0,0.000000,push @code, 'do { my ($orig, $return_orig, %new) = ($_, 0);';
0.000000,0,0.000000,push @code, 'for (keys %$orig) {';
0.000000,0,0.000000,push @code,
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'++$return_orig && last unless (%s);',
0.000000,0,0.000000,$kcoercable_item->inline_check( '$_' )
0.000000,0,0.000000,);
0.000000,0,0.000000,push @code,
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'++$return_orig && last unless (%s);',
0.000000,0,0.000000,$vcoercable_item->inline_check( '$orig->{$_}' )
0.000000,0,0.000000,);
0.000000,0,0.000000,push @code, sprintf(
0.000000,0,0.000000,'$new{(%s)} = (%s);',
0.000000,0,0.000000,$kparam->has_coercion ? $kparam->coercion->inline_coercion( '$_' ) : '$_',
0.000000,0,0.000000,$vparam->has_coercion
0.000000,0,0.000000,? $vparam->coercion->inline_coercion( '$orig->{$_}' )
0.000000,0,0.000000,: '$orig->{$_}',
0.000000,0,0.000000,);
0.000000,0,0.000000,push @code, '}';
0.000000,0,0.000000,push @code, '$return_orig ? $orig : \\%new';
0.000000,0,0.000000,push @code, '}';
0.000000,0,0.000000,"@code";
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ if ( ( !$kparam->has_coercion...))
0.000000,0,0.000000,else {
0.000000,0,0.000000,$C->add_type_coercions(
0.000000,0,0.000000,$parent => sub {
0.000000,0,0.000000,my $value = @_ ? $_[0] : $_;
0.000000,0,0.000000,my %new;
0.000000,0,0.000000,for my $k ( keys %$value ) {
0.000000,0,0.000000,return $value
0.000000,0,0.000000,unless $kcoercable_item->check( $k )
0.000000,0,0.000000,&& $vcoercable_item->check( $value->{$k} );
0.000000,0,0.000000,$new{ $kparam->has_coercion ? $kparam->coerce( $k ) : $k } =
0.000000,0,0.000000,$vparam->has_coercion
0.000000,0,0.000000,? $vparam->coerce( $value->{$k} )
0.000000,0,0.000000,: $value->{$k};
0.000000,0,0.000000,}
0.000000,0,0.000000,return \%new;
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ else [ if ( ( !$kparam->has_coercion...))]
0.000000,0,0.000000,
0.000000,0,0.000000,return $C;
0.000000,0,0.000000,} #/ sub __coercion_generator
0.000000,0,0.000000,
0.000000,0,0.000000,sub __hashref_allows_key {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $key ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return Types::Standard::is_Str( $key ) if $self == Types::Standard::Map();
0.000000,0,0.000000,
0.000000,0,0.000000,my $map = $self->find_parent(
0.000000,0,0.000000,sub { $_->has_parent && $_->parent == Types::Standard::Map() } );
0.000000,0,0.000000,my ( $kcheck, $vcheck ) = @{ $map->parameters };
0.000000,0,0.000000,
0.000000,0,0.000000,( $kcheck or Types::Standard::Any() )->check( $key );
0.000000,0,0.000000,} #/ sub __hashref_allows_key
0.000000,0,0.000000,
0.000000,0,0.000000,sub __hashref_allows_value {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $key, $value ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return !!0 unless $self->my_hashref_allows_key( $key );
0.000000,0,0.000000,return !!1 if $self == Types::Standard::Map();
0.000000,0,0.000000,
0.000000,0,0.000000,my $map = $self->find_parent(
0.000000,0,0.000000,sub { $_->has_parent && $_->parent == Types::Standard::Map() } );
0.000000,0,0.000000,my ( $kcheck, $vcheck ) = @{ $map->parameters };
0.000000,0,0.000000,
0.000000,0,0.000000,( $kcheck or Types::Standard::Any() )->check( $key )
0.000000,0,0.000000,and ( $vcheck or Types::Standard::Any() )->check( $value );
0.000000,0,0.000000,} #/ sub __hashref_allows_value
0.000000,0,0.000000,
0.000008,1,0.000008,1;
