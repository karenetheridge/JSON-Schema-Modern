# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,File::Basename - Parse file paths into directory, filename and suffix.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use File::Basename;
0.000000,0,0.000000,
0.000000,0,0.000000,($name,$path,$suffix) = fileparse($fullname,@suffixlist);
0.000000,0,0.000000,$name = fileparse($fullname,@suffixlist);
0.000000,0,0.000000,
0.000000,0,0.000000,$basename = basename($fullname,@suffixlist);
0.000000,0,0.000000,$dirname  = dirname($fullname);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,These routines allow you to parse file paths into their directory, filename
0.000000,0,0.000000,and suffix.
0.000000,0,0.000000,
0.000000,0,0.000000,B<NOTE>: C<dirname()> and C<basename()> emulate the behaviours, and
0.000000,0,0.000000,quirks, of the shell and C functions of the same name.  See each
0.000000,0,0.000000,function's documentation for details.  If your concern is just parsing
0.000000,0,0.000000,paths it is safer to use L<File::Spec>'s C<splitpath()> and
0.000000,0,0.000000,C<splitdir()> methods.
0.000000,0,0.000000,
0.000000,0,0.000000,It is guaranteed that
0.000000,0,0.000000,
0.000000,0,0.000000,# Where $path_separator is / for Unix, \ for Windows, etc...
0.000000,0,0.000000,dirname($path) . $path_separator . basename($path);
0.000000,0,0.000000,
0.000000,0,0.000000,is equivalent to the original path for all systems but VMS.
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,package File::Basename;
0.000000,0,0.000000,
0.000000,0,0.000000,# File::Basename is used during the Perl build, when the re extension may
0.000000,0,0.000000,# not be available, but we only actually need it if running under tainting.
0.000000,0,0.000000,BEGIN {
0.000004,1,0.000004,if (${^TAINT}) {
0.000000,0,0.000000,require re;
0.000000,0,0.000000,re->import('taint');
0.000000,0,0.000000,}
0.000012,1,0.000012,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000016,2,0.000008,use strict;
0.000023,2,0.000012,use 5.006;
0.000755,2,0.000377,use warnings;
0.000000,0,0.000000,our(@ISA, @EXPORT, $VERSION, $Fileparse_fstype, $Fileparse_igncase);
0.000000,1,0.000000,require Exporter;
0.000006,1,0.000006,@ISA = qw(Exporter);
0.000000,1,0.000000,@EXPORT = qw(fileparse fileparse_set_fstype basename dirname);
0.000000,1,0.000000,$VERSION = "2.85";
0.000000,0,0.000000,
0.000001,1,0.000001,fileparse_set_fstype($^O);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item C<fileparse>
0.000000,0,0.000000,X<fileparse>
0.000000,0,0.000000,
0.000000,0,0.000000,my($filename, $dirs, $suffix) = fileparse($path);
0.000000,0,0.000000,my($filename, $dirs, $suffix) = fileparse($path, @suffixes);
0.000000,0,0.000000,my $filename                  = fileparse($path, @suffixes);
0.000000,0,0.000000,
0.000000,0,0.000000,The C<fileparse()> routine divides a file path into its $dirs, $filename
0.000000,0,0.000000,and (optionally) the filename $suffix.
0.000000,0,0.000000,
0.000000,0,0.000000,$dirs contains everything up to and including the last
0.000000,0,0.000000,directory separator in the $path including the volume (if applicable).
0.000000,0,0.000000,The remainder of the $path is the $filename.
0.000000,0,0.000000,
0.000000,0,0.000000,# On Unix returns ("baz", "/foo/bar/", "")
0.000000,0,0.000000,fileparse("/foo/bar/baz");
0.000000,0,0.000000,
0.000000,0,0.000000,# On Windows returns ("baz", 'C:\foo\bar\', "")
0.000000,0,0.000000,fileparse('C:\foo\bar\baz');
0.000000,0,0.000000,
0.000000,0,0.000000,# On Unix returns ("", "/foo/bar/baz/", "")
0.000000,0,0.000000,fileparse("/foo/bar/baz/");
0.000000,0,0.000000,
0.000000,0,0.000000,If @suffixes are given each element is a pattern (either a string or a
0.000000,0,0.000000,C<qr//>) matched against the end of the $filename.  The matching
0.000000,0,0.000000,portion is removed and becomes the $suffix.
0.000000,0,0.000000,
0.000000,0,0.000000,# On Unix returns ("baz", "/foo/bar/", ".txt")
0.000000,0,0.000000,fileparse("/foo/bar/baz.txt", qr/\.[^.]*/);
0.000000,0,0.000000,
0.000000,0,0.000000,If type is non-Unix (see L</fileparse_set_fstype>) then the pattern
0.000000,0,0.000000,matching for suffix removal is performed case-insensitively, since
0.000000,0,0.000000,those systems are not case-sensitive when opening existing files.
0.000000,0,0.000000,
0.000000,0,0.000000,You are guaranteed that C<$dirs . $filename . $suffix> will
0.000000,0,0.000000,denote the same location as the original $path.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub fileparse {
0.000001,1,0.000001,my($fullname,@suffices) = @_;
0.000000,0,0.000000,
0.000001,1,0.000001,unless (defined $fullname) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("fileparse(): need a valid pathname");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,my $orig_type = '';
0.000001,1,0.000001,my($type,$igncase) = ($Fileparse_fstype, $Fileparse_igncase);
0.000000,0,0.000000,
0.000002,1,0.000002,my($taint) = substr($fullname,0,0);  # Is $fullname tainted?
0.000000,0,0.000000,
0.000001,1,0.000001,if ($type eq "VMS" and $fullname =~ m{/} ) {
0.000000,0,0.000000,# We're doing Unix emulation
0.000000,0,0.000000,$orig_type = $type;
0.000000,0,0.000000,$type = 'Unix';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my($dirpath, $basename);
0.000000,0,0.000000,
0.000005,1,0.000005,if (grep { $type eq $_ } qw(MSDOS DOS MSWin32 Epoc)) {
0.000000,0,0.000000,($dirpath,$basename) = ($fullname =~ /^((?:.*[:\\\/])?)(.*)/s);
0.000000,0,0.000000,$dirpath .= '.\\' unless $dirpath =~ /[\\\/]\z/;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type eq "OS2") {
0.000000,0,0.000000,($dirpath,$basename) = ($fullname =~ m#^((?:.*[:\\/])?)(.*)#s);
0.000000,0,0.000000,$dirpath = './' unless $dirpath;	# Can't be 0
0.000000,0,0.000000,$dirpath .= '/' unless $dirpath =~ m#[\\/]\z#;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type eq "MacOS") {
0.000000,0,0.000000,($dirpath,$basename) = ($fullname =~ /^(.*:)?(.*)/s);
0.000000,0,0.000000,$dirpath = ':' unless $dirpath;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type eq "AmigaOS") {
0.000000,0,0.000000,($dirpath,$basename) = ($fullname =~ /(.*[:\/])?(.*)/s);
0.000000,0,0.000000,$dirpath = './' unless $dirpath;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type eq 'VMS' ) {
0.000000,0,0.000000,($dirpath,$basename) = ($fullname =~ /^(.*[:>\]])?(.*)/s);
0.000000,0,0.000000,$dirpath ||= '';  # should always be defined
0.000000,0,0.000000,}
0.000000,0,0.000000,else { # Default to Unix semantics.
0.000015,1,0.000015,($dirpath,$basename) = ($fullname =~ m{^(.*/)?(.*)}s);
0.000001,1,0.000001,if ($orig_type eq 'VMS' and $fullname =~ m{^(/[^/]+/000000(/|$))(.*)}) {
0.000000,0,0.000000,# dev:[000000] is top of VMS tree, similar to Unix '/'
0.000000,0,0.000000,# so strip it off and treat the rest as "normal"
0.000000,0,0.000000,my $devspec  = $1;
0.000000,0,0.000000,my $remainder = $3;
0.000000,0,0.000000,($dirpath,$basename) = ($remainder =~ m{^(.*/)?(.*)}s);
0.000000,0,0.000000,$dirpath ||= '';  # should always be defined
0.000000,0,0.000000,$dirpath = $devspec.$dirpath;
0.000000,0,0.000000,}
0.000000,1,0.000000,$dirpath = './' unless $dirpath;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,1,0.000000,my $tail   = '';
0.000001,1,0.000001,my $suffix = '';
0.000000,1,0.000000,if (@suffices) {
0.000000,0,0.000000,foreach $suffix (@suffices) {
0.000000,0,0.000000,my $pat = ($igncase ? '(?i)' : '') . "($suffix)\$";
0.000000,0,0.000000,if ($basename =~ s/$pat//s) {
0.000000,0,0.000000,$taint .= substr($suffix,0,0);
0.000000,0,0.000000,$tail = $1 . $tail;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Ensure taint is propagated from the path to its pieces.
0.000000,1,0.000000,$tail .= $taint;
0.000004,1,0.000004,wantarray ? ($basename .= $taint, $dirpath .= $taint, $tail)
0.000000,0,0.000000,: ($basename .= $taint);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=item C<basename>
0.000000,0,0.000000,X<basename> X<filename>
0.000000,0,0.000000,
0.000000,0,0.000000,my $filename = basename($path);
0.000000,0,0.000000,my $filename = basename($path, @suffixes);
0.000000,0,0.000000,
0.000000,0,0.000000,This function is provided for compatibility with the Unix shell command
0.000000,0,0.000000,C<basename(1)>.  It does B<NOT> always return the file name portion of a
0.000000,0,0.000000,path as you might expect.  To be safe, if you want the file name portion of
0.000000,0,0.000000,a path use C<fileparse()>.
0.000000,0,0.000000,
0.000000,0,0.000000,C<basename()> returns the last level of a filepath even if the last
0.000000,0,0.000000,level is clearly directory.  In effect, it is acting like C<pop()> for
0.000000,0,0.000000,paths.  This differs from C<fileparse()>'s behaviour.
0.000000,0,0.000000,
0.000000,0,0.000000,# Both return "bar"
0.000000,0,0.000000,basename("/foo/bar");
0.000000,0,0.000000,basename("/foo/bar/");
0.000000,0,0.000000,
0.000000,0,0.000000,@suffixes work as in C<fileparse()> except all regex metacharacters are
0.000000,0,0.000000,quoted.
0.000000,0,0.000000,
0.000000,0,0.000000,# These two function calls are equivalent.
0.000000,0,0.000000,my $filename = basename("/foo/bar/baz.txt",  ".txt");
0.000000,0,0.000000,my $filename = fileparse("/foo/bar/baz.txt", qr/\Q.txt\E/);
0.000000,0,0.000000,
0.000000,0,0.000000,Also note that in order to be compatible with the shell command,
0.000000,0,0.000000,C<basename()> does not strip off a suffix if it is identical to the
0.000000,0,0.000000,remaining characters in the filename.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub basename {
0.000000,0,0.000000,my($path) = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# From BSD basename(1)
0.000000,0,0.000000,# The basename utility deletes any prefix ending with the last slash '/'
0.000000,0,0.000000,# character present in string (after first stripping trailing slashes)
0.000000,0,0.000000,_strip_trailing_sep($path);
0.000000,0,0.000000,
0.000000,0,0.000000,my($basename, $dirname, $suffix) = fileparse( $path, map("\Q$_\E",@_) );
0.000000,0,0.000000,
0.000000,0,0.000000,# From BSD basename(1)
0.000000,0,0.000000,# The suffix is not stripped if it is identical to the remaining 
0.000000,0,0.000000,# characters in string.
0.000000,0,0.000000,if( length $suffix and !length $basename ) {
0.000000,0,0.000000,$basename = $suffix;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Ensure that basename '/' == '/'
0.000000,0,0.000000,if( !length $basename ) {
0.000000,0,0.000000,$basename = $dirname;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $basename;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=item C<dirname>
0.000000,0,0.000000,X<dirname>
0.000000,0,0.000000,
0.000000,0,0.000000,This function is provided for compatibility with the Unix shell
0.000000,0,0.000000,command C<dirname(1)> and has inherited some of its quirks.  In spite of
0.000000,0,0.000000,its name it does B<NOT> always return the directory name as you might
0.000000,0,0.000000,expect.  To be safe, if you want the directory name of a path use
0.000000,0,0.000000,C<fileparse()>.
0.000000,0,0.000000,
0.000000,0,0.000000,Only on VMS (where there is no ambiguity between the file and directory
0.000000,0,0.000000,portions of a path) and AmigaOS (possibly due to an implementation quirk in
0.000000,0,0.000000,this module) does C<dirname()> work like C<fileparse($path)>, returning just the
0.000000,0,0.000000,$dirs.
0.000000,0,0.000000,
0.000000,0,0.000000,# On VMS and AmigaOS
0.000000,0,0.000000,my $dirs = dirname($path);
0.000000,0,0.000000,
0.000000,0,0.000000,When using Unix or MSDOS syntax this emulates the C<dirname(1)> shell function
0.000000,0,0.000000,which is subtly different from how C<fileparse()> works.  It returns all but
0.000000,0,0.000000,the last level of a file path even if the last level is clearly a directory.
0.000000,0,0.000000,In effect, it is not returning the directory portion but simply the path one
0.000000,0,0.000000,level up acting like C<chop()> for file paths.
0.000000,0,0.000000,
0.000000,0,0.000000,Also unlike C<fileparse()>, C<dirname()> does not include a trailing slash on
0.000000,0,0.000000,its returned path.
0.000000,0,0.000000,
0.000000,0,0.000000,# returns /foo/bar.  fileparse() would return /foo/bar/
0.000000,0,0.000000,dirname("/foo/bar/baz");
0.000000,0,0.000000,
0.000000,0,0.000000,# also returns /foo/bar despite the fact that baz is clearly a 
0.000000,0,0.000000,# directory.  fileparse() would return /foo/bar/baz/
0.000000,0,0.000000,dirname("/foo/bar/baz/");
0.000000,0,0.000000,
0.000000,0,0.000000,# returns '.'.  fileparse() would return 'foo/'
0.000000,0,0.000000,dirname("foo/");
0.000000,0,0.000000,
0.000000,0,0.000000,Under VMS, if there is no directory information in the $path, then the
0.000000,0,0.000000,current default device and directory is used.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub dirname {
0.000002,1,0.000002,my $path = shift;
0.000000,0,0.000000,
0.000001,1,0.000001,my($type) = $Fileparse_fstype;
0.000000,0,0.000000,
0.000001,1,0.000001,if( $type eq 'VMS' and $path =~ m{/} ) {
0.000000,0,0.000000,# Parse as Unix
0.000000,0,0.000000,local($File::Basename::Fileparse_fstype) = '';
0.000000,0,0.000000,return dirname($path);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,my($basename, $dirname) = fileparse($path);
0.000000,0,0.000000,
0.000004,1,0.000004,if ($type eq 'VMS') { 
0.000000,0,0.000000,$dirname ||= $ENV{DEFAULT};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type eq 'MacOS') {
0.000000,0,0.000000,if( !length($basename) && $dirname !~ /^[^:]+:\z/) {
0.000000,0,0.000000,_strip_trailing_sep($dirname);
0.000000,0,0.000000,($basename,$dirname) = fileparse $dirname;
0.000000,0,0.000000,}
0.000000,0,0.000000,$dirname .= ":" unless $dirname =~ /:\z/;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (grep { $type eq $_ } qw(MSDOS DOS MSWin32 OS2)) { 
0.000000,0,0.000000,_strip_trailing_sep($dirname);
0.000000,0,0.000000,unless( length($basename) ) {
0.000000,0,0.000000,($basename,$dirname) = fileparse $dirname;
0.000000,0,0.000000,_strip_trailing_sep($dirname);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type eq 'AmigaOS') {
0.000000,0,0.000000,if ( $dirname =~ /:\z/) { return $dirname }
0.000000,0,0.000000,chop $dirname;
0.000000,0,0.000000,$dirname =~ s{[^:/]+\z}{} unless length($basename);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000002,1,0.000002,_strip_trailing_sep($dirname);
0.000000,1,0.000000,unless( length($basename) ) {
0.000000,0,0.000000,($basename,$dirname) = fileparse $dirname;
0.000000,0,0.000000,_strip_trailing_sep($dirname);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,$dirname;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# Strip the trailing path separator.
0.000000,0,0.000000,sub _strip_trailing_sep  {
0.000001,1,0.000001,my $type = $Fileparse_fstype;
0.000000,0,0.000000,
0.000005,1,0.000005,if ($type eq 'MacOS') {
0.000000,0,0.000000,$_[0] =~ s/([^:]):\z/$1/s;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (grep { $type eq $_ } qw(MSDOS DOS MSWin32 OS2)) { 
0.000000,0,0.000000,$_[0] =~ s/([^:])[\\\/]*\z/$1/;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000018,1,0.000018,$_[0] =~ s{(.)/*\z}{$1}s;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=item C<fileparse_set_fstype>
0.000000,0,0.000000,X<filesystem>
0.000000,0,0.000000,
0.000000,0,0.000000,my $type = fileparse_set_fstype();
0.000000,0,0.000000,my $previous_type = fileparse_set_fstype($type);
0.000000,0,0.000000,
0.000000,0,0.000000,Normally File::Basename will assume a file path type native to your current
0.000000,0,0.000000,operating system (ie. /foo/bar style on Unix, \foo\bar on Windows, etc...).
0.000000,0,0.000000,With this function you can override that assumption.
0.000000,0,0.000000,
0.000000,0,0.000000,Valid $types are "MacOS", "VMS", "AmigaOS", "OS2", "RISCOS",
0.000000,0,0.000000,"MSWin32", "DOS" (also "MSDOS" for backwards bug compatibility),
0.000000,0,0.000000,"Epoc" and "Unix" (all case-insensitive).  If an unrecognized $type is
0.000000,0,0.000000,given "Unix" will be assumed.
0.000000,0,0.000000,
0.000000,0,0.000000,If you've selected VMS syntax, and the file specification you pass to
0.000000,0,0.000000,one of these routines contains a "/", they assume you are using Unix
0.000000,0,0.000000,emulation and apply the Unix syntax rules instead, for that function
0.000000,0,0.000000,call only.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,
0.000001,1,0.000001,my @Ignore_Case = qw(MacOS VMS AmigaOS OS2 RISCOS MSWin32 MSDOS DOS Epoc);
0.000004,1,0.000004,my @Types = (@Ignore_Case, qw(Unix));
0.000000,0,0.000000,
0.000000,0,0.000000,sub fileparse_set_fstype {
0.000000,1,0.000000,my $old = $Fileparse_fstype;
0.000000,0,0.000000,
0.000000,1,0.000000,if (@_) {
0.000002,1,0.000002,my $new_type = shift;
0.000000,0,0.000000,
0.000000,1,0.000000,$Fileparse_fstype = 'Unix';  # default
0.000002,1,0.000002,foreach my $type (@Types) {
0.000050,10,0.000005,$Fileparse_fstype = $type if $new_type =~ /^$type/i;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$Fileparse_igncase = 
0.000002,1,0.000002,(grep $Fileparse_fstype eq $_, @Ignore_Case) ? 1 : 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,return $old;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000045,1,0.000045,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,L<dirname(1)>, L<basename(1)>, L<File::Spec>
