# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Type::Tiny::ConstrainedObject;
0.000000,0,0.000000,
0.000042,2,0.000021,use 5.008001;
0.000020,2,0.000010,use strict;
0.000033,2,0.000017,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,$Type::Tiny::ConstrainedObject::AUTHORITY = 'cpan:TOBYINK';
0.000001,1,0.000001,$Type::Tiny::ConstrainedObject::VERSION   = '2.000001';
0.000063,1,0.000063,}
0.000000,0,0.000000,
0.000002,1,0.000002,$Type::Tiny::ConstrainedObject::VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
0.000000,0,0.000000,
0.000692,2,0.000346,use Type::Tiny ();
0.000010,1,0.000010,our @ISA = 'Type::Tiny';
0.000000,0,0.000000,
0.000002,1,0.000002,my %errlabel = (
0.000000,0,0.000000,parent     => 'a parent',
0.000000,0,0.000000,constraint => 'a constraint coderef',
0.000000,0,0.000000,inlined    => 'an inlining coderef',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000007,11,0.000001,my $proto = shift;
0.000014,11,0.000001,my %opts  = ( @_ == 1 ) ? %{ $_[0] } : @_;
0.000045,11,0.000004,for my $key ( qw/ parent constraint inlined / ) {
0.000013,33,0.000000,next unless exists $opts{$key};
0.000000,0,0.000000,_croak(
0.000000,0,0.000000,'%s type constraints cannot have %s passed to the constructor',
0.000000,0,0.000000,$proto->_short_name,
0.000000,0,0.000000,$errlabel{$key},
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000057,11,0.000005,$proto->SUPER::new( %opts );
0.000000,0,0.000000,} #/ sub new
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_parent {
0.000518,382,0.000001,!!1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parent {
0.000000,0,0.000000,require Types::Standard;
0.000000,0,0.000000,Types::Standard::Object();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _short_name {
0.000000,0,0.000000,die "subclasses must implement this";    # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,my $i                  = 0;
0.000000,0,0.000000,my $_where_expressions = sub {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $name = shift;
0.000000,0,0.000000,$name ||= "where expression check";
0.000000,0,0.000000,my ( %env, @codes );
0.000000,0,0.000000,while ( @_ ) {
0.000000,0,0.000000,my $expr       = shift;
0.000000,0,0.000000,my $constraint = shift;
0.000000,0,0.000000,if ( !ref $constraint ) {
0.000000,0,0.000000,push @codes, sprintf( 'do { local $_ = %s; %s }', $expr, $constraint );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,require Types::Standard;
0.000000,0,0.000000,my $type =
0.000000,0,0.000000,Types::Standard::is_RegexpRef( $constraint )
0.000000,0,0.000000,? Types::Standard::StrMatch()->of( $constraint )
0.000000,0,0.000000,: Types::TypeTiny::to_TypeTiny( $constraint );
0.000000,0,0.000000,if ( $type->can_be_inlined ) {
0.000000,0,0.000000,push @codes,
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'do { my $tmp = %s; %s }', $expr,
0.000000,0,0.000000,$type->inline_check( '$tmp' )
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,++$i;
0.000000,0,0.000000,$env{ '$chk' . $i } = do { my $chk = $type->compiled_check; \$chk };
0.000000,0,0.000000,push @codes, sprintf( '$chk%d->(%s)', $i, $expr );
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ else [ if ( !ref $constraint )]
0.000000,0,0.000000,} #/ while ( @_ )
0.000000,0,0.000000,
0.000000,0,0.000000,if ( keys %env ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# cannot inline
0.000000,0,0.000000,my $sub = Eval::TypeTiny::eval_closure(
0.000000,0,0.000000,source =>
0.000000,0,0.000000,sprintf( 'sub ($) { local $_ = shift; %s }', join( q( and ), @codes ) ),
0.000000,0,0.000000,description => sprintf( '%s for %s', $name, $self->name ),
0.000000,0,0.000000,environment => \%env,
0.000000,0,0.000000,);
0.000000,0,0.000000,return $self->where( $sub );
0.000000,0,0.000000,} #/ if ( keys %env )
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $self->where( join( q( and ), @codes ) );
0.000000,0,0.000000,}
0.000002,1,0.000002,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub stringifies_to {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $constraint ) = @_;
0.000000,0,0.000000,$self->$_where_expressions( "stringification check", q{"$_"}, $constraint );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub numifies_to {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $constraint ) = @_;
0.000000,0,0.000000,$self->$_where_expressions( "numification check", q{0+$_}, $constraint );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub with_attribute_values {
0.000000,0,0.000000,my $self       = shift;
0.000000,0,0.000000,my %constraint = @_;
0.000000,0,0.000000,$self->$_where_expressions(
0.000000,0,0.000000,"attributes check",
0.000000,0,0.000000,map { my $attr = $_; qq{\$_->$attr} => $constraint{$attr} }
0.000000,0,0.000000,sort keys %constraint,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
