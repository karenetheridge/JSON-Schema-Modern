# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Moo;
0.000026,2,0.000013,use strict;
0.000017,2,0.000008,use warnings;
0.000026,2,0.000013,no warnings 'once';
0.000000,0,0.000000,
0.000374,1,0.000374,use Moo::_Utils qw(
0.000000,0,0.000000,_check_tracked
0.000000,0,0.000000,_getglob
0.000000,0,0.000000,_getstash
0.000000,0,0.000000,_install_coderef
0.000000,0,0.000000,_install_modifier
0.000000,0,0.000000,_install_tracked
0.000000,0,0.000000,_linear_isa
0.000000,0,0.000000,_load_module
0.000000,0,0.000000,_set_loaded
0.000000,0,0.000000,_unimport_coderefs
0.000072,1,0.000072,);
0.000063,2,0.000031,use Carp qw(croak);
0.000000,0,0.000000,BEGIN {
0.000004,1,0.000004,our @CARP_NOT = qw(
0.000000,0,0.000000,Method::Generate::Constructor
0.000000,0,0.000000,Method::Generate::Accessor
0.000000,0,0.000000,Moo::sification
0.000000,0,0.000000,Moo::_Utils
0.000000,0,0.000000,Moo::Role
0.000000,0,0.000000,);
0.000353,1,0.000353,}
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '2.005004';
0.000002,1,0.000002,$VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.001419,1,0.001419,require Moo::sification;
0.000002,1,0.000002,Moo::sification->import;
0.000000,0,0.000000,
0.000000,0,0.000000,our %MAKERS;
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000019,17,0.000001,my $target = caller;
0.000006,17,0.000000,my $class = shift;
0.000058,17,0.000003,if ($INC{'Role/Tiny.pm'} and Role::Tiny->is_role($target)) {
0.000000,0,0.000000,croak "Cannot import Moo into a role";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000056,17,0.000003,_set_loaded(caller);
0.000000,0,0.000000,
0.000075,17,0.000004,strict->import;
0.000019,17,0.000001,warnings->import;
0.000000,0,0.000000,
0.000038,17,0.000002,$class->_install_subs($target, @_);
0.000034,17,0.000002,$class->make_class($target);
0.000071,17,0.000004,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub make_class {
0.000002,17,0.000000,my ($me, $target) = @_;
0.000000,0,0.000000,
0.000024,17,0.000001,my $makers = $MAKERS{$target} ||= {};
0.000009,17,0.000001,return $target if $makers->{is_class};
0.000000,0,0.000000,
0.000020,17,0.000001,my $stash = _getstash($target);
0.000000,0,0.000000,$makers->{non_methods} = {
0.000000,0,0.000000,map +($_ => \&{"${target}::${_}"}),
0.000635,17,0.000037,grep exists &{"${target}::${_}"},
0.000000,0,0.000000,grep !/::\z/ && !/\A\(/,
0.000000,0,0.000000,keys %$stash
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000007,17,0.000000,$makers->{is_class} = 1;
0.000000,0,0.000000,{
0.001089,19,0.000057,no strict 'refs';
0.000000,0,0.000000,@{"${target}::ISA"} = do {
0.002653,34,0.000078,require Moo::Object; ('Moo::Object');
0.000189,17,0.000011,} unless @{"${target}::ISA"};
0.000000,0,0.000000,}
0.000005,17,0.000000,if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
0.000000,0,0.000000,Moo::HandleMoose::inject_fake_metaclass_for($target);
0.000000,0,0.000000,}
0.000049,17,0.000003,return $target;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_class {
0.000003,7,0.000000,my ($me, $class) = @_;
0.000027,7,0.000004,return $MAKERS{$class} && $MAKERS{$class}{is_class};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_subs {
0.000011,17,0.000001,my ($me, $target) = @_;
0.000085,17,0.000005,my %install = $me->_gen_subs($target);
0.000000,0,0.000000,_install_tracked $target => $_ => $install{$_}
0.000288,17,0.000017,for sort keys %install;
0.000045,17,0.000003,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _gen_subs {
0.000009,17,0.000001,my ($me, $target) = @_;
0.000000,0,0.000000,return (
0.000000,0,0.000000,extends => sub {
0.000004,2,0.000002,$me->_set_superclasses($target, @_);
0.000002,2,0.000001,$me->_maybe_reset_handlemoose($target);
0.000005,2,0.000002,return;
0.000000,0,0.000000,},
0.000000,0,0.000000,with => sub {
0.000013,9,0.000001,require Moo::Role;
0.000039,9,0.000004,Moo::Role->apply_roles_to_package($target, @_);
0.000043,9,0.000005,$me->_maybe_reset_handlemoose($target);
0.000000,0,0.000000,},
0.000000,0,0.000000,has => sub {
0.000019,45,0.000000,my $name_proto = shift;
0.000068,45,0.000002,my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
0.000046,45,0.000001,if (@_ % 2 != 0) {
0.000000,0,0.000000,croak "Invalid options for " . join(', ', map "'$_'", @name_proto)
0.000000,0,0.000000,. " attribute(s): even number of arguments expected, got " . scalar @_;
0.000000,0,0.000000,}
0.000065,45,0.000001,my %spec = @_;
0.000035,45,0.000001,foreach my $name (@name_proto) {
0.000000,0,0.000000,# Note that when multiple attributes specified, each attribute
0.000000,0,0.000000,# needs a separate \%specs hashref
0.000041,49,0.000001,my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
0.000124,49,0.000003,$me->_constructor_maker_for($target)
0.000000,0,0.000000,->register_attribute_specs($name, $spec_ref);
0.000156,49,0.000003,$me->_accessor_maker_for($target)
0.000000,0,0.000000,->generate_method($target, $name, $spec_ref);
0.000171,49,0.000003,$me->_maybe_reset_handlemoose($target);
0.000000,0,0.000000,}
0.000174,45,0.000004,return;
0.000000,0,0.000000,},
0.000000,0,0.000000,(map {
0.000251,68,0.000004,my $type = $_;
0.000000,0,0.000000,(
0.000000,0,0.000000,$type => sub {
0.000015,7,0.000002,_install_modifier($target, $type, @_);
0.000027,7,0.000004,return;
0.000000,0,0.000000,},
0.000000,0,0.000000,)
0.000054,51,0.000001,} qw(before after around)),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unimport {
0.000000,0,0.000000,my $target = caller;
0.000000,0,0.000000,_unimport_coderefs($target);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _set_superclasses {
0.000001,2,0.000000,my $class = shift;
0.000000,2,0.000000,my $target = shift;
0.000000,2,0.000000,foreach my $superclass (@_) {
0.000001,2,0.000000,_load_module($superclass);
0.000005,2,0.000002,if ($INC{'Role/Tiny.pm'} && Role::Tiny->is_role($superclass)) {
0.000000,0,0.000000,croak "Can't extend role '$superclass'";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000024,2,0.000012,@{*{_getglob("${target}::ISA")}} = @_;
0.000002,2,0.000001,if (my $old = delete $Moo::MAKERS{$target}{constructor}) {
0.000003,2,0.000002,$old->assert_constructor;
0.000028,2,0.000014,delete _getstash($target)->{new};
0.000000,0,0.000000,Moo->_constructor_maker_for($target)
0.000007,2,0.000003,->register_attribute_specs(%{$old->all_attribute_specs});
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (!$target->isa('Moo::Object')) {
0.000000,0,0.000000,Moo->_constructor_maker_for($target);
0.000000,0,0.000000,}
0.000023,2,0.000012,$Moo::HandleMoose::MOUSE{$target} = [
0.000000,0,0.000000,grep defined, map Mouse::Util::find_meta($_), @_
0.000000,0,0.000000,] if Mouse::Util->can('find_meta');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _maybe_reset_handlemoose {
0.000030,60,0.000001,my ($class, $target) = @_;
0.000148,60,0.000002,if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
0.000000,0,0.000000,Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _accessor_maker_for {
0.000057,116,0.000000,my ($class, $target) = @_;
0.000084,116,0.000001,return unless $MAKERS{$target};
0.000300,116,0.000003,$MAKERS{$target}{accessor} ||= do {
0.000011,18,0.000001,my $maker_class = do {
0.000397,2,0.000199,no strict 'refs';
0.000011,18,0.000001,if (my $m = do {
0.000147,18,0.000008,my @isa = @{_linear_isa($target)};
0.000004,18,0.000000,shift @isa;
0.000085,18,0.000005,if (my ($parent_new) = grep +(defined &{$_.'::new'}), @isa) {
0.000000,0,0.000000,$MAKERS{$parent_new} && $MAKERS{$parent_new}{accessor};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,}) {
0.000000,0,0.000000,ref($m);
0.000000,0,0.000000,} else {
0.000699,18,0.000039,require Method::Generate::Accessor;
0.000007,18,0.000000,'Method::Generate::Accessor'
0.000000,0,0.000000,}
0.000000,0,0.000000,};
0.000063,18,0.000003,$maker_class->new;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _constructor_maker_for {
0.000034,99,0.000000,my ($class, $target) = @_;
0.000023,99,0.000000,return unless $MAKERS{$target};
0.000257,99,0.000003,$MAKERS{$target}{constructor} ||= do {
0.000462,10,0.000046,require Method::Generate::Constructor;
0.000000,0,0.000000,
0.000091,10,0.000009,my %construct_opts = (
0.000000,0,0.000000,package => $target,
0.000000,0,0.000000,accessor_generator => $class->_accessor_maker_for($target),
0.000000,0,0.000000,subconstructor_handler => (
0.000000,0,0.000000,'      if ($Moo::MAKERS{$class}) {'."\n"
0.000000,0,0.000000,.'        if ($Moo::MAKERS{$class}{constructor}) {'."\n"
0.000000,0,0.000000,.'          package '.$target.';'."\n"
0.000000,0,0.000000,.'          return $invoker->SUPER::new(@_);'."\n"
0.000000,0,0.000000,.'        }'."\n"
0.000000,0,0.000000,.'        '.$class.'->_constructor_maker_for($class);'."\n"
0.000000,0,0.000000,.'        return $invoker->new(@_)'.";\n"
0.000000,0,0.000000,.'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n"
0.000000,0,0.000000,.'        return $meta->new_object('."\n"
0.000000,0,0.000000,.'          $class->can("BUILDARGS") ? $class->BUILDARGS(@_)'."\n"
0.000000,0,0.000000,.'                      : $class->Moo::Object::BUILDARGS(@_)'."\n"
0.000000,0,0.000000,.'        );'."\n"
0.000000,0,0.000000,.'      }'."\n"
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,10,0.000000,my $con;
0.000042,10,0.000004,my @isa = @{_linear_isa($target)};
0.000003,10,0.000000,shift @isa;
0.000326,2,0.000163,no strict 'refs';
0.000054,10,0.000005,if (my ($parent_new) = grep +(defined &{$_.'::new'}), @isa) {
0.000028,10,0.000003,if ($parent_new eq 'Moo::Object') {
0.000000,0,0.000000,# no special constructor needed
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (my $makers = $MAKERS{$parent_new}) {
0.000000,1,0.000000,$con = $makers->{constructor};
0.000002,1,0.000002,$construct_opts{construction_string} = $con->construction_string
0.000000,0,0.000000,if $con;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($parent_new->can('BUILDALL')) {
0.000000,0,0.000000,$construct_opts{construction_builder} = sub {
0.000000,0,0.000000,my $inv = $target->can('BUILDARGS') ? '' : 'Moo::Object::';
0.000000,0,0.000000,'do {'
0.000000,0,0.000000,.'  my $args = $class->'.$inv.'BUILDARGS(@_);'
0.000000,0,0.000000,.'  $args->{__no_BUILD__} = 1;'
0.000000,0,0.000000,.'  $invoker->'.$target.'::SUPER::new($args);'
0.000000,0,0.000000,.'}'
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$construct_opts{construction_builder} = sub {
0.000010,1,0.000010,'$invoker->'.$target.'::SUPER::new('
0.000000,0,0.000000,.($target->can('FOREIGNBUILDARGS') ?
0.000000,0,0.000000,'$class->FOREIGNBUILDARGS(@_)' : '@_')
0.000000,0,0.000000,.')'
0.000003,1,0.000003,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,($con ? ref($con) : 'Method::Generate::Constructor')
0.000000,0,0.000000,->new(%construct_opts)
0.000000,0,0.000000,->install_delayed
0.000112,10,0.000011,->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _concrete_methods_of {
0.000000,0,0.000000,my ($me, $class) = @_;
0.000000,0,0.000000,my $makers = $MAKERS{$class};
0.000000,0,0.000000,
0.000000,0,0.000000,my $non_methods = $makers->{non_methods} || {};
0.000000,0,0.000000,my $stash = _getstash($class);
0.000000,0,0.000000,
0.000000,0,0.000000,my $subs = {
0.000000,0,0.000000,map {;
0.000437,2,0.000218,no strict 'refs';
0.000000,0,0.000000,${"${class}::${_}"} = ${"${class}::${_}"};
0.000000,0,0.000000,($_ => \&{"${class}::${_}"});
0.000000,0,0.000000,}
0.000000,0,0.000000,grep exists &{"${class}::${_}"},
0.000000,0,0.000000,grep !/::\z/,
0.000000,0,0.000000,keys %$stash
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,my %tracked = map +($_ => 1), _check_tracked($class, [ keys %$subs ]);
0.000000,0,0.000000,
0.000000,0,0.000000,return {
0.000000,0,0.000000,map +($_ => \&{"${class}::${_}"}),
0.000000,0,0.000000,grep !($non_methods->{$_} && $non_methods->{$_} == $subs->{$_}),
0.000000,0,0.000000,grep !exists $tracked{$_},
0.000000,0,0.000000,keys %$subs
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,1;
0.000000,0,0.000000,__END__
