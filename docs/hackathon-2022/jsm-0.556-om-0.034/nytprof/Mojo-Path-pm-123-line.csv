# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Mojo::Path;
0.000065,2,0.000032,use Mojo::Base -base;
1.285889,855701,0.000002,use overload '@{}' => sub { shift->parts }, bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
0.000000,0,0.000000,
0.001035,2,0.000518,use Mojo::Util qw(decode encode url_escape url_unescape);
0.000000,0,0.000000,
0.000002,1,0.000002,has charset => 'UTF-8';
0.000000,0,0.000000,
0.000000,0,0.000000,sub canonicalize {
0.008298,33963,0.000000,my $self = shift;
0.000000,0,0.000000,
0.033091,33963,0.000001,my $parts = $self->parts;
0.047464,33963,0.000001,for (my $i = 0; $i <= $#$parts;) {
0.136605,135851,0.000001,if    (!length $parts->[$i] || $parts->[$i] eq '.' || $parts->[$i] eq '...') { splice @$parts, $i, 1 }
0.000000,0,0.000000,elsif ($i < 1 || $parts->[$i] ne '..' || $parts->[$i - 1] eq '..')           { $i++ }
0.000000,0,0.000000,else                                                                         { splice @$parts, --$i, 2 }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.059973,33963,0.000002,return @$parts ? $self : $self->trailing_slash(undef);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone {
0.062342,421558,0.000000,my $self = shift;
0.000000,0,0.000000,
0.310064,421558,0.000001,my $clone = $self->new;
0.375837,421558,0.000001,if (exists $self->{charset}) { $clone->{charset} = $self->{charset} }
0.178432,421558,0.000000,if (my $parts = $self->{parts}) {
0.105150,66041,0.000002,$clone->{$_} = $self->{$_} for qw(leading_slash trailing_slash);
0.061337,66041,0.000001,$clone->{parts} = [@$parts];
0.000000,0,0.000000,}
0.173988,355517,0.000000,else { $clone->{path} = $self->{path} }
0.000000,0,0.000000,
0.590003,421558,0.000001,return $clone;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub contains { $_[1] eq '/' || $_[0]->to_route =~ m!^\Q$_[1]\E(?:/|$)! }
0.000000,0,0.000000,
0.245635,124504,0.000002,sub leading_slash { shift->_parse(leading_slash => @_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub merge {
0.090573,154687,0.000001,my ($self, $path) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Replace
0.504408,154687,0.000003,return $self->parse($path) if $path =~ m!^/!;
0.000000,0,0.000000,
0.000000,0,0.000000,# Merge
0.117637,54985,0.000002,pop @{$self->parts} unless $self->trailing_slash;
0.059717,54985,0.000001,$path = $self->new($path);
0.119501,54985,0.000002,push @{$self->parts}, @{$path->parts};
0.258519,54985,0.000005,return $self->trailing_slash($path->trailing_slash);
0.000000,0,0.000000,}
0.000000,0,0.000000,
1.152814,613160,0.000002,sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse {
0.026790,154687,0.000000,my $self = shift;
0.091504,154687,0.000001,$self->{path} = shift;
0.095023,154687,0.000001,delete @$self{qw(leading_slash parts trailing_slash)};
0.219315,154687,0.000001,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.569694,323422,0.000002,sub parts { shift->_parse(parts => @_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub to_abs_string {
0.000000,0,0.000000,my $path = shift->to_string;
0.000000,0,0.000000,return $path =~ m!^/! ? $path : "/$path";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub to_dir {
0.000000,0,0.000000,my $clone = shift->clone;
0.000000,0,0.000000,pop @{$clone->parts} unless $clone->trailing_slash;
0.000000,0,0.000000,return $clone->trailing_slash(!!@{$clone->parts});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub to_route {
0.000000,0,0.000000,my $clone = shift->clone;
0.000000,0,0.000000,return '/' . join '/', @{$clone->parts}, $clone->trailing_slash ? '' : ();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub to_string {
0.060740,366247,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Path
0.303388,366247,0.000001,my $charset = $self->charset;
0.152666,366247,0.000000,if (defined(my $path = $self->{path})) {
0.231333,275706,0.000001,$path = encode $charset, $path if $charset;
0.593183,275706,0.000002,return url_escape $path, '^A-Za-z0-9\-._~!$&\'()*+,;=%:@/';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Build path
0.136631,90541,0.000002,my @parts = @{$self->parts};
0.309613,338124,0.000001,@parts = map { encode $charset, $_ } @parts if $charset;
0.312526,338124,0.000001,my $path = join '/', map { url_escape $_, '^A-Za-z0-9\-._~!$&\'()*+,;=:@' } @parts;
0.101207,90541,0.000001,$path = "/$path" if $self->leading_slash;
0.074560,90541,0.000001,$path = "$path/" if $self->trailing_slash;
0.219079,90541,0.000002,return $path;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.457153,255496,0.000002,sub trailing_slash { shift->_parse(trailing_slash => @_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _parse {
0.170232,703422,0.000000,my ($self, $name) = (shift, shift);
0.000000,0,0.000000,
0.191625,703422,0.000000,unless ($self->{parts}) {
0.179152,125862,0.000001,my $path    = url_unescape delete($self->{path}) // '';
0.113585,125862,0.000001,my $charset = $self->charset;
0.146109,125862,0.000001,$path                   = decode($charset, $path) // $path if $charset;
0.355037,125862,0.000003,$self->{leading_slash}  = $path =~ s!^/!!;
0.191123,125862,0.000002,$self->{trailing_slash} = $path =~ s!/$!!;
0.212669,125862,0.000002,$self->{parts}          = [split /\//, $path, -1];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.941876,703422,0.000001,return $self->{$name} unless @_;
0.023207,54985,0.000000,$self->{$name} = shift;
0.086322,54985,0.000002,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,1;
0.000000,0,0.000000,
0.000000,0,0.000000,=encoding utf8
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,Mojo::Path - Path
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use Mojo::Path;
0.000000,0,0.000000,
0.000000,0,0.000000,# Parse
0.000000,0,0.000000,my $path = Mojo::Path->new('/foo%2Fbar%3B/baz.html');
0.000000,0,0.000000,say $path->[0];
0.000000,0,0.000000,
0.000000,0,0.000000,# Build
0.000000,0,0.000000,my $path = Mojo::Path->new('/i/♥');
0.000000,0,0.000000,push @$path, 'mojolicious';
0.000000,0,0.000000,say "$path";
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,L<Mojo::Path> is a container for paths used by L<Mojo::URL>, based on L<RFC 3986|https://tools.ietf.org/html/rfc3986>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 ATTRIBUTES
0.000000,0,0.000000,
0.000000,0,0.000000,L<Mojo::Path> implements the following attributes.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 charset
0.000000,0,0.000000,
0.000000,0,0.000000,my $charset = $path->charset;
0.000000,0,0.000000,$path       = $path->charset('UTF-8');
0.000000,0,0.000000,
0.000000,0,0.000000,Charset used for encoding and decoding, defaults to C<UTF-8>.
0.000000,0,0.000000,
0.000000,0,0.000000,# Disable encoding and decoding
0.000000,0,0.000000,$path->charset(undef);
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 METHODS
0.000000,0,0.000000,
0.000000,0,0.000000,L<Mojo::Path> inherits all methods from L<Mojo::Base> and implements the following new ones.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 canonicalize
0.000000,0,0.000000,
0.000000,0,0.000000,$path = $path->canonicalize;
0.000000,0,0.000000,
0.000000,0,0.000000,Canonicalize path by resolving C<.> and C<..>, in addition C<...> will be treated as C<.> to protect from path
0.000000,0,0.000000,traversal attacks.
0.000000,0,0.000000,
0.000000,0,0.000000,# "/foo/baz"
0.000000,0,0.000000,Mojo::Path->new('/foo/./bar/../baz')->canonicalize;
0.000000,0,0.000000,
0.000000,0,0.000000,# "/../baz"
0.000000,0,0.000000,Mojo::Path->new('/foo/../bar/../../baz')->canonicalize;
0.000000,0,0.000000,
0.000000,0,0.000000,# "/foo/bar"
0.000000,0,0.000000,Mojo::Path->new('/foo/.../bar')->canonicalize;
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 clone
0.000000,0,0.000000,
0.000000,0,0.000000,my $clone = $path->clone;
0.000000,0,0.000000,
0.000000,0,0.000000,Return a new L<Mojo::Path> object cloned from this path.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 contains
0.000000,0,0.000000,
0.000000,0,0.000000,my $bool = $path->contains('/i/♥/mojolicious');
0.000000,0,0.000000,
0.000000,0,0.000000,Check if path contains given prefix.
0.000000,0,0.000000,
0.000000,0,0.000000,# True
0.000000,0,0.000000,Mojo::Path->new('/foo/bar')->contains('/');
0.000000,0,0.000000,Mojo::Path->new('/foo/bar')->contains('/foo');
0.000000,0,0.000000,Mojo::Path->new('/foo/bar')->contains('/foo/bar');
0.000000,0,0.000000,
0.000000,0,0.000000,# False
0.000000,0,0.000000,Mojo::Path->new('/foo/bar')->contains('/f');
0.000000,0,0.000000,Mojo::Path->new('/foo/bar')->contains('/bar');
0.000000,0,0.000000,Mojo::Path->new('/foo/bar')->contains('/whatever');
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 leading_slash
0.000000,0,0.000000,
0.000000,0,0.000000,my $bool = $path->leading_slash;
0.000000,0,0.000000,$path    = $path->leading_slash($bool);
0.000000,0,0.000000,
0.000000,0,0.000000,Path has a leading slash. Note that this method will normalize the path and that C<%2F> will be treated as C</> for
0.000000,0,0.000000,security reasons.
0.000000,0,0.000000,
0.000000,0,0.000000,# "/foo/bar"
0.000000,0,0.000000,Mojo::Path->new('foo/bar')->leading_slash(1);
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo/bar"
0.000000,0,0.000000,Mojo::Path->new('/foo/bar')->leading_slash(0);
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 merge
0.000000,0,0.000000,
0.000000,0,0.000000,$path = $path->merge('/foo/bar');
0.000000,0,0.000000,$path = $path->merge('foo/bar');
0.000000,0,0.000000,$path = $path->merge(Mojo::Path->new);
0.000000,0,0.000000,
0.000000,0,0.000000,Merge paths. Note that this method will normalize both paths if necessary and that C<%2F> will be treated as C</> for
0.000000,0,0.000000,security reasons.
0.000000,0,0.000000,
0.000000,0,0.000000,# "/baz/yada"
0.000000,0,0.000000,Mojo::Path->new('/foo/bar')->merge('/baz/yada');
0.000000,0,0.000000,
0.000000,0,0.000000,# "/foo/baz/yada"
0.000000,0,0.000000,Mojo::Path->new('/foo/bar')->merge('baz/yada');
0.000000,0,0.000000,
0.000000,0,0.000000,# "/foo/bar/baz/yada"
0.000000,0,0.000000,Mojo::Path->new('/foo/bar/')->merge('baz/yada');
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 new
0.000000,0,0.000000,
0.000000,0,0.000000,my $path = Mojo::Path->new;
0.000000,0,0.000000,my $path = Mojo::Path->new('/foo%2Fbar%3B/baz.html');
0.000000,0,0.000000,
0.000000,0,0.000000,Construct a new L<Mojo::Path> object and L</"parse"> path if necessary.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 parse
0.000000,0,0.000000,
0.000000,0,0.000000,$path = $path->parse('/foo%2Fbar%3B/baz.html');
0.000000,0,0.000000,
0.000000,0,0.000000,Parse path.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 to_abs_string
0.000000,0,0.000000,
0.000000,0,0.000000,my $str = $path->to_abs_string;
0.000000,0,0.000000,
0.000000,0,0.000000,Turn path into an absolute string.
0.000000,0,0.000000,
0.000000,0,0.000000,# "/i/%E2%99%A5/mojolicious"
0.000000,0,0.000000,Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_abs_string;
0.000000,0,0.000000,Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_abs_string;
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 parts
0.000000,0,0.000000,
0.000000,0,0.000000,my $parts = $path->parts;
0.000000,0,0.000000,$path     = $path->parts([qw(foo bar baz)]);
0.000000,0,0.000000,
0.000000,0,0.000000,The path parts. Note that this method will normalize the path and that C<%2F> will be treated as C</> for security
0.000000,0,0.000000,reasons.
0.000000,0,0.000000,
0.000000,0,0.000000,# Part with slash
0.000000,0,0.000000,push @{$path->parts}, 'foo/bar';
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 to_dir
0.000000,0,0.000000,
0.000000,0,0.000000,my $dir = $route->to_dir;
0.000000,0,0.000000,
0.000000,0,0.000000,Clone path and remove everything after the right-most slash.
0.000000,0,0.000000,
0.000000,0,0.000000,# "/i/%E2%99%A5/"
0.000000,0,0.000000,Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_dir->to_abs_string;
0.000000,0,0.000000,
0.000000,0,0.000000,# "i/%E2%99%A5/"
0.000000,0,0.000000,Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_dir->to_abs_string;
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 to_route
0.000000,0,0.000000,
0.000000,0,0.000000,my $route = $path->to_route;
0.000000,0,0.000000,
0.000000,0,0.000000,Turn path into a route.
0.000000,0,0.000000,
0.000000,0,0.000000,# "/i/♥/mojolicious"
0.000000,0,0.000000,Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_route;
0.000000,0,0.000000,Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_route;
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 to_string
0.000000,0,0.000000,
0.000000,0,0.000000,my $str = $path->to_string;
0.000000,0,0.000000,
0.000000,0,0.000000,Turn path into a string.
0.000000,0,0.000000,
0.000000,0,0.000000,# "/i/%E2%99%A5/mojolicious"
0.000000,0,0.000000,Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_string;
0.000000,0,0.000000,
0.000000,0,0.000000,# "i/%E2%99%A5/mojolicious"
0.000000,0,0.000000,Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_string;
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 trailing_slash
0.000000,0,0.000000,
0.000000,0,0.000000,my $bool = $path->trailing_slash;
0.000000,0,0.000000,$path    = $path->trailing_slash($bool);
0.000000,0,0.000000,
0.000000,0,0.000000,Path has a trailing slash. Note that this method will normalize the path and that C<%2F> will be treated as C</> for
0.000000,0,0.000000,security reasons.
0.000000,0,0.000000,
0.000000,0,0.000000,# "/foo/bar/"
0.000000,0,0.000000,Mojo::Path->new('/foo/bar')->trailing_slash(1);
0.000000,0,0.000000,
0.000000,0,0.000000,# "/foo/bar"
0.000000,0,0.000000,Mojo::Path->new('/foo/bar/')->trailing_slash(0);
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 OPERATORS
0.000000,0,0.000000,
0.000000,0,0.000000,L<Mojo::Path> overloads the following operators.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 array
0.000000,0,0.000000,
0.000000,0,0.000000,my @parts = @$path;
0.000000,0,0.000000,
0.000000,0,0.000000,Alias for L</"parts">. Note that this will normalize the path and that C<%2F> will be treated as C</> for security
0.000000,0,0.000000,reasons.
0.000000,0,0.000000,
0.000000,0,0.000000,say $path->[0];
0.000000,0,0.000000,say for @$path;
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 bool
0.000000,0,0.000000,
0.000000,0,0.000000,my $bool = !!$path;
0.000000,0,0.000000,
0.000000,0,0.000000,Always true.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 stringify
0.000000,0,0.000000,
0.000000,0,0.000000,my $str = "$path";
0.000000,0,0.000000,
0.000000,0,0.000000,Alias for L</"to_string">.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
