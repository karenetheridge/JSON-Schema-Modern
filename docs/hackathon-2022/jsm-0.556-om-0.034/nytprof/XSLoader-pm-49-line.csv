# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# Generated from XSLoader_pm.PL (resolved %Config::Config value)
0.000000,0,0.000000,# This file is unique for every OS
0.000000,0,0.000000,
0.000000,0,0.000000,use strict;
0.000000,0,0.000000,no strict 'refs';
0.000000,0,0.000000,
0.000000,0,0.000000,package XSLoader;
0.000000,0,0.000000,
0.000000,0,0.000000,our $VERSION = "0.31"; # remember to update version in POD!
0.000000,0,0.000000,
0.000000,0,0.000000,package DynaLoader;
0.000000,0,0.000000,
0.000000,0,0.000000,# No prizes for guessing why we don't say 'bootstrap DynaLoader;' here.
0.000000,0,0.000000,# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB
0.000000,0,0.000000,boot_DynaLoader('DynaLoader') if defined(&boot_DynaLoader) &&
0.000000,0,0.000000,!defined(&dl_error);
0.000000,0,0.000000,package XSLoader;
0.000000,0,0.000000,
0.000000,0,0.000000,sub load {
0.000000,0,0.000000,package DynaLoader;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($caller, $modlibname) = caller();
0.000000,0,0.000000,my $module = $caller;
0.000000,0,0.000000,
0.000000,0,0.000000,if (@_) {
0.000000,0,0.000000,$module = $_[0];
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$_[0] = $module;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# work with static linking too
0.000000,0,0.000000,my $boots = "$module\::bootstrap";
0.000000,0,0.000000,goto &$boots if defined &$boots;
0.000000,0,0.000000,
0.000000,0,0.000000,goto \&XSLoader::bootstrap_inherit unless $module and defined &dl_load_file;
0.000000,0,0.000000,
0.000000,0,0.000000,my @modparts = split(/::/,$module);
0.000000,0,0.000000,my $modfname = $modparts[-1];
0.000000,0,0.000000,my $modfname_orig = $modfname; # For .bs file search
0.000000,0,0.000000,
0.000000,0,0.000000,my $modpname = join('/',@modparts);
0.000000,0,0.000000,my $c = () = split(/::/,$caller,-1);
0.000000,0,0.000000,$modlibname =~ s,[\\/][^\\/]+$,, while $c--;    # Q&D basename
0.000000,0,0.000000,# Does this look like a relative path?
0.000000,0,0.000000,if ($modlibname !~ m{^/}) {
0.000000,0,0.000000,# Someone may have a #line directive that changes the file name, or
0.000000,0,0.000000,# may be calling XSLoader::load from inside a string eval.  We cer-
0.000000,0,0.000000,# tainly do not want to go loading some code that is not in @INC,
0.000000,0,0.000000,# as it could be untrusted.
0.000000,0,0.000000,#
0.000000,0,0.000000,# We could just fall back to DynaLoader here, but then the rest of
0.000000,0,0.000000,# this function would go untested in the perl core, since all @INC
0.000000,0,0.000000,# paths are relative during testing.  That would be a time bomb
0.000000,0,0.000000,# waiting to happen, since bugs could be introduced into the code.
0.000000,0,0.000000,#
0.000000,0,0.000000,# So look through @INC to see if $modlibname is in it.  A rela-
0.000000,0,0.000000,# tive $modlibname is not a common occurrence, so this block is
0.000000,0,0.000000,# not hot code.
0.000000,0,0.000000,FOUND: {
0.000000,0,0.000000,for (@INC) {
0.000000,0,0.000000,if ($_ eq $modlibname) {
0.000000,0,0.000000,last FOUND;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,# Not found.  Fall back to DynaLoader.
0.000000,0,0.000000,goto \&XSLoader::bootstrap_inherit;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my $file = "$modlibname/auto/$modpname/$modfname.bundle";
0.000000,0,0.000000,
0.000000,0,0.000000,#   print STDERR "XSLoader::load for $module ($file)\n" if $dl_debug;
0.000000,0,0.000000,
0.000000,0,0.000000,# N.B. The .bs file does not following the naming convention used
0.000000,0,0.000000,# by mod2fname, so use the unedited version of the name.
0.000000,0,0.000000,
0.000000,0,0.000000,my $bs = "$modlibname/auto/$modpname/$modfname_orig.bs";
0.000000,0,0.000000,
0.000000,0,0.000000,# This calls DynaLoader::bootstrap, which will load the .bs file if present
0.000000,0,0.000000,goto \&XSLoader::bootstrap_inherit if not -f $file or -s $bs;
0.000000,0,0.000000,
0.000000,0,0.000000,my $bootname = "boot_$module";
0.000000,0,0.000000,$bootname =~ s/\W/_/g;
0.000000,0,0.000000,@DynaLoader::dl_require_symbols = ($bootname);
0.000000,0,0.000000,
0.000000,0,0.000000,my $boot_symbol_ref;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($boot_symbol_ref = dl_find_symbol( 0, $bootname )) {
0.000000,0,0.000000,goto boot; #extension library has already been loaded, e.g. darwin
0.000000,0,0.000000,}
0.000000,0,0.000000,# Many dynamic extension loading problems will appear to come from
0.000000,0,0.000000,# this section of code: XYZ failed at line 123 of DynaLoader.pm.
0.000000,0,0.000000,# Often these errors are actually occurring in the initialisation
0.000000,0,0.000000,# C code of the extension XS file. Perl reports the error as being
0.000000,0,0.000000,# in this perl code simply because this was the last perl code
0.000000,0,0.000000,# it executed.
0.000000,0,0.000000,
0.000000,0,0.000000,my $libref = dl_load_file($file, 0) or do { 
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Can't load '$file' for module $module: " . dl_error());
0.000000,0,0.000000,};
0.000000,0,0.000000,push(@DynaLoader::dl_librefs,$libref);  # record loaded object
0.000000,0,0.000000,
0.000000,0,0.000000,$boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Can't find '$bootname' symbol in $file\n");
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,push(@DynaLoader::dl_modules, $module); # record loaded module
0.000000,0,0.000000,
0.000000,0,0.000000,boot:
0.000000,0,0.000000,my $xs = dl_install_xsub($boots, $boot_symbol_ref, $file);
0.000000,0,0.000000,
0.000000,0,0.000000,# See comment block above
0.000000,0,0.000000,push(@DynaLoader::dl_shared_objects, $file); # record files loaded
0.000262,2,0.000131,return &$xs(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Can't test with DynaLoader->can('bootstrap_inherit') when building in the
0.000000,0,0.000000,# core, as XSLoader gets built before DynaLoader.
0.000000,0,0.000000,
0.000000,0,0.000000,sub bootstrap_inherit {
0.000000,0,0.000000,require DynaLoader;
0.000000,0,0.000000,goto \&DynaLoader::bootstrap_inherit;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,XSLoader - Dynamically load C libraries into Perl code
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 VERSION
0.000000,0,0.000000,
0.000000,0,0.000000,Version 0.31
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,package YourPackage;
0.000000,0,0.000000,require XSLoader;
0.000000,0,0.000000,
0.000000,0,0.000000,XSLoader::load(__PACKAGE__, $VERSION);
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,This module defines a standard I<simplified> interface to the dynamic
0.000000,0,0.000000,linking mechanisms available on many platforms.  Its primary purpose is
0.000000,0,0.000000,to implement cheap automatic dynamic loading of Perl modules.
0.000000,0,0.000000,
0.000000,0,0.000000,For a more complicated interface, see L<DynaLoader>.  Many (most)
0.000000,0,0.000000,features of C<DynaLoader> are not implemented in C<XSLoader>, like for
0.000000,0,0.000000,example the C<dl_load_flags>, not honored by C<XSLoader>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Migration from C<DynaLoader>
0.000000,0,0.000000,
0.000000,0,0.000000,A typical module using L<DynaLoader|DynaLoader> starts like this:
0.000000,0,0.000000,
0.000000,0,0.000000,package YourPackage;
0.000000,0,0.000000,require DynaLoader;
0.000000,0,0.000000,
0.000000,0,0.000000,our @ISA = qw( OnePackage OtherPackage DynaLoader );
0.000000,0,0.000000,our $VERSION = '0.01';
0.000000,0,0.000000,__PACKAGE__->bootstrap($VERSION);
0.000000,0,0.000000,
0.000000,0,0.000000,Change this to
0.000000,0,0.000000,
0.000000,0,0.000000,package YourPackage;
0.000000,0,0.000000,use XSLoader;
0.000000,0,0.000000,
0.000000,0,0.000000,our @ISA = qw( OnePackage OtherPackage );
0.000000,0,0.000000,our $VERSION = '0.01';
0.000000,0,0.000000,XSLoader::load(__PACKAGE__, $VERSION);
0.000000,0,0.000000,
0.000000,0,0.000000,In other words: replace C<require DynaLoader> by C<use XSLoader>, remove
0.000000,0,0.000000,C<DynaLoader> from C<@ISA>, change C<bootstrap> by C<XSLoader::load>.  Do not
0.000000,0,0.000000,forget to quote the name of your package on the C<XSLoader::load> line,
0.000000,0,0.000000,and add comma (C<,>) before the arguments (C<$VERSION> above).
0.000000,0,0.000000,
0.000000,0,0.000000,Of course, if C<@ISA> contained only C<DynaLoader>, there is no need to have
0.000000,0,0.000000,the C<@ISA> assignment at all; moreover, if instead of C<our> one uses the
0.000000,0,0.000000,more backward-compatible
0.000000,0,0.000000,
0.000000,0,0.000000,use vars qw($VERSION @ISA);
0.000000,0,0.000000,
0.000000,0,0.000000,one can remove this reference to C<@ISA> together with the C<@ISA> assignment.
0.000000,0,0.000000,
0.000000,0,0.000000,If no C<$VERSION> was specified on the C<bootstrap> line, the last line becomes
0.000000,0,0.000000,
0.000000,0,0.000000,XSLoader::load(__PACKAGE__);
0.000000,0,0.000000,
0.000000,0,0.000000,in which case it can be further simplified to
0.000000,0,0.000000,
0.000000,0,0.000000,XSLoader::load();
0.000000,0,0.000000,
0.000000,0,0.000000,as C<load> will use C<caller> to determine the package.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Backward compatible boilerplate
0.000000,0,0.000000,
0.000000,0,0.000000,If you want to have your cake and eat it too, you need a more complicated
0.000000,0,0.000000,boilerplate.
0.000000,0,0.000000,
0.000000,0,0.000000,package YourPackage;
0.000000,0,0.000000,
0.000000,0,0.000000,our @ISA = qw( OnePackage OtherPackage );
0.000000,0,0.000000,our $VERSION = '0.01';
0.000000,0,0.000000,eval {
0.000000,0,0.000000,require XSLoader;
0.000000,0,0.000000,XSLoader::load(__PACKAGE__, $VERSION);
0.000000,0,0.000000,1;
0.000000,0,0.000000,} or do {
0.000000,0,0.000000,require DynaLoader;
0.000000,0,0.000000,push @ISA, 'DynaLoader';
0.000000,0,0.000000,__PACKAGE__->bootstrap($VERSION);
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,The parentheses about C<XSLoader::load()> arguments are needed since we replaced
0.000000,0,0.000000,C<use XSLoader> by C<require>, so the compiler does not know that a function
0.000000,0,0.000000,C<XSLoader::load()> is present.
0.000000,0,0.000000,
0.000000,0,0.000000,This boilerplate uses the low-overhead C<XSLoader> if present; if used with
0.000000,0,0.000000,an antique Perl which has no C<XSLoader>, it falls back to using C<DynaLoader>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 Order of initialization: early load()
0.000000,0,0.000000,
0.000000,0,0.000000,I<Skip this section if the XSUB functions are supposed to be called from other
0.000000,0,0.000000,modules only; read it only if you call your XSUBs from the code in your module,
0.000000,0,0.000000,or have a C<BOOT:> section in your XS file (see L<perlxs/"The BOOT: Keyword">).
0.000000,0,0.000000,What is described here is equally applicable to the L<DynaLoader|DynaLoader>
0.000000,0,0.000000,interface.>
0.000000,0,0.000000,
0.000000,0,0.000000,A sufficiently complicated module using XS would have both Perl code (defined
0.000000,0,0.000000,in F<YourPackage.pm>) and XS code (defined in F<YourPackage.xs>).  If this
0.000000,0,0.000000,Perl code makes calls into this XS code, and/or this XS code makes calls to
0.000000,0,0.000000,the Perl code, one should be careful with the order of initialization.
0.000000,0,0.000000,
0.000000,0,0.000000,The call to C<XSLoader::load()> (or C<bootstrap()>) calls the module's
0.000000,0,0.000000,bootstrap code. For modules build by F<xsubpp> (nearly all modules) this
0.000000,0,0.000000,has three side effects:
0.000000,0,0.000000,
0.000000,0,0.000000,=over
0.000000,0,0.000000,
0.000000,0,0.000000,=item *
0.000000,0,0.000000,
0.000000,0,0.000000,A sanity check is done to ensure that the versions of the F<.pm> and the
0.000000,0,0.000000,(compiled) F<.xs> parts are compatible. If C<$VERSION> was specified, this
0.000000,0,0.000000,is used for the check. If not specified, it defaults to
0.000000,0,0.000000,C<$XS_VERSION // $VERSION> (in the module's namespace)
0.000000,0,0.000000,
0.000000,0,0.000000,=item *
0.000000,0,0.000000,
0.000000,0,0.000000,the XSUBs are made accessible from Perl
0.000000,0,0.000000,
0.000000,0,0.000000,=item *
0.000000,0,0.000000,
0.000000,0,0.000000,if a C<BOOT:> section was present in the F<.xs> file, the code there is called.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,Consequently, if the code in the F<.pm> file makes calls to these XSUBs, it is
0.000000,0,0.000000,convenient to have XSUBs installed before the Perl code is defined; for
0.000000,0,0.000000,example, this makes prototypes for XSUBs visible to this Perl code.
0.000000,0,0.000000,Alternatively, if the C<BOOT:> section makes calls to Perl functions (or
0.000000,0,0.000000,uses Perl variables) defined in the F<.pm> file, they must be defined prior to
0.000000,0,0.000000,the call to C<XSLoader::load()> (or C<bootstrap()>).
0.000000,0,0.000000,
0.000000,0,0.000000,The first situation being much more frequent, it makes sense to rewrite the
0.000000,0,0.000000,boilerplate as
0.000000,0,0.000000,
0.000000,0,0.000000,package YourPackage;
0.000000,0,0.000000,use XSLoader;
0.000000,0,0.000000,our ($VERSION, @ISA);
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,@ISA = qw( OnePackage OtherPackage );
0.000000,0,0.000000,$VERSION = '0.01';
0.000000,0,0.000000,
0.000000,0,0.000000,# Put Perl code used in the BOOT: section here
0.000000,0,0.000000,
0.000000,0,0.000000,XSLoader::load(__PACKAGE__, $VERSION);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Put Perl code making calls into XSUBs here
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 The most hairy case
0.000000,0,0.000000,
0.000000,0,0.000000,If the interdependence of your C<BOOT:> section and Perl code is
0.000000,0,0.000000,more complicated than this (e.g., the C<BOOT:> section makes calls to Perl
0.000000,0,0.000000,functions which make calls to XSUBs with prototypes), get rid of the C<BOOT:>
0.000000,0,0.000000,section altogether.  Replace it with a function C<onBOOT()>, and call it like
0.000000,0,0.000000,this:
0.000000,0,0.000000,
0.000000,0,0.000000,package YourPackage;
0.000000,0,0.000000,use XSLoader;
0.000000,0,0.000000,our ($VERSION, @ISA);
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,@ISA = qw( OnePackage OtherPackage );
0.000000,0,0.000000,$VERSION = '0.01';
0.000000,0,0.000000,XSLoader::load(__PACKAGE__, $VERSION);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Put Perl code used in onBOOT() function here; calls to XSUBs are
0.000000,0,0.000000,# prototype-checked.
0.000000,0,0.000000,
0.000000,0,0.000000,onBOOT;
0.000000,0,0.000000,
0.000000,0,0.000000,# Put Perl initialization code assuming that XS is initialized here
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DIAGNOSTICS
0.000000,0,0.000000,
0.000000,0,0.000000,=over
0.000000,0,0.000000,
0.000000,0,0.000000,=item C<Can't find '%s' symbol in %s>
0.000000,0,0.000000,
0.000000,0,0.000000,B<(F)> The bootstrap symbol could not be found in the extension module.
0.000000,0,0.000000,
0.000000,0,0.000000,=item C<Can't load '%s' for module %s: %s>
0.000000,0,0.000000,
0.000000,0,0.000000,B<(F)> The loading or initialisation of the extension module failed.
0.000000,0,0.000000,The detailed error follows.
0.000000,0,0.000000,
0.000000,0,0.000000,=item C<Undefined symbols present after loading %s: %s>
0.000000,0,0.000000,
0.000000,0,0.000000,B<(W)> As the message says, some symbols stay undefined although the
0.000000,0,0.000000,extension module was correctly loaded and initialised. The list of undefined
0.000000,0,0.000000,symbols follows.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 LIMITATIONS
0.000000,0,0.000000,
0.000000,0,0.000000,To reduce the overhead as much as possible, only one possible location
0.000000,0,0.000000,is checked to find the extension DLL (this location is where C<make install>
0.000000,0,0.000000,would put the DLL).  If not found, the search for the DLL is transparently
0.000000,0,0.000000,delegated to C<DynaLoader>, which looks for the DLL along the C<@INC> list.
0.000000,0,0.000000,
0.000000,0,0.000000,In particular, this is applicable to the structure of C<@INC> used for testing
0.000000,0,0.000000,not-yet-installed extensions.  This means that running uninstalled extensions
0.000000,0,0.000000,may have much more overhead than running the same extensions after
0.000000,0,0.000000,C<make install>.
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 KNOWN BUGS
0.000000,0,0.000000,
0.000000,0,0.000000,The new simpler way to call C<XSLoader::load()> with no arguments at all
0.000000,0,0.000000,does not work on Perl 5.8.4 and 5.8.5.
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 BUGS
0.000000,0,0.000000,
0.000000,0,0.000000,Please report any bugs or feature requests via the perlbug(1) utility.
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,L<DynaLoader>
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHORS
0.000000,0,0.000000,
0.000000,0,0.000000,Ilya Zakharevich originally extracted C<XSLoader> from C<DynaLoader>.
0.000000,0,0.000000,
0.000000,0,0.000000,CPAN version is currently maintained by SE<eacute>bastien Aperghis-Tramoni
0.000000,0,0.000000,E<lt>sebastien@aperghis.netE<gt>.
0.000000,0,0.000000,
0.000000,0,0.000000,Previous maintainer was Michael G Schwern <schwern@pobox.com>.
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT & LICENSE
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright (C) 1990-2011 by Larry Wall and others.
0.000000,0,0.000000,
0.000000,0,0.000000,This program is free software; you can redistribute it and/or modify
0.000000,0,0.000000,it under the same terms as Perl itself.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
