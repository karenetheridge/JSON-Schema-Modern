# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000042,2,0.000021,use strict;
0.000071,2,0.000036,use warnings;
0.000000,0,0.000000,package YAML::PP::Schema::Core;
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000001,1,0.000001,use YAML::PP::Schema::JSON qw/
0.000000,0,0.000000,represent_int represent_float represent_literal represent_bool
0.000000,0,0.000000,represent_undef
0.000179,1,0.000179,/;
0.000000,0,0.000000,
0.000076,2,0.000038,use B;
0.000000,0,0.000000,
0.000779,2,0.000389,use YAML::PP::Common qw/ YAML_PLAIN_SCALAR_STYLE /;
0.000000,0,0.000000,
0.000014,1,0.000014,my $RE_INT_CORE = qr{^([+-]?(?:[0-9]+))$};
0.000003,1,0.000003,my $RE_FLOAT_CORE = qr{^([+-]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)(?:[eE][+-]?[0-9]+)?)$};
0.000003,1,0.000003,my $RE_INT_OCTAL = qr{^0o([0-7]+)$};
0.000004,1,0.000004,my $RE_INT_HEX = qr{^0x([0-9a-fA-F]+)$};
0.000000,0,0.000000,
0.000000,0,0.000000,sub _from_oct { oct $_[2]->[0] }
0.000000,0,0.000000,sub _from_hex { hex $_[2]->[0] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub register {
0.000003,1,0.000003,my ($self, %args) = @_;
0.000001,1,0.000001,my $schema = $args{schema};
0.000000,0,0.000000,
0.000000,0,0.000000,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:null',
0.000000,0,0.000000,match => [ equals => $_ => undef ],
0.000010,1,0.000010,) for (qw/ null NULL Null ~ /, '');
0.000000,0,0.000000,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:bool',
0.000000,0,0.000000,match => [ equals => $_ => $schema->true ],
0.000011,1,0.000011,) for (qw/ true TRUE True /);
0.000000,0,0.000000,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:bool',
0.000000,0,0.000000,match => [ equals => $_ => $schema->false ],
0.000008,1,0.000008,) for (qw/ false FALSE False /);
0.000003,1,0.000003,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:int',
0.000000,0,0.000000,match => [ regex => $RE_INT_CORE => \&YAML::PP::Schema::JSON::_to_int ],
0.000000,0,0.000000,);
0.000002,1,0.000002,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:int',
0.000000,0,0.000000,match => [ regex => $RE_INT_OCTAL => \&_from_oct ],
0.000000,0,0.000000,);
0.000002,1,0.000002,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:int',
0.000000,0,0.000000,match => [ regex => $RE_INT_HEX => \&_from_hex ],
0.000000,0,0.000000,);
0.000001,1,0.000001,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:float',
0.000000,0,0.000000,match => [ regex => $RE_FLOAT_CORE => \&YAML::PP::Schema::JSON::_to_float ],
0.000000,0,0.000000,);
0.000000,0,0.000000,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:float',
0.000000,0,0.000000,match => [ equals => $_ => 0 + "inf" ],
0.000007,1,0.000007,) for (qw/ .inf .Inf .INF +.inf +.Inf +.INF /);
0.000000,0,0.000000,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:float',
0.000000,0,0.000000,match => [ equals => $_ => 0 - "inf" ],
0.000003,1,0.000003,) for (qw/ -.inf -.Inf -.INF /);
0.000000,0,0.000000,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:float',
0.000000,0,0.000000,match => [ equals => $_ => 0 + "nan" ],
0.000004,1,0.000004,) for (qw/ .nan .NaN .NAN /);
0.000000,0,0.000000,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:str',
0.036569,17714,0.000002,match => [ all => sub { $_[1]->{value} } ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000001,1,0.000001,my $int_flags = B::SVp_IOK;
0.000000,1,0.000000,my $float_flags = B::SVp_NOK;
0.000002,1,0.000002,$schema->add_representer(
0.000000,0,0.000000,flags => $int_flags,
0.000000,0,0.000000,code => \&represent_int,
0.000000,0,0.000000,);
0.000001,1,0.000001,$schema->add_representer(
0.000000,0,0.000000,flags => $float_flags,
0.000000,0,0.000000,code => \&represent_float,
0.000000,0,0.000000,);
0.000001,1,0.000001,$schema->add_representer(
0.000000,0,0.000000,undefined => \&represent_undef,
0.000000,0,0.000000,);
0.000000,0,0.000000,$schema->add_representer(
0.000000,0,0.000000,equals => $_,
0.000000,0,0.000000,code => \&represent_literal,
0.000023,1,0.000023,) for ("", qw/
0.000000,0,0.000000,true TRUE True false FALSE False null NULL Null ~
0.000000,0,0.000000,.inf .Inf .INF +.inf +.Inf +.INF -.inf -.Inf -.INF .nan .NaN .NAN
0.000000,0,0.000000,/);
0.000138,1,0.000138,$schema->add_representer(
0.000000,0,0.000000,regex => qr{$RE_INT_CORE|$RE_FLOAT_CORE|$RE_INT_OCTAL|$RE_INT_HEX},
0.000000,0,0.000000,code => \&represent_literal,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000003,1,0.000003,if ($schema->bool_class) {
0.000000,0,0.000000,for my $class (@{ $schema->bool_class }) {
0.000001,1,0.000001,$schema->add_representer(
0.000000,0,0.000000,class_equals => $class,
0.000000,0,0.000000,code => \&represent_bool,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
