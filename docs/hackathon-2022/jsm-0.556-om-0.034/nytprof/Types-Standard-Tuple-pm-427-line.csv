# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# INTERNAL MODULE: guts for Tuple type from Types::Standard.
0.000000,0,0.000000,
0.000000,0,0.000000,package Types::Standard::Tuple;
0.000000,0,0.000000,
0.000045,2,0.000023,use 5.008001;
0.000037,2,0.000019,use strict;
0.000056,2,0.000028,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000001,1,0.000001,$Types::Standard::Tuple::AUTHORITY = 'cpan:TOBYINK';
0.000003,1,0.000003,$Types::Standard::Tuple::VERSION   = '2.000001';
0.000035,1,0.000035,}
0.000000,0,0.000000,
0.000001,1,0.000001,$Types::Standard::Tuple::VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000041,2,0.000021,use Type::Tiny      ();
0.000010,2,0.000005,use Types::Standard ();
0.000061,2,0.000030,use Types::TypeTiny ();
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
0.000000,0,0.000000,
0.000001,1,0.000001,my $_Optional = Types::Standard::Optional;
0.000002,1,0.000002,my $_Slurpy   = Types::Standard::Slurpy;
0.000000,0,0.000000,
0.001411,2,0.000705,no warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,sub __constraint_generator {
0.000009,2,0.000004,my $slurpy =
0.000000,0,0.000000,@_
0.000000,0,0.000000,&& Types::TypeTiny::is_TypeTiny( $_[-1] )
0.000000,0,0.000000,&& $_[-1]->is_strictly_a_type_of( $_Slurpy )
0.000000,0,0.000000,? pop
0.000000,0,0.000000,: undef;
0.000000,0,0.000000,
0.000002,2,0.000001,my @constraints = @_;
0.000002,2,0.000001,for ( @constraints ) {
0.000003,4,0.000001,Types::TypeTiny::is_TypeTiny( $_ )
0.000000,0,0.000000,or
0.000000,0,0.000000,_croak( "Parameters to Tuple[...] expected to be type constraints; got $_" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# By god, the Type::Tiny::XS API is currently horrible
0.000001,2,0.000000,my @xsub;
0.000000,0,0.000000,if ( Type::Tiny::_USE_XS and !$slurpy ) {
0.000000,0,0.000000,my @known = map {
0.000000,0,0.000000,my $known;
0.000000,0,0.000000,$known = Type::Tiny::XS::is_known( $_->compiled_check )
0.000000,0,0.000000,unless $_->is_strictly_a_type_of( $_Optional );
0.000000,0,0.000000,defined( $known ) ? $known : ();
0.000000,0,0.000000,} @constraints;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( @known == @constraints ) {
0.000000,0,0.000000,my $xsub = Type::Tiny::XS::get_coderef_for(
0.000000,0,0.000000,sprintf( "Tuple[%s]", join( ',', @known ) ) );
0.000000,0,0.000000,push @xsub, $xsub if $xsub;
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( Type::Tiny::_USE_XS...)
0.000000,0,0.000000,
0.000009,2,0.000004,my @is_optional = map !!$_->is_strictly_a_type_of( $_Optional ), @constraints;
0.000000,2,0.000000,my $slurp_hash  = $slurpy && $slurpy->my_slurp_into eq 'HASH';
0.000001,2,0.000000,my $slurp_any   = $slurpy && $slurpy->my_unslurpy->equals( Types::Standard::Any );
0.000000,0,0.000000,
0.000013,2,0.000007,my @sorted_is_optional = sort @is_optional;
0.000003,2,0.000002,join( "|", @sorted_is_optional ) eq join( "|", @is_optional )
0.000000,0,0.000000,or _croak(
0.000000,0,0.000000,"Optional parameters to Tuple[...] cannot precede required parameters" );
0.000000,0,0.000000,
0.000000,0,0.000000,sub {
0.000000,0,0.000000,my $value = $_[0];
0.000000,0,0.000000,if ( $#constraints < $#$value ) {
0.000000,0,0.000000,return !!0 unless $slurpy;
0.000000,0,0.000000,my $tmp;
0.000000,0,0.000000,if ( $slurp_hash ) {
0.000000,0,0.000000,( $#$value - $#constraints + 1 ) % 2 or return;
0.000000,0,0.000000,$tmp = +{ @$value[ $#constraints + 1 .. $#$value ] };
0.000000,0,0.000000,$slurpy->check( $tmp ) or return;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( not $slurp_any ) {
0.000000,0,0.000000,$tmp = +[ @$value[ $#constraints + 1 .. $#$value ] ];
0.000000,0,0.000000,$slurpy->check( $tmp ) or return;
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( $#constraints < $#$value)
0.000000,0,0.000000,for my $i ( 0 .. $#constraints ) {
0.000000,0,0.000000,( $i > $#$value )
0.000000,0,0.000000,and return !!$is_optional[$i];
0.000000,0,0.000000,
0.000000,0,0.000000,$constraints[$i]->check( $value->[$i] )
0.000000,0,0.000000,or return !!0;
0.000000,0,0.000000,}
0.000000,0,0.000000,return !!1;
0.000018,2,0.000009,}, @xsub;
0.000000,0,0.000000,} #/ sub __constraint_generator
0.000000,0,0.000000,
0.000000,0,0.000000,sub __inline_generator {
0.000006,2,0.000003,my $slurpy =
0.000000,0,0.000000,@_
0.000000,0,0.000000,&& Types::TypeTiny::is_TypeTiny( $_[-1] )
0.000000,0,0.000000,&& $_[-1]->is_strictly_a_type_of( $_Slurpy )
0.000000,0,0.000000,? pop
0.000000,0,0.000000,: undef;
0.000003,2,0.000002,my @constraints = @_;
0.000000,0,0.000000,
0.000012,6,0.000002,return if grep { not $_->can_be_inlined } @constraints;
0.000001,2,0.000000,return if defined $slurpy && !$slurpy->can_be_inlined;
0.000000,0,0.000000,
0.000000,2,0.000000,my $xsubname;
0.000000,0,0.000000,if ( Type::Tiny::_USE_XS and !$slurpy ) {
0.000000,0,0.000000,my @known = map {
0.000000,0,0.000000,my $known;
0.000000,0,0.000000,$known = Type::Tiny::XS::is_known( $_->compiled_check )
0.000000,0,0.000000,unless $_->is_strictly_a_type_of( $_Optional );
0.000000,0,0.000000,defined( $known ) ? $known : ();
0.000000,0,0.000000,} @constraints;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( @known == @constraints ) {
0.000000,0,0.000000,$xsubname = Type::Tiny::XS::get_subname_for(
0.000000,0,0.000000,sprintf( "Tuple[%s]", join( ',', @known ) ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( Type::Tiny::_USE_XS...)
0.000000,0,0.000000,
0.000002,2,0.000001,my $tmpl = "do { my \$tmp = +[\@{%s}[%d..\$#{%s}]]; %s }";
0.000000,2,0.000000,my $slurpy_any;
0.000002,2,0.000001,if ( defined $slurpy ) {
0.000000,0,0.000000,$tmpl =
0.000000,0,0.000000,'do { my ($orig, $from, $to) = (%s, %d, $#{%s});'
0.000000,0,0.000000,. '(($to-$from) %% 2) and do { my $tmp = +{@{$orig}[$from..$to]}; %s }'
0.000000,0,0.000000,. '}'
0.000000,0,0.000000,if $slurpy->my_slurp_into eq 'HASH';
0.000000,0,0.000000,$slurpy_any = 1
0.000000,0,0.000000,if $slurpy->my_unslurpy->equals( Types::Standard::Any );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000009,2,0.000005,my @is_optional = map !!$_->is_strictly_a_type_of( $_Optional ), @constraints;
0.000003,2,0.000002,my $min = 0+ grep !$_, @is_optional;
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000004,8,0.000000,my $v = $_[1];
0.000005,8,0.000001,return "$xsubname\($v\)" if $xsubname && !$Type::Tiny::AvoidCallbacks;
0.000000,0,0.000000,join " and ",
0.000000,0,0.000000,Types::Standard::ArrayRef->inline_check( $v ),
0.000000,0,0.000000,(
0.000000,0,0.000000,( scalar @constraints == $min and not $slurpy )
0.000000,0,0.000000,? "\@{$v} == $min"
0.000000,0,0.000000,: sprintf(
0.000000,0,0.000000,"(\@{$v} == $min or (\@{$v} > $min and \@{$v} <= ${\(1+$#constraints)}) or (\@{$v} > ${\(1+$#constraints)} and %s))",
0.000000,0,0.000000,(
0.000000,0,0.000000,$slurpy_any ? '!!1'
0.000000,0,0.000000,: (
0.000000,0,0.000000,$slurpy
0.000000,0,0.000000,? sprintf( $tmpl, $v, $#constraints + 1, $v, $slurpy->inline_check( '$tmp' ) )
0.000000,0,0.000000,: sprintf( "\@{$v} <= %d", scalar @constraints )
0.000000,0,0.000000,)
0.000000,0,0.000000,),
0.000000,0,0.000000,)
0.000000,0,0.000000,),
0.000000,0,0.000000,map {
0.000131,24,0.000005,my $inline = $constraints[$_]->inline_check( "$v\->[$_]" );
0.000015,16,0.000001,$inline eq '(!!1)' ? ()
0.000000,0,0.000000,: (
0.000000,0,0.000000,$is_optional[$_] ? sprintf( '(@{%s} <= %d or %s)', $v, $_, $inline )
0.000000,0,0.000000,: $inline
0.000000,0,0.000000,);
0.000000,0,0.000000,} 0 .. $#constraints;
0.000016,2,0.000008,};
0.000000,0,0.000000,} #/ sub __inline_generator
0.000000,0,0.000000,
0.000000,0,0.000000,sub __deep_explanation {
0.000000,0,0.000000,my ( $type, $value, $varname ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @constraints = @{ $type->parameters };
0.000000,0,0.000000,my $slurpy =
0.000000,0,0.000000,@constraints
0.000000,0,0.000000,&& Types::TypeTiny::is_TypeTiny( $constraints[-1] )
0.000000,0,0.000000,&& $constraints[-1]->is_strictly_a_type_of( $_Slurpy )
0.000000,0,0.000000,? pop( @constraints )
0.000000,0,0.000000,: undef;
0.000000,0,0.000000,@constraints = map Types::TypeTiny::to_TypeTiny( $_ ), @constraints;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( @constraints < @$value and not $slurpy ) {
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'"%s" expects at most %d values in the array', $type, scalar( @constraints )
0.000000,0,0.000000,),
0.000000,0,0.000000,sprintf( '%d values found; too many', scalar( @$value ) ),
0.000000,0,0.000000,];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for my $i ( 0 .. $#constraints ) {
0.000000,0,0.000000,next
0.000000,0,0.000000,if $constraints[$i]
0.000000,0,0.000000,->is_strictly_a_type_of( Types::Standard::Optional )
0.000000,0,0.000000,&& $i > $#$value;
0.000000,0,0.000000,next if $constraints[$i]->check( $value->[$i] );
0.000000,0,0.000000,
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'"%s" constrains value at index %d of array with "%s"', $type, $i,
0.000000,0,0.000000,$constraints[$i]
0.000000,0,0.000000,),
0.000000,0,0.000000,@{
0.000000,0,0.000000,$constraints[$i]
0.000000,0,0.000000,->validate_explain( $value->[$i], sprintf( '%s->[%s]', $varname, $i ) )
0.000000,0,0.000000,},
0.000000,0,0.000000,];
0.000000,0,0.000000,} #/ for my $i ( 0 .. $#constraints)
0.000000,0,0.000000,
0.000000,0,0.000000,if ( defined( $slurpy ) ) {
0.000000,0,0.000000,my $tmp =
0.000000,0,0.000000,$slurpy->my_slurp_into eq 'HASH'
0.000000,0,0.000000,? +{ @$value[ $#constraints + 1 .. $#$value ] }
0.000000,0,0.000000,: +[ @$value[ $#constraints + 1 .. $#$value ] ];
0.000000,0,0.000000,$slurpy->check( $tmp )
0.000000,0,0.000000,or return [
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'Array elements from index %d are slurped into a %s which is constrained with "%s"',
0.000000,0,0.000000,$#constraints + 1,
0.000000,0,0.000000,( $slurpy->my_slurp_into eq 'HASH' ) ? 'hashref' : 'arrayref',
0.000000,0,0.000000,( $slurpy->my_unslurpy || $slurpy ),
0.000000,0,0.000000,),
0.000000,0,0.000000,@{ ( $slurpy->my_unslurpy || $slurpy )->validate_explain( $tmp, '$SLURPY' ) },
0.000000,0,0.000000,];
0.000000,0,0.000000,} #/ if ( defined( $slurpy ...))
0.000000,0,0.000000,
0.000000,0,0.000000,# This should never happen...
0.000000,0,0.000000,return;    # uncoverable statement
0.000000,0,0.000000,} #/ sub __deep_explanation
0.000000,0,0.000000,
0.000000,1,0.000000,my $label_counter = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,sub __coercion_generator {
0.000000,0,0.000000,my ( $parent, $child, @tuple ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $slurpy =
0.000000,0,0.000000,@tuple
0.000000,0,0.000000,&& Types::TypeTiny::is_TypeTiny( $tuple[-1] )
0.000000,0,0.000000,&& $tuple[-1]->is_strictly_a_type_of( $_Slurpy )
0.000000,0,0.000000,? pop( @tuple )
0.000000,0,0.000000,: undef;
0.000000,0,0.000000,
0.000000,0,0.000000,my $child_coercions_exist = 0;
0.000000,0,0.000000,my $all_inlinable         = 1;
0.000000,0,0.000000,for my $tc ( @tuple, ( $slurpy ? $slurpy : () ) ) {
0.000000,0,0.000000,$all_inlinable = 0 if !$tc->can_be_inlined;
0.000000,0,0.000000,$all_inlinable = 0 if $tc->has_coercion && !$tc->coercion->can_be_inlined;
0.000000,0,0.000000,$child_coercions_exist++ if $tc->has_coercion;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return unless $child_coercions_exist;
0.000000,0,0.000000,my $C = "Type::Coercion"->new( type_constraint => $child );
0.000000,0,0.000000,
0.000000,0,0.000000,my $slurpy_is_hashref = $slurpy && $slurpy->my_slurp_into eq 'HASH';
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $all_inlinable ) {
0.000000,0,0.000000,$C->add_type_coercions(
0.000000,0,0.000000,$parent => Types::Standard::Stringable {
0.000000,0,0.000000,my $label = sprintf( "TUPLELABEL%d", ++$label_counter );
0.000000,0,0.000000,my @code;
0.000000,0,0.000000,push @code, 'do { my ($orig, $return_orig, $tmp, @new) = ($_, 0);';
0.000000,0,0.000000,push @code, "$label: {";
0.000000,0,0.000000,push @code,
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'(($return_orig = 1), last %s) if @$orig > %d;', $label,
0.000000,0,0.000000,scalar @tuple
0.000000,0,0.000000,) unless $slurpy;
0.000000,0,0.000000,for my $i ( 0 .. $#tuple ) {
0.000000,0,0.000000,my $ct          = $tuple[$i];
0.000000,0,0.000000,my $ct_coerce   = $ct->has_coercion;
0.000000,0,0.000000,my $ct_optional = $ct->is_a_type_of( Types::Standard::Optional );
0.000000,0,0.000000,
0.000000,0,0.000000,push @code, sprintf(
0.000000,0,0.000000,'if (@$orig > %d) { $tmp = %s; (%s) ? ($new[%d]=$tmp) : (($return_orig=1), last %s) }',
0.000000,0,0.000000,$i,
0.000000,0,0.000000,$ct_coerce
0.000000,0,0.000000,? $ct->coercion->inline_coercion( "\$orig->[$i]" )
0.000000,0,0.000000,: "\$orig->[$i]",
0.000000,0,0.000000,$ct->inline_check( '$tmp' ),
0.000000,0,0.000000,$i,
0.000000,0,0.000000,$label,
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ for my $i ( 0 .. $#tuple)
0.000000,0,0.000000,if ( $slurpy ) {
0.000000,0,0.000000,my $size = @tuple;
0.000000,0,0.000000,push @code, sprintf( 'if (@$orig > %d) {', $size );
0.000000,0,0.000000,push @code, sprintf(
0.000000,0,0.000000,(
0.000000,0,0.000000,$slurpy_is_hashref
0.000000,0,0.000000,? 'my $tail = do { no warnings; +{ @{$orig}[%d .. $#$orig]} };'
0.000000,0,0.000000,: 'my $tail = [ @{$orig}[%d .. $#$orig] ];'
0.000000,0,0.000000,),
0.000000,0,0.000000,$size,
0.000000,0,0.000000,);
0.000000,0,0.000000,push @code,
0.000000,0,0.000000,$slurpy->has_coercion
0.000000,0,0.000000,? sprintf(
0.000000,0,0.000000,'$tail = %s;',
0.000000,0,0.000000,$slurpy->coercion->inline_coercion( '$tail' )
0.000000,0,0.000000,)
0.000000,0,0.000000,: q();
0.000000,0,0.000000,push @code, sprintf(
0.000000,0,0.000000,'(%s) ? push(@new, %s$tail) : ($return_orig++);',
0.000000,0,0.000000,$slurpy->inline_check( '$tail' ),
0.000000,0,0.000000,( $slurpy_is_hashref ? '%' : '@' ),
0.000000,0,0.000000,);
0.000000,0,0.000000,push @code, '}';
0.000000,0,0.000000,} #/ if ( $slurpy )
0.000000,0,0.000000,push @code, '}';
0.000000,0,0.000000,push @code, '$return_orig ? $orig : \\@new';
0.000000,0,0.000000,push @code, '}';
0.000000,0,0.000000,"@code";
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ if ( $all_inlinable )
0.000000,0,0.000000,
0.000000,0,0.000000,else {
0.000000,0,0.000000,my @is_optional = map !!$_->is_strictly_a_type_of( $_Optional ), @tuple;
0.000000,0,0.000000,
0.000000,0,0.000000,$C->add_type_coercions(
0.000000,0,0.000000,$parent => sub {
0.000000,0,0.000000,my $value = @_ ? $_[0] : $_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( !$slurpy and @$value > @tuple ) {
0.000000,0,0.000000,return $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @new;
0.000000,0,0.000000,for my $i ( 0 .. $#tuple ) {
0.000000,0,0.000000,return \@new if $i > $#$value and $is_optional[$i];
0.000000,0,0.000000,
0.000000,0,0.000000,my $ct = $tuple[$i];
0.000000,0,0.000000,my $x  = $ct->has_coercion ? $ct->coerce( $value->[$i] ) : $value->[$i];
0.000000,0,0.000000,
0.000000,0,0.000000,return $value unless $ct->check( $x );
0.000000,0,0.000000,
0.000000,0,0.000000,$new[$i] = $x;
0.000000,0,0.000000,} #/ for my $i ( 0 .. $#tuple)
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $slurpy and @$value > @tuple ) {
0.000165,2,0.000082,no warnings;
0.000000,0,0.000000,my $tmp =
0.000000,0,0.000000,$slurpy_is_hashref
0.000000,0,0.000000,? { @{$value}[ @tuple .. $#$value ] }
0.000000,0,0.000000,: [ @{$value}[ @tuple .. $#$value ] ];
0.000000,0,0.000000,$tmp = $slurpy->coerce( $tmp ) if $slurpy->has_coercion;
0.000000,0,0.000000,$slurpy->check( $tmp )
0.000000,0,0.000000,? push( @new, $slurpy_is_hashref ? %$tmp : @$tmp )
0.000000,0,0.000000,: return ( $value );
0.000000,0,0.000000,} #/ if ( $slurpy and @$value...)
0.000000,0,0.000000,
0.000000,0,0.000000,return \@new;
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ else [ if ( $all_inlinable ) ]
0.000000,0,0.000000,
0.000000,0,0.000000,return $C;
0.000000,0,0.000000,} #/ sub __coercion_generator
0.000000,0,0.000000,
0.000004,1,0.000004,1;
