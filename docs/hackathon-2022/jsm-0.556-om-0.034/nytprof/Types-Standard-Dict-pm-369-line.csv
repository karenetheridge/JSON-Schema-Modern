# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# INTERNAL MODULE: guts for Dict type from Types::Standard.
0.000000,0,0.000000,
0.000000,0,0.000000,package Types::Standard::Dict;
0.000000,0,0.000000,
0.000074,2,0.000037,use 5.008001;
0.000031,2,0.000016,use strict;
0.000087,2,0.000044,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,$Types::Standard::Dict::AUTHORITY = 'cpan:TOBYINK';
0.000005,1,0.000005,$Types::Standard::Dict::VERSION   = '2.000001';
0.000090,1,0.000090,}
0.000000,0,0.000000,
0.000002,1,0.000002,$Types::Standard::Dict::VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000060,2,0.000030,use Types::Standard ();
0.000125,2,0.000063,use Types::TypeTiny ();
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak ($;@) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,goto \&Carp::confess;
0.000000,0,0.000000,require Error::TypeTiny;
0.000000,0,0.000000,goto \&Error::TypeTiny::croak;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,my $_Slurpy   = Types::Standard::Slurpy;
0.000002,1,0.000002,my $_optional = Types::Standard::Optional;
0.000002,1,0.000002,my $_hash     = Types::Standard::HashRef;
0.000002,1,0.000002,my $_map      = Types::Standard::Map;
0.000002,1,0.000002,my $_any      = Types::Standard::Any;
0.000000,0,0.000000,
0.003272,2,0.001636,no warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,sub pair_iterator {
0.000009,8,0.000001,_croak( "Expected even-sized list" ) if @_ % 2;
0.000014,8,0.000002,my @array = @_;
0.000000,0,0.000000,sub {
0.000016,72,0.000000,return unless @array;
0.000138,64,0.000002,splice( @array, 0, 2 );
0.000031,8,0.000004,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub __constraint_generator {
0.000035,4,0.000009,my $slurpy =
0.000000,0,0.000000,@_
0.000000,0,0.000000,&& Types::TypeTiny::is_TypeTiny( $_[-1] )
0.000000,0,0.000000,&& $_[-1]->is_strictly_a_type_of( $_Slurpy )
0.000000,0,0.000000,? pop->my_unslurpy
0.000000,0,0.000000,: undef;
0.000008,4,0.000002,my $iterator = pair_iterator @_;
0.000003,4,0.000001,my %constraints;
0.000000,0,0.000000,my %is_optional;
0.000000,0,0.000000,my @keys;
0.000000,0,0.000000,
0.000074,4,0.000018,while ( my ( $k, $v ) = $iterator->() ) {
0.000023,32,0.000001,$constraints{$k} = $v;
0.000037,32,0.000001,Types::TypeTiny::is_TypeTiny( $v )
0.000000,0,0.000000,or _croak(
0.000000,0,0.000000,"Parameter for Dict[...] with key '$k' expected to be a type constraint; got $v"
0.000000,0,0.000000,);
0.000030,32,0.000001,Types::TypeTiny::is_StringLike( $k )
0.000000,0,0.000000,or _croak( "Key for Dict[...] expected to be string; got $k" );
0.000014,32,0.000000,push @keys, $k;
0.000064,32,0.000002,$is_optional{$k} = !!$constraints{$k}->is_strictly_a_type_of( $_optional );
0.000000,0,0.000000,} #/ while ( my ( $k, $v ) = $iterator...)
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,my $value = $_[0];
0.000000,0,0.000000,if ( $slurpy ) {
0.000000,0,0.000000,my %tmp = map +( exists( $constraints{$_} ) ? () : ( $_ => $value->{$_} ) ),
0.000000,0,0.000000,keys %$value;
0.000000,0,0.000000,return unless $slurpy->check( \%tmp );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,exists( $constraints{$_} ) || return for sort keys %$value;
0.000000,0,0.000000,}
0.000000,0,0.000000,for my $k ( @keys ) {
0.000000,0,0.000000,exists( $value->{$k} )                  or ( $is_optional{$k} ? next : return );
0.000000,0,0.000000,$constraints{$k}->check( $value->{$k} ) or return;
0.000000,0,0.000000,}
0.000000,0,0.000000,return !!1;
0.000037,4,0.000009,};
0.000000,0,0.000000,} #/ sub __constraint_generator
0.000000,0,0.000000,
0.000000,0,0.000000,sub __inline_generator {
0.000000,0,0.000000,
0.000000,0,0.000000,# We can only inline a parameterized Dict if all the
0.000000,0,0.000000,# constraints inside can be inlined.
0.000000,0,0.000000,
0.000025,4,0.000006,my $slurpy =
0.000000,0,0.000000,@_
0.000000,0,0.000000,&& Types::TypeTiny::is_TypeTiny( $_[-1] )
0.000000,0,0.000000,&& $_[-1]->is_strictly_a_type_of( $_Slurpy )
0.000000,0,0.000000,? pop->my_unslurpy
0.000000,0,0.000000,: undef;
0.000013,4,0.000003,return if $slurpy && !$slurpy->can_be_inlined;
0.000000,0,0.000000,
0.000000,0,0.000000,# Is slurpy a very loose type constraint?
0.000000,0,0.000000,# i.e. Any, Item, Defined, Ref, or HashRef
0.000012,4,0.000003,my $slurpy_is_any = $slurpy && $_hash->is_a_type_of( $slurpy );
0.000000,0,0.000000,
0.000000,0,0.000000,# Is slurpy a parameterized Map, or expressable as a parameterized Map?
0.000024,4,0.000006,my $slurpy_is_map =
0.000000,0,0.000000,$slurpy
0.000000,0,0.000000,&& $slurpy->is_parameterized
0.000000,0,0.000000,&& (
0.000000,0,0.000000,( $slurpy->parent->strictly_equals( $_map ) && $slurpy->parameters )
0.000000,0,0.000000,|| ( $slurpy->parent->strictly_equals( $_hash )
0.000000,0,0.000000,&& [ $_any, $slurpy->parameters->[0] ] )
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000004,4,0.000001,my $iterator = pair_iterator @_;
0.000002,4,0.000000,my %constraints;
0.000000,0,0.000000,my @keys;
0.000000,0,0.000000,
0.000037,4,0.000009,while ( my ( $k, $c ) = $iterator->() ) {
0.000015,32,0.000000,return unless $c->can_be_inlined;
0.000020,32,0.000001,$constraints{$k} = $c;
0.000012,32,0.000000,push @keys, $k;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000020,4,0.000005,my $regexp = join "|", map quotemeta, @keys;
0.000000,0,0.000000,return sub {
0.000019,24,0.000001,require B;
0.000007,24,0.000000,my $h = $_[1];
0.000000,0,0.000000,join " and ",
0.000000,0,0.000000,Types::Standard::HashRef->inline_check( $h ),
0.000000,0,0.000000,(
0.000000,0,0.000000,$slurpy_is_any
0.000000,0,0.000000,? ()
0.000000,0,0.000000,: $slurpy_is_map ? do {
0.000000,0,0.000000,'(not grep {' . "my \$v = ($h)->{\$_};" . sprintf(
0.000000,0,0.000000,'not((/\\A(?:%s)\\z/) or ((%s) and (%s)))',
0.000000,0,0.000000,$regexp,
0.000000,0,0.000000,$slurpy_is_map->[0]->inline_check( '$_' ),
0.000000,0,0.000000,$slurpy_is_map->[1]->inline_check( '$v' ),
0.000000,0,0.000000,) . "} keys \%{$h})";
0.000000,0,0.000000,}
0.000000,0,0.000000,: $slurpy ? do {
0.000000,0,0.000000,'do {'
0.000000,0,0.000000,. "my \$slurpy_tmp = +{ map /\\A(?:$regexp)\\z/ ? () : (\$_ => ($h)->{\$_}), keys \%{$h} };"
0.000000,0,0.000000,. $slurpy->inline_check( '$slurpy_tmp' ) . '}';
0.000000,0,0.000000,}
0.000000,0,0.000000,: "not(grep !/\\A(?:$regexp)\\z/, keys \%{$h})"
0.000000,0,0.000000,),
0.000000,0,0.000000,(
0.000000,0,0.000000,map {
0.000940,158,0.000006,my $k = B::perlstring( $_ );
0.000000,0,0.000000,$constraints{$_}->is_strictly_a_type_of( $_optional )
0.000000,0,0.000000,? sprintf(
0.000000,0,0.000000,'(!exists %s->{%s} or %s)', $h, $k,
0.000000,0,0.000000,$constraints{$_}->inline_check( "$h\->{$k}" )
0.000000,0,0.000000,)
0.000000,0,0.000000,: (
0.000000,0,0.000000,"exists($h\->{$k})",
0.000829,134,0.000006,$constraints{$_}->inline_check( "$h\->{$k}" )
0.000000,0,0.000000,)
0.000000,0,0.000000,} @keys
0.000000,0,0.000000,),
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000029,4,0.000007,} #/ sub __inline_generator
0.000000,0,0.000000,
0.000000,0,0.000000,sub __deep_explanation {
0.000000,0,0.000000,require B;
0.000000,0,0.000000,my ( $type, $value, $varname ) = @_;
0.000000,0,0.000000,my @params = @{ $type->parameters };
0.000000,0,0.000000,
0.000000,0,0.000000,my $slurpy =
0.000000,0,0.000000,@params
0.000000,0,0.000000,&& Types::TypeTiny::is_TypeTiny( $params[-1] )
0.000000,0,0.000000,&& $params[-1]->is_strictly_a_type_of( $_Slurpy )
0.000000,0,0.000000,? pop( @params )->my_unslurpy
0.000000,0,0.000000,: undef;
0.000000,0,0.000000,my $iterator = pair_iterator @params;
0.000000,0,0.000000,my %constraints;
0.000000,0,0.000000,my @keys;
0.000000,0,0.000000,
0.000000,0,0.000000,while ( my ( $k, $c ) = $iterator->() ) {
0.000000,0,0.000000,push @keys, $k;
0.000000,0,0.000000,$constraints{$k} = $c;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for my $k ( @keys ) {
0.000000,0,0.000000,next
0.000000,0,0.000000,if $constraints{$k}->has_parent
0.000000,0,0.000000,&& ( $constraints{$k}->parent == Types::Standard::Optional )
0.000000,0,0.000000,&& ( !exists $value->{$k} );
0.000000,0,0.000000,next if $constraints{$k}->check( $value->{$k} );
0.000000,0,0.000000,
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf( '"%s" requires key %s to appear in hash', $type, B::perlstring( $k ) )
0.000000,0,0.000000,]
0.000000,0,0.000000,unless exists $value->{$k};
0.000000,0,0.000000,
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'"%s" constrains value at key %s of hash with "%s"',
0.000000,0,0.000000,$type,
0.000000,0,0.000000,B::perlstring( $k ),
0.000000,0,0.000000,$constraints{$k},
0.000000,0,0.000000,),
0.000000,0,0.000000,@{
0.000000,0,0.000000,$constraints{$k}->validate_explain(
0.000000,0,0.000000,$value->{$k},
0.000000,0,0.000000,sprintf( '%s->{%s}', $varname, B::perlstring( $k ) ),
0.000000,0,0.000000,)
0.000000,0,0.000000,},
0.000000,0,0.000000,];
0.000000,0,0.000000,} #/ for my $k ( @keys )
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $slurpy ) {
0.000000,0,0.000000,my %tmp = map { exists( $constraints{$_} ) ? () : ( $_ => $value->{$_} ) }
0.000000,0,0.000000,keys %$value;
0.000000,0,0.000000,
0.000000,0,0.000000,my $explain = $slurpy->validate_explain( \%tmp, '$slurpy' );
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'"%s" requires the hashref of additional key/value pairs to conform to "%s"',
0.000000,0,0.000000,$type, $slurpy
0.000000,0,0.000000,),
0.000000,0,0.000000,@$explain,
0.000000,0,0.000000,] if $explain;
0.000000,0,0.000000,} #/ if ( $slurpy )
0.000000,0,0.000000,else {
0.000000,0,0.000000,for my $k ( sort keys %$value ) {
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'"%s" does not allow key %s to appear in hash', $type, B::perlstring( $k )
0.000000,0,0.000000,)
0.000000,0,0.000000,]
0.000000,0,0.000000,unless exists $constraints{$k};
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ else [ if ( $slurpy ) ]
0.000000,0,0.000000,
0.000000,0,0.000000,# This should never happen...
0.000000,0,0.000000,return;    # uncoverable statement
0.000000,0,0.000000,} #/ sub __deep_explanation
0.000000,0,0.000000,
0.000001,1,0.000001,my $label_counter = 0;
0.000001,1,0.000001,our ( $keycheck_counter, @KEYCHECK ) = -1;
0.000000,0,0.000000,
0.000000,0,0.000000,sub __coercion_generator {
0.000012,1,0.000012,my $slurpy =
0.000000,0,0.000000,@_
0.000000,0,0.000000,&& Types::TypeTiny::is_TypeTiny( $_[-1] )
0.000000,0,0.000000,&& $_[-1]->is_strictly_a_type_of( $_Slurpy )
0.000000,0,0.000000,? pop->my_unslurpy
0.000000,0,0.000000,: undef;
0.000001,1,0.000001,my ( $parent, $child, %dict ) = @_;
0.000002,1,0.000002,my $C = "Type::Coercion"->new( type_constraint => $child );
0.000000,0,0.000000,
0.000001,1,0.000001,my $all_inlinable         = 1;
0.000000,1,0.000000,my $child_coercions_exist = 0;
0.000001,1,0.000001,for my $tc ( values %dict ) {
0.000004,2,0.000002,$all_inlinable = 0 if !$tc->can_be_inlined;
0.000009,2,0.000005,$all_inlinable = 0 if $tc->has_coercion && !$tc->coercion->can_be_inlined;
0.000002,2,0.000001,$child_coercions_exist++ if $tc->has_coercion;
0.000000,0,0.000000,}
0.000001,1,0.000001,$all_inlinable = 0 if $slurpy && !$slurpy->can_be_inlined;
0.000000,1,0.000000,$all_inlinable = 0
0.000000,0,0.000000,if $slurpy
0.000000,0,0.000000,&& $slurpy->has_coercion
0.000000,0,0.000000,&& !$slurpy->coercion->can_be_inlined;
0.000000,0,0.000000,
0.000000,1,0.000000,$child_coercions_exist++ if $slurpy && $slurpy->has_coercion;
0.000012,1,0.000012,return unless $child_coercions_exist;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $all_inlinable ) {
0.000000,0,0.000000,$C->add_type_coercions(
0.000000,0,0.000000,$parent => Types::Standard::Stringable {
0.000000,0,0.000000,require B;
0.000000,0,0.000000,
0.000000,0,0.000000,my $keycheck = join "|", map quotemeta,
0.000000,0,0.000000,sort { length( $b ) <=> length( $a ) or $a cmp $b } keys %dict;
0.000000,0,0.000000,$keycheck = $KEYCHECK[ ++$keycheck_counter ] = qr{^($keycheck)$}ms;    # regexp for legal keys
0.000000,0,0.000000,
0.000000,0,0.000000,my $label = sprintf( "DICTLABEL%d", ++$label_counter );
0.000000,0,0.000000,my @code;
0.000000,0,0.000000,push @code, 'do { my ($orig, $return_orig, $tmp, %new) = ($_, 0);';
0.000000,0,0.000000,push @code, "$label: {";
0.000000,0,0.000000,if ( $slurpy ) {
0.000000,0,0.000000,push @code,
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'my $slurped = +{ map +($_=~$%s::KEYCHECK[%d])?():($_=>$orig->{$_}), keys %%$orig };',
0.000000,0,0.000000,__PACKAGE__, $keycheck_counter
0.000000,0,0.000000,);
0.000000,0,0.000000,if ( $slurpy->has_coercion ) {
0.000000,0,0.000000,push @code,
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'my $coerced = %s;',
0.000000,0,0.000000,$slurpy->coercion->inline_coercion( '$slurped' )
0.000000,0,0.000000,);
0.000000,0,0.000000,push @code,
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'((%s)&&(%s))?(%%new=%%$coerced):(($return_orig = 1), last %s);',
0.000000,0,0.000000,$_hash->inline_check( '$coerced' ), $slurpy->inline_check( '$coerced' ),
0.000000,0,0.000000,$label
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ if ( $slurpy->has_coercion)
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @code,
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'(%s)?(%%new=%%$slurped):(($return_orig = 1), last %s);',
0.000000,0,0.000000,$slurpy->inline_check( '$slurped' ), $label
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( $slurpy )
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @code,
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'($_ =~ $%s::KEYCHECK[%d])||(($return_orig = 1), last %s) for sort keys %%$orig;',
0.000000,0,0.000000,__PACKAGE__, $keycheck_counter, $label
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,for my $k ( keys %dict ) {
0.000000,0,0.000000,my $ct          = $dict{$k};
0.000000,0,0.000000,my $ct_coerce   = $ct->has_coercion;
0.000000,0,0.000000,my $ct_optional = $ct->is_a_type_of( $_optional );
0.000000,0,0.000000,my $K           = B::perlstring( $k );
0.000000,0,0.000000,
0.000000,0,0.000000,push @code, sprintf(
0.000000,0,0.000000,'if (exists $orig->{%s}) { $tmp = %s; (%s) ? ($new{%s}=$tmp) : (($return_orig=1), last %s) }',
0.000000,0,0.000000,$K,
0.000000,0,0.000000,$ct_coerce
0.000000,0,0.000000,? $ct->coercion->inline_coercion( "\$orig->{$K}" )
0.000000,0,0.000000,: "\$orig->{$K}",
0.000000,0,0.000000,$ct->inline_check( '$tmp' ),
0.000000,0,0.000000,$K,
0.000000,0,0.000000,$label,
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ for my $k ( keys %dict )
0.000000,0,0.000000,push @code, '}';
0.000000,0,0.000000,push @code, '$return_orig ? $orig : \\%new';
0.000000,0,0.000000,push @code, '}';
0.000000,0,0.000000,
0.000000,0,0.000000,#warn "CODE:: @code";
0.000000,0,0.000000,"@code";
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ if ( $all_inlinable )
0.000000,0,0.000000,
0.000000,0,0.000000,else {
0.000000,0,0.000000,my %is_optional = map {
0.000000,0,0.000000,;
0.000000,0,0.000000,$_ => !!$dict{$_}->is_strictly_a_type_of( $_optional )
0.000000,0,0.000000,} sort keys %dict;
0.000000,0,0.000000,$C->add_type_coercions(
0.000000,0,0.000000,$parent => sub {
0.000000,0,0.000000,my $value = @_ ? $_[0] : $_;
0.000000,0,0.000000,my %new;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $slurpy ) {
0.000000,0,0.000000,my %slurped = map exists( $dict{$_} ) ? () : ( $_ => $value->{$_} ),
0.000000,0,0.000000,keys %$value;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $slurpy->check( \%slurped ) ) {
0.000000,0,0.000000,%new = %slurped;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $slurpy->has_coercion ) {
0.000000,0,0.000000,my $coerced = $slurpy->coerce( \%slurped );
0.000000,0,0.000000,$slurpy->check( $coerced ) ? ( %new = %$coerced ) : ( return $value );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( $slurpy )
0.000000,0,0.000000,else {
0.000000,0,0.000000,for my $k ( keys %$value ) {
0.000000,0,0.000000,return $value unless exists $dict{$k};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for my $k ( keys %dict ) {
0.000000,0,0.000000,next if $is_optional{$k} and not exists $value->{$k};
0.000000,0,0.000000,
0.000000,0,0.000000,my $ct = $dict{$k};
0.000000,0,0.000000,my $x  = $ct->has_coercion ? $ct->coerce( $value->{$k} ) : $value->{$k};
0.000000,0,0.000000,
0.000000,0,0.000000,return $value unless $ct->check( $x );
0.000000,0,0.000000,
0.000000,0,0.000000,$new{$k} = $x;
0.000000,0,0.000000,} #/ for my $k ( keys %dict )
0.000000,0,0.000000,
0.000000,0,0.000000,return \%new;
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ else [ if ( $all_inlinable ) ]
0.000000,0,0.000000,
0.000000,0,0.000000,return $C;
0.000000,0,0.000000,} #/ sub __coercion_generator
0.000000,0,0.000000,
0.000000,0,0.000000,sub __dict_is_slurpy {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return !!0 if $self == Types::Standard::Dict();
0.000000,0,0.000000,
0.000000,0,0.000000,my $dict = $self->find_parent(
0.000000,0,0.000000,sub { $_->has_parent && $_->parent == Types::Standard::Dict() } );
0.000000,0,0.000000,my $slurpy =
0.000000,0,0.000000,@{ $dict->parameters }
0.000000,0,0.000000,&& Types::TypeTiny::is_TypeTiny( $dict->parameters->[-1] )
0.000000,0,0.000000,&& $dict->parameters->[-1]->is_strictly_a_type_of( $_Slurpy )
0.000000,0,0.000000,? $dict->parameters->[-1]
0.000000,0,0.000000,: undef;
0.000000,0,0.000000,} #/ sub __dict_is_slurpy
0.000000,0,0.000000,
0.000000,0,0.000000,sub __hashref_allows_key {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $key ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return Types::Standard::is_Str( $key ) if $self == Types::Standard::Dict();
0.000000,0,0.000000,
0.000000,0,0.000000,my $dict = $self->find_parent(
0.000000,0,0.000000,sub { $_->has_parent && $_->parent == Types::Standard::Dict() } );
0.000000,0,0.000000,my %params;
0.000000,0,0.000000,my $slurpy = $dict->my_dict_is_slurpy;
0.000000,0,0.000000,if ( $slurpy ) {
0.000000,0,0.000000,my @args = @{ $dict->parameters };
0.000000,0,0.000000,pop @args;
0.000000,0,0.000000,%params = @args;
0.000000,0,0.000000,$slurpy = $slurpy->my_unslurpy;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,%params = @{ $dict->parameters };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return !!1
0.000000,0,0.000000,if exists( $params{$key} );
0.000000,0,0.000000,return !!0
0.000000,0,0.000000,if !$slurpy;
0.000000,0,0.000000,return Types::Standard::is_Str( $key )
0.000000,0,0.000000,if $slurpy == Types::Standard::Any()
0.000000,0,0.000000,|| $slurpy == Types::Standard::Item()
0.000000,0,0.000000,|| $slurpy == Types::Standard::Defined()
0.000000,0,0.000000,|| $slurpy == Types::Standard::Ref();
0.000000,0,0.000000,return $slurpy->my_hashref_allows_key( $key )
0.000000,0,0.000000,if $slurpy->is_a_type_of( Types::Standard::HashRef() );
0.000000,0,0.000000,return !!0;
0.000000,0,0.000000,} #/ sub __hashref_allows_key
0.000000,0,0.000000,
0.000000,0,0.000000,sub __hashref_allows_value {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $key, $value ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return !!0 unless $self->my_hashref_allows_key( $key );
0.000000,0,0.000000,return !!1 if $self == Types::Standard::Dict();
0.000000,0,0.000000,
0.000000,0,0.000000,my $dict = $self->find_parent(
0.000000,0,0.000000,sub { $_->has_parent && $_->parent == Types::Standard::Dict() } );
0.000000,0,0.000000,my %params;
0.000000,0,0.000000,my $slurpy = $dict->my_dict_is_slurpy;
0.000000,0,0.000000,if ( $slurpy ) {
0.000000,0,0.000000,my @args = @{ $dict->parameters };
0.000000,0,0.000000,pop @args;
0.000000,0,0.000000,%params = @args;
0.000000,0,0.000000,$slurpy = $slurpy->my_unslurpy;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,%params = @{ $dict->parameters };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return !!1
0.000000,0,0.000000,if exists( $params{$key} ) && $params{$key}->check( $value );
0.000000,0,0.000000,return !!0
0.000000,0,0.000000,if !$slurpy;
0.000000,0,0.000000,return !!1
0.000000,0,0.000000,if $slurpy == Types::Standard::Any()
0.000000,0,0.000000,|| $slurpy == Types::Standard::Item()
0.000000,0,0.000000,|| $slurpy == Types::Standard::Defined()
0.000000,0,0.000000,|| $slurpy == Types::Standard::Ref();
0.000000,0,0.000000,return $slurpy->my_hashref_allows_value( $key, $value )
0.000000,0,0.000000,if $slurpy->is_a_type_of( Types::Standard::HashRef() );
0.000000,0,0.000000,return !!0;
0.000000,0,0.000000,} #/ sub __hashref_allows_value
0.000000,0,0.000000,
0.000009,1,0.000009,1;
