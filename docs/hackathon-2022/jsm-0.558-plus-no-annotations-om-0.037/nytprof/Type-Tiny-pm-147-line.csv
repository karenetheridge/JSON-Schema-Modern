# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Type::Tiny;
0.000000,0,0.000000,
0.000030,2,0.000015,use 5.008001;
0.000015,2,0.000008,use strict;
0.000021,2,0.000011,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000002,1,0.000002,if ( $] < 5.010 ) { require Devel::TypeTiny::Perl58Compat }
0.000020,1,0.000020,}
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,$Type::Tiny::AUTHORITY  = 'cpan:TOBYINK';
0.000000,1,0.000000,$Type::Tiny::VERSION    = '2.000001';
0.000002,1,0.000002,$Type::Tiny::XS_VERSION = '0.016';
0.000025,1,0.000025,}
0.000000,0,0.000000,
0.000001,1,0.000001,$Type::Tiny::VERSION    =~ tr/_//d;
0.000000,1,0.000000,$Type::Tiny::XS_VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000014,2,0.000007,use Scalar::Util qw( blessed );
0.000675,2,0.000338,use Types::TypeTiny ();
0.000000,0,0.000000,
0.000001,1,0.000001,our $SafePackage = sprintf 'package %s;', __PACKAGE__;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
0.000000,0,0.000000,
0.000003,1,0.000003,sub _swap { $_[2] ? @_[ 1, 0 ] : @_[ 0, 1 ] }
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000001,1,0.000001,my $support_smartmatch = 0+ !!( $] >= 5.010001 );
0.000015,1,0.000015,eval qq{ sub SUPPORT_SMARTMATCH () { !! $support_smartmatch } };
0.000000,0,0.000000,
0.000001,1,0.000001,my $fixed_precedence = 0+ !!( $] >= 5.014 );
0.000020,1,0.000020,eval qq{ sub _FIXED_PRECEDENCE () { !! $fixed_precedence } };
0.000000,0,0.000000,
0.000000,0,0.000000,my $try_xs =
0.000000,0,0.000000,exists( $ENV{PERL_TYPE_TINY_XS} ) ? !!$ENV{PERL_TYPE_TINY_XS}
0.000000,0,0.000000,: exists( $ENV{PERL_ONLY} )       ? !$ENV{PERL_ONLY}
0.000001,1,0.000001,:                                   1;
0.000000,0,0.000000,
0.000000,1,0.000000,my $use_xs = 0;
0.000000,1,0.000000,$try_xs and eval {
0.000086,1,0.000086,require Type::Tiny::XS;
0.000000,0,0.000000,'Type::Tiny::XS'->VERSION( $Type::Tiny::XS_VERSION );
0.000000,0,0.000000,$use_xs++;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,*_USE_XS =
0.000000,0,0.000000,$use_xs
0.000000,0,0.000000,? sub () { !!1 }
0.000001,1,0.000001,: sub () { !!0 };
0.000000,0,0.000000,
0.000000,0,0.000000,*_USE_MOUSE =
0.000000,0,0.000000,$try_xs
0.000097,43,0.000002,? sub () { $INC{'Mouse/Util.pm'} and Mouse::Util::MOUSE_XS() }
0.000001,1,0.000001,: sub () { !!0 };
0.000000,0,0.000000,
0.000000,1,0.000000,my $strict_mode = 0;
0.000002,1,0.000002,$ENV{$_} && ++$strict_mode for qw(
0.000000,0,0.000000,EXTENDED_TESTING
0.000000,0,0.000000,AUTHOR_TESTING
0.000000,0,0.000000,RELEASE_TESTING
0.000000,0,0.000000,PERL_STRICT
0.000000,0,0.000000,);
0.000004,1,0.000004,*_STRICT_MODE = $strict_mode ? sub () { !!1 } : sub () { !!0 };
0.000022,1,0.000022,} #/ BEGIN
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_overloads {
0.000026,2,0.000013,no strict 'refs';
0.005462,2,0.002731,no warnings 'redefine', 'once';
0.000000,0,0.000000,
0.000000,0,0.000000,# Coverage is checked on Perl 5.26
0.000004,8,0.000000,if ( $] < 5.010 ) {    # uncoverable statement
0.000000,0,0.000000,require overload;             # uncoverable statement
0.000000,0,0.000000,push @_, fallback => 1;       # uncoverable statement
0.000000,0,0.000000,goto \&overload::OVERLOAD;    # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,8,0.000000,my $class = shift;
0.000027,8,0.000003,*{ $class . '::((' } = sub { };
0.000014,8,0.000002,*{ $class . '::()' } = sub { };
0.000013,24,0.000001,*{ $class . '::()' } = do { my $x = 1; \$x };
0.000033,8,0.000004,while ( @_ ) {
0.000004,25,0.000000,my $f = shift;
0.000061,25,0.000002,*{ $class . '::(' . $f } = ref $_[0] ? shift : do {
0.000002,2,0.000001,my $m = shift;
0.000610,183,0.000003,sub { shift->$m( @_ ) }
0.000002,2,0.000001,};
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ sub _install_overloads
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,__PACKAGE__->_install_overloads(
0.000000,0,0.000000,q("") => sub {
0.001286,367,0.000004,caller =~ m{^(Moo::HandleMoose|Sub::Quote)}
0.000000,0,0.000000,? $_[0]->_stringify_no_magic
0.000000,0,0.000000,: $_[0]->display_name;
0.000000,0,0.000000,},
0.000313,240,0.000001,q(bool) => sub { 1 },
0.000000,0,0.000000,q(&{})  => "_overload_coderef",
0.000000,0,0.000000,q(|)    => sub {
0.000001,1,0.000001,my @tc = _swap @_;
0.000000,0,0.000000,if ( !_FIXED_PRECEDENCE && $_[2] ) {
0.000000,0,0.000000,if ( blessed $tc[0] ) {
0.000000,0,0.000000,if ( blessed $tc[0] eq "Type::Tiny::_HalfOp" ) {
0.000000,0,0.000000,my $type  = $tc[0]->{type};
0.000000,0,0.000000,my $param = $tc[0]->{param};
0.000000,0,0.000000,my $op    = $tc[0]->{op};
0.000000,0,0.000000,require Type::Tiny::Union;
0.000000,0,0.000000,return "Type::Tiny::_HalfOp"->new(
0.000000,0,0.000000,$op,
0.000000,0,0.000000,$param,
0.000000,0,0.000000,"Type::Tiny::Union"->new_by_overload( type_constraints => [ $type, $tc[1] ] ),
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ if ( blessed $tc[0] eq...)
0.000000,0,0.000000,} #/ if ( blessed $tc[0] )
0.000000,0,0.000000,elsif ( ref $tc[0] eq 'ARRAY' ) {
0.000000,0,0.000000,require Type::Tiny::_HalfOp;
0.000000,0,0.000000,return "Type::Tiny::_HalfOp"->new( '|', @tc );
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( !_FIXED_PRECEDENCE...)
0.000406,1,0.000406,require Type::Tiny::Union;
0.000004,1,0.000004,return "Type::Tiny::Union"->new_by_overload( type_constraints => \@tc );
0.000000,0,0.000000,},
0.000000,0,0.000000,q(&) => sub {
0.000000,0,0.000000,my @tc = _swap @_;
0.000000,0,0.000000,if ( !_FIXED_PRECEDENCE && $_[2] ) {
0.000000,0,0.000000,if ( blessed $tc[0] ) {
0.000000,0,0.000000,if ( blessed $tc[0] eq "Type::Tiny::_HalfOp" ) {
0.000000,0,0.000000,my $type  = $tc[0]->{type};
0.000000,0,0.000000,my $param = $tc[0]->{param};
0.000000,0,0.000000,my $op    = $tc[0]->{op};
0.000000,0,0.000000,require Type::Tiny::Intersection;
0.000000,0,0.000000,return "Type::Tiny::_HalfOp"->new(
0.000000,0,0.000000,$op,
0.000000,0,0.000000,$param,
0.000000,0,0.000000,"Type::Tiny::Intersection"->new_by_overload( type_constraints => [ $type, $tc[1] ] ),
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ if ( blessed $tc[0] eq...)
0.000000,0,0.000000,} #/ if ( blessed $tc[0] )
0.000000,0,0.000000,elsif ( ref $tc[0] eq 'ARRAY' ) {
0.000000,0,0.000000,require Type::Tiny::_HalfOp;
0.000000,0,0.000000,return "Type::Tiny::_HalfOp"->new( '&', @tc );
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( !_FIXED_PRECEDENCE...)
0.000000,0,0.000000,require Type::Tiny::Intersection;
0.000000,0,0.000000,"Type::Tiny::Intersection"->new_by_overload( type_constraints => \@tc );
0.000000,0,0.000000,},
0.000000,0,0.000000,q(~)  => sub { shift->complementary_type },
0.000000,0,0.000000,q(==) => sub { $_[0]->equals( $_[1] ) },
0.000000,0,0.000000,q(!=) => sub { not $_[0]->equals( $_[1] ) },
0.000000,0,0.000000,q(<)  => sub { my $m = $_[0]->can( 'is_subtype_of' ); $m->( _swap @_ ) },
0.000000,0,0.000000,q(>)  => sub {
0.000000,0,0.000000,my $m = $_[0]->can( 'is_subtype_of' );
0.000000,0,0.000000,$m->( reverse _swap @_ );
0.000000,0,0.000000,},
0.000000,0,0.000000,q(<=) => sub { my $m = $_[0]->can( 'is_a_type_of' ); $m->( _swap @_ ) },
0.000000,0,0.000000,q(>=) => sub {
0.000000,0,0.000000,my $m = $_[0]->can( 'is_a_type_of' );
0.000000,0,0.000000,$m->( reverse _swap @_ );
0.000000,0,0.000000,},
0.000000,0,0.000000,q(eq)  => sub { "$_[0]" eq "$_[1]" },
0.000000,0,0.000000,q(cmp) => sub { $_[2] ? ( "$_[1]" cmp "$_[0]" ) : ( "$_[0]" cmp "$_[1]" ) },
0.000000,0,0.000000,q(0+)  => sub { $_[0]{uniq} },
0.000000,0,0.000000,q(/)   => sub { ( _STRICT_MODE xor $_[2] ) ? $_[0] : $_[1] },
0.000030,1,0.000030,);
0.000000,0,0.000000,
0.000000,0,0.000000,__PACKAGE__->_install_overloads(
0.000000,0,0.000000,q(~~) => sub { $_[0]->check( $_[1] ) },
0.000001,1,0.000001,) if Type::Tiny::SUPPORT_SMARTMATCH;
0.000000,0,0.000000,
0.000000,0,0.000000,# Would be easy to just return sub { $self->assert_return(@_) }
0.000000,0,0.000000,# but try to build a more efficient coderef whenever possible.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub _overload_coderef {
0.000027,220,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Bypass generating a coderef if we've already got the best possible one.
0.000000,0,0.000000,#
0.000351,220,0.000002,return $self->{_overload_coderef} if $self->{_overload_coderef_no_rebuild};
0.000000,0,0.000000,
0.000000,0,0.000000,# Subclasses of Type::Tiny might override assert_return to do some kind
0.000000,0,0.000000,# of interesting thing. In that case, we can't rely on it having identical
0.000000,0,0.000000,# behaviour to Type::Tiny::inline_assert.
0.000000,0,0.000000,#
0.000000,0,0.000000,$self->{_overrides_assert_return} =
0.000000,0,0.000000,( $self->can( 'assert_return' ) != \&assert_return )
0.000186,64,0.000003,unless exists $self->{_overrides_assert_return};
0.000000,0,0.000000,
0.000069,64,0.000001,if ( $self->{_overrides_assert_return} ) {
0.000000,0,0.000000,$self->{_overload_coderef} ||= do {
0.000000,0,0.000000,Scalar::Util::weaken( my $weak = $self );
0.000000,0,0.000000,sub { $weak->assert_return( @_ ) };
0.000000,0,0.000000,};
0.000000,0,0.000000,++$self->{_overload_coderef_no_rebuild};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( exists( &Sub::Quote::quote_sub ) ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Use `=` instead of `||=` because we want to overwrite non-Sub::Quote
0.000000,0,0.000000,# coderef if possible.
0.000140,27,0.000005,$self->{_overload_coderef} = $self->can_be_inlined
0.000000,0,0.000000,? Sub::Quote::quote_sub(
0.000000,0,0.000000,$self->inline_assert( '$_[0]' ),
0.000000,0,0.000000,)
0.000000,0,0.000000,: Sub::Quote::quote_sub(
0.000000,0,0.000000,$self->inline_assert( '$_[0]', '$type' ),
0.000000,0,0.000000,{ '$type' => \$self },
0.000000,0,0.000000,);
0.000025,27,0.000001,++$self->{_overload_coderef_no_rebuild};
0.000000,0,0.000000,} #/ elsif ( exists( &Sub::Quote::quote_sub...))
0.000000,0,0.000000,else {
0.000008,37,0.000000,require Eval::TypeTiny;
0.000152,37,0.000004,$self->{_overload_coderef} ||= $self->can_be_inlined
0.000000,0,0.000000,? Eval::TypeTiny::eval_closure(
0.000000,0,0.000000,source => sprintf(
0.000000,0,0.000000,'sub { %s }', $self->inline_assert( '$_[0]', undef, no_wrapper => 1 )
0.000000,0,0.000000,),
0.000000,0,0.000000,description => sprintf( "compiled assertion 'assert_%s'", $self ),
0.000000,0,0.000000,)
0.000000,0,0.000000,: Eval::TypeTiny::eval_closure(
0.000000,0,0.000000,source => sprintf(
0.000000,0,0.000000,'sub { %s }', $self->inline_assert( '$_[0]', '$type', no_wrapper => 1 )
0.000000,0,0.000000,),
0.000000,0,0.000000,description => sprintf( "compiled assertion 'assert_%s'", $self ),
0.000000,0,0.000000,environment => { '$type' => \$self },
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ else [ if ( $self->{_overrides_assert_return...})]
0.000000,0,0.000000,
0.000121,64,0.000002,$self->{_overload_coderef};
0.000000,0,0.000000,} #/ sub _overload_coderef
0.000000,0,0.000000,
0.000000,0,0.000000,our %ALL_TYPES;
0.000000,0,0.000000,
0.000001,1,0.000001,my $QFS;
0.000000,1,0.000000,my $uniq = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000030,82,0.000000,my $class  = shift;
0.000114,82,0.000001,my %params = ( @_ == 1 ) ? %{ $_[0] } : @_;
0.000000,0,0.000000,
0.000039,82,0.000000,for ( qw/ name display_name library / ) {
0.000129,246,0.000001,$params{$_} = $params{$_} . '' if defined $params{$_};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000031,82,0.000000,if ( exists $params{parent} ) {
0.000000,0,0.000000,$params{parent} =
0.000000,0,0.000000,ref( $params{parent} ) =~ /^Type::Tiny\b/
0.000000,0,0.000000,? $params{parent}
0.000213,63,0.000003,: Types::TypeTiny::to_TypeTiny( $params{parent} );
0.000000,0,0.000000,
0.000000,0,0.000000,_croak "Parent must be an instance of %s", __PACKAGE__
0.000000,0,0.000000,unless blessed( $params{parent} )
0.000168,63,0.000003,&& $params{parent}->isa( __PACKAGE__ );
0.000000,0,0.000000,
0.000053,63,0.000001,if ( $params{parent}->deprecated and not exists $params{deprecated} ) {
0.000000,0,0.000000,$params{deprecated} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( exists $params{parent...})
0.000000,0,0.000000,
0.000030,82,0.000000,if ( exists $params{constraint}
0.000000,0,0.000000,and defined $params{constraint}
0.000000,0,0.000000,and not ref $params{constraint} )
0.000000,0,0.000000,{
0.000003,5,0.000001,require Eval::TypeTiny;
0.000002,5,0.000000,my $code = $params{constraint};
0.000029,5,0.000006,$params{constraint} = Eval::TypeTiny::eval_closure(
0.000000,0,0.000000,source      => sprintf( 'sub ($) { %s }', $code ),
0.000000,0,0.000000,description => "anonymous check",
0.000000,0,0.000000,);
0.000000,0,0.000000,$params{inlined} ||= sub {
0.000012,30,0.000000,my ( $type ) = @_;
0.000042,30,0.000001,my $inlined  = $_ eq '$_' ? "do { $code }" : "do { local \$_ = $_; $code }";
0.000103,30,0.000003,$type->has_parent ? ( undef, $inlined ) : $inlined;
0.000000,0,0.000000,}
0.000026,5,0.000005,if ( !exists $params{parent} or $params{parent}->can_be_inlined );
0.000000,0,0.000000,} #/ if ( exists $params{constraint...})
0.000000,0,0.000000,
0.000000,0,0.000000,# canonicalize to a boolean
0.000049,82,0.000001,$params{deprecated} = !!$params{deprecated};
0.000000,0,0.000000,
0.000043,82,0.000001,$params{name} = "__ANON__" unless exists $params{name};
0.000046,82,0.000001,$params{uniq} = $uniq++;
0.000000,0,0.000000,
0.000039,82,0.000000,if ( $params{name} ne "__ANON__" ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# First try a fast ASCII-only expression, but fall back to Unicode
0.000000,0,0.000000,$params{name} =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm
0.000000,0,0.000000,or eval q( use 5.008; $params{name} =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm )
0.000100,39,0.000003,or _croak '"%s" is not a valid type name', $params{name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000022,82,0.000000,if ( exists $params{coercion} and !ref $params{coercion} and $params{coercion} )
0.000000,0,0.000000,{
0.000000,0,0.000000,$params{parent}->has_coercion
0.000000,0,0.000000,or _croak
0.000000,0,0.000000,"coercion => 1 requires type to have a direct parent with a coercion";
0.000000,0,0.000000,
0.000000,0,0.000000,$params{coercion} = $params{parent}->coercion->type_coercion_map;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000019,82,0.000000,if ( !exists $params{inlined}
0.000000,0,0.000000,and exists $params{constraint}
0.000000,0,0.000000,and ( !exists $params{parent} or $params{parent}->can_be_inlined )
0.000000,0,0.000000,and $QFS ||= "Sub::Quote"->can( "quoted_from_sub" ) )
0.000000,0,0.000000,{
0.000000,0,0.000000,my ( undef, $perlstring, $captures ) = @{ $QFS->( $params{constraint} ) || [] };
0.000000,0,0.000000,
0.000000,0,0.000000,$params{inlined} = sub {
0.000000,0,0.000000,my ( $self, $var ) = @_;
0.000000,0,0.000000,my $code = Sub::Quote::inlinify(
0.000000,0,0.000000,$perlstring,
0.000000,0,0.000000,$var,
0.000000,0,0.000000,$var eq q($_) ? '' : "local \$_ = $var;",
0.000000,0,0.000000,1,
0.000000,0,0.000000,);
0.000000,0,0.000000,$code = sprintf( '%s and %s', $self->parent->inline_check( $var ), $code )
0.000000,0,0.000000,if $self->has_parent;
0.000000,0,0.000000,return $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,if $perlstring && !$captures;
0.000000,0,0.000000,} #/ if ( !exists $params{inlined...})
0.000000,0,0.000000,
0.000047,82,0.000001,my $self = bless \%params, $class;
0.000000,0,0.000000,
0.000033,82,0.000000,unless ( $params{tmp} ) {
0.000153,82,0.000002,my $uniq = $self->{uniq};
0.000000,0,0.000000,
0.000069,82,0.000001,$ALL_TYPES{$uniq} = $self;
0.000160,82,0.000002,Scalar::Util::weaken( $ALL_TYPES{$uniq} );
0.000000,0,0.000000,
0.000013,82,0.000000,my $tmp = $self;
0.000162,82,0.000002,Scalar::Util::weaken( $tmp );
0.000241,82,0.000003,$Moo::HandleMoose::TYPE_MAP{ $self->_stringify_no_magic } = sub { $tmp };
0.000000,0,0.000000,} #/ unless ( $params{tmp} )
0.000000,0,0.000000,
0.000044,82,0.000001,if ( ref( $params{coercion} ) eq q(CODE) ) {
0.000000,0,0.000000,require Types::Standard;
0.000000,0,0.000000,my $code = delete( $params{coercion} );
0.000000,0,0.000000,$self->{coercion} = $self->_build_coercion;
0.000000,0,0.000000,$self->coercion->add_type_coercions( Types::Standard::Any(), $code );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( ref( $params{coercion} ) eq q(ARRAY) ) {
0.000000,0,0.000000,my $arr = delete( $params{coercion} );
0.000000,0,0.000000,$self->{coercion} = $self->_build_coercion;
0.000000,0,0.000000,$self->coercion->add_type_coercions( @$arr );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Documenting this here because it's too weird to be in the pod.
0.000000,0,0.000000,# There's a secret attribute called "_build_coercion" which takes a
0.000000,0,0.000000,# coderef. If present, then when $type->coercion is lazy built,
0.000000,0,0.000000,# the blank Type::Coercion object gets passed to the coderef,
0.000000,0,0.000000,# allowing the coderef to manipulate it a little. This is used by
0.000000,0,0.000000,# Types::TypeTiny to allow it to build a coercion for the TypeTiny
0.000000,0,0.000000,# type constraint without needing to load Type::Coercion yet.
0.000000,0,0.000000,
0.000018,82,0.000000,if ( $params{my_methods} ) {
0.000000,4,0.000000,require Eval::TypeTiny;
0.000000,0,0.000000,Scalar::Util::reftype( $params{my_methods}{$_} ) eq 'CODE'
0.000000,0,0.000000,and Eval::TypeTiny::set_subname(
0.000000,0,0.000000,sprintf( "%s::my_%s", $self->qualified_name, $_ ),
0.000000,0,0.000000,$params{my_methods}{$_},
0.000018,4,0.000005,) for keys %{ $params{my_methods} };
0.000000,0,0.000000,} #/ if ( $params{my_methods...})
0.000000,0,0.000000,
0.000152,82,0.000002,return $self;
0.000000,0,0.000000,} #/ sub new
0.000000,0,0.000000,
0.000000,0,0.000000,sub DESTROY {
0.000001,1,0.000001,my $self = shift;
0.000018,1,0.000018,delete( $ALL_TYPES{ $self->{uniq} } );
0.000003,1,0.000003,delete( $Moo::HandleMoose::TYPE_MAP{ $self->_stringify_no_magic } );
0.000007,1,0.000007,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _clone {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %opts;
0.000000,0,0.000000,$opts{$_} = $self->{$_} for qw< name display_name message >;
0.000000,0,0.000000,$self->create_child_type( %opts );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _stringify_no_magic {
0.000674,83,0.000008,sprintf(
0.000000,0,0.000000,'%s=%s(0x%08x)', blessed( $_[0] ), Scalar::Util::reftype( $_[0] ),
0.000000,0,0.000000,Scalar::Util::refaddr( $_[0] )
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,our $DD;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _dd {
0.000000,0,0.000000,@_ = $_ unless @_;
0.000000,0,0.000000,my ( $value ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,goto $DD if ref( $DD ) eq q(CODE);
0.000000,0,0.000000,
0.000000,0,0.000000,require B;
0.000000,0,0.000000,
0.000000,0,0.000000,!defined $value  ? 'Undef'
0.000000,0,0.000000,: !ref $value ? sprintf( 'Value %s', B::perlstring( $value ) )
0.000000,0,0.000000,: do {
0.000000,0,0.000000,my $N = 0+ ( defined( $DD ) ? $DD : 72 );
0.000000,0,0.000000,require Data::Dumper;
0.000000,0,0.000000,local $Data::Dumper::Indent   = 0;
0.000000,0,0.000000,local $Data::Dumper::Useqq    = 1;
0.000000,0,0.000000,local $Data::Dumper::Terse    = 1;
0.000000,0,0.000000,local $Data::Dumper::Sortkeys = 1;
0.000000,0,0.000000,local $Data::Dumper::Maxdepth = 2;
0.000000,0,0.000000,my $str;
0.000000,0,0.000000,eval {
0.000000,0,0.000000,$str = Data::Dumper::Dumper( $value );
0.000000,0,0.000000,$str = substr( $str, 0, $N - 12 ) . '...' . substr( $str, -1, 1 )
0.000000,0,0.000000,if length( $str ) >= $N;
0.000000,0,0.000000,1;
0.000000,0,0.000000,} or do { $str = 'which cannot be dumped' };
0.000000,0,0.000000,"Reference $str";
0.000000,0,0.000000,} #/ do
0.000000,0,0.000000,} #/ sub _dd
0.000000,0,0.000000,
0.000000,0,0.000000,sub _loose_to_TypeTiny {
0.000339,1691,0.000000,my $caller = caller( 1 ); # assumption
0.000000,0,0.000000,map +(
0.000000,0,0.000000,ref( $_ )
0.000000,0,0.000000,? Types::TypeTiny::to_TypeTiny( $_ )
0.003198,1691,0.000002,: do { require Type::Utils; Type::Utils::dwim_type( $_, for => $caller ) }
0.000000,0,0.000000,), @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000410,297,0.000001,sub name         { $_[0]{name} }
0.000499,367,0.000001,sub display_name { $_[0]{display_name} ||= $_[0]->_build_display_name }
0.001133,1139,0.000001,sub parent       { $_[0]{parent} }
0.001606,1539,0.000001,sub constraint   { $_[0]{constraint} ||= $_[0]->_build_constraint }
0.000000,0,0.000000,
0.000000,0,0.000000,sub compiled_check {
0.000351,169,0.000002,$_[0]{compiled_type_constraint} ||= $_[0]->_build_compiled_check;
0.000000,0,0.000000,}
0.000132,58,0.000002,sub coercion             { $_[0]{coercion} ||= $_[0]->_build_coercion }
0.000000,0,0.000000,sub message              { $_[0]{message} }
0.000000,0,0.000000,sub library              { $_[0]{library} }
0.000633,525,0.000001,sub inlined              { $_[0]{inlined} }
0.000134,103,0.000001,sub deprecated           { $_[0]{deprecated} }
0.000055,34,0.000002,sub constraint_generator { $_[0]{constraint_generator} }
0.000028,20,0.000001,sub inline_generator     { $_[0]{inline_generator} }
0.000044,22,0.000002,sub name_generator       { $_[0]{name_generator} ||= $_[0]->_build_name_generator }
0.000012,3,0.000004,sub coercion_generator   { $_[0]{coercion_generator} }
0.000007,5,0.000001,sub parameters           { $_[0]{parameters} }
0.000000,0,0.000000,sub moose_type           { $_[0]{moose_type} ||= $_[0]->_build_moose_type }
0.000000,0,0.000000,sub mouse_type           { $_[0]{mouse_type} ||= $_[0]->_build_mouse_type }
0.000000,0,0.000000,sub deep_explanation     { $_[0]{deep_explanation} }
0.000020,18,0.000001,sub my_methods           { $_[0]{my_methods} ||= $_[0]->_build_my_methods }
0.000000,0,0.000000,sub sorter               { $_[0]{sorter} }
0.000000,0,0.000000,
0.003900,3624,0.000001,sub has_parent               { exists $_[0]{parent} }
0.000000,0,0.000000,sub has_library              { exists $_[0]{library} }
0.000808,796,0.000001,sub has_inlined              { exists $_[0]{inlined} }
0.000167,106,0.000002,sub has_constraint_generator { exists $_[0]{constraint_generator} }
0.000037,20,0.000002,sub has_inline_generator     { exists $_[0]{inline_generator} }
0.000092,54,0.000002,sub has_coercion_generator   { exists $_[0]{coercion_generator} }
0.000006,3,0.000002,sub has_parameters           { exists $_[0]{parameters} }
0.000000,0,0.000000,sub has_message              { defined $_[0]{message} }
0.000000,0,0.000000,sub has_deep_explanation     { exists $_[0]{deep_explanation} }
0.000000,0,0.000000,sub has_sorter               { exists $_[0]{sorter} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _default_message {
0.000000,0,0.000000,$_[0]{_default_message} ||= $_[0]->_build_default_message;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_coercion {
0.000023,85,0.000000,$_[0]->coercion if $_[0]{_build_coercion};    # trigger auto build thing
0.000165,85,0.000002,$_[0]{coercion} and !!@{ $_[0]{coercion}->type_coercion_map };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _assert_coercion {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return $self->coercion if $self->{_build_coercion};    # trigger auto build thing
0.000000,0,0.000000,_croak "No coercion for this type constraint"
0.000000,0,0.000000,unless $self->has_coercion
0.000000,0,0.000000,&& @{ $self->coercion->type_coercion_map };
0.000000,0,0.000000,$self->coercion;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,my $null_constraint = sub { !!1 };
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_display_name {
0.000081,44,0.000002,shift->name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_constraint {
0.000017,15,0.000001,return $null_constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _is_null_constraint {
0.002498,1539,0.000002,shift->constraint == $null_constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_coercion {
0.000365,54,0.000007,require Type::Coercion;
0.000011,54,0.000000,my $self = shift;
0.000030,54,0.000001,my %opts = ( type_constraint => $self );
0.000091,54,0.000002,$opts{display_name} = "to_$self" unless $self->is_anon;
0.000071,54,0.000001,my $coercion = "Type::Coercion"->new( %opts );
0.000028,54,0.000001,$self->{_build_coercion}->( $coercion ) if ref $self->{_build_coercion};
0.000095,54,0.000002,$coercion;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_default_message {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->{is_using_default_message} = 1;
0.000000,0,0.000000,return sub { sprintf '%s did not pass type constraint', _dd( $_[0] ) }
0.000000,0,0.000000,if "$self" eq "__ANON__";
0.000000,0,0.000000,my $name = "$self";
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,sprintf '%s did not pass type constraint "%s"', _dd( $_[0] ), $name;
0.000000,0,0.000000,};
0.000000,0,0.000000,} #/ sub _build_default_message
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_name_generator {
0.000001,5,0.000000,my $self = shift;
0.000000,0,0.000000,return sub {
0.000161,16,0.000010,defined && s/[\x00-\x1F]//smg for ( my ( $s, @a ) = @_ );
0.000096,16,0.000006,sprintf( '%s[%s]', $s, join q[,], map !defined() ? 'undef' : !ref() && /\W/ ? B::perlstring($_) : $_, @a );
0.000018,5,0.000004,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_compiled_check {
0.000011,62,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000021,62,0.000000,local our $AvoidCallbacks = 0;
0.000000,0,0.000000,
0.000091,62,0.000001,if ( $self->_is_null_constraint and $self->has_parent ) {
0.000000,0,0.000000,return $self->parent->compiled_check;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000023,48,0.000000,require Eval::TypeTiny;
0.000331,48,0.000007,return Eval::TypeTiny::eval_closure(
0.000000,0,0.000000,source      => sprintf( 'sub ($) { %s }',      $self->inline_check( '$_[0]' ) ),
0.000000,0,0.000000,description => sprintf( "compiled check '%s'", $self ),
0.000000,0,0.000000,) if $self->can_be_inlined;
0.000000,0,0.000000,
0.000000,0,0.000000,my @constraints;
0.000000,0,0.000000,push @constraints, $self->parent->compiled_check if $self->has_parent;
0.000000,0,0.000000,push @constraints, $self->constraint             if !$self->_is_null_constraint;
0.000000,0,0.000000,return $null_constraint unless @constraints;
0.000000,0,0.000000,
0.000000,0,0.000000,return sub ($) {
0.000000,0,0.000000,local $_ = $_[0];
0.000000,0,0.000000,for my $c ( @constraints ) {
0.000000,0,0.000000,return unless $c->( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,return !!1;
0.000000,0,0.000000,};
0.000000,0,0.000000,} #/ sub _build_compiled_check
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_constraining_type {
0.000002,6,0.000000,my $self = shift;
0.000002,6,0.000000,if ( $self->_is_null_constraint and $self->has_parent ) {
0.000000,0,0.000000,return $self->parent->find_constraining_type;
0.000000,0,0.000000,}
0.000007,6,0.000001,$self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub type_default {
0.000008,17,0.000000,my ( $self, @args ) = @_;
0.000008,17,0.000000,if ( exists $self->{type_default} ) {
0.000001,16,0.000000,if ( @args ) {
0.000000,0,0.000000,my $td = $self->{type_default};
0.000000,0,0.000000,return sub { local $_ = \@args; &$td; };
0.000000,0,0.000000,}
0.000035,16,0.000002,return $self->{type_default};
0.000000,0,0.000000,}
0.000007,1,0.000007,if ( my $parent = $self->parent ) {
0.000000,0,0.000000,return $parent->type_default( @args ) if $self->_is_null_constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,our @CMP;
0.000000,0,0.000000,
0.000000,0,0.000000,sub CMP_SUPERTYPE ()  { -1 }
0.000000,0,0.000000,sub CMP_EQUAL ()      { 0 }
0.000000,0,0.000000,sub CMP_EQUIVALENT () { '0E0' }
0.000000,0,0.000000,sub CMP_SUBTYPE ()    { 1 }
0.000000,0,0.000000,sub CMP_UNKNOWN ()    { ''; }
0.000000,0,0.000000,
0.000000,0,0.000000,# avoid getting mixed up with cmp operator at compile time
0.000000,0,0.000000,*cmp = sub {
0.000002,3,0.000001,my ( $A, $B ) = _loose_to_TypeTiny( $_[0], $_[1] );
0.000009,3,0.000003,return unless blessed( $A ) && $A->isa( "Type::Tiny" );
0.000008,3,0.000003,return unless blessed( $B ) && $B->isa( "Type::Tiny" );
0.000003,3,0.000001,for my $comparator ( @CMP ) {
0.000005,3,0.000002,my $result = $comparator->( $A, $B );
0.000002,3,0.000001,next if $result eq CMP_UNKNOWN;
0.000001,3,0.000000,if ( $result eq CMP_EQUIVALENT ) {
0.000000,0,0.000000,my $prefer = @_ == 3 ? $_[2] : CMP_EQUAL;
0.000000,0,0.000000,return $prefer;
0.000000,0,0.000000,}
0.000007,3,0.000002,return $result;
0.000000,0,0.000000,}
0.000000,0,0.000000,return CMP_UNKNOWN;
0.000002,1,0.000002,};
0.000000,0,0.000000,
0.000000,0,0.000000,push @CMP, sub {
0.000001,3,0.000000,my ( $A, $B ) = @_;
0.000012,3,0.000004,return CMP_EQUAL
0.000000,0,0.000000,if Scalar::Util::refaddr( $A ) == Scalar::Util::refaddr( $B );
0.000000,0,0.000000,
0.000012,3,0.000004,return CMP_EQUIVALENT
0.000000,0,0.000000,if Scalar::Util::refaddr( $A->compiled_check ) ==
0.000000,0,0.000000,Scalar::Util::refaddr( $B->compiled_check );
0.000000,0,0.000000,
0.000005,3,0.000002,my $A_stem = $A->find_constraining_type;
0.000002,3,0.000001,my $B_stem = $B->find_constraining_type;
0.000008,3,0.000003,return CMP_EQUIVALENT
0.000000,0,0.000000,if Scalar::Util::refaddr( $A_stem ) == Scalar::Util::refaddr( $B_stem );
0.000009,3,0.000003,return CMP_EQUIVALENT
0.000000,0,0.000000,if Scalar::Util::refaddr( $A_stem->compiled_check ) ==
0.000000,0,0.000000,Scalar::Util::refaddr( $B_stem->compiled_check );
0.000000,0,0.000000,
0.000009,3,0.000003,if ( $A_stem->can_be_inlined and $B_stem->can_be_inlined ) {
0.000000,0,0.000000,return CMP_EQUIVALENT
0.000000,0,0.000000,if $A_stem->inline_check( '$WOLFIE' ) eq $B_stem->inline_check( '$WOLFIE' );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,A_IS_SUBTYPE: {
0.000003,6,0.000000,my $A_prime = $A_stem;
0.000003,3,0.000001,while ( $A_prime->has_parent ) {
0.000007,12,0.000001,$A_prime = $A_prime->parent;
0.000026,12,0.000002,return CMP_SUBTYPE
0.000000,0,0.000000,if Scalar::Util::refaddr( $A_prime ) == Scalar::Util::refaddr( $B_stem );
0.000032,12,0.000003,return CMP_SUBTYPE
0.000000,0,0.000000,if Scalar::Util::refaddr( $A_prime->compiled_check ) ==
0.000000,0,0.000000,Scalar::Util::refaddr( $B_stem->compiled_check );
0.000034,12,0.000003,if ( $A_prime->can_be_inlined and $B_stem->can_be_inlined ) {
0.000000,0,0.000000,return CMP_SUBTYPE
0.000000,0,0.000000,if $A_prime->inline_check( '$WOLFIE' ) eq $B_stem->inline_check( '$WOLFIE' );
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ while ( $A_prime->has_parent)
0.000000,0,0.000000,} #/ A_IS_SUBTYPE:
0.000000,0,0.000000,
0.000000,0,0.000000,B_IS_SUBTYPE: {
0.000002,6,0.000000,my $B_prime = $B_stem;
0.000001,3,0.000000,while ( $B_prime->has_parent ) {
0.000003,3,0.000001,$B_prime = $B_prime->parent;
0.000031,3,0.000010,return CMP_SUPERTYPE
0.000000,0,0.000000,if Scalar::Util::refaddr( $B_prime ) == Scalar::Util::refaddr( $A_stem );
0.000000,0,0.000000,return CMP_SUPERTYPE
0.000000,0,0.000000,if Scalar::Util::refaddr( $B_prime->compiled_check ) ==
0.000000,0,0.000000,Scalar::Util::refaddr( $A_stem->compiled_check );
0.000000,0,0.000000,if ( $A_stem->can_be_inlined and $B_prime->can_be_inlined ) {
0.000000,0,0.000000,return CMP_SUPERTYPE
0.000000,0,0.000000,if $B_prime->inline_check( '$WOLFIE' ) eq $A_stem->inline_check( '$WOLFIE' );
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ while ( $B_prime->has_parent)
0.000000,0,0.000000,} #/ B_IS_SUBTYPE:
0.000000,0,0.000000,
0.000000,0,0.000000,return CMP_UNKNOWN;
0.000004,1,0.000004,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub equals {
0.000000,0,0.000000,my $result = Type::Tiny::cmp( $_[0], $_[1] );
0.000000,0,0.000000,return unless defined $result;
0.000000,0,0.000000,$result eq CMP_EQUAL;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_subtype_of {
0.000000,0,0.000000,my $result = Type::Tiny::cmp( $_[0], $_[1], CMP_SUBTYPE );
0.000000,0,0.000000,return unless defined $result;
0.000000,0,0.000000,$result eq CMP_SUBTYPE;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_supertype_of {
0.000000,0,0.000000,my $result = Type::Tiny::cmp( $_[0], $_[1], CMP_SUBTYPE );
0.000000,0,0.000000,return unless defined $result;
0.000000,0,0.000000,$result eq CMP_SUPERTYPE;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_a_type_of {
0.000007,3,0.000002,my $result = Type::Tiny::cmp( $_[0], $_[1] );
0.000002,3,0.000001,return unless defined $result;
0.000006,3,0.000002,$result eq CMP_SUBTYPE or $result eq CMP_EQUAL or $result eq CMP_EQUIVALENT;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub strictly_equals {
0.000423,794,0.000001,my ( $self, $other ) = _loose_to_TypeTiny( @_ );
0.001449,794,0.000002,return unless blessed( $self )  && $self->isa( "Type::Tiny" );
0.001346,794,0.000002,return unless blessed( $other ) && $other->isa( "Type::Tiny" );
0.001218,794,0.000002,$self->{uniq} == $other->{uniq};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_strictly_subtype_of {
0.000417,703,0.000001,my ( $self, $other ) = _loose_to_TypeTiny( @_ );
0.001337,703,0.000002,return unless blessed( $self )  && $self->isa( "Type::Tiny" );
0.001151,703,0.000002,return unless blessed( $other ) && $other->isa( "Type::Tiny" );
0.000000,0,0.000000,
0.000484,703,0.000001,return unless $self->has_parent;
0.001724,597,0.000003,$self->parent->strictly_equals( $other )
0.000000,0,0.000000,or $self->parent->is_strictly_subtype_of( $other );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_strictly_supertype_of {
0.000000,0,0.000000,my ( $self, $other ) = _loose_to_TypeTiny( @_ );
0.000000,0,0.000000,return unless blessed( $self )  && $self->isa( "Type::Tiny" );
0.000000,0,0.000000,return unless blessed( $other ) && $other->isa( "Type::Tiny" );
0.000000,0,0.000000,
0.000000,0,0.000000,$other->is_strictly_subtype_of( $self );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_strictly_a_type_of {
0.000170,191,0.000001,my ( $self, $other ) = _loose_to_TypeTiny( @_ );
0.000398,191,0.000002,return unless blessed( $self )  && $self->isa( "Type::Tiny" );
0.000327,191,0.000002,return unless blessed( $other ) && $other->isa( "Type::Tiny" );
0.000000,0,0.000000,
0.000451,191,0.000002,$self->strictly_equals( $other ) or $self->is_strictly_subtype_of( $other );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub qualified_name {
0.000009,46,0.000000,my $self = shift;
0.000000,0,0.000000,( exists $self->{library} and $self->name ne "__ANON__" )
0.000000,0,0.000000,? "$self->{library}::$self->{name}"
0.000103,46,0.000002,: $self->{name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_anon {
0.000015,129,0.000000,my $self = shift;
0.000247,129,0.000002,$self->name eq "__ANON__";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parents {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return unless $self->has_parent;
0.000000,0,0.000000,return ( $self->parent, $self->parent->parents );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_parent {
0.000000,2,0.000000,my $self = shift;
0.000000,2,0.000000,my ( $test ) = @_;
0.000000,0,0.000000,
0.000003,2,0.000002,local ( $_, $. );
0.000002,2,0.000001,my $type  = $self;
0.000000,2,0.000000,my $count = 0;
0.000003,2,0.000002,while ( $type ) {
0.000011,2,0.000005,if ( $test->( $_ = $type, $. = $count ) ) {
0.000000,0,0.000000,return wantarray ? ( $type, $count ) : $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$type = $type->parent;
0.000000,0,0.000000,$count++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,} #/ sub find_parent
0.000000,0,0.000000,
0.000000,0,0.000000,sub check {
0.000043,381,0.000000,my $self = shift;
0.000619,381,0.000002,( $self->{compiled_type_constraint} ||= $self->_build_compiled_check )->( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _strict_check {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,local $_ = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,my @constraints =
0.000000,0,0.000000,reverse
0.000000,0,0.000000,map { $_->constraint }
0.000000,0,0.000000,grep { not $_->_is_null_constraint } ( $self, $self->parents );
0.000000,0,0.000000,
0.000000,0,0.000000,for my $c ( @constraints ) {
0.000000,0,0.000000,return unless $c->( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return !!1;
0.000000,0,0.000000,} #/ sub _strict_check
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_message {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,local $_ = $_[0];
0.000000,0,0.000000,$self->has_message
0.000000,0,0.000000,? $self->message->( @_ )
0.000000,0,0.000000,: $self->_default_message->( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub validate {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef
0.000000,0,0.000000,if ( $self->{compiled_type_constraint} ||= $self->_build_compiled_check )
0.000000,0,0.000000,->( @_ );
0.000000,0,0.000000,
0.000000,0,0.000000,local $_ = $_[0];
0.000000,0,0.000000,return $self->get_message( @_ );
0.000000,0,0.000000,} #/ sub validate
0.000000,0,0.000000,
0.000000,0,0.000000,sub validate_explain {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $value, $varname ) = @_;
0.000000,0,0.000000,$varname = '$_' unless defined $varname;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef if $self->check( $value );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->has_parent ) {
0.000000,0,0.000000,my $parent = $self->parent->validate_explain( $value, $varname );
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf( '"%s" is a subtype of "%s"', $self, $self->parent ),
0.000000,0,0.000000,@$parent
0.000000,0,0.000000,]
0.000000,0,0.000000,if $parent;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $message = sprintf(
0.000000,0,0.000000,'%s%s',
0.000000,0,0.000000,$self->get_message( $value ),
0.000000,0,0.000000,$varname eq q{$_} ? '' : sprintf( ' (in %s)', $varname ),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->is_parameterized and $self->parent->has_deep_explanation ) {
0.000000,0,0.000000,my $deep = $self->parent->deep_explanation->( $self, $value, $varname );
0.000000,0,0.000000,return [ $message, @$deep ] if $deep;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,local $SIG{__WARN__} = sub {};
0.000000,0,0.000000,return [
0.000000,0,0.000000,$message,
0.000000,0,0.000000,sprintf( '"%s" is defined as: %s', $self, $self->_perlcode )
0.000000,0,0.000000,];
0.000000,0,0.000000,} #/ sub validate_explain
0.000000,0,0.000000,
0.000000,1,0.000000,my $b;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _perlcode {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,local our $AvoidCallbacks = 1;
0.000000,0,0.000000,return $self->inline_check( '$_' )
0.000000,0,0.000000,if $self->can_be_inlined;
0.000000,0,0.000000,
0.000000,0,0.000000,$b ||= do {
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,require B::Deparse;
0.000000,0,0.000000,my $tmp = "B::Deparse"->new;
0.000000,0,0.000000,$tmp->ambient_pragmas( strict => "all", warnings => "all" )
0.000000,0,0.000000,if $tmp->can( 'ambient_pragmas' );
0.000000,0,0.000000,$tmp;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,my $code = $b->coderef2text( $self->constraint );
0.000000,0,0.000000,$code =~ s/\s+/ /g;
0.000000,0,0.000000,return "sub $code";
0.000000,0,0.000000,} #/ sub _perlcode
0.000000,0,0.000000,
0.000000,0,0.000000,sub assert_valid {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return !!1
0.000000,0,0.000000,if ( $self->{compiled_type_constraint} ||= $self->_build_compiled_check )
0.000000,0,0.000000,->( @_ );
0.000000,0,0.000000,
0.000000,0,0.000000,local $_ = $_[0];
0.000000,0,0.000000,$self->_failed_check( "$self", $_ );
0.000000,0,0.000000,} #/ sub assert_valid
0.000000,0,0.000000,
0.000000,0,0.000000,sub assert_return {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $_[0]
0.000000,0,0.000000,if ( $self->{compiled_type_constraint} ||= $self->_build_compiled_check )
0.000000,0,0.000000,->( @_ );
0.000000,0,0.000000,
0.000000,0,0.000000,local $_ = $_[0];
0.000000,0,0.000000,$self->_failed_check( "$self", $_ );
0.000000,0,0.000000,} #/ sub assert_return
0.000000,0,0.000000,
0.000000,0,0.000000,sub can_be_inlined {
0.000107,1016,0.000000,my $self = shift;
0.001180,1016,0.000001,return $self->parent->can_be_inlined
0.000000,0,0.000000,if $self->has_parent && $self->_is_null_constraint;
0.000534,956,0.000001,return !!1
0.000000,0,0.000000,if !$self->has_parent && $self->_is_null_constraint;
0.001401,901,0.000002,return $self->has_inlined;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub inline_check {
0.000069,633,0.000000,my $self = shift;
0.000361,633,0.000001,_croak 'Cannot inline type constraint check for "%s"', $self
0.000000,0,0.000000,unless $self->can_be_inlined;
0.000000,0,0.000000,
0.000667,633,0.000001,return $self->parent->inline_check( @_ )
0.000000,0,0.000000,if $self->has_parent && $self->_is_null_constraint;
0.000351,613,0.000001,return '(!!1)'
0.000000,0,0.000000,if !$self->has_parent && $self->_is_null_constraint;
0.000000,0,0.000000,
0.000112,587,0.000000,local $_ = $_[0];
0.001646,587,0.000003,my @r = $self->inlined->( $self, @_ );
0.000114,587,0.000000,if ( @r and not defined $r[0] ) {
0.000011,32,0.000000,_croak 'Inlining type constraint check for "%s" returned undef!', $self
0.000000,0,0.000000,unless $self->has_parent;
0.000078,32,0.000002,$r[0] = $self->parent->inline_check( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,my $r = join " && " => map {
0.002314,1206,0.000002,/[;{}]/ && !/\Ado \{.+\}\z/
0.000000,0,0.000000,? "do { $SafePackage $_ }"
0.000000,0,0.000000,: "($_)"
0.000000,0,0.000000,} @r;
0.001060,587,0.000002,return @r == 1 ? $r : "($r)";
0.000000,0,0.000000,} #/ sub inline_check
0.000000,0,0.000000,
0.000000,0,0.000000,sub inline_assert {
0.000738,132,0.000006,require B;
0.000062,132,0.000000,my $self = shift;
0.000186,132,0.000001,my ( $varname, $typevarname, %extras ) = @_;
0.000000,0,0.000000,
0.000020,132,0.000000,my $inline_check;
0.000354,132,0.000003,if ( $self->can_be_inlined ) {
0.000000,0,0.000000,$inline_check = sprintf( '(%s)', $self->inline_check( $varname ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $typevarname ) {
0.000000,0,0.000000,$inline_check = sprintf( '%s->check(%s)', $typevarname, $varname );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,_croak 'Cannot inline type constraint check for "%s"', $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000069,132,0.000001,my $do_wrapper = !delete $extras{no_wrapper};
0.000000,0,0.000000,
0.000019,132,0.000000,my $inline_throw;
0.000137,132,0.000001,if ( $typevarname ) {
0.000000,0,0.000000,$inline_throw = sprintf(
0.000000,0,0.000000,'Type::Tiny::_failed_check(%s, %s, %s, %s)',
0.000000,0,0.000000,$typevarname,
0.000000,0,0.000000,B::perlstring( "$self" ),
0.000000,0,0.000000,$varname,
0.000000,0,0.000000,join(
0.001391,68,0.000020,',', map +( B::perlstring( $_ ) => B::perlstring( $extras{$_} ) ),
0.000000,0,0.000000,sort keys %extras
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ if ( $typevarname )
0.000000,0,0.000000,else {
0.000000,0,0.000000,$inline_throw = sprintf(
0.000000,0,0.000000,'Type::Tiny::_failed_check(%s, %s, %s, %s)',
0.000000,0,0.000000,$self->{uniq},
0.000000,0,0.000000,B::perlstring( "$self" ),
0.000000,0,0.000000,$varname,
0.000000,0,0.000000,join(
0.000565,64,0.000009,',', map +( B::perlstring( $_ ) => B::perlstring( $extras{$_} ) ),
0.000000,0,0.000000,sort keys %extras
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ else [ if ( $typevarname ) ]
0.000000,0,0.000000,
0.000375,132,0.000003,$do_wrapper
0.000000,0,0.000000,? qq[do { no warnings "void"; $SafePackage $inline_check or $inline_throw; $varname };]
0.000000,0,0.000000,: qq[     no warnings "void"; $SafePackage $inline_check or $inline_throw; $varname   ];
0.000000,0,0.000000,} #/ sub inline_assert
0.000000,0,0.000000,
0.000000,0,0.000000,sub _failed_check {
0.000000,0,0.000000,require Error::TypeTiny::Assertion;
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $self, $name, $value, %attrs ) = @_;
0.000000,0,0.000000,$self = $ALL_TYPES{$self} if defined $self && !ref $self;
0.000000,0,0.000000,
0.000000,0,0.000000,my $exception_class =
0.000000,0,0.000000,delete( $attrs{exception_class} ) || "Error::TypeTiny::Assertion";
0.000000,0,0.000000,my $callback = delete( $attrs{on_die} );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self ) {
0.000000,0,0.000000,return $exception_class->throw_cb(
0.000000,0,0.000000,$callback,
0.000000,0,0.000000,message => $self->get_message( $value ),
0.000000,0,0.000000,type    => $self,
0.000000,0,0.000000,value   => $value,
0.000000,0,0.000000,%attrs,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $exception_class->throw_cb(
0.000000,0,0.000000,$callback,
0.000000,0,0.000000,message => sprintf( '%s did not pass type constraint "%s"', _dd( $value ), $name ),
0.000000,0,0.000000,value => $value,
0.000000,0,0.000000,%attrs,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ sub _failed_check
0.000000,0,0.000000,
0.000000,0,0.000000,sub coerce {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->_assert_coercion->coerce( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub assert_coerce {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->_assert_coercion->assert_coerce( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_parameterizable {
0.000205,106,0.000002,shift->has_constraint_generator;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_parameterized {
0.000007,3,0.000002,shift->has_parameters;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,1,0.000000,my %seen;
0.000000,0,0.000000,
0.000000,0,0.000000,sub ____make_key {
0.000000,0,0.000000,#<<<
0.000000,0,0.000000,join ',', map {
0.000200,69,0.000003,Types::TypeTiny::is_TypeTiny( $_ )  ? sprintf( '$Type::Tiny::ALL_TYPES{%s}', defined( $_->{uniq} ) ? $_->{uniq} : '____CANNOT_KEY____' ) :
0.000000,0,0.000000,ref() eq 'ARRAY'                    ? do { $seen{$_}++ ? '____CANNOT_KEY____' : sprintf( '[%s]', ____make_key( @$_ ) ) } :
0.000000,0,0.000000,ref() eq 'HASH'                     ? do { $seen{$_}++ ? '____CANNOT_KEY____' : sprintf( '{%s}', ____make_key( do { my %h = %$_; map +( $_, $h{$_} ), sort keys %h; } ) ) } :
0.000000,0,0.000000,ref() eq 'SCALAR' || ref() eq 'REF' ? do { $seen{$_}++ ? '____CANNOT_KEY____' : sprintf( '\\(%s)', ____make_key( $$_ ) ) } :
0.000000,0,0.000000,!defined()                          ? 'undef' :
0.000495,388,0.000001,!ref()                              ? do { require B; B::perlstring( $_ ) } :
0.000000,0,0.000000,'____CANNOT_KEY____';
0.000000,0,0.000000,} @_;
0.000000,0,0.000000,#>>>
0.000000,0,0.000000,} #/ sub ____make_key
0.000001,1,0.000001,my %param_cache;
0.000000,0,0.000000,
0.000000,0,0.000000,sub parameterize {
0.000019,69,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000100,69,0.000001,$self->is_parameterizable
0.000000,0,0.000000,or @_
0.000000,0,0.000000,? _croak( "Type '%s' does not accept parameters", "$self" )
0.000000,0,0.000000,: return ( $self );
0.000000,0,0.000000,
0.000150,69,0.000002,@_ = map Types::TypeTiny::to_TypeTiny( $_ ), @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Generate a key for caching parameterized type constraints,
0.000000,0,0.000000,# but only if all the parameters are strings or type constraints.
0.000020,69,0.000000,%seen = ();
0.000072,69,0.000001,my $key = $self->____make_key( @_ );
0.000140,69,0.000002,undef( $key )             if $key =~ /____CANNOT_KEY____/;
0.000089,69,0.000001,return $param_cache{$key} if defined $key && defined $param_cache{$key};
0.000000,0,0.000000,
0.000010,34,0.000000,local $Type::Tiny::parameterize_type = $self;
0.000015,34,0.000000,local $_                             = $_[0];
0.000000,34,0.000000,my $P;
0.000000,0,0.000000,
0.000136,34,0.000004,my ( $constraint, $compiled ) = $self->constraint_generator->( @_ );
0.000000,0,0.000000,
0.000037,34,0.000001,if ( Types::TypeTiny::is_TypeTiny( $constraint ) ) {
0.000000,0,0.000000,$P = $constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000112,20,0.000006,my %options = (
0.000000,0,0.000000,constraint   => $constraint,
0.000000,0,0.000000,display_name => $self->name_generator->( $self, @_ ),
0.000000,0,0.000000,parameters   => [@_],
0.000000,0,0.000000,);
0.000003,20,0.000000,$options{compiled_type_constraint} = $compiled
0.000000,0,0.000000,if $compiled;
0.000069,20,0.000003,$options{inlined} = $self->inline_generator->( @_ )
0.000000,0,0.000000,if $self->has_inline_generator;
0.000000,0,0.000000,$options{type_default} = $self->{type_default_generator}->( @_ )
0.000034,20,0.000002,if exists $self->{type_default_generator}; # undocumented
0.000000,0,0.000000,exists $options{$_} && !defined $options{$_} && delete $options{$_}
0.000046,20,0.000002,for keys %options;
0.000000,0,0.000000,
0.000036,20,0.000002,$P = $self->create_child_type( %options );
0.000000,0,0.000000,
0.000034,20,0.000002,if ( $self->has_coercion_generator ) {
0.000049,20,0.000002,my @args = @_;
0.000000,0,0.000000,$P->{_build_coercion} = sub {
0.000000,3,0.000000,my $coercion = shift;
0.000007,3,0.000002,my $built    = $self->coercion_generator->( $self, $P, @args );
0.000002,3,0.000001,$coercion->add_type_coercions( @{ $built->type_coercion_map } ) if $built;
0.000007,3,0.000002,$coercion->freeze;
0.000055,20,0.000003,};
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ else [ if ( Types::TypeTiny::is_TypeTiny...)]
0.000000,0,0.000000,
0.000015,34,0.000000,if ( defined $key ) {
0.000033,34,0.000001,$param_cache{$key} = $P;
0.000103,34,0.000003,Scalar::Util::weaken( $param_cache{$key} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000062,34,0.000002,$P->coercion->freeze unless $self->has_coercion_generator;
0.000000,0,0.000000,
0.000083,34,0.000002,return $P;
0.000000,0,0.000000,} #/ sub parameterize
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,sub child_type_class {
0.000038,27,0.000001,__PACKAGE__;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_child_type {
0.000009,27,0.000000,my $self = shift;
0.000002,27,0.000000,my %moreopts;
0.000034,27,0.000001,$moreopts{is_object} = 1 if $self->{is_object};
0.000123,27,0.000005,return $self->child_type_class->new( parent => $self, %moreopts, @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub complementary_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $r    = ( $self->{complementary_type} ||= $self->_build_complementary_type );
0.000000,0,0.000000,Scalar::Util::weaken( $self->{complementary_type} )
0.000000,0,0.000000,unless Scalar::Util::isweak( $self->{complementary_type} );
0.000000,0,0.000000,return $r;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_complementary_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %opts = (
0.000000,0,0.000000,constraint   => sub { not $self->check( $_ ) },
0.000000,0,0.000000,display_name => sprintf( "~%s", $self ),
0.000000,0,0.000000,);
0.000000,0,0.000000,$opts{display_name} =~ s/^\~{2}//;
0.000000,0,0.000000,$opts{inlined} = sub { shift; "not(" . $self->inline_check( @_ ) . ")" }
0.000000,0,0.000000,if $self->can_be_inlined;
0.000000,0,0.000000,$opts{display_name} = $opts{name} = $self->{complement_name}
0.000000,0,0.000000,if $self->{complement_name};
0.000000,0,0.000000,return "Type::Tiny"->new( %opts );
0.000000,0,0.000000,} #/ sub _build_complementary_type
0.000000,0,0.000000,
0.000000,0,0.000000,sub _instantiate_moose_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %opts = @_;
0.000000,0,0.000000,require Moose::Meta::TypeConstraint;
0.000000,0,0.000000,return "Moose::Meta::TypeConstraint"->new( %opts );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_moose_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $r;
0.000000,0,0.000000,if ( $self->{_is_core} ) {
0.000000,0,0.000000,require Moose::Util::TypeConstraints;
0.000000,0,0.000000,$r = Moose::Util::TypeConstraints::find_type_constraint( $self->name );
0.000000,0,0.000000,$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
0.000000,0,0.000000,Scalar::Util::weaken( $r->{"Types::TypeTiny::to_TypeTiny"} );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# Type::Tiny is more flexible than Moose, allowing
0.000000,0,0.000000,# inlined to return a list. So we need to wrap the
0.000000,0,0.000000,# inlined coderef to make sure Moose gets a single
0.000000,0,0.000000,# string.
0.000000,0,0.000000,#
0.000000,0,0.000000,my $wrapped_inlined = sub {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,$self->inline_check( @_ );
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,my %opts;
0.000000,0,0.000000,$opts{name}   = $self->qualified_name if $self->has_library && !$self->is_anon;
0.000000,0,0.000000,$opts{parent} = $self->parent->moose_type if $self->has_parent;
0.000000,0,0.000000,$opts{constraint} = $self->constraint unless $self->_is_null_constraint;
0.000000,0,0.000000,$opts{message}    = $self->message   if $self->has_message;
0.000000,0,0.000000,$opts{inlined}    = $wrapped_inlined if $self->has_inlined;
0.000000,0,0.000000,
0.000000,0,0.000000,$r                                   = $self->_instantiate_moose_type( %opts );
0.000000,0,0.000000,$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
0.000000,0,0.000000,$self->{moose_type}                  = $r;                                     # prevent recursion
0.000000,0,0.000000,$r->coercion( $self->coercion->moose_coercion ) if $self->has_coercion;
0.000000,0,0.000000,} #/ else [ if ( $self->{_is_core})]
0.000000,0,0.000000,
0.000000,0,0.000000,return $r;
0.000000,0,0.000000,} #/ sub _build_moose_type
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_mouse_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my %options;
0.000000,0,0.000000,$options{name} = $self->qualified_name if $self->has_library && !$self->is_anon;
0.000000,0,0.000000,$options{parent}     = $self->parent->mouse_type if $self->has_parent;
0.000000,0,0.000000,$options{constraint} = $self->constraint unless $self->_is_null_constraint;
0.000000,0,0.000000,$options{message}    = $self->message if $self->has_message;
0.000000,0,0.000000,
0.000000,0,0.000000,require Mouse::Meta::TypeConstraint;
0.000000,0,0.000000,my $r = "Mouse::Meta::TypeConstraint"->new( %options );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{mouse_type} = $r;    # prevent recursion
0.000000,0,0.000000,$r->_add_type_coercions(
0.000000,0,0.000000,$self->coercion->freeze->_codelike_type_coercion_map( 'mouse_type' ) )
0.000000,0,0.000000,if $self->has_coercion;
0.000000,0,0.000000,
0.000000,0,0.000000,return $r;
0.000000,0,0.000000,} #/ sub _build_mouse_type
0.000000,0,0.000000,
0.000000,0,0.000000,sub exportables {
0.000016,38,0.000000,my ( $self, $base_name, $tag ) = ( shift, @_ ); # $tag is undocumented
0.000039,38,0.000001,if ( not $self->is_anon ) {
0.000000,0,0.000000,$base_name ||= $self->name;
0.000000,0,0.000000,}
0.000006,38,0.000000,$tag ||= 0;
0.000000,0,0.000000,
0.000002,38,0.000000,my @exportables;
0.000005,38,0.000000,return \@exportables if ! $base_name;
0.000000,0,0.000000,
0.000016,38,0.000000,require Eval::TypeTiny;
0.000000,0,0.000000,
0.000071,38,0.000002,push @exportables, {
0.000000,0,0.000000,name => $base_name,
0.000000,0,0.000000,code => Eval::TypeTiny::type_to_coderef( $self ),
0.000000,0,0.000000,tags => [ 'types' ],
0.000000,0,0.000000,} if $tag eq 'types' || !$tag;
0.000000,0,0.000000,
0.000081,38,0.000002,push @exportables, {
0.000000,0,0.000000,name => sprintf( 'is_%s', $base_name ),
0.000000,0,0.000000,code => $self->compiled_check,
0.000000,0,0.000000,tags => [ 'is' ],
0.000000,0,0.000000,} if $tag eq 'is' || !$tag;
0.000000,0,0.000000,
0.000096,38,0.000003,push @exportables, {
0.000000,0,0.000000,name => sprintf( 'assert_%s', $base_name ),
0.000000,0,0.000000,code => $self->_overload_coderef,
0.000000,0,0.000000,tags => [ 'assert' ],
0.000000,0,0.000000,} if $tag eq 'assert' || !$tag;
0.000000,0,0.000000,
0.000000,0,0.000000,push @exportables, {
0.000000,0,0.000000,name => sprintf( 'to_%s', $base_name ),
0.000000,0,0.000000,code => $self->has_coercion && $self->coercion->frozen
0.000000,0,0.000000,? $self->coercion->compiled_coercion
0.000000,0,0.000000,: sub ($) { $self->coerce( $_[0] ) },
0.000120,38,0.000003,tags => [ 'to' ],
0.000000,0,0.000000,} if $tag eq 'to' || !$tag;
0.000000,0,0.000000,
0.000057,38,0.000001,return \@exportables;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub exportables_by_tag {
0.000001,1,0.000001,my ( $self, $tag, $base_name ) = ( shift, @_ );
0.000000,0,0.000000,my @matched = grep {
0.000000,1,0.000000,my $e = $_;
0.000002,1,0.000002,grep $_ eq $tag, @{ $e->{tags} || [] };
0.000004,1,0.000004,} @{ $self->exportables( $base_name, $tag ) };
0.000003,1,0.000003,return @matched if wantarray;
0.000000,0,0.000000,_croak( 'Expected to find one exportable tagged "%s", found %d', $tag, scalar @matched )
0.000000,0,0.000000,unless @matched == 1;
0.000000,0,0.000000,return $matched[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_coercion_list {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my @pairs;
0.000000,0,0.000000,while ( @_ ) {
0.000000,0,0.000000,my $next = shift;
0.000000,0,0.000000,if ( blessed( $next )
0.000000,0,0.000000,and $next->isa( 'Type::Coercion' )
0.000000,0,0.000000,and $next->is_parameterized )
0.000000,0,0.000000,{
0.000000,0,0.000000,push @pairs => ( @{ $next->_reparameterize( $self )->type_coercion_map } );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( blessed( $next ) and $next->can( 'type_coercion_map' ) ) {
0.000000,0,0.000000,push @pairs => (
0.000000,0,0.000000,@{ $next->type_coercion_map },
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( ref( $next ) eq q(ARRAY) ) {
0.000000,0,0.000000,unshift @_, @$next;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @pairs => (
0.000000,0,0.000000,Types::TypeTiny::to_TypeTiny( $next ),
0.000000,0,0.000000,shift,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ while ( @_ )
0.000000,0,0.000000,
0.000000,0,0.000000,return @pairs;
0.000000,0,0.000000,} #/ sub _process_coercion_list
0.000000,0,0.000000,
0.000000,0,0.000000,sub plus_coercions {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $new  = $self->_clone;
0.000000,0,0.000000,$new->coercion->add_type_coercions(
0.000000,0,0.000000,$self->_process_coercion_list( @_ ),
0.000000,0,0.000000,@{ $self->coercion->type_coercion_map },
0.000000,0,0.000000,);
0.000000,0,0.000000,$new->coercion->freeze;
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,} #/ sub plus_coercions
0.000000,0,0.000000,
0.000000,0,0.000000,sub plus_fallback_coercions {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $new = $self->_clone;
0.000000,0,0.000000,$new->coercion->add_type_coercions(
0.000000,0,0.000000,@{ $self->coercion->type_coercion_map },
0.000000,0,0.000000,$self->_process_coercion_list( @_ ),
0.000000,0,0.000000,);
0.000000,0,0.000000,$new->coercion->freeze;
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,} #/ sub plus_fallback_coercions
0.000000,0,0.000000,
0.000000,0,0.000000,sub minus_coercions {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $new = $self->_clone;
0.000000,0,0.000000,my @not = grep Types::TypeTiny::is_TypeTiny( $_ ),
0.000000,0,0.000000,$self->_process_coercion_list( $new, @_ );
0.000000,0,0.000000,
0.000000,0,0.000000,my @keep;
0.000000,0,0.000000,my $c = $self->coercion->type_coercion_map;
0.000000,0,0.000000,for ( my $i = 0 ; $i <= $#$c ; $i += 2 ) {
0.000000,0,0.000000,my $keep_this = 1;
0.000000,0,0.000000,NOT: for my $n ( @not ) {
0.000000,0,0.000000,if ( $c->[$i] == $n ) {
0.000000,0,0.000000,$keep_this = 0;
0.000000,0,0.000000,last NOT;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @keep, $c->[$i], $c->[ $i + 1 ] if $keep_this;
0.000000,0,0.000000,} #/ for ( my $i = 0 ; $i <=...)
0.000000,0,0.000000,
0.000000,0,0.000000,$new->coercion->add_type_coercions( @keep );
0.000000,0,0.000000,$new->coercion->freeze;
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,} #/ sub minus_coercions
0.000000,0,0.000000,
0.000000,0,0.000000,sub no_coercions {
0.000000,0,0.000000,my $new = shift->_clone;
0.000000,0,0.000000,$new->coercion->freeze;
0.000000,0,0.000000,$new;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub coercibles {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->has_coercion ? $self->coercion->_source_type_union : $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub isa {
0.000352,3751,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000491,3751,0.000000,if ( $INC{"Moose.pm"}
0.000000,0,0.000000,and ref( $self )
0.000000,0,0.000000,and $_[0] =~ /^(?:Class::MOP|MooseX?::Meta)::(.+)$/ )
0.000000,0,0.000000,{
0.000000,0,0.000000,my $meta = $1;
0.000000,0,0.000000,
0.000000,0,0.000000,return !!1                       if $meta eq 'TypeConstraint';
0.000000,0,0.000000,return $self->is_parameterized   if $meta eq 'TypeConstraint::Parameterized';
0.000000,0,0.000000,return $self->is_parameterizable if $meta eq 'TypeConstraint::Parameterizable';
0.000000,0,0.000000,return $self->isa( 'Type::Tiny::Union' ) if $meta eq 'TypeConstraint::Union';
0.000000,0,0.000000,
0.000000,0,0.000000,my $inflate = $self->moose_type;
0.000000,0,0.000000,return $inflate->isa( @_ );
0.000000,0,0.000000,} #/ if ( $INC{"Moose.pm"} ...)
0.000000,0,0.000000,
0.000370,3751,0.000000,if ( $INC{"Mouse.pm"}
0.000000,0,0.000000,and ref( $self )
0.000000,0,0.000000,and $_[0] eq 'Mouse::Meta::TypeConstraint' )
0.000000,0,0.000000,{
0.000000,0,0.000000,return !!1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.007985,3751,0.000002,$self->SUPER::isa( @_ );
0.000000,0,0.000000,} #/ sub isa
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_my_methods {
0.000004,2,0.000002,return {};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _lookup_my_method {
0.000002,12,0.000000,my $self = shift;
0.000009,12,0.000001,my ( $name ) = @_;
0.000000,0,0.000000,
0.000021,12,0.000002,if ( $self->my_methods->{$name} ) {
0.000000,0,0.000000,return $self->my_methods->{$name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000017,6,0.000003,if ( $self->has_parent ) {
0.000000,0,0.000000,return $self->parent->_lookup_my_method( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,} #/ sub _lookup_my_method
0.000000,0,0.000000,
0.000002,1,0.000002,my %object_methods = (
0.000000,0,0.000000,with_attribute_values => 1, stringifies_to => 1,
0.000000,0,0.000000,numifies_to           => 1
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub can {
0.000007,67,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000028,67,0.000000,return !!0
0.000000,0,0.000000,if $_[0] eq 'type_parameter'
0.000000,0,0.000000,&& blessed( $_[0] )
0.000000,0,0.000000,&& $_[0]->has_parameters;
0.000000,0,0.000000,
0.000230,67,0.000003,my $can = $self->SUPER::can( @_ );
0.000120,67,0.000002,return $can if $can;
0.000000,0,0.000000,
0.000002,6,0.000000,if ( ref( $self ) ) {
0.000003,6,0.000000,if ( $INC{"Moose.pm"} ) {
0.000000,0,0.000000,my $method = $self->moose_type->can( @_ );
0.000000,0,0.000000,return sub { shift->moose_type->$method( @_ ) }
0.000000,0,0.000000,if $method;
0.000000,0,0.000000,}
0.000011,6,0.000002,if ( $_[0] =~ /\Amy_(.+)\z/ ) {
0.000000,0,0.000000,my $method = $self->_lookup_my_method( $1 );
0.000000,0,0.000000,return $method if $method;
0.000000,0,0.000000,}
0.000003,6,0.000000,if ( $self->{is_object} && $object_methods{ $_[0] } ) {
0.000000,0,0.000000,require Type::Tiny::ConstrainedObject;
0.000000,0,0.000000,return Type::Tiny::ConstrainedObject->can( $_[0] );
0.000000,0,0.000000,}
0.000005,6,0.000001,for my $util ( qw/ grep map sort rsort first any all assert_any assert_all / ) {
0.000007,54,0.000000,if ( $_[0] eq $util ) {
0.000000,0,0.000000,$self->{'_util'}{$util} ||= eval { $self->_build_util( $util ) };
0.000000,0,0.000000,return unless $self->{'_util'}{$util};
0.000000,0,0.000000,return sub { my $s = shift; $s->{'_util'}{$util}( @_ ) };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( ref( $self ) )
0.000000,0,0.000000,
0.000006,6,0.000001,return;
0.000000,0,0.000000,} #/ sub can
0.000000,0,0.000000,
0.000000,0,0.000000,sub AUTOLOAD {
0.000001,6,0.000000,my $self = shift;
0.000022,6,0.000004,my ( $m ) = ( our $AUTOLOAD =~ /::(\w+)$/ );
0.000003,6,0.000000,return if $m eq 'DESTROY';
0.000000,0,0.000000,
0.000001,6,0.000000,if ( ref( $self ) ) {
0.000003,6,0.000000,if ( $INC{"Moose.pm"} ) {
0.000000,0,0.000000,my $method = $self->moose_type->can( $m );
0.000000,0,0.000000,return $self->moose_type->$method( @_ ) if $method;
0.000000,0,0.000000,}
0.000010,6,0.000002,if ( $m =~ /\Amy_(.+)\z/ ) {
0.000008,6,0.000001,my $method = $self->_lookup_my_method( $1 );
0.000020,6,0.000003,return &$method( $self, @_ ) if $method;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( $self->{is_object} && $object_methods{$m} ) {
0.000000,0,0.000000,require Type::Tiny::ConstrainedObject;
0.000000,0,0.000000,unshift @_, $self;
0.001027,2,0.000513,no strict 'refs';
0.000000,0,0.000000,goto \&{"Type::Tiny::ConstrainedObject::$m"};
0.000000,0,0.000000,}
0.000000,0,0.000000,for my $util ( qw/ grep map sort rsort first any all assert_any assert_all / ) {
0.000000,0,0.000000,if ( $m eq $util ) {
0.000000,0,0.000000,return ( $self->{'_util'}{$util} ||= $self->_build_util( $util ) )->( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( ref( $self ) )
0.000000,0,0.000000,
0.000000,0,0.000000,_croak q[Can't locate object method "%s" via package "%s"], $m,
0.000000,0,0.000000,ref( $self ) || $self;
0.000000,0,0.000000,} #/ sub AUTOLOAD
0.000000,0,0.000000,
0.000000,0,0.000000,sub DOES {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return !!1
0.000000,0,0.000000,if ref( $self )
0.000000,0,0.000000,&& $_[0] =~ m{^ Type::API::Constraint (?: ::Coercible | ::Inlinable )? $}x;
0.000000,0,0.000000,return !!1 if !ref( $self ) && $_[0] eq 'Type::API::Constraint::Constructor';
0.000000,0,0.000000,
0.000000,0,0.000000,"UNIVERSAL"->can( "DOES" ) ? $self->SUPER::DOES( @_ ) : $self->isa( @_ );
0.000000,0,0.000000,} #/ sub DOES
0.000000,0,0.000000,
0.000000,0,0.000000,sub _has_xsub {
0.000000,0,0.000000,require B;
0.000000,0,0.000000,!!B::svref_2object( shift->compiled_check )->XSUB;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_util {
0.000000,0,0.000000,my ( $self, $func ) = @_;
0.000000,0,0.000000,Scalar::Util::weaken( my $type = $self );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $func eq 'grep'
0.000000,0,0.000000,|| $func eq 'first'
0.000000,0,0.000000,|| $func eq 'any'
0.000000,0,0.000000,|| $func eq 'all'
0.000000,0,0.000000,|| $func eq 'assert_any'
0.000000,0,0.000000,|| $func eq 'assert_all' )
0.000000,0,0.000000,{
0.000000,0,0.000000,my ( $inline, $compiled );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->can_be_inlined ) {
0.000000,0,0.000000,$inline = $self->inline_check( '$_' );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$compiled = $self->compiled_check;
0.000000,0,0.000000,$inline   = '$compiled->($_)';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $func eq 'grep' ) {
0.000000,0,0.000000,return eval "sub { grep { $inline } \@_ }";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $func eq 'first' ) {
0.000000,0,0.000000,return eval "sub { for (\@_) { return \$_ if ($inline) }; undef; }";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $func eq 'any' ) {
0.000000,0,0.000000,return eval "sub { for (\@_) { return !!1 if ($inline) }; !!0; }";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $func eq 'assert_any' ) {
0.000000,0,0.000000,my $qname = B::perlstring( $self->name );
0.000000,0,0.000000,return
0.000000,0,0.000000,eval
0.000000,0,0.000000,"sub { for (\@_) { return \@_ if ($inline) }; Type::Tiny::_failed_check(\$type, $qname, \@_ ? \$_[-1] : undef); }";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $func eq 'all' ) {
0.000000,0,0.000000,return eval "sub { for (\@_) { return !!0 unless ($inline) }; !!1; }";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $func eq 'assert_all' ) {
0.000000,0,0.000000,my $qname = B::perlstring( $self->name );
0.000000,0,0.000000,return
0.000000,0,0.000000,eval
0.000000,0,0.000000,"sub { my \$idx = 0; for (\@_) { Type::Tiny::_failed_check(\$type, $qname, \$_, varname => sprintf('\$_[%d]', \$idx)) unless ($inline); ++\$idx }; \@_; }";
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( $func eq 'grep' ||...)
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $func eq 'map' ) {
0.000000,0,0.000000,my ( $inline, $compiled );
0.000000,0,0.000000,my $c = $self->_assert_coercion;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $c->can_be_inlined ) {
0.000000,0,0.000000,$inline = $c->inline_coercion( '$_' );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$compiled = $c->compiled_coercion;
0.000000,0,0.000000,$inline   = '$compiled->($_)';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return eval "sub { map { $inline } \@_ }";
0.000000,0,0.000000,} #/ if ( $func eq 'map' )
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $func eq 'sort' || $func eq 'rsort' ) {
0.000000,0,0.000000,my ( $inline, $compiled );
0.000000,0,0.000000,
0.000000,0,0.000000,my $ptype = $self->find_parent( sub { $_->has_sorter } );
0.000000,0,0.000000,_croak "No sorter for this type constraint" unless $ptype;
0.000000,0,0.000000,
0.000000,0,0.000000,my $sorter = $ptype->sorter;
0.000000,0,0.000000,
0.000000,0,0.000000,# Schwarzian transformation
0.000000,0,0.000000,if ( ref( $sorter ) eq 'ARRAY' ) {
0.000000,0,0.000000,my $sort_key;
0.000000,0,0.000000,( $sorter, $sort_key ) = @$sorter;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $func eq 'sort' ) {
0.000000,0,0.000000,return
0.000000,0,0.000000,eval
0.000000,0,0.000000,"our (\$a, \$b); sub { map \$_->[0], sort { \$sorter->(\$a->[1],\$b->[1]) } map [\$_,\$sort_key->(\$_)], \@_ }";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $func eq 'rsort' ) {
0.000000,0,0.000000,return
0.000000,0,0.000000,eval
0.000000,0,0.000000,"our (\$a, \$b); sub { map \$_->[0], sort { \$sorter->(\$b->[1],\$a->[1]) } map [\$_,\$sort_key->(\$_)], \@_ }";
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( ref( $sorter ) eq...)
0.000000,0,0.000000,
0.000000,0,0.000000,# Simple sort
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ( $func eq 'sort' ) {
0.000000,0,0.000000,return eval "our (\$a, \$b); sub { sort { \$sorter->(\$a,\$b) } \@_ }";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $func eq 'rsort' ) {
0.000000,0,0.000000,return eval "our (\$a, \$b); sub { sort { \$sorter->(\$b,\$a) } \@_ }";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( $func eq 'sort' ||...)
0.000000,0,0.000000,
0.000000,0,0.000000,die "Unknown function: $func";
0.000000,0,0.000000,} #/ sub _build_util
0.000000,0,0.000000,
0.000000,0,0.000000,sub of    { shift->parameterize( @_ ) }
0.000026,5,0.000005,sub where { shift->create_child_type( constraint => @_ ) }
0.000000,0,0.000000,
0.000000,0,0.000000,# fill out Moose-compatible API
0.000000,0,0.000000,sub inline_environment        { +{} }
0.000000,0,0.000000,sub _inline_check             { shift->inline_check( @_ ) }
0.000000,0,0.000000,sub _compiled_type_constraint { shift->compiled_check( @_ ) }
0.000000,0,0.000000,sub meta { _croak( "Not really a Moose::Meta::TypeConstraint. Sorry!" ) }
0.000000,0,0.000000,sub compile_type_constraint           { shift->compiled_check }
0.000000,0,0.000000,sub _actually_compile_type_constraint { shift->_build_compiled_check }
0.000000,0,0.000000,sub hand_optimized_type_constraint { shift->{hand_optimized_type_constraint} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_hand_optimized_type_constraint {
0.000000,0,0.000000,exists( shift->{hand_optimized_type_constraint} );
0.000000,0,0.000000,}
0.000006,2,0.000003,sub type_parameter { ( shift->parameters || [] )->[0] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub parameterized_from {
0.000000,0,0.000000,$_[0]->is_parameterized ? shift->parent : _croak( "Not a parameterized type" );
0.000000,0,0.000000,}
0.000000,0,0.000000,sub has_parameterized_from { $_[0]->is_parameterized }
0.000000,0,0.000000,
0.000000,0,0.000000,# some stuff for Mouse-compatible API
0.000000,0,0.000000,sub __is_parameterized      { shift->is_parameterized( @_ ) }
0.000000,0,0.000000,sub _add_type_coercions     { shift->coercion->add_type_coercions( @_ ) }
0.000000,0,0.000000,sub _as_string              { shift->qualified_name( @_ ) }
0.000000,0,0.000000,sub _compiled_type_coercion { shift->coercion->compiled_coercion( @_ ) }
0.000000,0,0.000000,sub _identity               { Scalar::Util::refaddr( shift ) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _unite {
0.000000,0,0.000000,require Type::Tiny::Union;
0.000000,0,0.000000,"Type::Tiny::Union"->new( type_constraints => \@_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Hooks for Type::Tie
0.000000,0,0.000000,sub TIESCALAR {
0.000000,0,0.000000,require Type::Tie;
0.000000,0,0.000000,unshift @_, 'Type::Tie::SCALAR';
0.000000,0,0.000000,goto \&Type::Tie::SCALAR::TIESCALAR;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub TIEARRAY {
0.000000,0,0.000000,require Type::Tie;
0.000000,0,0.000000,unshift @_, 'Type::Tie::ARRAY';
0.000000,0,0.000000,goto \&Type::Tie::ARRAY::TIEARRAY;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub TIEHASH {
0.000000,0,0.000000,require Type::Tie;
0.000000,0,0.000000,unshift @_, 'Type::Tie::HASH';
0.000000,0,0.000000,goto \&Type::Tie::HASH::TIEHASH;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000013,1,0.000013,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
