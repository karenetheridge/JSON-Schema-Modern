# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000072,2,0.000036,use strict;
0.000040,2,0.000020,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Vocabulary;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Base role for JSON Schema vocabulary classes
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.559';
0.000000,0,0.000000,
0.000029,2,0.000015,use 5.020;
0.000026,2,0.000013,use Moo::Role;
0.000056,3,0.000019,use strictures 2;
0.000038,2,0.000019,use experimental qw(signatures postderef);
0.000028,2,0.000014,use if "$]" >= 5.022, experimental => 're_strict';
0.000019,2,0.000010,no if "$]" >= 5.031009, feature => 'indirect';
0.000019,2,0.000010,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000035,2,0.000017,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000052,3,0.000017,use Ref::Util 0.100 'is_plain_arrayref';
0.000015,2,0.000007,use JSON::Schema::Modern::Utilities qw(jsonp assert_keyword_type abort);
0.000012,2,0.000006,use Carp ();
0.000543,2,0.000271,use namespace::clean;
0.000000,0,0.000000,
0.000001,1,0.000001,our @CARP_NOT = qw(JSON::Schema::Modern);
0.000000,0,0.000000,
0.000001,1,0.000001,requires qw(vocabulary keywords);
0.000000,0,0.000000,
0.000004,3,0.000001,sub evaluation_order { 999 }  # override, if needed
0.000000,0,0.000000,
0.000000,0,0.000000,sub traverse ($self, $schema, $state) {
0.000000,0,0.000000,$state->{evaluator}->_traverse_subschema($schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000371,2212,0.000000,sub traverse_subschema ($self, $schema, $state) {
0.000000,0,0.000000,$state->{evaluator}->_traverse_subschema($schema->{$state->{keyword}},
0.004129,553,0.000007,+{ %$state, schema_path => $state->{schema_path}.'/'.$state->{keyword} });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000072,296,0.000000,sub traverse_array_schemas ($self, $schema, $state) {
0.000090,74,0.000001,return if not assert_keyword_type($state, $schema, 'array');
0.000055,74,0.000001,return E($state, '%s array is empty', $state->{keyword}) if not $schema->{$state->{keyword}}->@*;
0.000000,0,0.000000,
0.000016,74,0.000000,my $valid = 1;
0.000141,74,0.000002,foreach my $idx (0 .. $schema->{$state->{keyword}}->$#*) {
0.000000,0,0.000000,$valid = 0 if not $state->{evaluator}->_traverse_subschema($schema->{$state->{keyword}}[$idx],
0.001239,199,0.000006,+{ %$state, schema_path => $state->{schema_path}.'/'.$state->{keyword}.'/'.$idx });
0.000000,0,0.000000,}
0.000174,74,0.000002,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000287,1588,0.000000,sub traverse_object_schemas ($self, $schema, $state) {
0.000624,397,0.000002,return if not assert_keyword_type($state, $schema, 'object');
0.000000,0,0.000000,
0.000112,397,0.000000,my $valid = 1;
0.002238,397,0.000006,foreach my $property (sort keys $schema->{$state->{keyword}}->%*) {
0.000000,0,0.000000,$valid = 0 if not $state->{evaluator}->_traverse_subschema($schema->{$state->{keyword}}{$property},
0.009576,1334,0.000007,+{ %$state, schema_path => jsonp($state->{schema_path}, $state->{keyword}, $property) });
0.000000,0,0.000000,}
0.000689,397,0.000002,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000011,30,0.000000,sub traverse_property_schema ($self, $schema, $state, $property) {
0.000007,6,0.000001,return if not assert_keyword_type($state, $schema, 'object');
0.000000,0,0.000000,
0.000000,0,0.000000,$state->{evaluator}->_traverse_subschema($schema->{$state->{keyword}}{$property},
0.000043,6,0.000007,+{ %$state, schema_path => jsonp($state->{schema_path}, $state->{keyword}, $property) });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.069361,247195,0.000000,sub eval ($self, $data, $schema, $state) {
0.183210,49439,0.000004,$state->{evaluator}->_eval_subschema($data, $schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.041329,248022,0.000000,sub eval_subschema_at_uri ($self, $data, $schema, $state, $uri) {
0.072955,41337,0.000002,my $schema_info = $state->{evaluator}->_fetch_from_uri($uri);
0.011827,41337,0.000000,abort($state, 'EXCEPTION: unable to find resource %s', $uri) if not $schema_info;
0.000000,0,0.000000,
0.014991,41337,0.000000,my $vocabularies = $schema_info->{vocabularies}; # reference, not copy
0.018971,41337,0.000000,if ($state->{validate_formats}) {
0.000000,0,0.000000,$vocabularies = [
0.000000,0,0.000000,map s/^JSON::Schema::Modern::Vocabulary::Format\KAnnotation$/Assertion/r, $state->{vocabularies}->@*
0.377904,41337,0.000009,];
0.028241,41337,0.000001,require JSON::Schema::Modern::Vocabulary::FormatAssertion;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $state->{evaluator}->_eval_subschema($data, $schema_info->{schema},
0.000000,0,0.000000,+{
0.000000,0,0.000000,$schema_info->{configs}->%*,
0.000000,0,0.000000,%$state,
0.000000,0,0.000000,traversed_schema_path => $state->{traversed_schema_path}.$state->{schema_path}
0.000000,0,0.000000,.jsonp('', $state->{keyword}, exists $state->{_schema_path_suffix}
0.000000,0,0.000000,? (is_plain_arrayref($state->{_schema_path_suffix}) ? $state->{_schema_path_suffix}->@* : $state->{_schema_path_suffix})
0.000000,0,0.000000,: ()),
0.000000,0,0.000000,initial_schema_uri => $schema_info->{canonical_uri},
0.000000,0,0.000000,document => $schema_info->{document},
0.000000,0,0.000000,document_path => $schema_info->{document_path},
0.000000,0,0.000000,spec_version => $schema_info->{specification_version},
0.678003,41337,0.000016,schema_path => '',
0.000000,0,0.000000,vocabularies => $vocabularies,
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000020,1,0.000020,__END__
