# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Eval::TypeTiny;
0.000000,0,0.000000,
0.000055,2,0.000028,use strict;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _clean_eval {
0.000018,131,0.000000,local $@;
0.000158,131,0.000001,local $SIG{__DIE__};
0.013140,131,0.000100,my $r = eval $_[0];
0.000025,131,0.000000,my $e = $@;
0.000378,131,0.000003,return ( $r, $e );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000059,2,0.000029,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000002,1,0.000002,*HAS_LEXICAL_SUBS = ( $] >= 5.018 ) ? sub () { !!1 } : sub () { !!0 };
0.000002,1,0.000002,*NICE_PROTOTYPES  = ( $] >= 5.014 ) ? sub () { !!1 } : sub () { !!0 };
0.000171,1,0.000171,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _pick_alternative {
0.000000,1,0.000000,my $ok = 0;
0.000001,1,0.000001,while ( @_ ) {
0.000001,1,0.000001,my ( $type, $condition, $result ) = splice @_, 0, 3;
0.000002,1,0.000002,if ( $type eq 'needs' ) {
0.000016,1,0.000016,++$ok if eval "require $condition; 1";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $type eq 'if' ) {
0.000000,0,0.000000,++$ok if $condition;
0.000000,0,0.000000,}
0.000000,1,0.000000,next unless $ok;
0.000019,1,0.000019,return ref( $result ) eq 'CODE' ? $result->() : ref( $result ) eq 'SCALAR' ? eval( $$result ) : $result;
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,sub IMPLEMENTATION_DEVEL_LEXALIAS () { 'Devel::LexAlias' }
0.000000,0,0.000000,sub IMPLEMENTATION_PADWALKER ()      { 'PadWalker' }
0.000000,0,0.000000,sub IMPLEMENTATION_TIE ()            { 'tie' }
0.000000,0,0.000000,sub IMPLEMENTATION_NATIVE ()         { 'perl' }
0.000000,0,0.000000,
0.000000,1,0.000000,my $implementation;
0.000000,0,0.000000,
0.000000,0,0.000000,#<<<
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,sub ALIAS_IMPLEMENTATION () {
0.000000,0,0.000000,$implementation ||= _pick_alternative(
0.000000,0,0.000000,if    => ( $] ge '5.022' ) => IMPLEMENTATION_NATIVE,
0.000000,0,0.000000,needs => 'Devel::LexAlias' => IMPLEMENTATION_DEVEL_LEXALIAS,
0.000000,0,0.000000,needs => 'PadWalker'       => IMPLEMENTATION_PADWALKER,
0.000000,0,0.000000,if    => !!1               => IMPLEMENTATION_TIE,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,#>>>
0.000000,0,0.000000,
0.000000,0,0.000000,sub _force_implementation {
0.000000,0,0.000000,$implementation = shift;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,BEGIN {
0.000003,1,0.000003,*_EXTENDED_TESTING = $ENV{EXTENDED_TESTING} ? sub() { !!1 } : sub() { !!0 };
0.000055,1,0.000055,}
0.000000,0,0.000000,
0.000001,1,0.000001,our $AUTHORITY = 'cpan:TOBYINK';
0.000000,1,0.000000,our $VERSION   = '2.000001';
0.000001,1,0.000001,our @EXPORT    = qw( eval_closure );
0.000001,1,0.000001,our @EXPORT_OK = qw(
0.000000,0,0.000000,HAS_LEXICAL_SUBS HAS_LEXICAL_VARS ALIAS_IMPLEMENTATION
0.000000,0,0.000000,IMPLEMENTATION_DEVEL_LEXALIAS IMPLEMENTATION_PADWALKER
0.000000,0,0.000000,IMPLEMENTATION_NATIVE IMPLEMENTATION_TIE
0.000000,0,0.000000,set_subname type_to_coderef NICE_PROTOTYPES
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000001,1,0.000001,$VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000000,0,0.000000,# See Types::TypeTiny for an explanation of this import method.
0.000000,0,0.000000,#
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,sub import {
0.001332,2,0.000666,no warnings "redefine";
0.000006,1,0.000006,our @ISA = qw( Exporter::Tiny );
0.000002,1,0.000002,require Exporter::Tiny;
0.000000,1,0.000000,my $next = \&Exporter::Tiny::import;
0.000000,1,0.000000,*import = $next;
0.000000,1,0.000000,my $class = shift;
0.000001,1,0.000001,my $opts  = { ref( $_[0] ) ? %{ +shift } : () };
0.000001,1,0.000001,$opts->{into} ||= scalar( caller );
0.000013,1,0.000013,return $class->$next( $opts, @_ );
0.000000,0,0.000000,} #/ sub import
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,1,0.000000,my $subname;
0.000000,1,0.000000,my %already;    # prevent renaming established functions
0.000000,0,0.000000,sub set_subname ($$) {
0.000025,198,0.000000,$subname = _pick_alternative(
0.000000,0,0.000000,needs => 'Sub::Util' => \ q{ \&Sub::Util::set_subname },
0.000000,0,0.000000,needs => 'Sub::Name' => \ q{ \&Sub::Name::subname     },
0.000000,0,0.000000,if    => !!1         => 0,
0.000000,0,0.000000,) unless defined $subname;
0.000850,198,0.000004,$subname and !$already{$_[1]}++ and return &$subname;
0.000051,51,0.000001,$_[1];
0.000000,0,0.000000,} #/ sub set_subname ($$)
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,sub type_to_coderef {
0.000009,40,0.000000,my ( $type, %args ) = @_;
0.000016,40,0.000000,my $post_method = $args{post_method} || q();
0.000000,0,0.000000,
0.000005,40,0.000000,my ( $coderef, $qualified_name );
0.000000,0,0.000000,
0.000037,40,0.000001,if ( ! defined $type ) {
0.000000,0,0.000000,my $library = $args{type_library};
0.000000,0,0.000000,my $name    = $args{type_name};
0.000000,0,0.000000,
0.000000,0,0.000000,$qualified_name = "$library\::$name";
0.000000,0,0.000000,$coderef = sub (;@) {
0.000000,0,0.000000,my $params;
0.000000,0,0.000000,$params = shift if ref( $_[0] ) eq "ARRAY";
0.000000,0,0.000000,
0.000000,0,0.000000,$type ||= do {
0.000000,0,0.000000,$library->can( 'get_type' )
0.000000,0,0.000000,or require Error::TypeTiny
0.000000,0,0.000000,&& Error::TypeTiny::croak( "Expected $library to be a type library, but it doesn't seem to be" );
0.000000,0,0.000000,$library->get_type( $name );
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,my $t;
0.000000,0,0.000000,if ( $type ) {
0.000000,0,0.000000,$t = $params ? $type->parameterize( @$params ) : $type;
0.000000,0,0.000000,$t = $t->$post_method if $post_method;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,require Error::TypeTiny && Error::TypeTiny::croak( "Cannot parameterize a non-existant type" )
0.000000,0,0.000000,if $params;
0.000000,0,0.000000,require Type::Tiny::_DeclaredType;
0.000000,0,0.000000,$t = Type::Tiny::_DeclaredType->new( library => $library, name => $name );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,@_ && wantarray ? return ( $t, @_ ) : return $t;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,require Scalar::Util && &Scalar::Util::set_prototype( $coderef, ';$' )
0.000000,0,0.000000,if Eval::TypeTiny::NICE_PROTOTYPES;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,#<<<
0.000048,40,0.000001,my $source = $type->is_parameterizable ?
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,q{
0.000000,0,0.000000,sub (%s) {
0.000000,0,0.000000,if (ref($_[0]) eq 'Type::Tiny::_HalfOp') {
0.000000,0,0.000000,my $complete_type = shift->complete($type);
0.000000,0,0.000000,@_ && wantarray ? return($complete_type, @_) : return $complete_type;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $params; $params = shift if ref($_[0]) eq q(ARRAY);
0.000000,0,0.000000,my $t = $params ? $type->parameterize(@$params) : $type;
0.000000,0,0.000000,@_ && wantarray ? return($t%s, @_) : return $t%s;
0.000000,0,0.000000,}
0.000000,0,0.000000,},
0.000000,0,0.000000,NICE_PROTOTYPES ? q(;$) : q(;@),
0.000000,0,0.000000,$post_method,
0.000000,0,0.000000,$post_method,
0.000000,0,0.000000,) :
0.000000,0,0.000000,sprintf( q{ sub () { $type%s if $] } }, $post_method );
0.000000,0,0.000000,#>>>
0.000000,0,0.000000,
0.000048,40,0.000001,$qualified_name = $type->qualified_name;
0.000000,0,0.000000,$coderef = eval_closure(
0.000000,0,0.000000,source      => $source,
0.000066,40,0.000002,description => $args{description} || sprintf( "exportable function '%s'", $qualified_name ),
0.000000,0,0.000000,environment => { '$type' => \$type },
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000082,40,0.000002,$args{anonymous} ? $coderef : set_subname( $qualified_name, $coderef );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub eval_closure {
0.000100,131,0.000001,my ( %args ) = @_;
0.000000,0,0.000000,my $src =
0.000000,0,0.000000,ref $args{source} eq "ARRAY"
0.000000,0,0.000000,? join( "\n", @{ $args{source} } )
0.000070,131,0.000001,: $args{source};
0.000000,0,0.000000,
0.000056,131,0.000000,$args{alias} = 0 unless defined $args{alias};
0.000030,131,0.000000,$args{line}  = 1 unless defined $args{line};
0.000000,0,0.000000,$args{description} =~ s/[^\w .:-\[\]\(\)\{\}\']//g
0.000370,131,0.000003,if defined $args{description};
0.000000,0,0.000000,$src = qq{#line $args{line} "$args{description}"\n$src}
0.000080,131,0.000001,if defined $args{description} && !( $^P & 0x10 );
0.000064,131,0.000000,$args{environment} ||= {};
0.000000,0,0.000000,
0.000000,0,0.000000,if ( _EXTENDED_TESTING ) {
0.000000,0,0.000000,require Scalar::Util;
0.000000,0,0.000000,for my $k ( sort keys %{ $args{environment} } ) {
0.000000,0,0.000000,next
0.000000,0,0.000000,if $k =~ /^\$/
0.000000,0,0.000000,&& Scalar::Util::reftype( $args{environment}{$k} ) =~ /^(SCALAR|REF)$/;
0.000000,0,0.000000,next
0.000000,0,0.000000,if $k =~ /^\@/
0.000000,0,0.000000,&& Scalar::Util::reftype( $args{environment}{$k} ) eq q(ARRAY);
0.000000,0,0.000000,next
0.000000,0,0.000000,if $k =~ /^\%/
0.000000,0,0.000000,&& Scalar::Util::reftype( $args{environment}{$k} ) eq q(HASH);
0.000000,0,0.000000,next
0.000000,0,0.000000,if $k =~ /^\&/
0.000000,0,0.000000,&& Scalar::Util::reftype( $args{environment}{$k} ) eq q(CODE);
0.000000,0,0.000000,
0.000000,0,0.000000,require Error::TypeTiny;
0.000000,0,0.000000,Error::TypeTiny::croak(
0.000000,0,0.000000,"Expected a variable name and ref; got %s => %s", $k,
0.000000,0,0.000000,$args{environment}{$k}
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ for my $k ( sort keys %...)
0.000000,0,0.000000,} #/ if ( _EXTENDED_TESTING)
0.000000,0,0.000000,
0.000057,131,0.000000,my $sandpkg = 'Eval::TypeTiny::Sandbox';
0.000030,131,0.000000,my $alias   = exists( $args{alias} ) ? $args{alias} : 0;
0.000331,131,0.000003,my @keys    = sort keys %{ $args{environment} };
0.000017,131,0.000000,my $i       = 0;
0.000165,131,0.000001,my $source  = join "\n" => (
0.000000,0,0.000000,"package $sandpkg;",
0.000000,0,0.000000,"sub {",
0.000000,0,0.000000,map( _make_lexical_assignment( $_, $i++, $alias ), @keys ),
0.000000,0,0.000000,$src,
0.000000,0,0.000000,"}",
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000012,131,0.000000,if ( $alias and ALIAS_IMPLEMENTATION eq IMPLEMENTATION_TIE ) {
0.000000,0,0.000000,_manufacture_ties();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000147,131,0.000001,my ( $compiler, $e ) = _clean_eval( $source );
0.000011,131,0.000000,if ( $e ) {
0.000000,0,0.000000,chomp $e;
0.000000,0,0.000000,require Error::TypeTiny::Compilation;
0.000000,0,0.000000,"Error::TypeTiny::Compilation"->throw(
0.000000,0,0.000000,code => (
0.000000,0,0.000000,ref $args{source} eq "ARRAY" ? join( "\n", @{ $args{source} } ) : $args{source}
0.000000,0,0.000000,),
0.000000,0,0.000000,errstr      => $e,
0.000000,0,0.000000,environment => $args{environment},
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ if ( $e )
0.000000,0,0.000000,
0.000179,131,0.000001,my $code = $compiler->( @{ $args{environment} }{@keys} );
0.000028,131,0.000000,undef( $compiler );
0.000000,0,0.000000,
0.000013,131,0.000000,if ( $alias and ALIAS_IMPLEMENTATION eq IMPLEMENTATION_DEVEL_LEXALIAS ) {
0.000000,0,0.000000,require Devel::LexAlias;
0.000000,0,0.000000,Devel::LexAlias::lexalias( $code, $_ => $args{environment}{$_} )
0.000000,0,0.000000,for grep !/^\&/, @keys;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000015,131,0.000000,if ( $alias and ALIAS_IMPLEMENTATION eq IMPLEMENTATION_PADWALKER ) {
0.000000,0,0.000000,require PadWalker;
0.000000,0,0.000000,my %env = map +( $_ => $args{environment}{$_} ), grep !/^\&/, @keys;
0.000000,0,0.000000,PadWalker::set_closed_over( $code, \%env );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000274,131,0.000002,return $code;
0.000000,0,0.000000,} #/ sub eval_closure
0.000000,0,0.000000,
0.000000,1,0.000000,my $tmp;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_lexical_assignment {
0.000012,40,0.000000,my ( $key, $index, $alias ) = @_;
0.000020,40,0.000001,my $name = substr( $key, 1 );
0.000000,0,0.000000,
0.000046,40,0.000001,if ( HAS_LEXICAL_SUBS and $key =~ /^\&/ ) {
0.000000,0,0.000000,$tmp++;
0.000000,0,0.000000,my $tmpname = '$__LEXICAL_SUB__' . $tmp;
0.000000,0,0.000000,return
0.000000,0,0.000000,"no warnings 'experimental::lexical_subs';"
0.000000,0,0.000000,. "use feature 'lexical_subs';"
0.000000,0,0.000000,. "my $tmpname = \$_[$index];"
0.000000,0,0.000000,. "my sub $name { goto $tmpname };";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,40,0.000000,if ( !$alias ) {
0.000009,40,0.000000,my $sigil = substr( $key, 0, 1 );
0.000066,40,0.000002,return "my $key = $sigil\{ \$_[$index] };";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( ALIAS_IMPLEMENTATION eq IMPLEMENTATION_NATIVE ) {
0.000000,0,0.000000,return
0.000000,0,0.000000,"no warnings 'experimental::refaliasing';"
0.000000,0,0.000000,. "use feature 'refaliasing';"
0.000000,0,0.000000,. "my $key; \\$key = \$_[$index];";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( ALIAS_IMPLEMENTATION eq IMPLEMENTATION_DEVEL_LEXALIAS ) {
0.000000,0,0.000000,return "my $key;";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( ALIAS_IMPLEMENTATION eq IMPLEMENTATION_PADWALKER ) {
0.000000,0,0.000000,return "my $key;";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $tieclass = {
0.000000,0,0.000000,'@' => 'Eval::TypeTiny::_TieArray',
0.000000,0,0.000000,'%' => 'Eval::TypeTiny::_TieHash',
0.000000,0,0.000000,'$' => 'Eval::TypeTiny::_TieScalar',
0.000000,0,0.000000,}->{ substr( $key, 0, 1 ) };
0.000000,0,0.000000,
0.000000,0,0.000000,return sprintf(
0.000000,0,0.000000,'tie(my(%s), "%s", $_[%d]);',
0.000000,0,0.000000,$key,
0.000000,0,0.000000,$tieclass,
0.000000,0,0.000000,$index,
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ else [ if ( !$alias ) ]
0.000000,0,0.000000,} #/ sub _make_lexical_assignment
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,1,0.000000,my $tie;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _manufacture_ties {
0.000000,0,0.000000,$tie ||= eval <<'FALLBACK'; } }
0.000000,0,0.000000,no warnings qw(void once uninitialized numeric);
0.000000,0,0.000000,use Type::Tiny ();
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,package #
0.000000,0,0.000000,Eval::TypeTiny::_TieArray;
0.000000,0,0.000000,require Tie::Array;
0.000000,0,0.000000,our @ISA = qw( Tie::StdArray );
0.000000,0,0.000000,sub TIEARRAY {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,bless $_[0] => $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub AUTOLOAD {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
0.000000,0,0.000000,defined tied(@$self) and return tied(@$self)->$method(@_);
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak(qq[Can't call method "$method" on an undefined value]) unless $method eq 'DESTROY';
0.000000,0,0.000000,}
0.000000,0,0.000000,sub can {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $code = $self->SUPER::can(@_)
0.000000,0,0.000000,|| (defined tied(@$self) and tied(@$self)->can(@_));
0.000000,0,0.000000,return $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,__PACKAGE__->Type::Tiny::_install_overloads(
0.000000,0,0.000000,q[bool]  => sub { !!   tied @{$_[0]} },
0.000000,0,0.000000,q[""]    => sub { '' . tied @{$_[0]} },
0.000000,0,0.000000,q[0+]    => sub { 0  + tied @{$_[0]} },
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,{
0.000000,0,0.000000,package #
0.000000,0,0.000000,Eval::TypeTiny::_TieHash;
0.000000,0,0.000000,require Tie::Hash;
0.000000,0,0.000000,our @ISA = qw( Tie::StdHash );
0.000000,0,0.000000,sub TIEHASH {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,bless $_[0] => $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub AUTOLOAD {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
0.000000,0,0.000000,defined tied(%$self) and return tied(%$self)->$method(@_);
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak(qq[Can't call method "$method" on an undefined value]) unless $method eq 'DESTROY';
0.000000,0,0.000000,}
0.000000,0,0.000000,sub can {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $code = $self->SUPER::can(@_)
0.000000,0,0.000000,|| (defined tied(%$self) and tied(%$self)->can(@_));
0.000000,0,0.000000,return $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,__PACKAGE__->Type::Tiny::_install_overloads(
0.000000,0,0.000000,q[bool]  => sub { !!   tied %{$_[0]} },
0.000000,0,0.000000,q[""]    => sub { '' . tied %{$_[0]} },
0.000000,0,0.000000,q[0+]    => sub { 0  + tied %{$_[0]} },
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,{
0.000000,0,0.000000,package #
0.000000,0,0.000000,Eval::TypeTiny::_TieScalar;
0.000000,0,0.000000,require Tie::Scalar;
0.000000,0,0.000000,our @ISA = qw( Tie::StdScalar );
0.000000,0,0.000000,sub TIESCALAR {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,bless $_[0] => $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub AUTOLOAD {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
0.000000,0,0.000000,defined tied($$self) and return tied($$self)->$method(@_);
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak(qq[Can't call method "$method" on an undefined value]) unless $method eq 'DESTROY';
0.000000,0,0.000000,}
0.000000,0,0.000000,sub can {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $code = $self->SUPER::can(@_)
0.000000,0,0.000000,|| (defined tied($$self) and tied($$self)->can(@_));
0.000000,0,0.000000,return $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,__PACKAGE__->Type::Tiny::_install_overloads(
0.000000,0,0.000000,q[bool]  => sub { !!   tied ${$_[0]} },
0.000000,0,0.000000,q[""]    => sub { '' . tied ${$_[0]} },
0.000000,0,0.000000,q[0+]    => sub { 0  + tied ${$_[0]} },
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,1;
0.000000,0,0.000000,FALLBACK
0.000000,0,0.000000,
0.000005,2,0.000003,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
