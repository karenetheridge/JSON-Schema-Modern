# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# ABSTRACT: Construct data structure from Parser Events
0.000030,2,0.000015,use strict;
0.000035,2,0.000017,use warnings;
0.000000,0,0.000000,package YAML::PP::Constructor;
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000027,2,0.000013,use YAML::PP;
0.000001,1,0.000001,use YAML::PP::Common qw/
0.000000,0,0.000000,PRESERVE_ORDER PRESERVE_SCALAR_STYLE PRESERVE_FLOW_STYLE PRESERVE_ALIAS
0.000024,1,0.000024,/;
0.000013,2,0.000007,use Scalar::Util qw/ reftype /;
0.000025,2,0.000012,use Carp qw/ croak /;
0.000000,0,0.000000,
0.000024,2,0.000012,use constant DEBUG => ($ENV{YAML_PP_LOAD_DEBUG} or $ENV{YAML_PP_LOAD_TRACE}) ? 1 : 0;
0.001641,2,0.000821,use constant TRACE => $ENV{YAML_PP_LOAD_TRACE} ? 1 : 0;
0.000000,0,0.000000,
0.000003,1,0.000003,my %cyclic_refs = qw/ allow 1 ignore 1 warn 1 fatal 1 /;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000002,1,0.000002,my ($class, %args) = @_;
0.000000,0,0.000000,
0.000000,1,0.000000,my $default_yaml_version = delete $args{default_yaml_version};
0.000001,1,0.000001,my $duplicate_keys = delete $args{duplicate_keys};
0.000001,1,0.000001,unless (defined $duplicate_keys) {
0.000000,0,0.000000,$duplicate_keys = 0;
0.000000,0,0.000000,}
0.000000,1,0.000000,my $preserve = delete $args{preserve} || 0;
0.000000,1,0.000000,if ($preserve == 1) {
0.000000,0,0.000000,$preserve = PRESERVE_ORDER | PRESERVE_SCALAR_STYLE | PRESERVE_FLOW_STYLE | PRESERVE_ALIAS;
0.000000,0,0.000000,}
0.000001,1,0.000001,my $cyclic_refs = delete $args{cyclic_refs} || 'allow';
0.000000,0,0.000000,die "Invalid value for cyclic_refs: $cyclic_refs"
0.000001,1,0.000001,unless $cyclic_refs{ $cyclic_refs };
0.000000,1,0.000000,my $schemas = delete $args{schemas};
0.000000,0,0.000000,
0.000000,1,0.000000,if (keys %args) {
0.000000,0,0.000000,die "Unexpected arguments: " . join ', ', sort keys %args;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,my $self = bless {
0.000000,0,0.000000,default_yaml_version => $default_yaml_version,
0.000000,0,0.000000,schemas => $schemas,
0.000000,0,0.000000,cyclic_refs => $cyclic_refs,
0.000000,0,0.000000,preserve => $preserve,
0.000000,0,0.000000,duplicate_keys => $duplicate_keys,
0.000000,0,0.000000,}, $class;
0.000002,1,0.000002,$self->init;
0.000003,1,0.000003,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my $clone = {
0.000000,0,0.000000,schemas => $self->{schemas},
0.000000,0,0.000000,schema => $self->{schema},
0.000000,0,0.000000,default_yaml_version => $self->{default_yaml_version},
0.000000,0,0.000000,cyclic_refs => $self->cyclic_refs,
0.000000,0,0.000000,preserve => $self->{preserve},
0.000000,0,0.000000,};
0.000000,0,0.000000,return bless $clone, ref $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub init {
0.000000,2,0.000000,my ($self) = @_;
0.000006,2,0.000003,$self->set_docs([]);
0.000001,2,0.000000,$self->set_stack([]);
0.000002,2,0.000001,$self->set_anchors({});
0.000005,2,0.000002,$self->set_yaml_version($self->default_yaml_version);
0.000009,2,0.000005,$self->set_schema($self->schemas->{ $self->yaml_version } );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,2,0.000002,sub docs { return $_[0]->{docs} }
0.059090,35838,0.000002,sub stack { return $_[0]->{stack} }
0.000000,0,0.000000,sub anchors { return $_[0]->{anchors} }
0.000007,2,0.000003,sub set_docs { $_[0]->{docs} = $_[1] }
0.000005,3,0.000002,sub set_stack { $_[0]->{stack} = $_[1] }
0.000007,3,0.000002,sub set_anchors { $_[0]->{anchors} = $_[1] }
0.000004,2,0.000002,sub schemas { return $_[0]->{schemas} }
0.033126,28300,0.000001,sub schema { return $_[0]->{schema} }
0.000003,2,0.000002,sub set_schema { $_[0]->{schema} = $_[1] }
0.000000,0,0.000000,sub cyclic_refs { return $_[0]->{cyclic_refs} }
0.000000,0,0.000000,sub set_cyclic_refs { $_[0]->{cyclic_refs} = $_[1] }
0.000003,2,0.000002,sub yaml_version { return $_[0]->{yaml_version} }
0.000005,2,0.000002,sub set_yaml_version { $_[0]->{yaml_version} = $_[1] }
0.000003,2,0.000002,sub default_yaml_version { return $_[0]->{default_yaml_version} }
0.008626,6900,0.000001,sub preserve_order { return $_[0]->{preserve} & PRESERVE_ORDER }
0.022568,20764,0.000001,sub preserve_scalar_style { return $_[0]->{preserve} & PRESERVE_SCALAR_STYLE }
0.009484,7536,0.000001,sub preserve_flow_style { return $_[0]->{preserve} & PRESERVE_FLOW_STYLE }
0.032263,28300,0.000001,sub preserve_alias { return $_[0]->{preserve} & PRESERVE_ALIAS }
0.000000,0,0.000000,sub duplicate_keys { return $_[0]->{duplicate_keys} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub document_start_event {
0.000000,1,0.000000,my ($self, $event) = @_;
0.000002,1,0.000002,my $stack = $self->stack;
0.000000,1,0.000000,if ($event->{version_directive}) {
0.000000,0,0.000000,my $version = $event->{version_directive};
0.000000,0,0.000000,$version = "$version->{major}.$version->{minor}";
0.000000,0,0.000000,if ($self->{schemas}->{ $version }) {
0.000000,0,0.000000,$self->set_yaml_version($version);
0.000000,0,0.000000,$self->set_schema($self->schemas->{ $version });
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->set_yaml_version($self->default_yaml_version);
0.000000,0,0.000000,$self->set_schema($self->schemas->{ $self->default_yaml_version });
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000001,1,0.000001,my $ref = [];
0.000004,1,0.000004,push @$stack, { type => 'document', ref => $ref, data => $ref, event => $event };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub document_end_event {
0.000000,1,0.000000,my ($self, $event) = @_;
0.000002,1,0.000002,my $stack = $self->stack;
0.000000,1,0.000000,my $last = pop @$stack;
0.000001,1,0.000001,$last->{type} eq 'document' or die "Expected mapping, but got $last->{type}";
0.000001,1,0.000001,if (@$stack) {
0.000000,0,0.000000,die "Got unexpected end of document";
0.000000,0,0.000000,}
0.000002,1,0.000002,my $docs = $self->docs;
0.000000,1,0.000000,push @$docs, $last->{ref}->[0];
0.000002,1,0.000002,$self->set_anchors({});
0.000005,1,0.000005,$self->set_stack([]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mapping_start_event {
0.001279,6900,0.000000,my ($self, $event) = @_;
0.011740,6900,0.000002,my ($data, $on_data) = $self->schema->create_mapping($self, $event);
0.011159,6900,0.000002,my $ref = {
0.000000,0,0.000000,type => 'mapping',
0.000000,0,0.000000,ref => [],
0.000000,0,0.000000,data => \$data,
0.000000,0,0.000000,event => $event,
0.000000,0,0.000000,on_data => $on_data,
0.000000,0,0.000000,};
0.004456,6900,0.000001,my $stack = $self->stack;
0.000000,0,0.000000,
0.005384,6900,0.000001,my $preserve_order = $self->preserve_order;
0.005102,6900,0.000001,my $preserve_style = $self->preserve_flow_style;
0.004281,6900,0.000001,my $preserve_alias = $self->preserve_alias;
0.001419,6900,0.000000,if (($preserve_order or $preserve_style or $preserve_alias) and not tied(%$data)) {
0.000000,0,0.000000,tie %$data, 'YAML::PP::Preserve::Hash', %$data;
0.000000,0,0.000000,}
0.000960,6900,0.000000,if ($preserve_style) {
0.000000,0,0.000000,my $t = tied %$data;
0.000000,0,0.000000,$t->{style} = $event->{style};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001668,6900,0.000000,push @$stack, $ref;
0.012193,6900,0.000002,if (defined(my $anchor = $event->{anchor})) {
0.000000,0,0.000000,if ($preserve_alias) {
0.000000,0,0.000000,my $t = tied %$data;
0.000000,0,0.000000,unless (exists $self->anchors->{ $anchor }) {
0.000000,0,0.000000,# Repeated anchors cannot be preserved
0.000000,0,0.000000,$t->{alias} = $anchor;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->anchors->{ $anchor } = { data => $ref->{data} };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mapping_end_event {
0.001189,6900,0.000000,my ($self, $event) = @_;
0.003923,6900,0.000001,my $stack = $self->stack;
0.000000,0,0.000000,
0.001765,6900,0.000000,my $last = pop @$stack;
0.003446,6900,0.000000,my ($ref, $data) = @{ $last }{qw/ ref data /};
0.001880,6900,0.000000,$last->{type} eq 'mapping' or die "Expected mapping, but got $last->{type}";
0.000000,0,0.000000,
0.000896,6900,0.000000,my @merge_keys;
0.000000,0,0.000000,my @ref;
0.006959,6900,0.000001,for (my $i = 0; $i < @$ref; $i += 2) {
0.004203,13349,0.000000,my $key = $ref->[ $i ];
0.004111,13349,0.000000,if (ref $key eq 'YAML::PP::Type::MergeKey') {
0.000000,0,0.000000,my $merge = $ref->[ $i + 1 ];
0.000000,0,0.000000,if ((reftype($merge) || '') eq 'HASH') {
0.000000,0,0.000000,push @merge_keys, $merge;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ((reftype($merge) || '') eq 'ARRAY') {
0.000000,0,0.000000,for my $item (@$merge) {
0.000000,0,0.000000,if ((reftype($item) || '') eq 'HASH') {
0.000000,0,0.000000,push @merge_keys, $item;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die "Expected hash for merge key";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die "Expected hash or array for merge key";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.005700,13349,0.000000,push @ref, $key, $ref->[ $i + 1 ];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.002592,6900,0.000000,for my $merge (@merge_keys) {
0.000000,0,0.000000,for my $key (keys %$merge) {
0.000000,0,0.000000,unless (exists $$data->{ $key }) {
0.000000,0,0.000000,$$data->{ $key } = $merge->{ $key };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my $on_data = $last->{on_data} || sub {
0.001419,6900,0.000000,my ($self, $hash, $items) = @_;
0.000932,6900,0.000000,my %seen;
0.018959,6900,0.000003,for (my $i = 0; $i < @$items; $i += 2) {
0.006355,13349,0.000000,my ($key, $value) = @$items[ $i, $i + 1 ];
0.001351,13349,0.000000,$key = '' unless defined $key;
0.001065,13349,0.000000,if (ref $key) {
0.000000,0,0.000000,$key = $self->stringify_complex($key);
0.000000,0,0.000000,}
0.013456,13349,0.000001,if ($seen{ $key }++ and not $self->duplicate_keys) {
0.000000,0,0.000000,croak "Duplicate key '$key'";
0.000000,0,0.000000,}
0.007641,13349,0.000001,$$hash->{ $key } = $value;
0.000000,0,0.000000,}
0.014379,6900,0.000002,};
0.006011,6900,0.000001,$on_data->($self, $data, \@ref);
0.005294,6900,0.000001,push @{ $stack->[-1]->{ref} }, $$data;
0.002545,6900,0.000000,if (defined(my $anchor = $last->{event}->{anchor})) {
0.000000,0,0.000000,$self->anchors->{ $anchor }->{finished} = 1;
0.000000,0,0.000000,}
0.033340,6900,0.000005,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sequence_start_event {
0.000222,636,0.000000,my ($self, $event) = @_;
0.001287,636,0.000002,my ($data, $on_data) = $self->schema->create_sequence($self, $event);
0.001310,636,0.000002,my $ref = {
0.000000,0,0.000000,type => 'sequence',
0.000000,0,0.000000,ref => [],
0.000000,0,0.000000,data => \$data,
0.000000,0,0.000000,event => $event,
0.000000,0,0.000000,on_data => $on_data,
0.000000,0,0.000000,};
0.000583,636,0.000001,my $stack = $self->stack;
0.000000,0,0.000000,
0.000469,636,0.000001,my $preserve_style = $self->preserve_flow_style;
0.000479,636,0.000001,my $preserve_alias = $self->preserve_alias;
0.000175,636,0.000000,if ($preserve_style or $preserve_alias and not tied(@$data)) {
0.000000,0,0.000000,tie @$data, 'YAML::PP::Preserve::Array', @$data;
0.000000,0,0.000000,my $t = tied @$data;
0.000000,0,0.000000,$t->{style} = $event->{style};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000247,636,0.000000,push @$stack, $ref;
0.001639,636,0.000003,if (defined(my $anchor = $event->{anchor})) {
0.000000,0,0.000000,if ($preserve_alias) {
0.000000,0,0.000000,my $t = tied @$data;
0.000000,0,0.000000,unless (exists $self->anchors->{ $anchor }) {
0.000000,0,0.000000,# Repeated anchors cannot be preserved
0.000000,0,0.000000,$t->{alias} = $anchor;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->anchors->{ $anchor } = { data => $ref->{data} };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sequence_end_event {
0.000191,636,0.000000,my ($self, $event) = @_;
0.000440,636,0.000001,my $stack = $self->stack;
0.000286,636,0.000000,my $last = pop @$stack;
0.000418,636,0.000001,$last->{type} eq 'sequence' or die "Expected mapping, but got $last->{type}";
0.000369,636,0.000001,my ($ref, $data) = @{ $last }{qw/ ref data /};
0.000000,0,0.000000,
0.000000,0,0.000000,my $on_data = $last->{on_data} || sub {
0.000176,636,0.000000,my ($self, $array, $items) = @_;
0.001576,636,0.000002,push @$$array, @$items;
0.001543,636,0.000002,};
0.000599,636,0.000001,$on_data->($self, $data, $ref);
0.000367,636,0.000001,push @{ $stack->[-1]->{ref} }, $$data;
0.000312,636,0.000000,if (defined(my $anchor = $last->{event}->{anchor})) {
0.000000,0,0.000000,my $test = $self->anchors->{ $anchor };
0.000000,0,0.000000,$self->anchors->{ $anchor }->{finished} = 1;
0.000000,0,0.000000,}
0.002634,636,0.000004,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,sub stream_start_event {}
0.000000,0,0.000000,
0.000002,1,0.000002,sub stream_end_event {}
0.000000,0,0.000000,
0.000000,0,0.000000,sub scalar_event {
0.003171,20764,0.000000,my ($self, $event) = @_;
0.000000,0,0.000000,DEBUG and warn "CONTENT $event->{value} ($event->{style})\n";
0.029597,20764,0.000001,my $value = $self->schema->load_scalar($self, $event);
0.040556,20764,0.000002,my $last = $self->stack->[-1];
0.013129,20764,0.000001,my $preserve_alias = $self->preserve_alias;
0.013433,20764,0.000001,my $preserve_style = $self->preserve_scalar_style;
0.004008,20764,0.000000,if (($preserve_style or $preserve_alias) and not ref $value) {
0.000000,0,0.000000,my %args = (
0.000000,0,0.000000,value => $value,
0.000000,0,0.000000,tag => $event->{tag},
0.000000,0,0.000000,);
0.000000,0,0.000000,if ($preserve_style) {
0.000000,0,0.000000,$args{style} = $event->{style};
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($preserve_alias and defined $event->{anchor}) {
0.000000,0,0.000000,my $anchor = $event->{anchor};
0.000000,0,0.000000,unless (exists $self->anchors->{ $anchor }) {
0.000000,0,0.000000,# Repeated anchors cannot be preserved
0.000000,0,0.000000,$args{alias} = $event->{anchor};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$value = YAML::PP::Preserve::Scalar->new( %args );
0.000000,0,0.000000,}
0.006427,20764,0.000000,if (defined (my $name = $event->{anchor})) {
0.000000,0,0.000000,$self->anchors->{ $name } = { data => \$value, finished => 1 };
0.000000,0,0.000000,}
0.041144,20764,0.000002,push @{ $last->{ref} }, $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub alias_event {
0.000000,0,0.000000,my ($self, $event) = @_;
0.000000,0,0.000000,my $value;
0.000000,0,0.000000,my $name = $event->{value};
0.000000,0,0.000000,if (my $anchor = $self->anchors->{ $name }) {
0.000000,0,0.000000,# We know this is a cyclic ref since the node hasn't
0.000000,0,0.000000,# been constructed completely yet
0.000000,0,0.000000,unless ($anchor->{finished} ) {
0.000000,0,0.000000,my $cyclic_refs = $self->cyclic_refs;
0.000000,0,0.000000,if ($cyclic_refs ne 'allow') {
0.000000,0,0.000000,if ($cyclic_refs eq 'fatal') {
0.000000,0,0.000000,die "Found cyclic ref for alias '$name'";
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($cyclic_refs eq 'warn') {
0.000000,0,0.000000,$anchor = { data => \undef };
0.000000,0,0.000000,warn "Found cyclic ref for alias '$name'";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($cyclic_refs eq 'ignore') {
0.000000,0,0.000000,$anchor = { data => \undef };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$value = $anchor->{data};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,croak "No anchor defined for alias '$name'";
0.000000,0,0.000000,}
0.000000,0,0.000000,my $last = $self->stack->[-1];
0.000000,0,0.000000,push @{ $last->{ref} }, $$value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub stringify_complex {
0.000000,0,0.000000,my ($self, $data) = @_;
0.000000,0,0.000000,return $data if (
0.000000,0,0.000000,ref $data eq 'YAML::PP::Preserve::Scalar'
0.000000,0,0.000000,and ($self->preserve_scalar_style or $self->preserve_alias)
0.000000,0,0.000000,);
0.000000,0,0.000000,require Data::Dumper;
0.000000,0,0.000000,local $Data::Dumper::Quotekeys = 0;
0.000000,0,0.000000,local $Data::Dumper::Terse = 1;
0.000000,0,0.000000,local $Data::Dumper::Indent = 0;
0.000000,0,0.000000,local $Data::Dumper::Useqq = 0;
0.000000,0,0.000000,local $Data::Dumper::Sortkeys = 1;
0.000000,0,0.000000,my $string = Data::Dumper->Dump([$data], ['data']);
0.000000,0,0.000000,$string =~ s/^\$data = //;
0.000000,0,0.000000,return $string;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
