# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000033,2,0.000017,use strict;
0.000041,2,0.000021,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Document::OpenAPI;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: One OpenAPI v3.1 document
0.000000,0,0.000000,# KEYWORDS: JSON Schema data validation request response OpenAPI
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.037';
0.000000,0,0.000000,
0.000027,2,0.000013,use 5.020;
0.000032,2,0.000016,use Moo;
0.000110,3,0.000037,use strictures 2;
0.000089,2,0.000044,use experimental qw(signatures postderef);
0.000025,2,0.000013,use if "$]" >= 5.022, experimental => 're_strict';
0.000020,2,0.000010,no if "$]" >= 5.031009, feature => 'indirect';
0.000016,2,0.000008,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000017,2,0.000008,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000034,3,0.000011,use JSON::Schema::Modern::Utilities 0.525 qw(assert_keyword_exists assert_keyword_type E canonical_uri get_type);
0.000019,2,0.000010,use Safe::Isa;
0.000015,2,0.000008,use File::ShareDir 'dist_dir';
0.000016,2,0.000008,use Path::Tiny;
0.000017,2,0.000008,use List::Util qw(any pairs);
0.000013,2,0.000007,use Ref::Util 'is_plain_hashref';
0.000018,2,0.000009,use MooX::HandlesVia;
0.000029,3,0.000010,use MooX::TypeTiny 0.002002;
0.000033,2,0.000017,use Types::Standard qw(InstanceOf HashRef Str);
0.000060,2,0.000030,use namespace::clean;
0.000000,0,0.000000,
0.000001,1,0.000001,extends 'JSON::Schema::Modern::Document';
0.000000,0,0.000000,
0.000040,2,0.000020,use constant DEFAULT_DIALECT => 'https://spec.openapis.org/oas/3.1/dialect/base';
0.000000,0,0.000000,
0.000001,1,0.000001,use constant DEFAULT_SCHEMAS => {
0.000000,0,0.000000,# local filename => identifier to add the schema as
0.000000,0,0.000000,'oas/dialect/base.schema.json' => 'https://spec.openapis.org/oas/3.1/dialect/base', # metaschema for json schemas contained within openapi documents
0.000000,0,0.000000,'oas/meta/base.schema.json' => 'https://spec.openapis.org/oas/3.1/meta/base',  # vocabulary definition
0.000000,0,0.000000,'oas/schema-base.json' => 'https://spec.openapis.org/oas/3.1/schema-base',  # the main openapi document schema + draft2020-12 jsonSchemaDialect
0.000000,0,0.000000,'oas/schema.json' => 'https://spec.openapis.org/oas/3.1/schema', # the main openapi document schema + permissive jsonSchemaDialect
0.000000,0,0.000000,'strict-schema.json' => 'https://raw.githubusercontent.com/karenetheridge/OpenAPI-Modern/master/share/strict-schema.json',
0.000000,0,0.000000,'strict-dialect.json' => 'https://raw.githubusercontent.com/karenetheridge/OpenAPI-Modern/master/share/strict-dialect.json',
0.000020,1,0.000020,};
0.000000,0,0.000000,
0.001088,2,0.000544,use constant DEFAULT_METASCHEMA => 'https://spec.openapis.org/oas/3.1/schema-base/latest';
0.000000,0,0.000000,
0.000002,1,0.000002,has '+evaluator' => (
0.000000,0,0.000000,required => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000002,1,0.000002,has '+metaschema_uri' => (
0.000000,0,0.000000,default => DEFAULT_METASCHEMA,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,has json_schema_dialect => (
0.000000,0,0.000000,is => 'rwp',
0.000000,0,0.000000,isa => InstanceOf['Mojo::URL'],
0.000006,1,0.000006,coerce => sub { $_[0]->$_isa('Mojo::URL') ? $_[0] : Mojo::URL->new($_[0]) },
0.000008,1,0.000008,);
0.000000,0,0.000000,
0.000000,0,0.000000,# operationId => document path
0.000000,0,0.000000,has operationIds => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => HashRef[Str],
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,_add_operationId => 'set',
0.000000,0,0.000000,get_operationId_path => 'get',
0.000000,0,0.000000,},
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,default => sub { {} },
0.000009,1,0.000009,);
0.000000,0,0.000000,
0.000001,3,0.000000,sub traverse ($self, $evaluator) {
0.000006,1,0.000006,$self->_add_vocab_and_default_schemas;
0.000000,0,0.000000,
0.000004,1,0.000004,my $schema = $self->schema;
0.000014,1,0.000014,my $state = {
0.000000,0,0.000000,initial_schema_uri => $self->canonical_uri,
0.000000,0,0.000000,traversed_schema_path => '',
0.000000,0,0.000000,schema_path => '',
0.000000,0,0.000000,data_path => '',
0.000000,0,0.000000,errors => [],
0.000000,0,0.000000,evaluator => $evaluator,
0.000000,0,0.000000,identifiers => [],
0.000000,0,0.000000,configs => {},
0.000000,0,0.000000,spec_version => $evaluator->SPECIFICATION_VERSION_DEFAULT,
0.000000,0,0.000000,vocabularies => [],
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000003,1,0.000003,if ((my $type = get_type($schema)) ne 'object') {
0.000000,0,0.000000,()= E($state, 'invalid document type: %s', $type);
0.000000,0,0.000000,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# /openapi: https://spec.openapis.org/oas/v3.1.0#openapi-object
0.000009,1,0.000009,return $state if not assert_keyword_exists({ %$state, keyword => 'openapi' }, $schema)
0.000000,0,0.000000,or not assert_keyword_type({ %$state, keyword => 'openapi' }, $schema, 'string');
0.000000,0,0.000000,
0.000006,1,0.000006,if ($schema->{openapi} !~ /^3\.1\.[0-9]+(-.+)?$/) {
0.000000,0,0.000000,()= E({ %$state, keyword => 'openapi' }, 'unrecognized openapi version %s', $schema->{openapi});
0.000000,0,0.000000,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# /jsonSchemaDialect: https://spec.openapis.org/oas/v3.1.0#specifying-schema-dialects
0.000000,0,0.000000,{
0.000001,1,0.000001,return $state if exists $schema->{jsonSchemaDialect}
0.000000,1,0.000000,and not assert_keyword_type({ %$state, keyword => 'jsonSchemaDialect' }, $schema, 'string');
0.000000,0,0.000000,
0.000003,1,0.000003,my $json_schema_dialect = $self->json_schema_dialect // $schema->{jsonSchemaDialect};
0.000000,0,0.000000,
0.000000,0,0.000000,# "If [jsonSchemaDialect] is not set, then the OAS dialect schema id MUST be used for these Schema Objects."
0.000001,1,0.000001,$json_schema_dialect //= DEFAULT_DIALECT;
0.000000,0,0.000000,
0.000000,0,0.000000,# traverse an empty schema with this metaschema uri to confirm it is valid
0.000008,1,0.000008,my $check_metaschema_state = $evaluator->traverse({}, {
0.000000,0,0.000000,metaschema_uri => $json_schema_dialect,
0.000000,0,0.000000,initial_schema_uri => $self->canonical_uri->clone->fragment('/jsonSchemaDialect'),
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,# we cannot continue if the metaschema is invalid
0.000000,1,0.000000,if ($check_metaschema_state->{errors}->@*) {
0.000000,0,0.000000,push $state->{errors}->@*, $check_metaschema_state->{errors}->@*;
0.000000,0,0.000000,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,$state->@{qw(spec_version vocabularies)} = $check_metaschema_state->@{qw(spec_version vocabularies)};
0.000006,1,0.000006,$self->_set_json_schema_dialect($json_schema_dialect);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# evaluate the document against its metaschema to find any errors, to identify all schema
0.000000,0,0.000000,# resources within to add to the global resource index, and to extract all operationIds
0.000000,1,0.000000,my (@json_schema_paths, @operation_paths);
0.000416,2556,0.000000,my $result = $self->evaluator->evaluate(
0.000000,0,0.000000,$self->schema,
0.000000,0,0.000000,$self->metaschema_uri,
0.000000,0,0.000000,{
0.000000,0,0.000000,callbacks => {
0.000897,5112,0.000000,'$dynamicRef' => sub ($, $schema, $state) {
0.008912,2556,0.000003,push @json_schema_paths, $state->{data_path} if $schema->{'$dynamicRef'} eq '#meta';
0.000000,0,0.000000,},
0.035982,154860,0.000000,'$ref' => sub ($data, $schema, $state) {
0.000000,0,0.000000,push @operation_paths, [ $data->{operationId} => $state->{data_path} ]
0.083384,38715,0.000002,if $schema->{'$ref'} eq '#/$defs/operation' and defined $data->{operationId};
0.000000,0,0.000000,},
0.000000,0,0.000000,},
0.000000,0,0.000000,},
0.000046,1,0.000046,);
0.000000,0,0.000000,
0.000011,1,0.000011,if (not $result) {
0.000000,0,0.000000,$_->mode('evaluate') foreach $result->errors;
0.000000,0,0.000000,push $state->{errors}->@*, $result->errors;
0.000000,0,0.000000,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my @real_json_schema_paths;
0.001030,1,0.001030,foreach my $path (sort @json_schema_paths) {
0.000000,0,0.000000,# disregard paths that are not the root of each embedded subschema.
4.741766,467388,0.000010,next if any { $path =~ m{^\Q$_\E(?:/|\z)} } @real_json_schema_paths;
0.000000,0,0.000000,
0.001456,963,0.000002,unshift @real_json_schema_paths, $path;
0.012351,963,0.000013,$self->_traverse_schema($self->get($path), { %$state, schema_path => $path });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,foreach my $pair (@operation_paths) {
0.000000,0,0.000000,my ($operation_id, $path) = @$pair;
0.000000,0,0.000000,if (my $existing = $self->get_operationId_path($operation_id)) {
0.000000,0,0.000000,()= E({ %$state, keyword => 'operationId', schema_path => $path },
0.000000,0,0.000000,'duplicate of operationId at %s', $existing);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->_add_operationId($operation_id => $path);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.003680,1,0.003680,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,######## NO PUBLIC INTERFACES FOLLOW THIS POINT ########
0.000000,0,0.000000,
0.000000,2,0.000000,sub _add_vocab_and_default_schemas ($self) {
0.000001,1,0.000001,my $js = $self->evaluator;
0.000006,1,0.000006,$js->add_vocabulary('JSON::Schema::Modern::Vocabulary::OpenAPI');
0.000000,0,0.000000,
0.000000,0,0.000000,$js->add_format_validation(
0.000000,0,0.000000,int32 => +{ type => 'integer', sub => sub ($x) {
0.000000,0,0.000000,require Math::BigInt;
0.000000,0,0.000000,$x = Math::BigInt->new($x);
0.000000,0,0.000000,my $bound = Math::BigInt->new(2) ** 31;
0.000000,0,0.000000,$x >= -$bound && $x < $bound;
0.000000,0,0.000000,} },
0.000000,0,0.000000,int64 => +{ type => 'integer', sub => sub ($x) {
0.000000,0,0.000000,require Math::BigInt;
0.000000,0,0.000000,$x = Math::BigInt->new($x);
0.000000,0,0.000000,my $bound = Math::BigInt->new(2) ** 63;
0.000000,0,0.000000,$x >= -$bound && $x < $bound;
0.000000,0,0.000000,} },
0.000000,0,0.000000,float => +{ type => 'number', sub => sub ($) { 1 } },
0.000000,0,0.000000,double => +{ type => 'number', sub => sub ($) { 1 } },
0.000000,0,0.000000,password => +{ type => 'string', sub => sub ($) { 1 } },
0.000016,1,0.000016,);
0.000000,0,0.000000,
0.000014,1,0.000014,foreach my $pairs (pairs DEFAULT_SCHEMAS->%*) {
0.000006,6,0.000001,my ($filename, $uri) = @$pairs;
0.000591,6,0.000099,my $document = $js->add_schema($uri,
0.000000,0,0.000000,$js->_json_decoder->decode(path(dist_dir('OpenAPI-Modern'), $filename)->slurp_raw));
0.000046,6,0.000008,$js->add_schema($uri.'/latest', $document) if $uri =~ /schema(-base)?$/;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# https://spec.openapis.org/oas/v3.1.0#schema-object
0.001101,3852,0.000000,sub _traverse_schema ($self, $schema, $state) {
0.001568,963,0.000002,return if not is_plain_hashref($schema) or not keys %$schema;
0.000000,0,0.000000,
0.000000,0,0.000000,my $subschema_state = $self->evaluator->traverse($schema, {
0.000000,0,0.000000,%$state,  # so we don't have to enumerate everything that may be in config_override
0.000000,0,0.000000,initial_schema_uri => canonical_uri($state),
0.000000,0,0.000000,traversed_schema_path => $state->{traversed_schema_path}.$state->{schema_path},
0.012350,725,0.000017,metaschema_uri => $self->json_schema_dialect,
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000928,725,0.000001,push $state->{errors}->@*, $subschema_state->{errors}->@*;
0.000270,725,0.000000,return if $subschema_state->{errors}->@*;
0.000000,0,0.000000,
0.005729,725,0.000008,push $state->{identifiers}->@*, $subschema_state->{identifiers}->@*;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000017,1,0.000017,1;
0.000000,0,0.000000,
0.000032,1,0.000032,__END__
