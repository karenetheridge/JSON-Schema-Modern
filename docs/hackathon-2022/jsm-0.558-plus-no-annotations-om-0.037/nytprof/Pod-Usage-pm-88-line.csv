# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,#############################################################################
0.000000,0,0.000000,# Pod/Usage.pm -- print usage messages for the running script.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Copyright (c) 1996-2000 by Bradford Appleton. All rights reserved.
0.000000,0,0.000000,# Copyright (c) 2001-2016 by Marek Rouchal.
0.000000,0,0.000000,# This file is part of "Pod-Usage". Pod-Usage is free software;
0.000000,0,0.000000,# you can redistribute it and/or modify it under the same terms
0.000000,0,0.000000,# as Perl itself.
0.000000,0,0.000000,#############################################################################
0.000000,0,0.000000,
0.000000,0,0.000000,package Pod::Usage;
0.000000,0,0.000000,
0.000030,2,0.000015,use strict;
0.000007,1,0.000007,require  5.006;    ## requires this Perl version or later
0.000000,0,0.000000,
0.000016,2,0.000008,use Carp;
0.000015,2,0.000007,use Config;
0.000078,2,0.000039,use Exporter;
0.000404,2,0.000202,use File::Spec;
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '2.01';
0.000000,0,0.000000,
0.000001,1,0.000001,our @EXPORT = qw(&pod2usage);
0.000000,0,0.000000,our @ISA;
0.000000,0,0.000000,BEGIN {
0.000001,1,0.000001,$Pod::Usage::Formatter ||= 'Pod::Text';
0.000535,1,0.000535,eval "require $Pod::Usage::Formatter";
0.000001,1,0.000001,die $@ if $@;
0.000009,1,0.000009,@ISA = ( $Pod::Usage::Formatter );
0.001869,1,0.001869,}
0.000000,0,0.000000,
0.000000,1,0.000000,our $MAX_HEADING_LEVEL = 3;
0.000000,0,0.000000,
0.000000,0,0.000000,##---------------------------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,##---------------------------------
0.000000,0,0.000000,## Function definitions begin here
0.000000,0,0.000000,##---------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,sub pod2usage {
0.000000,0,0.000000,local($_) = shift;
0.000000,0,0.000000,my %opts;
0.000000,0,0.000000,## Collect arguments
0.000000,0,0.000000,if (@_ > 0) {
0.000000,0,0.000000,## Too many arguments - assume that this is a hash and
0.000000,0,0.000000,## the user forgot to pass a reference to it.
0.000000,0,0.000000,%opts = ($_, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (!defined $_) {
0.000000,0,0.000000,$_ = '';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (ref $_) {
0.000000,0,0.000000,## User passed a ref to a hash
0.000000,0,0.000000,%opts = %{$_}  if (ref($_) eq 'HASH');
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (/^[-+]?\d+$/) {
0.000000,0,0.000000,## User passed in the exit value to use
0.000000,0,0.000000,$opts{'-exitval'} =  $_;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,## User passed in a message to print before issuing usage.
0.000000,0,0.000000,$_  and  $opts{'-message'} = $_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## Need this for backward compatibility since we formerly used
0.000000,0,0.000000,## options that were all uppercase words rather than ones that
0.000000,0,0.000000,## looked like Unix command-line options.
0.000000,0,0.000000,## to be uppercase keywords)
0.000000,0,0.000000,%opts = map {
0.000000,0,0.000000,my ($key, $val) = ($_, $opts{$_});
0.000000,0,0.000000,$key =~ s/^(?=\w)/-/;
0.000000,0,0.000000,$key =~ /^-msg/i   and  $key = '-message';
0.000000,0,0.000000,$key =~ /^-exit/i  and  $key = '-exitval';
0.000000,0,0.000000,lc($key) => $val;
0.000000,0,0.000000,} (keys %opts);
0.000000,0,0.000000,
0.000000,0,0.000000,## Now determine default -exitval and -verbose values to use
0.000000,0,0.000000,if ((! defined $opts{'-exitval'}) && (! defined $opts{'-verbose'})) {
0.000000,0,0.000000,$opts{'-exitval'} = 2;
0.000000,0,0.000000,$opts{'-verbose'} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (! defined $opts{'-exitval'}) {
0.000000,0,0.000000,$opts{'-exitval'} = ($opts{'-verbose'} > 0) ? 1 : 2;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (! defined $opts{'-verbose'}) {
0.000000,0,0.000000,$opts{'-verbose'} = (lc($opts{'-exitval'}) eq 'noexit' ||
0.000000,0,0.000000,$opts{'-exitval'} < 2);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## Default the output file
0.000000,0,0.000000,$opts{'-output'} = (lc($opts{'-exitval'}) eq 'noexit' ||
0.000000,0,0.000000,$opts{'-exitval'} < 2) ? \*STDOUT : \*STDERR
0.000000,0,0.000000,unless (defined $opts{'-output'});
0.000000,0,0.000000,## Default the input file
0.000000,0,0.000000,$opts{'-input'} = $0  unless (defined $opts{'-input'});
0.000000,0,0.000000,
0.000000,0,0.000000,## Look up input file in path if it doesn't exist.
0.000000,0,0.000000,unless ((ref $opts{'-input'}) || (-e $opts{'-input'})) {
0.000000,0,0.000000,my $basename = $opts{'-input'};
0.000000,0,0.000000,my $pathsep = ($^O =~ /^(?:dos|os2|MSWin32)$/i) ? ';'
0.000000,0,0.000000,: (($^O eq 'MacOS' || $^O eq 'VMS') ? ',' :  ':');
0.000000,0,0.000000,my $pathspec = $opts{'-pathlist'} || $ENV{PATH} || $ENV{PERL5LIB};
0.000000,0,0.000000,
0.000000,0,0.000000,my @paths = (ref $pathspec) ? @$pathspec : split($pathsep, $pathspec);
0.000000,0,0.000000,for my $dirname (@paths) {
0.000000,0,0.000000,$_ = length($dirname) ? File::Spec->catfile($dirname, $basename) : $basename;
0.000000,0,0.000000,last if (-e $_) && ($opts{'-input'} = $_);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## Now create a pod reader and constrain it to the desired sections.
0.000000,0,0.000000,my $parser = Pod::Usage->new(USAGE_OPTIONS => \%opts);
0.000000,0,0.000000,if ($opts{'-verbose'} == 0) {
0.000000,0,0.000000,$parser->select('(?:SYNOPSIS|USAGE)\s*');
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($opts{'-verbose'} == 1) {
0.000000,0,0.000000,my $opt_re = '(?i)' .
0.000000,0,0.000000,'(?:OPTIONS|ARGUMENTS)' .
0.000000,0,0.000000,'(?:\s*(?:AND|\/)\s*(?:OPTIONS|ARGUMENTS))?';
0.000000,0,0.000000,$parser->select( '(?:SYNOPSIS|USAGE)\s*', $opt_re, "DESCRIPTION/$opt_re" );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($opts{'-verbose'} >= 2 && $opts{'-verbose'} != 99) {
0.000000,0,0.000000,$parser->select('.*');
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($opts{'-verbose'} == 99) {
0.000000,0,0.000000,my $sections = $opts{'-sections'};
0.000000,0,0.000000,$parser->select( (ref $sections) ? @$sections : $sections );
0.000000,0,0.000000,$opts{'-verbose'} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## Check for perldoc
0.000000,0,0.000000,my $progpath = $opts{'-perldoc'} ? $opts{'-perldoc'} :
0.000000,0,0.000000,File::Spec->catfile($Config{scriptdirexp} || $Config{scriptdir},
0.000000,0,0.000000,'perldoc');
0.000000,0,0.000000,
0.000000,0,0.000000,my $version = sprintf("%vd",$^V);
0.000000,0,0.000000,if ($Config{versiononly} and $Config{startperl} =~ /\Q$version\E$/ ) {
0.000000,0,0.000000,$progpath .= $version;
0.000000,0,0.000000,}
0.000000,0,0.000000,$opts{'-noperldoc'} = 1 unless -e $progpath;
0.000000,0,0.000000,
0.000000,0,0.000000,## Now translate the pod document and then exit with the desired status
0.000000,0,0.000000,if (      !$opts{'-noperldoc'}
0.000000,0,0.000000,and  $opts{'-verbose'} >= 2
0.000000,0,0.000000,and  !ref($opts{'-input'})
0.000000,0,0.000000,and  $opts{'-output'} == \*STDOUT )
0.000000,0,0.000000,{
0.000000,0,0.000000,## spit out the entire PODs. Might as well invoke perldoc
0.000000,0,0.000000,print { $opts{'-output'} } ($opts{'-message'}, "\n") if($opts{'-message'});
0.000000,0,0.000000,if(defined $opts{-input} && $opts{-input} =~ /^\s*(\S.*?)\s*$/) {
0.000000,0,0.000000,# the perldocs back to 5.005 should all have -F
0.000000,0,0.000000,# without -F there are warnings in -T scripts
0.000000,0,0.000000,my $f = $1;
0.000000,0,0.000000,my @perldoc_cmd = ($progpath);
0.000000,0,0.000000,if ($opts{'-perldocopt'}) {
0.000000,0,0.000000,$opts{'-perldocopt'} =~ s/^\s+|\s+$//g;
0.000000,0,0.000000,push @perldoc_cmd, split(/\s+/, $opts{'-perldocopt'});
0.000000,0,0.000000,}
0.000000,0,0.000000,push @perldoc_cmd, ('-F', $f);
0.000000,0,0.000000,unshift @perldoc_cmd, $opts{'-perlcmd'} if $opts{'-perlcmd'};
0.000000,0,0.000000,system(@perldoc_cmd);
0.000000,0,0.000000,# RT16091: fall back to more if perldoc failed
0.000000,0,0.000000,if($?) {
0.000000,0,0.000000,# RT131844: prefer PAGER env
0.000000,0,0.000000,my $pager = $ENV{PAGER} || $Config{pager};
0.000000,0,0.000000,if(defined($pager) && length($pager)) {
0.000000,0,0.000000,my $cmd = $pager . ' ' . ($^O =~ /win/i ? qq("$f") : quotemeta($f));
0.000000,0,0.000000,system($cmd);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# the most humble fallback; should work (at least) on *nix and Win
0.000000,0,0.000000,system('more', $f);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak "Unspecified input file or insecure argument.\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$parser->parse_from_file($opts{'-input'}, $opts{'-output'});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,exit($opts{'-exitval'})  unless (lc($opts{'-exitval'}) eq 'noexit');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##---------------------------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,##-------------------------------
0.000000,0,0.000000,## Method definitions begin here
0.000000,0,0.000000,##-------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my $this = shift;
0.000000,0,0.000000,my $class = ref($this) || $this;
0.000000,0,0.000000,my %params = @_;
0.000000,0,0.000000,my $self = {%params};
0.000000,0,0.000000,bless $self, $class;
0.000000,0,0.000000,if ($self->can('initialize')) {
0.000000,0,0.000000,$self->initialize();
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# pass through options to Pod::Text
0.000000,0,0.000000,my %opts;
0.000000,0,0.000000,for (qw(alt code indent loose margin quotes sentence stderr utf8 width)) {
0.000000,0,0.000000,my $val = $params{USAGE_OPTIONS}{"-$_"};
0.000000,0,0.000000,$opts{$_} = $val if defined $val;
0.000000,0,0.000000,}
0.000000,0,0.000000,$self = $self->SUPER::new(%opts);
0.000000,0,0.000000,%$self = (%$self, %params);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This subroutine was copied in whole-cloth from Pod::Select 1.60 in order to
0.000000,0,0.000000,# allow the ejection of Pod::Select from the core without breaking Pod::Usage.
0.000000,0,0.000000,# -- rjbs, 2013-03-18
0.000000,0,0.000000,sub _compile_section_spec {
0.000000,0,0.000000,my ($section_spec) = @_;
0.000000,0,0.000000,my (@regexs, $negated);
0.000000,0,0.000000,
0.000000,0,0.000000,## Compile the spec into a list of regexs
0.000000,0,0.000000,local $_ = $section_spec;
0.000000,0,0.000000,s{\\\\}{\001}g;  ## handle escaped backward slashes
0.000000,0,0.000000,s{\\/}{\002}g;   ## handle escaped forward slashes
0.000000,0,0.000000,
0.000000,0,0.000000,## Parse the regexs for the heading titles
0.000000,0,0.000000,@regexs = split(/\//, $_, $MAX_HEADING_LEVEL);
0.000000,0,0.000000,
0.000000,0,0.000000,## Set default regex for ommitted levels
0.000000,0,0.000000,for (my $i = 0; $i < $MAX_HEADING_LEVEL; ++$i) {
0.000000,0,0.000000,$regexs[$i]  = '.*'  unless ((defined $regexs[$i])
0.000000,0,0.000000,&& (length $regexs[$i]));
0.000000,0,0.000000,}
0.000000,0,0.000000,## Modify the regexs as needed and validate their syntax
0.000000,0,0.000000,my $bad_regexs = 0;
0.000000,0,0.000000,for (@regexs) {
0.000000,0,0.000000,$_ .= '.+'  if ($_ eq '!');
0.000000,0,0.000000,s{\001}{\\\\}g;       ## restore escaped backward slashes
0.000000,0,0.000000,s{\002}{\\/}g;        ## restore escaped forward slashes
0.000000,0,0.000000,$negated = s/^\!//;   ## check for negation
0.000000,0,0.000000,eval "m{$_}";         ## check regex syntax
0.000000,0,0.000000,if ($@) {
0.000000,0,0.000000,++$bad_regexs;
0.000000,0,0.000000,carp qq{Bad regular expression /$_/ in "$section_spec": $@\n};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,## Add the forward and rear anchors (and put the negator back)
0.000000,0,0.000000,$_ = '^' . $_  unless (/^\^/);
0.000000,0,0.000000,$_ = $_ . '$'  unless (/\$$/);
0.000000,0,0.000000,$_ = '!' . $_  if ($negated);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return  (! $bad_regexs) ? [ @regexs ] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub select {
0.000000,0,0.000000,my ($self, @sections) = @_;
0.000000,0,0.000000,if ($ISA[0]->can('select')) {
0.000000,0,0.000000,$self->SUPER::select(@sections);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# we're using Pod::Simple - need to mimic the behavior of Pod::Select
0.000000,0,0.000000,my $add = ($sections[0] eq '+') ? shift(@sections) : '';
0.000000,0,0.000000,## Reset the set of sections to use
0.000000,0,0.000000,unless (@sections) {
0.000000,0,0.000000,delete $self->{USAGE_SELECT} unless ($add);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->{USAGE_SELECT} = []
0.000000,0,0.000000,unless ($add && $self->{USAGE_SELECT});
0.000000,0,0.000000,my $sref = $self->{USAGE_SELECT};
0.000000,0,0.000000,## Compile each spec
0.000000,0,0.000000,for my $spec (@sections) {
0.000000,0,0.000000,my $cs = _compile_section_spec($spec);
0.000000,0,0.000000,if ( defined $cs ) {
0.000000,0,0.000000,## Store them in our sections array
0.000000,0,0.000000,push(@$sref, $cs);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,carp qq{Ignoring section spec "$spec"!\n};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Override Pod::Text->seq_i to return just "arg", not "*arg*".
0.000000,0,0.000000,sub seq_i { return $_[1] }
0.000000,0,0.000000,# Override Pod::Text->cmd_i to return just "arg", not "*arg*".
0.000000,0,0.000000,# newer version based on Pod::Simple
0.000000,0,0.000000,sub cmd_i {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,# RT121489: highlighting should be there with Termcap
0.000000,0,0.000000,return $self->SUPER::cmd_i(@_) if $self->isa('Pod::Text::Termcap');
0.000000,0,0.000000,return $_[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This overrides the Pod::Text method to do something very akin to what
0.000000,0,0.000000,# Pod::Select did as well as the work done below by preprocess_paragraph.
0.000000,0,0.000000,# Note that the below is very, very specific to Pod::Text and Pod::Simple.
0.000000,0,0.000000,sub _handle_element_end {
0.000000,0,0.000000,my ($self, $element) = @_;
0.000000,0,0.000000,if ($element eq 'head1') {
0.000000,0,0.000000,$self->{USAGE_HEADINGS} = [ $$self{PENDING}[-1][1] ];
0.000000,0,0.000000,if ($self->{USAGE_OPTIONS}->{-verbose} < 2) {
0.000000,0,0.000000,$$self{PENDING}[-1][1] =~ s/^\s*SYNOPSIS\s*$/USAGE/;
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif ($element =~ /^head(\d+)$/ && $1) { # avoid 0
0.000000,0,0.000000,my $idx = $1 - 1;
0.000000,0,0.000000,$self->{USAGE_HEADINGS} = [] unless($self->{USAGE_HEADINGS});
0.000000,0,0.000000,$self->{USAGE_HEADINGS}->[$idx] = $$self{PENDING}[-1][1];
0.000000,0,0.000000,# we have to get rid of the lower headings
0.000000,0,0.000000,splice(@{$self->{USAGE_HEADINGS}},$idx+1);
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($element =~ /^head\d+$/) {
0.000000,0,0.000000,$$self{USAGE_SKIPPING} = 1;
0.000000,0,0.000000,if (!$$self{USAGE_SELECT} || !@{ $$self{USAGE_SELECT} }) {
0.000000,0,0.000000,$$self{USAGE_SKIPPING} = 0;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,my @headings = @{$$self{USAGE_HEADINGS}};
0.000000,0,0.000000,for my $section_spec ( @{$$self{USAGE_SELECT}} ) {
0.000000,0,0.000000,my $match = 1;
0.000000,0,0.000000,for (my $i = 0; $i < $MAX_HEADING_LEVEL; ++$i) {
0.000000,0,0.000000,$headings[$i] = '' unless defined $headings[$i];
0.000000,0,0.000000,my $regex   = $section_spec->[$i];
0.000000,0,0.000000,my $negated = ($regex =~ s/^\!//);
0.000000,0,0.000000,$match  &= ($negated ? ($headings[$i] !~ /${regex}/)
0.000000,0,0.000000,: ($headings[$i] =~ /${regex}/));
0.000000,0,0.000000,last unless ($match);
0.000000,0,0.000000,} # end heading levels
0.000000,0,0.000000,if ($match) {
0.000000,0,0.000000,$$self{USAGE_SKIPPING} = 0;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,} # end sections
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Try to do some lowercasing instead of all-caps in headings, and use
0.000000,0,0.000000,# a colon to end all headings.
0.000000,0,0.000000,if($self->{USAGE_OPTIONS}->{-verbose} < 2) {
0.000000,0,0.000000,local $_ = $$self{PENDING}[-1][1];
0.000000,0,0.000000,s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;
0.000000,0,0.000000,s/\s*$/:/  unless (/:\s*$/);
0.000000,0,0.000000,$_ .= "\n";
0.000000,0,0.000000,$$self{PENDING}[-1][1] = $_;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($$self{USAGE_SKIPPING} && $element !~ m/^over-|^[BCFILSZ]$/) {
0.000000,0,0.000000,pop @{ $$self{PENDING} };
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$self->SUPER::_handle_element_end($element);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# required for Pod::Simple API
0.000000,0,0.000000,sub start_document {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->SUPER::start_document();
0.000000,0,0.000000,my $msg = $self->{USAGE_OPTIONS}->{-message}  or  return 1;
0.000000,0,0.000000,my $out_fh = $self->output_fh();
0.000000,0,0.000000,print $out_fh "$msg\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# required for old Pod::Parser API
0.000000,0,0.000000,sub begin_pod {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->SUPER::begin_pod();  ## Have to call superclass
0.000000,0,0.000000,my $msg = $self->{USAGE_OPTIONS}->{-message}  or  return 1;
0.000000,0,0.000000,my $out_fh = $self->output_handle();
0.000000,0,0.000000,print $out_fh "$msg\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub preprocess_paragraph {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,local $_ = shift;
0.000000,0,0.000000,my $line = shift;
0.000000,0,0.000000,## See if this is a heading and we aren't printing the entire manpage.
0.000000,0,0.000000,if (($self->{USAGE_OPTIONS}->{-verbose} < 2) && /^=head/) {
0.000000,0,0.000000,## Change the title of the SYNOPSIS section to USAGE
0.000000,0,0.000000,s/^=head1\s+SYNOPSIS\s*$/=head1 USAGE/;
0.000000,0,0.000000,## Try to do some lowercasing instead of all-caps in headings
0.000000,0,0.000000,s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;
0.000000,0,0.000000,## Use a colon to end all headings
0.000000,0,0.000000,s/\s*$/:/  unless (/:\s*$/);
0.000000,0,0.000000,$_ .= "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,return  $self->SUPER::preprocess_paragraph($_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1; # keep require happy
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
