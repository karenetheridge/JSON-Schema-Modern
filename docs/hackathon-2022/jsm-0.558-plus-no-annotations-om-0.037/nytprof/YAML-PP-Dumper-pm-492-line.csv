# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000026,2,0.000013,use strict;
0.000032,2,0.000016,use warnings;
0.000000,0,0.000000,package YAML::PP::Dumper;
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000015,2,0.000007,use Scalar::Util qw/ blessed refaddr reftype /;
0.000018,2,0.000009,use YAML::PP;
0.000397,2,0.000199,use YAML::PP::Emitter;
0.000481,2,0.000241,use YAML::PP::Representer;
0.000328,2,0.000164,use YAML::PP::Writer;
0.000580,2,0.000290,use YAML::PP::Writer::File;
0.000000,1,0.000000,use YAML::PP::Common qw/
0.000000,0,0.000000,YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,YAML_DOUBLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,YAML_ANY_SCALAR_STYLE
0.000000,0,0.000000,YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE
0.000000,0,0.000000,YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE
0.000000,0,0.000000,YAML_BLOCK_MAPPING_STYLE YAML_BLOCK_SEQUENCE_STYLE
0.001050,1,0.001050,/;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000002,1,0.000002,my ($class, %args) = @_;
0.000000,0,0.000000,
0.000001,1,0.000001,my $header = delete $args{header};
0.000000,1,0.000000,$header = 1 unless defined $header;
0.000000,1,0.000000,my $footer = delete $args{footer};
0.000001,1,0.000001,$footer = 0 unless defined $footer;
0.000000,1,0.000000,my $version_directive = delete $args{version_directive};
0.000000,1,0.000000,my $preserve = delete $args{preserve};
0.000000,0,0.000000,
0.000000,1,0.000000,my $schema = delete $args{schema} || YAML::PP->default_schema(
0.000000,0,0.000000,boolean => 'perl',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,1,0.000000,my $emitter = delete $args{emitter} || YAML::PP::Emitter->new;
0.000008,1,0.000008,unless (blessed($emitter)) {
0.000000,0,0.000000,$emitter = YAML::PP::Emitter->new(
0.000000,0,0.000000,%$emitter
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,if (keys %args) {
0.000000,0,0.000000,die "Unexpected arguments: " . join ', ', sort keys %args;
0.000000,0,0.000000,}
0.000005,1,0.000005,my $self = bless {
0.000000,0,0.000000,representer => YAML::PP::Representer->new(
0.000000,0,0.000000,schema => $schema,
0.000000,0,0.000000,preserve => $preserve,
0.000000,0,0.000000,),
0.000000,0,0.000000,version_directive => $version_directive,
0.000000,0,0.000000,emitter => $emitter,
0.000000,0,0.000000,seen => {},
0.000000,0,0.000000,anchors => {},
0.000000,0,0.000000,anchor_num => 0,
0.000000,0,0.000000,header => $header,
0.000000,0,0.000000,footer => $footer,
0.000000,0,0.000000,}, $class;
0.000003,1,0.000003,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my $clone = {
0.000000,0,0.000000,representer => $self->representer->clone,
0.000000,0,0.000000,emitter => $self->emitter->clone,
0.000000,0,0.000000,version_directive => $self->version_directive,
0.000000,0,0.000000,seen => {},
0.000000,0,0.000000,anchors => {},
0.000000,0,0.000000,anchor_num => 0,
0.000000,0,0.000000,header => $self->header,
0.000000,0,0.000000,footer => $self->footer,
0.000000,0,0.000000,};
0.000000,0,0.000000,return bless $clone, ref $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub init {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,$self->{seen} = {};
0.000000,0,0.000000,$self->{anchors} = {};
0.000000,0,0.000000,$self->{anchor_num} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub emitter { return $_[0]->{emitter} }
0.000000,0,0.000000,sub representer { return $_[0]->{representer} }
0.000000,0,0.000000,sub set_representer { $_[0]->{representer} = $_[1] }
0.000000,0,0.000000,sub header { return $_[0]->{header} }
0.000000,0,0.000000,sub footer { return $_[0]->{footer} }
0.000000,0,0.000000,sub version_directive { return $_[0]->{version_directive} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub dump {
0.000000,0,0.000000,my ($self, @docs) = @_;
0.000000,0,0.000000,$self->emitter->init;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->emitter->stream_start_event({});
0.000000,0,0.000000,
0.000000,0,0.000000,for my $i (0 .. $#docs) {
0.000000,0,0.000000,my $header_implicit = ($i == 0 and not $self->header);
0.000000,0,0.000000,my %args = (
0.000000,0,0.000000,implicit => $header_implicit,
0.000000,0,0.000000,);
0.000000,0,0.000000,if ($self->version_directive) {
0.000000,0,0.000000,my ($major, $minor) = split m/\./, $self->representer->schema->yaml_version;
0.000000,0,0.000000,$args{version_directive} = { major => $major, minor => $minor };
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->emitter->document_start_event( \%args );
0.000000,0,0.000000,$self->init;
0.000000,0,0.000000,$self->_check_references($docs[ $i ]);
0.000000,0,0.000000,$self->_dump_node($docs[ $i ]);
0.000000,0,0.000000,my $footer_implicit = (not $self->footer);
0.000000,0,0.000000,$self->emitter->document_end_event({ implicit => $footer_implicit });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->emitter->stream_end_event({});
0.000000,0,0.000000,
0.000000,0,0.000000,my $output = $self->emitter->writer->output;
0.000000,0,0.000000,$self->emitter->finish;
0.000000,0,0.000000,return $output;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _dump_node {
0.000000,0,0.000000,my ($self, $value) = @_;
0.000000,0,0.000000,my $node = {
0.000000,0,0.000000,value => $value,
0.000000,0,0.000000,};
0.000000,0,0.000000,if (ref $value) {
0.000000,0,0.000000,
0.000000,0,0.000000,my $seen = $self->{seen};
0.000000,0,0.000000,my $refaddr = refaddr $value;
0.000000,0,0.000000,if ($seen->{ $refaddr } and $seen->{ $refaddr } > 1) {
0.000000,0,0.000000,my $anchor = $self->{anchors}->{ $refaddr };
0.000000,0,0.000000,unless (defined $anchor) {
0.000000,0,0.000000,if ($self->representer->preserve_alias) {
0.000000,0,0.000000,if (ref $node->{value} eq 'YAML::PP::Preserve::Scalar') {
0.000000,0,0.000000,if (defined $node->{value}->alias) {
0.000000,0,0.000000,$node->{anchor} = $node->{value}->alias;
0.000000,0,0.000000,$self->{anchors}->{ $refaddr } = $node->{value}->alias;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (reftype $node->{value} eq 'HASH') {
0.000000,0,0.000000,if (my $tied = tied %{ $node->{value} } ) {
0.000000,0,0.000000,if (defined $tied->{alias}) {
0.000000,0,0.000000,$node->{anchor} = $tied->{alias};
0.000000,0,0.000000,$self->{anchors}->{ $refaddr } = $node->{anchor};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (reftype $node->{value} eq 'ARRAY') {
0.000000,0,0.000000,if (my $tied = tied @{ $node->{value} } ) {
0.000000,0,0.000000,if (defined $tied->{alias}) {
0.000000,0,0.000000,$node->{anchor} = $tied->{alias};
0.000000,0,0.000000,$self->{anchors}->{ $refaddr } = $node->{anchor};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,unless (defined $node->{anchor}) {
0.000000,0,0.000000,my $num = ++$self->{anchor_num};
0.000000,0,0.000000,$self->{anchors}->{ $refaddr } = $num;
0.000000,0,0.000000,$node->{anchor} = $num;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$node->{value} = $anchor;
0.000000,0,0.000000,$self->_emit_node([ alias => $node ]);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$node = $self->representer->represent_node($node);
0.000000,0,0.000000,$self->_emit_node($node);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _emit_node {
0.000000,0,0.000000,my ($self, $item) = @_;
0.000000,0,0.000000,my ($type, $node, %args) = @$item;
0.000000,0,0.000000,if ($type eq 'alias') {
0.000000,0,0.000000,$self->emitter->alias_event({ value => $node->{value} });
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($type eq 'mapping') {
0.000000,0,0.000000,my $style = $args{style} || YAML_BLOCK_MAPPING_STYLE;
0.000000,0,0.000000,# TODO
0.000000,0,0.000000,if ($node->{items} and @{ $node->{items} } == 0) {
0.000000,0,0.000000,#            $style = YAML_FLOW_MAPPING_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->emitter->mapping_start_event({
0.000000,0,0.000000,anchor => $node->{anchor},
0.000000,0,0.000000,style => $style,
0.000000,0,0.000000,tag => $node->{tag},
0.000000,0,0.000000,});
0.000000,0,0.000000,for (@{ $node->{items} }) {
0.000000,0,0.000000,$self->_dump_node($_);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->emitter->mapping_end_event;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($type eq 'sequence') {
0.000000,0,0.000000,my $style = $args{style} || YAML_BLOCK_SEQUENCE_STYLE;
0.000000,0,0.000000,if (@{ $node->{items} } == 0) {
0.000000,0,0.000000,#            $style = YAML_FLOW_SEQUENCE_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->emitter->sequence_start_event({
0.000000,0,0.000000,anchor => $node->{anchor},
0.000000,0,0.000000,style => $style,
0.000000,0,0.000000,tag => $node->{tag},
0.000000,0,0.000000,});
0.000000,0,0.000000,for (@{ $node->{items} }) {
0.000000,0,0.000000,$self->_dump_node($_);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->emitter->sequence_end_event;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->emitter->scalar_event({
0.000000,0,0.000000,value => $node->{items}->[0],
0.000000,0,0.000000,style => $node->{style},
0.000000,0,0.000000,anchor => $node->{anchor},
0.000000,0,0.000000,tag => $node->{tag},
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub dump_string {
0.000000,0,0.000000,my ($self, @docs) = @_;
0.000000,0,0.000000,my $writer = YAML::PP::Writer->new;
0.000000,0,0.000000,$self->emitter->set_writer($writer);
0.000000,0,0.000000,my $output = $self->dump(@docs);
0.000000,0,0.000000,return $output;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub dump_file {
0.000000,0,0.000000,my ($self, $file, @docs) = @_;
0.000000,0,0.000000,my $writer = YAML::PP::Writer::File->new(output => $file);
0.000000,0,0.000000,$self->emitter->set_writer($writer);
0.000000,0,0.000000,my $output = $self->dump(@docs);
0.000000,0,0.000000,return $output;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,my %_reftypes = (
0.000000,0,0.000000,HASH => 1,
0.000000,0,0.000000,ARRAY => 1,
0.000000,0,0.000000,Regexp => 1,
0.000000,0,0.000000,REGEXP => 1,
0.000000,0,0.000000,CODE => 1,
0.000000,0,0.000000,SCALAR => 1,
0.000000,0,0.000000,REF => 1,
0.000000,0,0.000000,GLOB => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub _check_references {
0.000000,0,0.000000,my ($self, $doc) = @_;
0.000000,0,0.000000,my $reftype = reftype $doc or return;
0.000000,0,0.000000,my $seen = $self->{seen};
0.000000,0,0.000000,# check which references are used more than once
0.000000,0,0.000000,if ($reftype eq 'SCALAR' and
0.000000,0,0.000000,grep { ref $doc eq $_ } @{ $self->representer->schema->bool_class || [] }) {
0.000000,0,0.000000,# JSON::PP and boolean.pm always return the same reference for booleans
0.000000,0,0.000000,# Avoid printing *aliases in those case
0.000000,0,0.000000,if (ref $doc eq 'boolean' or ref $doc eq 'JSON::PP::Boolean') {
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if (++$seen->{ refaddr $doc } > 1) {
0.000000,0,0.000000,# seen already
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,unless ($_reftypes{ $reftype }) {
0.000000,0,0.000000,die sprintf "Reference %s not implemented",
0.000000,0,0.000000,$reftype;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($reftype eq 'HASH') {
0.000000,0,0.000000,$self->_check_references($doc->{ $_ }) for keys %$doc;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($reftype eq 'ARRAY') {
0.000000,0,0.000000,$self->_check_references($_) for @$doc;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($reftype eq 'REF') {
0.000000,0,0.000000,$self->_check_references($$doc);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
