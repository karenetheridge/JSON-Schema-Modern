# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000023,2,0.000012,use strict;
0.000026,2,0.000013,use warnings;
0.000000,0,0.000000,package YAML::PP::Schema;
0.000013,2,0.000007,use B;
0.000614,2,0.000307,use Module::Load qw//;
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000570,2,0.000285,use YAML::PP::Common qw/ YAML_PLAIN_SCALAR_STYLE /;
0.000000,0,0.000000,
0.001833,2,0.000916,use Scalar::Util qw/ blessed /;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000001,1,0.000001,my ($class, %args) = @_;
0.000000,0,0.000000,
0.000001,1,0.000001,my $yaml_version = delete $args{yaml_version};
0.000000,1,0.000000,my $bool = delete $args{boolean};
0.000000,1,0.000000,$bool = 'perl' unless defined $bool;
0.000000,1,0.000000,if (keys %args) {
0.000000,0,0.000000,die "Unexpected arguments: " . join ', ', sort keys %args;
0.000000,0,0.000000,}
0.000000,1,0.000000,my $true;
0.000000,0,0.000000,my $false;
0.000000,0,0.000000,my @bool_class;
0.000002,1,0.000002,my @bools = split m/,/, $bool;
0.000001,1,0.000001,for my $b (@bools) {
0.000001,1,0.000001,if ($b eq '*') {
0.000000,0,0.000000,push @bool_class, ('boolean', 'JSON::PP::Boolean');
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($b eq 'JSON::PP') {
0.000001,1,0.000001,require JSON::PP;
0.000000,1,0.000000,$true ||= \&_bool_jsonpp_true;
0.000001,1,0.000001,$false ||= \&_bool_jsonpp_false;
0.000000,1,0.000000,push @bool_class, 'JSON::PP::Boolean';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($b eq 'boolean') {
0.000000,0,0.000000,require boolean;
0.000000,0,0.000000,$true ||= \&_bool_booleanpm_true;
0.000000,0,0.000000,$false ||= \&_bool_booleanpm_false;
0.000000,0,0.000000,push @bool_class, 'boolean';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($b eq 'perl') {
0.000000,0,0.000000,$true ||= \&_bool_perl_true;
0.000000,0,0.000000,$false ||= \&_bool_perl_false;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($b eq 'perl_experimental') {
0.000000,0,0.000000,$true ||= \&_bool_perl_true;
0.000000,0,0.000000,$false ||= \&_bool_perl_false;
0.000000,0,0.000000,push @bool_class, 'perl_experimental';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die "Invalid value for 'boolean': '$b'. Allowed: ('perl', 'boolean', 'JSON::PP')";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000012,1,0.000012,my %representers = (
0.000000,0,0.000000,'undef' => undef,
0.000000,0,0.000000,flags => [],
0.000000,0,0.000000,equals => {},
0.000000,0,0.000000,regex => [],
0.000000,0,0.000000,class_equals => {},
0.000000,0,0.000000,class_matches => [],
0.000000,0,0.000000,class_isa => [],
0.000000,0,0.000000,scalarref => undef,
0.000000,0,0.000000,refref => undef,
0.000000,0,0.000000,coderef => undef,
0.000000,0,0.000000,glob => undef,
0.000000,0,0.000000,tied_equals => {},
0.000000,0,0.000000,);
0.000004,1,0.000004,my $self = bless {
0.000000,0,0.000000,yaml_version => $yaml_version,
0.000000,0,0.000000,resolvers => {},
0.000000,0,0.000000,representers => \%representers,
0.000000,0,0.000000,true => $true,
0.000000,0,0.000000,false => $false,
0.000000,0,0.000000,bool_class => \@bool_class,
0.000000,0,0.000000,}, $class;
0.000005,1,0.000005,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.033587,28328,0.000001,sub resolvers { return $_[0]->{resolvers} }
0.000019,28,0.000001,sub representers { return $_[0]->{representers} }
0.000000,0,0.000000,
0.000003,3,0.000001,sub true { return $_[0]->{true} }
0.000002,3,0.000001,sub false { return $_[0]->{false} }
0.000004,2,0.000002,sub bool_class { return @{ $_[0]->{bool_class} } ? $_[0]->{bool_class} : undef }
0.000005,1,0.000005,sub yaml_version { return $_[0]->{yaml_version} }
0.000000,0,0.000000,
0.000002,1,0.000002,my %LOADED_SCHEMA = (
0.000000,0,0.000000,JSON => 1,
0.000000,0,0.000000,);
0.000001,1,0.000001,my %DEFAULT_SCHEMA = (
0.000000,0,0.000000,'1.2' => 'Core',
0.000000,0,0.000000,'1.1' => 'YAML1_1',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub load_subschemas {
0.000001,1,0.000001,my ($self, @schemas) = @_;
0.000001,1,0.000001,my $yaml_version = $self->yaml_version;
0.000000,1,0.000000,my $i = 0;
0.000005,1,0.000005,while ($i < @schemas) {
0.000001,1,0.000001,my $item = $schemas[ $i ];
0.000001,1,0.000001,if ($item eq '+') {
0.000000,0,0.000000,$item = $DEFAULT_SCHEMA{ $yaml_version };
0.000000,0,0.000000,}
0.000001,1,0.000001,$i++;
0.000003,1,0.000003,if (blessed($item)) {
0.000000,0,0.000000,$item->register(
0.000000,0,0.000000,schema => $self,
0.000000,0,0.000000,);
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,1,0.000000,my @options;
0.000001,1,0.000001,while ($i < @schemas
0.000000,0,0.000000,and (
0.000000,0,0.000000,$schemas[ $i ] =~ m/^[^A-Za-z]/
0.000000,0,0.000000,or
0.000000,0,0.000000,$schemas[ $i ] =~ m/^[a-zA-Z0-9]+=/
0.000000,0,0.000000,)
0.000000,0,0.000000,) {
0.000000,0,0.000000,push @options, $schemas[ $i ];
0.000000,0,0.000000,$i++;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my $class;
0.000005,1,0.000005,if ($item =~ m/^\:(.*)/) {
0.000000,0,0.000000,$class = "$1";
0.000000,0,0.000000,unless ($class =~ m/\A[A-Za-z0-9_:]+\z/) {
0.000000,0,0.000000,die "Module name '$class' is invalid";
0.000000,0,0.000000,}
0.000000,0,0.000000,Module::Load::load $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000001,1,0.000001,$class = "YAML::PP::Schema::$item";
0.000007,1,0.000007,unless ($class =~ m/\A[A-Za-z0-9_:]+\z/) {
0.000000,0,0.000000,die "Module name '$class' is invalid";
0.000000,0,0.000000,}
0.000003,1,0.000003,$LOADED_SCHEMA{ $item } ||= Module::Load::load $class;
0.000000,0,0.000000,}
0.000004,1,0.000004,$class->register(
0.000000,0,0.000000,schema => $self,
0.000000,0,0.000000,options => \@options,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_resolver {
0.000009,28,0.000000,my ($self, %args) = @_;
0.000003,28,0.000000,my $tag = $args{tag};
0.000004,28,0.000000,my $rule = $args{match};
0.000013,28,0.000000,my $resolvers = $self->resolvers;
0.000006,28,0.000000,my ($type, @rule) = @$rule;
0.000005,28,0.000000,my $implicit = $args{implicit};
0.000004,28,0.000000,$implicit = 1 unless defined $implicit;
0.000006,28,0.000000,my $resolver_list = [];
0.000005,28,0.000000,if ($tag) {
0.000004,28,0.000000,if (ref $tag eq 'Regexp') {
0.000000,0,0.000000,my $res = $resolvers->{tags} ||= [];
0.000000,0,0.000000,push @$res, [ $tag, {} ];
0.000000,0,0.000000,push @$resolver_list, $res->[-1]->[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000005,28,0.000000,my $res = $resolvers->{tag}->{ $tag } ||= {};
0.000004,28,0.000000,push @$resolver_list, $res;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000006,28,0.000000,if ($implicit) {
0.000000,0,0.000000,push @$resolver_list, $resolvers->{value} ||= {};
0.000000,0,0.000000,}
0.000055,28,0.000002,for my $res (@$resolver_list) {
0.000007,56,0.000000,if ($type eq 'equals') {
0.000004,46,0.000000,my ($match, $value) = @rule;
0.000027,46,0.000001,unless (exists $res->{equals}->{ $match }) {
0.000000,0,0.000000,$res->{equals}->{ $match } = $value;
0.000000,0,0.000000,}
0.000006,46,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type eq 'regex') {
0.000002,8,0.000000,my ($match, $value) = @rule;
0.000005,8,0.000001,push @{ $res->{regex} }, [ $match => $value ];
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type eq 'all') {
0.000000,2,0.000000,my ($value) = @rule;
0.000000,2,0.000000,$res->{all} = $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_sequence_resolver {
0.000000,0,0.000000,my ($self, %args) = @_;
0.000000,0,0.000000,return $self->add_collection_resolver(sequence => %args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_mapping_resolver {
0.000000,0,0.000000,my ($self, %args) = @_;
0.000000,0,0.000000,return $self->add_collection_resolver(mapping => %args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_collection_resolver {
0.000000,0,0.000000,my ($self, $type, %args) = @_;
0.000000,0,0.000000,my $tag = $args{tag};
0.000000,0,0.000000,my $implicit = $args{implicit};
0.000000,0,0.000000,my $resolvers = $self->resolvers;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($tag and ref $tag eq 'Regexp') {
0.000000,0,0.000000,my $res = $resolvers->{ $type }->{tags} ||= [];
0.000000,0,0.000000,push @$res, [ $tag, {
0.000000,0,0.000000,on_create => $args{on_create},
0.000000,0,0.000000,on_data => $args{on_data},
0.000000,0,0.000000,} ];
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($tag) {
0.000000,0,0.000000,my $res = $resolvers->{ $type }->{tag}->{ $tag } ||= {
0.000000,0,0.000000,on_create => $args{on_create},
0.000000,0,0.000000,on_data => $args{on_data},
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_representer {
0.000007,28,0.000000,my ($self, %args) = @_;
0.000000,0,0.000000,
0.000020,28,0.000001,my $representers = $self->representers;
0.000002,28,0.000000,if (my $flags = $args{flags}) {
0.000001,2,0.000000,my $rep = $representers->{flags};
0.000000,2,0.000000,push @$rep, \%args;
0.000003,2,0.000002,return;
0.000000,0,0.000000,}
0.000001,26,0.000000,if (my $regex = $args{regex}) {
0.000001,1,0.000001,my $rep = $representers->{regex};
0.000000,1,0.000000,push @$rep, \%args;
0.000002,1,0.000002,return;
0.000000,0,0.000000,}
0.000006,25,0.000000,if (my $regex = $args{class_matches}) {
0.000000,0,0.000000,my $rep = $representers->{class_matches};
0.000000,0,0.000000,push @$rep, [ $args{class_matches}, $args{code} ];
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000003,25,0.000000,if (my $class_equals = $args{class_equals}) {
0.000001,1,0.000001,if ($] >= 5.036000 and $class_equals eq 'perl_experimental') {
0.000000,0,0.000000,$representers->{bool} = {
0.000000,0,0.000000,code => $args{code},
0.000000,0,0.000000,};
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000001,1,0.000001,my $rep = $representers->{class_equals};
0.000000,0,0.000000,$rep->{ $class_equals } = {
0.000000,0,0.000000,code => $args{code},
0.000001,1,0.000001,};
0.000003,1,0.000003,return;
0.000000,0,0.000000,}
0.000001,24,0.000000,if (my $class_isa = $args{class_isa}) {
0.000000,0,0.000000,my $rep = $representers->{class_isa};
0.000000,0,0.000000,push @$rep, [ $args{class_isa}, $args{code} ];
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000003,24,0.000000,if (my $tied_equals = $args{tied_equals}) {
0.000000,0,0.000000,my $rep = $representers->{tied_equals};
0.000000,0,0.000000,$rep->{ $tied_equals } = {
0.000000,0,0.000000,code => $args{code},
0.000000,0,0.000000,};
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000006,24,0.000000,if (defined(my $equals = $args{equals})) {
0.000004,23,0.000000,my $rep = $representers->{equals};
0.000000,0,0.000000,$rep->{ $equals } = {
0.000000,0,0.000000,code => $args{code},
0.000012,23,0.000001,};
0.000023,23,0.000001,return;
0.000000,0,0.000000,}
0.000001,1,0.000001,if (defined(my $scalarref = $args{scalarref})) {
0.000000,0,0.000000,$representers->{scalarref} = {
0.000000,0,0.000000,code => $args{code},
0.000000,0,0.000000,};
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,1,0.000000,if (defined(my $refref = $args{refref})) {
0.000000,0,0.000000,$representers->{refref} = {
0.000000,0,0.000000,code => $args{code},
0.000000,0,0.000000,};
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000001,1,0.000001,if (defined(my $coderef = $args{coderef})) {
0.000000,0,0.000000,$representers->{coderef} = {
0.000000,0,0.000000,code => $args{code},
0.000000,0,0.000000,};
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,1,0.000000,if (defined(my $glob = $args{glob})) {
0.000000,0,0.000000,$representers->{glob} = {
0.000000,0,0.000000,code => $args{code},
0.000000,0,0.000000,};
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000001,1,0.000001,if (my $undef = $args{undefined}) {
0.000000,1,0.000000,$representers->{undef} = $undef;
0.000002,1,0.000002,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub load_scalar {
0.003335,20764,0.000000,my ($self, $constructor, $event) = @_;
0.004402,20764,0.000000,my $tag = $event->{tag};
0.005353,20764,0.000000,my $value = $event->{value};
0.000000,0,0.000000,
0.012340,20764,0.000001,my $resolvers = $self->resolvers;
0.002636,20764,0.000000,my $res;
0.005190,20764,0.000000,if ($tag) {
0.000000,0,0.000000,$res = $resolvers->{tag}->{ $tag };
0.000000,0,0.000000,if (not $res and my $matches = $resolvers->{tags}) {
0.000000,0,0.000000,for my $match (@$matches) {
0.000000,0,0.000000,my ($re, $rule) = @$match;
0.000000,0,0.000000,if ($tag =~ $re) {
0.000000,0,0.000000,$res = $rule;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.003760,20764,0.000000,$res = $resolvers->{value};
0.008407,20764,0.000000,if ($event->{style} ne YAML_PLAIN_SCALAR_STYLE) {
0.000000,0,0.000000,return $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.006802,18718,0.000000,if (my $equals = $res->{equals}) {
0.012938,18718,0.000001,if (exists $equals->{ $value }) {
0.000472,1003,0.000000,my $res = $equals->{ $value };
0.002753,1003,0.000003,if (ref $res eq 'CODE') {
0.000000,0,0.000000,return $res->($constructor, $event);
0.000000,0,0.000000,}
0.000046,34,0.000001,return $res;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.005699,17715,0.000000,if (my $regex = $res->{regex}) {
0.007599,17715,0.000000,for my $item (@$regex) {
0.013986,70425,0.000000,my ($re, $sub) = @$item;
0.257767,70425,0.000004,my @matches = $value =~ $re;
0.024476,70425,0.000000,if (@matches) {
0.000000,0,0.000000,return $sub->($constructor, $event, \@matches);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.004384,17570,0.000000,if (my $catch_all = $res->{all}) {
0.042158,17570,0.000002,if (ref $catch_all eq 'CODE') {
0.000000,0,0.000000,return $catch_all->($constructor, $event);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $catch_all;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_sequence {
0.000161,636,0.000000,my ($self, $constructor, $event) = @_;
0.000309,636,0.000000,my $tag = $event->{tag};
0.000314,636,0.000000,my $data = [];
0.000113,636,0.000000,my $on_data;
0.000000,0,0.000000,
0.000637,636,0.000001,my $resolvers = $self->resolvers->{sequence};
0.000160,636,0.000000,if ($tag) {
0.000000,0,0.000000,if (my $equals = $resolvers->{tag}->{ $tag }) {
0.000000,0,0.000000,my $on_create = $equals->{on_create};
0.000000,0,0.000000,$on_data = $equals->{on_data};
0.000000,0,0.000000,$on_create and $data = $on_create->($constructor, $event);
0.000000,0,0.000000,return ($data, $on_data);
0.000000,0,0.000000,}
0.000000,0,0.000000,if (my $matches = $resolvers->{tags}) {
0.000000,0,0.000000,for my $match (@$matches) {
0.000000,0,0.000000,my ($re, $actions) = @$match;
0.000000,0,0.000000,my $on_create = $actions->{on_create};
0.000000,0,0.000000,if ($tag =~ $re) {
0.000000,0,0.000000,$on_data = $actions->{on_data};
0.000000,0,0.000000,$on_create and $data = $on_create->($constructor, $event);
0.000000,0,0.000000,return ($data, $on_data);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001099,636,0.000002,return ($data, $on_data);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_mapping {
0.001271,6900,0.000000,my ($self, $constructor, $event) = @_;
0.002092,6900,0.000000,my $tag = $event->{tag};
0.001965,6900,0.000000,my $data = {};
0.000883,6900,0.000000,my $on_data;
0.000000,0,0.000000,
0.006395,6900,0.000001,my $resolvers = $self->resolvers->{mapping};
0.001000,6900,0.000000,if ($tag) {
0.000000,0,0.000000,if (my $equals = $resolvers->{tag}->{ $tag }) {
0.000000,0,0.000000,my $on_create = $equals->{on_create};
0.000000,0,0.000000,$on_data = $equals->{on_data};
0.000000,0,0.000000,$on_create and $data = $on_create->($constructor, $event);
0.000000,0,0.000000,return ($data, $on_data);
0.000000,0,0.000000,}
0.000000,0,0.000000,if (my $matches = $resolvers->{tags}) {
0.000000,0,0.000000,for my $match (@$matches) {
0.000000,0,0.000000,my ($re, $actions) = @$match;
0.000000,0,0.000000,my $on_create = $actions->{on_create};
0.000000,0,0.000000,if ($tag =~ $re) {
0.000000,0,0.000000,$on_data = $actions->{on_data};
0.000000,0,0.000000,$on_create and $data = $on_create->($constructor, $event);
0.000000,0,0.000000,return ($data, $on_data);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.009633,6900,0.000001,return ($data, $on_data);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002012,566,0.000004,sub _bool_jsonpp_true { JSON::PP::true() }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _bool_booleanpm_true { boolean::true() }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _bool_perl_true { !!1 }
0.000000,0,0.000000,
0.001569,403,0.000004,sub _bool_jsonpp_false { JSON::PP::false() }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _bool_booleanpm_false { boolean::false() }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _bool_perl_false { !!0 }
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
