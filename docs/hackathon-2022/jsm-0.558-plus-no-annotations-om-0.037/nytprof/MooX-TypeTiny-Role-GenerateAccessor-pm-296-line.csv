# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package MooX::TypeTiny::Role::GenerateAccessor;
0.000035,2,0.000017,use Moo::Role;
0.000017,2,0.000008,use Sub::Quote qw(quotify sanitize_identifier);
0.000476,2,0.000238,use Scalar::Util qw(blessed);
0.000000,0,0.000000,
0.000000,0,0.000000,around _generate_isa_check => sub {
0.000000,0,0.000000,$Error::TypeTiny::CarpInternal{$_} = 1
0.000330,68,0.000005,for grep /\A(?:MooX?|Method::Generate)::/, keys %Carp::CarpInternal;
0.000000,0,0.000000,
0.000011,68,0.000000,my $orig = shift;
0.000009,68,0.000000,my $self = shift;
0.000039,68,0.000001,my ($name, $value, $check, $init_arg) = @_;
0.000251,68,0.000004,return $self->$orig(@_)
0.000000,0,0.000000,unless blessed $check && $check->isa('Type::Tiny');
0.000000,0,0.000000,
0.000060,68,0.000001,my $var = '$isa_check_for_'.sanitize_identifier($name);
0.000056,68,0.000001,$self->{captures}->{$var} = \$check;
0.000000,0,0.000000,
0.000103,68,0.000002,my $varname = defined $init_arg
0.000000,0,0.000000,? sprintf('$args->{%s}', quotify($init_arg))
0.000000,0,0.000000,: sprintf('$self->{%s}', quotify($name));
0.000000,0,0.000000,
0.000097,68,0.000001,my $assertion = $check->inline_assert(
0.000000,0,0.000000,$value,
0.000000,0,0.000000,$var,
0.000000,0,0.000000,mgaca           => 0,
0.000000,0,0.000000,attribute_name  => $name,
0.000000,0,0.000000,attribute_step  => 'isa check',
0.000000,0,0.000000,varname         => $varname,
0.000000,0,0.000000,);
0.000206,68,0.000003,$assertion =~ s/;\z//;
0.000186,68,0.000003,return $assertion;
0.000004,1,0.000004,};
0.000000,0,0.000000,
0.000000,0,0.000000,around _generate_coerce => sub {
0.000000,0,0.000000,$Error::TypeTiny::CarpInternal{$_} = 1
0.001090,20,0.000054,for grep /\A(?:MooX?|Method::Generate)::/, keys %Carp::Internal;
0.000000,0,0.000000,
0.000012,20,0.000001,my $orig = shift;
0.000002,20,0.000000,my $self = shift;
0.000023,20,0.000001,my ($name, $value, $coerce, $init_arg) = @_;
0.000103,20,0.000005,return $self->$orig(@_)
0.000000,0,0.000000,unless blessed $coerce && $coerce->isa('Type::Coercion');
0.000000,0,0.000000,
0.000000,0,0.000000,my $var = '$coercion_for_'.sanitize_identifier($name);
0.000000,0,0.000000,$self->{captures}->{$var} = \$coerce;
0.000000,0,0.000000,
0.000000,0,0.000000,my $need_temp = !$self->_is_simple_value($value);
0.000000,0,0.000000,my $inline_value = $value;
0.000000,0,0.000000,if ($need_temp) {
0.000000,0,0.000000,$inline_value = $value;
0.000000,0,0.000000,$value = '$tmp';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $code = $coerce->can_be_inlined ? $coerce->inline_coercion($value) : "${var}->coerce(${value})";
0.000000,0,0.000000,
0.000000,0,0.000000,if ($need_temp) {
0.000000,0,0.000000,return "do { my \$tmp = $inline_value; $code }";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $code;
0.000000,0,0.000000,}
0.000002,1,0.000002,};
0.000000,0,0.000000,
0.000000,0,0.000000,# this doesn't need to be perfect.  false negatives are fine.
0.000000,0,0.000000,sub _is_simple_value {
0.000000,0,0.000000,my ($self, $value) = @_;
0.000000,0,0.000000,return $value =~ /\A(?:
0.000000,0,0.000000,\$\w+(?:(?:->)?(?:\[[0-9]+\]|\{\w+\}))?
0.000000,0,0.000000,|
0.000000,0,0.000000,[-0-9_.ex]+
0.000000,0,0.000000,|
0.000000,0,0.000000,"[^\$\@"]*"
0.000000,0,0.000000,|
0.000000,0,0.000000,'[^']*'
0.000000,0,0.000000,|
0.000000,0,0.000000,undef\(\)
0.000000,0,0.000000,|
0.000000,0,0.000000,\(!1\)
0.000000,0,0.000000,)\z/x;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,1;
