# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# ABSTRACT: YAML Parser
0.000068,2,0.000034,use strict;
0.000049,2,0.000025,use warnings;
0.000000,0,0.000000,package YAML::PP::Parser;
0.000000,0,0.000000,
0.000003,1,0.000003,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000028,2,0.000014,use constant TRACE => $ENV{YAML_PP_TRACE} ? 1 : 0;
0.000025,2,0.000012,use constant DEBUG => ($ENV{YAML_PP_DEBUG} || $ENV{YAML_PP_TRACE}) ? 1 : 0;
0.000000,0,0.000000,
0.000001,1,0.000001,use YAML::PP::Common qw/
0.000000,0,0.000000,YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,YAML_DOUBLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE
0.000000,0,0.000000,YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE
0.000015,1,0.000015,/;
0.000696,2,0.000348,use YAML::PP::Render;
0.000692,2,0.000346,use YAML::PP::Lexer;
0.000023,2,0.000011,use YAML::PP::Grammar qw/ $GRAMMAR /;
0.000585,2,0.000293,use YAML::PP::Exception;
0.000283,2,0.000141,use YAML::PP::Reader;
0.000400,2,0.000200,use Carp qw/ croak /;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000001,1,0.000001,my ($class, %args) = @_;
0.000004,1,0.000004,my $reader = delete $args{reader} || YAML::PP::Reader->new;
0.000000,1,0.000000,my $default_yaml_version = delete $args{default_yaml_version};
0.000004,1,0.000004,my $self = bless {
0.000000,0,0.000000,default_yaml_version => $default_yaml_version || '1.2',
0.000000,0,0.000000,lexer => YAML::PP::Lexer->new(
0.000000,0,0.000000,reader => $reader,
0.000000,0,0.000000,),
0.000000,0,0.000000,}, $class;
0.000000,1,0.000000,my $receiver = delete $args{receiver};
0.000001,1,0.000001,if ($receiver) {
0.000000,0,0.000000,$self->set_receiver($receiver);
0.000000,0,0.000000,}
0.000008,1,0.000008,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my $clone = {
0.000000,0,0.000000,default_yaml_version => $self->default_yaml_version,
0.000000,0,0.000000,lexer => YAML::PP::Lexer->new(),
0.000000,0,0.000000,};
0.000000,0,0.000000,return bless $clone, ref $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,sub receiver { return $_[0]->{receiver} }
0.000000,0,0.000000,sub set_receiver {
0.000000,1,0.000000,my ($self, $receiver) = @_;
0.000000,1,0.000000,my $callback;
0.000000,1,0.000000,if (ref $receiver eq 'CODE') {
0.000000,0,0.000000,$callback = $receiver;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$callback = sub {
0.007778,35840,0.000000,my ($self, $event, $info) = @_;
0.072938,35840,0.000002,return $receiver->$event($info);
0.000003,1,0.000003,};
0.000000,0,0.000000,}
0.000001,1,0.000001,$self->{callback} = $callback;
0.000002,1,0.000002,$self->{receiver} = $receiver;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub reader { return $_[0]->lexer->{reader} }
0.000000,0,0.000000,sub set_reader {
0.000001,1,0.000001,my ($self, $reader) = @_;
0.000005,1,0.000005,$self->lexer->set_reader($reader);
0.000000,0,0.000000,}
0.061480,54888,0.000001,sub lexer { return $_[0]->{lexer} }
0.037936,35840,0.000001,sub callback { return $_[0]->{callback} }
0.000000,0,0.000000,sub set_callback { $_[0]->{callback} = $_[1] }
0.011287,6934,0.000002,sub level { return $#{ $_[0]->{offset} } }
0.036198,31736,0.000001,sub offset { return $_[0]->{offset} }
0.000002,1,0.000002,sub set_offset { $_[0]->{offset} = $_[1] }
0.068418,62214,0.000001,sub events { return $_[0]->{events} }
0.000003,1,0.000003,sub set_events { $_[0]->{events} = $_[1] }
0.030499,27254,0.000001,sub new_node { return $_[0]->{new_node} }
0.041251,35930,0.000001,sub set_new_node { $_[0]->{new_node} = $_[1] }
0.000000,0,0.000000,sub tagmap { return $_[0]->{tagmap} }
0.000007,2,0.000004,sub set_tagmap { $_[0]->{tagmap} = $_[1] }
0.016016,13355,0.000001,sub tokens { return $_[0]->{tokens} }
0.000002,1,0.000002,sub set_tokens { $_[0]->{tokens} = $_[1] }
0.117377,69800,0.000002,sub event_stack { return $_[0]->{event_stack} }
0.000002,1,0.000002,sub set_event_stack { $_[0]->{event_stack} = $_[1] }
0.000001,1,0.000001,sub default_yaml_version { return $_[0]->{default_yaml_version} }
0.000002,1,0.000002,sub yaml_version { return $_[0]->{yaml_version} }
0.000002,1,0.000002,sub set_yaml_version { $_[0]->{yaml_version} = $_[1] }
0.000002,1,0.000002,sub yaml_version_directive { return $_[0]->{yaml_version_directive} }
0.000004,2,0.000002,sub set_yaml_version_directive { $_[0]->{yaml_version_directive} = $_[1] }
0.000000,0,0.000000,
0.016594,13355,0.000001,sub rule { return $_[0]->{rule} }
0.000000,0,0.000000,sub set_rule {
0.012034,54556,0.000000,my ($self, $name) = @_;
0.004865,2,0.002432,no warnings 'uninitialized';
0.000000,0,0.000000,DEBUG and $self->info("set_rule($name)");
0.068232,54556,0.000001,$self->{rule} = $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub init {
0.000001,1,0.000001,my ($self) = @_;
0.000002,1,0.000002,$self->set_offset([]);
0.000003,1,0.000003,$self->set_events([]);
0.000001,1,0.000001,$self->set_new_node(0);
0.000001,1,0.000001,$self->set_tagmap({
0.000000,0,0.000000,'!!' => "tag:yaml.org,2002:",
0.000000,0,0.000000,});
0.000001,1,0.000001,$self->set_tokens([]);
0.000001,1,0.000001,$self->set_rule(undef);
0.000002,1,0.000002,$self->set_event_stack([]);
0.000001,1,0.000001,$self->set_yaml_version($self->default_yaml_version);
0.000000,1,0.000000,$self->set_yaml_version_directive(undef);
0.000003,1,0.000003,$self->lexer->init;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_string {
0.000000,0,0.000000,my ($self, $yaml) = @_;
0.000000,0,0.000000,$self->set_reader(YAML::PP::Reader->new( input => $yaml ));
0.000000,0,0.000000,$self->parse();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_file {
0.000000,0,0.000000,my ($self, $file) = @_;
0.000000,0,0.000000,$self->set_reader(YAML::PP::Reader::File->new( input => $file ));
0.000000,0,0.000000,$self->parse();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,my %nodetypes = (
0.000000,0,0.000000,MAPVALUE     => 'NODETYPE_COMPLEX',
0.000000,0,0.000000,MAP          => 'NODETYPE_MAP',
0.000000,0,0.000000,#    IMAP         => 'NODETYPE_SEQ',
0.000000,0,0.000000,SEQ          => 'NODETYPE_SEQ',
0.000000,0,0.000000,SEQ0         => 'NODETYPE_SEQ',
0.000000,0,0.000000,FLOWMAP      => 'NODETYPE_FLOWMAP',
0.000000,0,0.000000,FLOWMAPVALUE => 'NODETYPE_FLOWMAPVALUE',
0.000000,0,0.000000,FLOWSEQ      => 'NODETYPE_FLOWSEQ',
0.000000,0,0.000000,FLOWSEQ_NEXT => 'FLOWSEQ_NEXT',
0.000000,0,0.000000,DOC          => 'FULLNODE',
0.000000,0,0.000000,DOC_END      => 'DOCUMENT_END',
0.000000,0,0.000000,STR          => 'STREAM',
0.000000,0,0.000000,END_FLOW     => 'END_FLOW',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse {
0.000000,1,0.000000,my ($self) = @_;
0.000000,0,0.000000,TRACE and warn "=== parse()\n";
0.000000,0,0.000000,TRACE and $self->debug_yaml;
0.000001,1,0.000001,$self->init;
0.000001,1,0.000001,$self->lexer->init;
0.000001,1,0.000001,eval {
0.000001,1,0.000001,$self->start_stream;
0.000000,1,0.000000,$self->set_rule( 'STREAM' );
0.000000,0,0.000000,
0.000001,1,0.000001,$self->parse_tokens();
0.000000,0,0.000000,
0.000003,1,0.000003,$self->end_stream;
0.000000,0,0.000000,};
0.000001,1,0.000001,if (my $error = $@) {
0.000000,0,0.000000,if (ref $error) {
0.000000,0,0.000000,croak "$error\n ";
0.000000,0,0.000000,}
0.000000,0,0.000000,croak $error;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and $self->highlight_yaml;
0.000003,1,0.000003,TRACE and $self->debug_tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub lex_next_tokens {
0.003108,13356,0.000000,my ($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and $self->info("----------------> lex_next_tokens");
0.000000,0,0.000000,TRACE and $self->debug_events;
0.000000,0,0.000000,
0.009076,13356,0.000001,my $indent = $self->offset->[-1];
0.007163,13356,0.000001,my $event_types = $self->events;
0.017821,13356,0.000001,my $next_tokens = $self->lexer->fetch_next_tokens($indent);
0.001714,13356,0.000000,return unless @$next_tokens;
0.000000,0,0.000000,
0.002464,13355,0.000000,my $next = $next_tokens->[0];
0.000000,0,0.000000,
0.004205,13355,0.000000,return 1 if ($next->{name} ne 'SPACE');
0.020613,13354,0.000002,my $flow = $event_types->[-1] =~ m/^FLOW/;
0.005211,13354,0.000000,my $space = length $next->{value};
0.009680,13354,0.000001,my $tokens = $self->tokens;
0.000000,0,0.000000,
0.004105,13354,0.000000,if (not $space) {
0.000000,0,0.000000,shift @$next_tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.003701,13349,0.000000,push @$tokens, shift @$next_tokens;
0.000000,0,0.000000,}
0.001397,13354,0.000000,if ($flow) {
0.000000,0,0.000000,if ($space >= $indent) {
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->exception("Bad indendation in " . $self->events->[-1]);
0.000000,0,0.000000,}
0.002434,13354,0.000000,$next = $next_tokens->[0];
0.003175,13354,0.000000,if ($space > $indent ) {
0.001201,6116,0.000000,return 1 if $indent < 0;
0.004723,6115,0.000001,unless ($self->new_node) {
0.000000,0,0.000000,$self->exception("Bad indendation in " . $self->events->[-1]);
0.000000,0,0.000000,}
0.009419,6115,0.000002,return 1;
0.000000,0,0.000000,}
0.006573,7238,0.000001,if ($self->new_node) {
0.000258,305,0.000001,if ($space < $indent) {
0.000000,0,0.000000,$self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
0.000000,0,0.000000,$self->remove_nodes($space);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# unindented sequence starts
0.000316,305,0.000001,my $exp = $self->events->[-1];
0.000168,305,0.000001,my $seq_start = $next->{name} eq 'DASH';
0.000196,305,0.000001,if ( $seq_start and ($exp eq 'MAPVALUE' or $exp eq 'MAP')) {
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.003913,6933,0.000001,if ($space < $indent) {
0.000000,0,0.000000,$self->remove_nodes($space);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.005911,7238,0.000001,my $exp = $self->events->[-1];
0.000000,0,0.000000,
0.002611,7238,0.000000,if ($exp eq 'SEQ0' and $next->{name} ne 'DASH') {
0.000000,0,0.000000,TRACE and $self->info("In unindented sequence");
0.000265,261,0.000001,$self->end_sequence;
0.000247,261,0.000001,$exp = $self->events->[-1];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.005047,7238,0.000001,if ($self->offset->[-1] != $space) {
0.000000,0,0.000000,$self->exception("Expected " . $self->events->[-1]);
0.000000,0,0.000000,}
0.011820,7238,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,my %next_event = (
0.000000,0,0.000000,MAP => 'MAPVALUE',
0.000000,0,0.000000,IMAP => 'IMAPVALUE',
0.000000,0,0.000000,MAPVALUE => 'MAP',
0.000000,0,0.000000,IMAPVALUE => 'IMAP',
0.000000,0,0.000000,SEQ => 'SEQ',
0.000000,0,0.000000,SEQ0 => 'SEQ0',
0.000000,0,0.000000,DOC => 'DOC_END',
0.000000,0,0.000000,STR => 'STR',
0.000000,0,0.000000,FLOWSEQ => 'FLOWSEQ_NEXT',
0.000000,0,0.000000,FLOWSEQ_NEXT => 'FLOWSEQ',
0.000000,0,0.000000,FLOWMAP => 'FLOWMAPVALUE',
0.000000,0,0.000000,FLOWMAPVALUE => 'FLOWMAP',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000002,1,0.000002,my %event_to_method = (
0.000000,0,0.000000,MAP => 'mapping',
0.000000,0,0.000000,IMAP => 'mapping',
0.000000,0,0.000000,FLOWMAP => 'mapping',
0.000000,0,0.000000,SEQ => 'sequence',
0.000000,0,0.000000,SEQ0 => 'sequence',
0.000000,0,0.000000,FLOWSEQ => 'sequence',
0.000000,0,0.000000,DOC => 'document',
0.000000,0,0.000000,STR => 'stream',
0.000000,0,0.000000,VAL => 'scalar',
0.000000,0,0.000000,ALI => 'alias',
0.000000,0,0.000000,MAPVALUE => 'mapping',
0.000000,0,0.000000,IMAPVALUE => 'mapping',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,#sub process_events {
0.000000,0,0.000000,#    my ($self, $res) = @_;
0.000000,0,0.000000,#
0.000000,0,0.000000,#    my $event_stack = $self->event_stack;
0.000000,0,0.000000,#    return unless @$event_stack;
0.000000,0,0.000000,#
0.000000,0,0.000000,#    if (@$event_stack == 1 and $event_stack->[0]->[0] eq 'properties') {
0.000000,0,0.000000,#        return;
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#
0.000000,0,0.000000,#    my $event_types = $self->events;
0.000000,0,0.000000,#    my $properties;
0.000000,0,0.000000,#    my @send_events;
0.000000,0,0.000000,#    for my $event (@$event_stack) {
0.000000,0,0.000000,#        TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$event], ['event']);
0.000000,0,0.000000,#        my ($type, $info) = @$event;
0.000000,0,0.000000,#        if ($type eq 'properties') {
0.000000,0,0.000000,#            $properties = $info;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#        elsif ($type eq 'scalar') {
0.000000,0,0.000000,#            $info->{name} = 'scalar_event';
0.000000,0,0.000000,#            $event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,#            push @send_events, $info;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#        elsif ($type eq 'begin') {
0.000000,0,0.000000,#            my $name = $info->{name};
0.000000,0,0.000000,#            $info->{name} = $event_to_method{ $name } . '_start_event';
0.000000,0,0.000000,#            push @{ $event_types }, $name;
0.000000,0,0.000000,#            push @{ $self->offset }, $info->{offset};
0.000000,0,0.000000,#            push @send_events, $info;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#        elsif ($type eq 'end') {
0.000000,0,0.000000,#            my $name = $info->{name};
0.000000,0,0.000000,#            $info->{name} = $event_to_method{ $name } . '_end_event';
0.000000,0,0.000000,#            $self->$type($name, $info);
0.000000,0,0.000000,#            push @send_events, $info;
0.000000,0,0.000000,#            if (@$event_types) {
0.000000,0,0.000000,#                $event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,#            }
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#        elsif ($type eq 'alias') {
0.000000,0,0.000000,#            if ($properties) {
0.000000,0,0.000000,#                $self->exception("Parse error: Alias not allowed in this context");
0.000000,0,0.000000,#            }
0.000000,0,0.000000,#            $info->{name} = 'alias_event';
0.000000,0,0.000000,#            $event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,#            push @send_events, $info;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#    @$event_stack = ();
0.000000,0,0.000000,#    for my $info (@send_events) {
0.000000,0,0.000000,#        DEBUG and $self->debug_event( $info );
0.000000,0,0.000000,#        $self->callback->($self, $info->{name}, $info);
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#}
0.000000,0,0.000000,
0.000004,1,0.000004,my %fetch_method = (
0.000000,0,0.000000,'"' => 'fetch_quoted',
0.000000,0,0.000000,"'" => 'fetch_quoted',
0.000000,0,0.000000,'|' => 'fetch_block',
0.000000,0,0.000000,'>' => 'fetch_block',
0.000000,0,0.000000,''  => 'fetch_plain',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_tokens {
0.000001,1,0.000001,my ($self) = @_;
0.000000,1,0.000000,my $event_types = $self->events;
0.000001,1,0.000001,my $offsets = $self->offset;
0.000001,1,0.000001,my $tokens = $self->tokens;
0.000002,1,0.000002,my $next_tokens = $self->lexer->next_tokens;
0.000000,0,0.000000,
0.000001,1,0.000001,unless ($self->lex_next_tokens) {
0.000000,0,0.000000,$self->end_document(1);
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000002,1,0.000002,unless ($self->new_node) {
0.000002,1,0.000002,if ($self->level > 0) {
0.000000,0,0.000000,my $new_rule = $nodetypes{ $event_types->[-1] }
0.000000,0,0.000000,or die "Did not find '$event_types->[-1]'";
0.000000,0,0.000000,$self->set_rule( $new_rule );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,my $rule_name = $self->rule;
0.000000,0,0.000000,DEBUG and $self->info("----------------> parse_tokens($rule_name)");
0.000002,1,0.000002,my $rule = $GRAMMAR->{ $rule_name }
0.000000,0,0.000000,or die "Could not find rule $rule_name";
0.000000,0,0.000000,
0.000000,0,0.000000,TRACE and $self->debug_rules($rule);
0.000000,0,0.000000,TRACE and $self->debug_yaml;
0.000000,0,0.000000,DEBUG and $self->debug_next_line;
0.000000,0,0.000000,
0.007324,1,0.007324,RULE: while ($rule_name) {
0.000000,0,0.000000,DEBUG and $self->info("RULE: $rule_name");
0.000000,0,0.000000,TRACE and $self->debug_tokens($next_tokens);
0.000000,0,0.000000,
0.010788,110006,0.000000,unless (@$next_tokens) {
0.000000,0,0.000000,$self->exception("No more tokens");
0.000000,0,0.000000,}
0.000000,0,0.000000,TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$next_tokens->[0]], ['next_token']);
0.026475,110006,0.000000,my $got = $next_tokens->[0]->{name};
0.012784,110006,0.000000,if ($got eq 'CONTEXT') {
0.003849,20764,0.000000,my $context = shift @$next_tokens;
0.003613,20764,0.000000,my $indent = $offsets->[-1];
0.023861,20764,0.000001,$indent++ unless $self->lexer->flowcontext;
0.008151,20764,0.000000,my $method = $fetch_method{ $context->{value} };
0.027125,20764,0.000001,my $partial = $self->lexer->$method($indent, $context->{value});
0.021889,20764,0.000001,next RULE;
0.000000,0,0.000000,}
0.028427,89242,0.000000,my $def = $rule->{ $got };
0.028335,89242,0.000000,if ($def) {
0.000000,0,0.000000,push @$tokens, shift @$next_tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($def = $rule->{DEFAULT}) {
0.000000,0,0.000000,$got = 'DEFAULT';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->expected(
0.000000,0,0.000000,expected => [keys %$rule],
0.000000,0,0.000000,got => $next_tokens->[0],
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and $self->got("---got $got");
0.029791,89242,0.000000,if (my $sub = $def->{match}) {
0.000000,0,0.000000,DEBUG and $self->info("CALLBACK $sub");
0.045111,43398,0.000001,$self->$sub(@$tokens ? $tokens->[-1] : ());
0.000000,0,0.000000,}
0.014370,89242,0.000000,my $eol = $got eq 'EOL';
0.019237,89242,0.000000,my $new = $def->{new};
0.019310,89242,0.000000,if ($new) {
0.000000,0,0.000000,DEBUG and $self->got("NEW: $new");
0.006056,46373,0.000000,$rule_name = $new;
0.029241,46373,0.000001,$self->set_rule($rule_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($eol) {
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($def->{return}) {
0.000670,1246,0.000001,$rule_name = $nodetypes{ $event_types->[-1] }
0.000000,0,0.000000,or die "Unexpected event type $event_types->[-1]";
0.000816,1246,0.000001,$self->set_rule($rule_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.014678,34689,0.000000,$rule_name .= " - $got"; # for debugging
0.003620,34689,0.000000,$rule = $def;
0.009794,34689,0.000000,next RULE;
0.000000,0,0.000000,}
0.007387,54553,0.000000,if ($eol) {
0.011199,13355,0.000001,unless ($self->lex_next_tokens) {
0.000000,1,0.000000,if ($rule_name eq 'DIRECTIVE') {
0.000000,0,0.000000,$self->exception("Directive needs document start");
0.000000,0,0.000000,}
0.000002,1,0.000002,$self->end_document(1);
0.000004,1,0.000004,return 0;
0.000000,0,0.000000,}
0.009151,13354,0.000001,unless ($self->new_node) {
0.006675,6933,0.000001,if ($self->level > 0) {
0.003263,6933,0.000000,$rule_name = $nodetypes{ $event_types->[-1] }
0.000000,0,0.000000,or die "Did not find '$event_types->[-1]'";
0.004272,6933,0.000001,$self->set_rule( $rule_name );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.011072,13354,0.000001,$rule_name = $self->rule;
0.000000,0,0.000000,}
0.034746,54552,0.000001,$rule = $GRAMMAR->{ $rule_name }
0.000000,0,0.000000,or die "Unexpected rule $rule_name";
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,die "Unexpected";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_sequence {
0.000109,261,0.000000,my ($self) = @_;
0.000184,261,0.000001,my $event_types = $self->events;
0.000116,261,0.000000,pop @{ $event_types };
0.000157,261,0.000001,pop @{ $self->offset };
0.000190,261,0.000001,my $info = { name => 'sequence_end_event' };
0.000418,261,0.000002,$self->callback->($self, $info->{name} => $info );
0.000688,261,0.000003,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove_nodes {
0.000798,2795,0.000000,my ($self, $space) = @_;
0.001949,2795,0.000001,my $offset = $self->offset;
0.001970,2795,0.000001,my $event_types = $self->events;
0.000000,0,0.000000,
0.000954,2795,0.000000,my $exp = $event_types->[-1];
0.000891,2795,0.000000,while (@$offset) {
0.002199,9525,0.000000,if ($offset->[ -1 ] <= $space) {
0.000882,2795,0.000000,last;
0.000000,0,0.000000,}
0.001157,6730,0.000000,if ($exp eq 'MAPVALUE') {
0.000000,0,0.000000,$self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
0.000000,0,0.000000,$exp = 'MAP';
0.000000,0,0.000000,}
0.003393,6730,0.000001,my $info = { name => $exp };
0.003691,6730,0.000001,$info->{name} = $event_to_method{ $exp } . '_end_event';
0.001444,6730,0.000000,pop @{ $event_types };
0.001054,6730,0.000000,pop @{ $offset };
0.008113,6730,0.000001,$self->callback->($self, $info->{name} => $info );
0.003205,6730,0.000000,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.005006,6730,0.000001,$exp = $event_types->[-1];
0.000000,0,0.000000,}
0.004006,2795,0.000001,return $exp;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_stream {
0.000001,1,0.000001,my ($self) = @_;
0.000002,1,0.000002,push @{ $self->events }, 'STR';
0.000002,1,0.000002,push @{ $self->offset }, -1;
0.000005,1,0.000005,$self->callback->($self, 'stream_start_event', {
0.000000,0,0.000000,name => 'stream_start_event',
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_document {
0.000001,1,0.000001,my ($self, $implicit) = @_;
0.000001,1,0.000001,push @{ $self->events }, 'DOC';
0.000001,1,0.000001,push @{ $self->offset }, -1;
0.000002,1,0.000002,my $directive = $self->yaml_version_directive;
0.000000,1,0.000000,my %directive;
0.000001,1,0.000001,if ($directive) {
0.000000,0,0.000000,my ($major, $minor) = split m/\./, $self->yaml_version;
0.000000,0,0.000000,%directive = ( version_directive => { major => $major, minor => $minor } );
0.000000,0,0.000000,}
0.000004,1,0.000004,$self->callback->($self, 'document_start_event', {
0.000000,0,0.000000,name => 'document_start_event',
0.000000,0,0.000000,implicit => $implicit,
0.000000,0,0.000000,%directive,
0.000000,0,0.000000,});
0.000001,1,0.000001,$self->set_yaml_version_directive(undef);
0.000001,1,0.000001,$self->set_rule( 'FULLNODE' );
0.000003,1,0.000003,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_sequence {
0.000104,305,0.000000,my ($self, $offset) = @_;
0.000182,305,0.000001,my $offsets = $self->offset;
0.000387,305,0.000001,if ($offsets->[-1] == $offset) {
0.000000,0,0.000000,push @{ $self->events }, 'SEQ0';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @{ $self->events }, 'SEQ';
0.000000,0,0.000000,}
0.000161,305,0.000001,push @{ $offsets }, $offset;
0.000182,305,0.000001,my $event_stack = $self->event_stack;
0.000231,305,0.000001,my $info = { name => 'sequence_start_event' };
0.000052,305,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,my $properties = pop @$event_stack;
0.000000,0,0.000000,$self->node_properties($properties->[1], $info);
0.000000,0,0.000000,}
0.000969,305,0.000003,$self->callback->($self, 'sequence_start_event', $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_flow_sequence {
0.000093,331,0.000000,my ($self, $offset) = @_;
0.000269,331,0.000001,my $offsets = $self->offset;
0.000181,331,0.000001,my $new_offset = $offsets->[-1];
0.000256,331,0.000001,my $event_types = $self->events;
0.000378,331,0.000001,if ($new_offset < 0) {
0.000000,0,0.000000,$new_offset = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->new_node) {
0.000660,331,0.000002,if ($event_types->[-1] !~ m/^FLOW/) {
0.000000,0,0.000000,$new_offset++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000429,331,0.000001,push @{ $self->events }, 'FLOWSEQ';
0.000102,331,0.000000,push @{ $offsets }, $new_offset;
0.000000,0,0.000000,
0.000264,331,0.000001,my $event_stack = $self->event_stack;
0.000407,331,0.000001,my $info = { style => YAML_FLOW_SEQUENCE_STYLE, name => 'sequence_start_event'  };
0.000135,331,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($event_stack, $info);
0.000000,0,0.000000,}
0.000970,331,0.000003,$self->callback->($self, 'sequence_start_event', $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_flow_mapping {
0.000075,214,0.000000,my ($self, $offset, $implicit_flowseq_map) = @_;
0.000158,214,0.000001,my $offsets = $self->offset;
0.000097,214,0.000000,my $new_offset = $offsets->[-1];
0.000176,214,0.000001,my $event_types = $self->events;
0.000256,214,0.000001,if ($new_offset < 0) {
0.000000,0,0.000000,$new_offset = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->new_node) {
0.000377,214,0.000002,if ($event_types->[-1] !~ m/^FLOW/) {
0.000000,0,0.000000,$new_offset++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000215,214,0.000001,push @{ $self->events }, $implicit_flowseq_map ? 'IMAP' : 'FLOWMAP';
0.000032,214,0.000000,push @{ $offsets }, $new_offset;
0.000000,0,0.000000,
0.000111,214,0.000001,my $event_stack = $self->event_stack;
0.000154,214,0.000001,my $info = { name => 'mapping_start_event', style => YAML_FLOW_MAPPING_STYLE };
0.000043,214,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($event_stack, $info);
0.000000,0,0.000000,}
0.000701,214,0.000003,$self->callback->($self, 'mapping_start_event', $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_flow_sequence {
0.000107,331,0.000000,my ($self) = @_;
0.000218,331,0.000001,my $event_types = $self->events;
0.000115,331,0.000000,pop @{ $event_types };
0.000312,331,0.000001,pop @{ $self->offset };
0.000261,331,0.000001,my $info = { name => 'sequence_end_event' };
0.000440,331,0.000001,$self->callback->($self, $info->{name}, $info);
0.001517,331,0.000005,if ($event_types->[-1] =~ m/^FLOW|^IMAP/) {
0.000000,0,0.000000,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000218,308,0.000001,push @$event_types, 'END_FLOW';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_flow_mapping {
0.000056,214,0.000000,my ($self) = @_;
0.000196,214,0.000001,my $event_types = $self->events;
0.000087,214,0.000000,pop @{ $event_types };
0.000228,214,0.000001,pop @{ $self->offset };
0.000148,214,0.000001,my $info = { name => 'mapping_end_event' };
0.000247,214,0.000001,$self->callback->($self, $info->{name}, $info);
0.001069,214,0.000005,if ($event_types->[-1] =~ m/^FLOW|^IMAP/) {
0.000000,0,0.000000,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000096,214,0.000000,push @$event_types, 'END_FLOW';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_outer_flow {
0.000168,522,0.000000,my ($self) = @_;
0.000406,522,0.000001,my $event_types = $self->events;
0.000183,522,0.000000,pop @$event_types;
0.000942,522,0.000002,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_mapping {
0.001669,6686,0.000000,my ($self, $offset) = @_;
0.004839,6686,0.000001,my $offsets = $self->offset;
0.006000,6686,0.000001,push @{ $self->events }, 'MAP';
0.001518,6686,0.000000,push @{ $offsets }, $offset;
0.003321,6686,0.000000,my $event_stack = $self->event_stack;
0.003708,6686,0.000001,my $info = { name => 'mapping_start_event' };
0.001381,6686,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,my $properties = pop @$event_stack;
0.000000,0,0.000000,$self->node_properties($properties->[1], $info);
0.000000,0,0.000000,}
0.017229,6686,0.000003,$self->callback->($self, 'mapping_start_event', $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_document {
0.000001,1,0.000001,my ($self, $implicit) = @_;
0.000000,0,0.000000,
0.000000,1,0.000000,my $event_types = $self->events;
0.000002,1,0.000002,if ($event_types->[-1] =~ m/FLOW/) {
0.000000,0,0.000000,die "Unexpected end of flow context";
0.000000,0,0.000000,}
0.000001,1,0.000001,if ($self->new_node) {
0.000000,0,0.000000,$self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
0.000000,0,0.000000,}
0.000001,1,0.000001,$self->remove_nodes(-1);
0.000000,0,0.000000,
0.000001,1,0.000001,if ($event_types->[-1] eq 'STR') {
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000001,1,0.000001,my $last = pop @{ $event_types };
0.000001,1,0.000001,if ($last ne 'DOC' and $last ne 'DOC_END') {
0.000000,0,0.000000,$self->exception("Unexpected event type $last");
0.000000,0,0.000000,}
0.000002,1,0.000002,pop @{ $self->offset };
0.000002,1,0.000002,$self->callback->($self, 'document_end_event', {
0.000000,0,0.000000,name => 'document_end_event',
0.000000,0,0.000000,implicit => $implicit,
0.000000,0,0.000000,});
0.000005,1,0.000005,if ($self->yaml_version eq '1.2') {
0.000000,0,0.000000,# In YAML 1.2, directives are only for the following
0.000000,0,0.000000,# document. In YAML 1.1, they are global
0.000000,0,0.000000,$self->set_tagmap({ '!!' => "tag:yaml.org,2002:" });
0.000000,0,0.000000,}
0.000001,1,0.000001,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000002,1,0.000002,$self->set_rule('STREAM');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_stream {
0.000000,1,0.000000,my ($self) = @_;
0.000001,1,0.000001,my $last = pop @{ $self->events };
0.000001,1,0.000001,$self->exception("Unexpected event type $last") unless $last eq 'STR';
0.000000,1,0.000000,pop @{ $self->offset };
0.000003,1,0.000003,$self->callback->($self, 'stream_end_event', {
0.000000,0,0.000000,name => 'stream_end_event',
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetch_inline_properties {
0.000000,0,0.000000,my ($self, $stack, $info) = @_;
0.000000,0,0.000000,my $properties = $stack->[-1];
0.000000,0,0.000000,
0.000000,0,0.000000,$properties = $properties->[1];
0.000000,0,0.000000,my $property_offset;
0.000000,0,0.000000,if ($properties) {
0.000000,0,0.000000,for my $p (@{ $properties->{inline} }) {
0.000000,0,0.000000,my $type = $p->{type};
0.000000,0,0.000000,if (exists $info->{ $type }) {
0.000000,0,0.000000,$self->exception("A node can only have one $type");
0.000000,0,0.000000,}
0.000000,0,0.000000,$info->{ $type } = $p->{value};
0.000000,0,0.000000,unless (defined $property_offset) {
0.000000,0,0.000000,$property_offset = $p->{offset};
0.000000,0,0.000000,$info->{offset} = $p->{offset};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,delete $properties->{inline};
0.000000,0,0.000000,undef $properties unless $properties->{newline};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless ($properties) {
0.000000,0,0.000000,pop @$stack;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub node_properties {
0.000000,0,0.000000,my ($self, $properties, $info) = @_;
0.000000,0,0.000000,if ($properties) {
0.000000,0,0.000000,for my $p (@{ $properties->{newline} }) {
0.000000,0,0.000000,my $type = $p->{type};
0.000000,0,0.000000,if (exists $info->{ $type }) {
0.000000,0,0.000000,$self->exception("A node can only have one $type");
0.000000,0,0.000000,}
0.000000,0,0.000000,$info->{ $type } = $p->{value};
0.000000,0,0.000000,}
0.000000,0,0.000000,undef $properties;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub scalar_event {
0.003238,20764,0.000000,my ($self, $info) = @_;
0.012687,20764,0.000001,my $event_types = $self->events;
0.010382,20764,0.000000,my $event_stack = $self->event_stack;
0.003554,20764,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,my $properties = pop @$event_stack;
0.000000,0,0.000000,$properties = $self->node_properties($properties->[1], $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.005865,20764,0.000000,$info->{name} = 'scalar_event';
0.023194,20764,0.000001,$self->callback->($self, 'scalar_event', $info);
0.013466,20764,0.000001,$self->set_new_node(0);
0.036840,20764,0.000002,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub alias_event {
0.000000,0,0.000000,my ($self, $info) = @_;
0.000000,0,0.000000,my $event_stack = $self->event_stack;
0.000000,0,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->exception("Parse error: Alias not allowed in this context");
0.000000,0,0.000000,}
0.000000,0,0.000000,my $event_types = $self->events;
0.000000,0,0.000000,$info->{name} = 'alias_event';
0.000000,0,0.000000,$self->callback->($self, 'alias_event', $info);
0.000000,0,0.000000,$self->set_new_node(0);
0.000000,0,0.000000,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub yaml_to_tokens {
0.000000,0,0.000000,my ($class, $type, $input) = @_;
0.000000,0,0.000000,my $yp = YAML::PP::Parser->new( receiver => sub {} );
0.000000,0,0.000000,my @docs = eval {
0.000000,0,0.000000,$type eq 'string' ? $yp->parse_string($input) : $yp->parse_file($input);
0.000000,0,0.000000,};
0.000000,0,0.000000,my $error = $@;
0.000000,0,0.000000,
0.000000,0,0.000000,my $tokens = $yp->tokens;
0.000000,0,0.000000,if ($error) {
0.000000,0,0.000000,my $remaining_tokens = $yp->_remaining_tokens;
0.000000,0,0.000000,push @$tokens, map { +{ %$_, name => 'ERROR' } } @$remaining_tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $error, $tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _remaining_tokens {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my @tokens;
0.000000,0,0.000000,my $next = $self->lexer->next_tokens;
0.000000,0,0.000000,push @tokens, @$next;
0.000000,0,0.000000,my $next_line = $self->lexer->next_line;
0.000000,0,0.000000,my $remaining = '';
0.000000,0,0.000000,if ($next_line) {
0.000000,0,0.000000,if ($self->lexer->offset > 0) {
0.000000,0,0.000000,$remaining = $next_line->[1] . $next_line->[2];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$remaining = join '', @$next_line;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$remaining .= $self->reader->read;
0.000000,0,0.000000,$remaining = '' unless defined $remaining;
0.000000,0,0.000000,push @tokens, { name => "ERROR", value => $remaining };
0.000000,0,0.000000,return \@tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# deprecated
0.000000,0,0.000000,sub event_to_test_suite {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self, $event) = @_; # uncoverable statement
0.000000,0,0.000000,if (ref $event eq 'ARRAY') { # uncoverable statement
0.000000,0,0.000000,return YAML::PP::Common::event_to_test_suite($event->[1]); # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,return YAML::PP::Common::event_to_test_suite($event); # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_events {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self) = @_; # uncoverable statement
0.000000,0,0.000000,$self->note("EVENTS: (" # uncoverable statement
0.000000,0,0.000000,. join (' | ', @{ $_[0]->events }) . ')' # uncoverable statement
0.000000,0,0.000000,);
0.000000,0,0.000000,$self->debug_offset; # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_offset {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self) = @_; # uncoverable statement
0.000000,0,0.000000,$self->note(
0.000000,0,0.000000,qq{OFFSET: (}
0.000000,0,0.000000,# uncoverable statement count:1
0.000000,0,0.000000,# uncoverable statement count:2
0.000000,0,0.000000,# uncoverable statement count:3
0.000000,0,0.000000,. join (' | ', map { defined $_ ? sprintf "%-3d", $_ : '?' } @{ $_[0]->offset })
0.000000,0,0.000000,# uncoverable statement
0.000000,0,0.000000,. qq/) level=@{[ $_[0]->level ]}]}/
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_yaml {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self) = @_; # uncoverable statement
0.000000,0,0.000000,my $line = $self->lexer->line; # uncoverable statement
0.000000,0,0.000000,$self->note("LINE NUMBER: $line"); # uncoverable statement
0.000000,0,0.000000,my $next_tokens = $self->lexer->next_tokens; # uncoverable statement
0.000000,0,0.000000,if (@$next_tokens) { # uncoverable statement
0.000000,0,0.000000,$self->debug_tokens($next_tokens); # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_next_line {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my $next_line = $self->lexer->next_line || [];
0.000000,0,0.000000,my $line = $next_line->[0];
0.000000,0,0.000000,$line = '' unless defined $line;
0.000000,0,0.000000,$line =~ s/( +)$/'·' x length $1/e;
0.000000,0,0.000000,$line =~ s/\t/▸/g;
0.000000,0,0.000000,$self->note("NEXT LINE: >>$line<<");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub note {
0.000000,0,0.000000,my ($self, $msg) = @_;
0.000000,0,0.000000,$self->_colorize_warn(["yellow"], "============ $msg");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub info {
0.000000,0,0.000000,my ($self, $msg) = @_;
0.000000,0,0.000000,$self->_colorize_warn(["cyan"], "============ $msg");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub got {
0.000000,0,0.000000,my ($self, $msg) = @_;
0.000000,0,0.000000,$self->_colorize_warn(["green"], "============ $msg");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _colorize_warn {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self, $colors, $text) = @_; # uncoverable statement
0.000000,0,0.000000,require Term::ANSIColor; # uncoverable statement
0.000000,0,0.000000,warn Term::ANSIColor::colored($colors, $text), "\n"; # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_event {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self, $event) = @_; # uncoverable statement
0.000000,0,0.000000,my $str = YAML::PP::Common::event_to_test_suite($event); # uncoverable statement
0.000000,0,0.000000,require Term::ANSIColor; # uncoverable statement
0.000000,0,0.000000,warn Term::ANSIColor::colored(["magenta"], "============ $str"), "\n"; # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_rules {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self, $rules) = @_; # uncoverable statement
0.000000,0,0.000000,local $Data::Dumper::Maxdepth = 2; # uncoverable statement
0.000000,0,0.000000,$self->note("RULES:"); # uncoverable statement
0.000000,0,0.000000,for my $rule ($rules) { # uncoverable statement
0.000000,0,0.000000,if (ref $rule eq 'ARRAY') { # uncoverable statement
0.000000,0,0.000000,my $first = $rule->[0]; # uncoverable statement
0.000000,0,0.000000,if (ref $first eq 'SCALAR') { # uncoverable statement
0.000000,0,0.000000,$self->info("-> $$first"); # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,else { # uncoverable statement
0.000000,0,0.000000,if (ref $first eq 'ARRAY') { # uncoverable statement
0.000000,0,0.000000,$first = $first->[0]; # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->info("TYPE $first"); # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else { # uncoverable statement
0.000000,0,0.000000,eval { # uncoverable statement
0.000000,0,0.000000,my @keys = sort keys %$rule; # uncoverable statement
0.000000,0,0.000000,$self->info("@keys"); # uncoverable statement
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_tokens {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self, $tokens) = @_; # uncoverable statement
0.000000,0,0.000000,$tokens ||= $self->tokens; # uncoverable statement
0.000000,0,0.000000,require Term::ANSIColor; # uncoverable statement
0.000000,0,0.000000,for my $token (@$tokens) { # uncoverable statement
0.000000,0,0.000000,my $type = Term::ANSIColor::colored(["green"], # uncoverable statement
0.000000,0,0.000000,sprintf "%-22s L %2d C %2d ", # uncoverable statement
0.000000,0,0.000000,$token->{name}, $token->{line}, $token->{column} + 1 # uncoverable statement
0.000000,0,0.000000,);
0.000000,0,0.000000,local $Data::Dumper::Useqq = 1; # uncoverable statement
0.000000,0,0.000000,local $Data::Dumper::Terse = 1; # uncoverable statement
0.000000,0,0.000000,require Data::Dumper; # uncoverable statement
0.000000,0,0.000000,my $str = Data::Dumper->Dump([$token->{value}], ['str']); # uncoverable statement
0.000000,0,0.000000,chomp $str; # uncoverable statement
0.000000,0,0.000000,$str =~ s/(^.|.$)/Term::ANSIColor::colored(['blue'], $1)/ge; # uncoverable statement
0.000000,0,0.000000,warn "$type$str\n"; # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub highlight_yaml {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,require YAML::PP::Highlight;
0.000000,0,0.000000,my $tokens = $self->tokens;
0.000000,0,0.000000,my $highlighted = YAML::PP::Highlight->ansicolored($tokens);
0.000000,0,0.000000,warn $highlighted;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub exception {
0.000000,0,0.000000,my ($self, $msg, %args) = @_;
0.000000,0,0.000000,my $next = $self->lexer->next_tokens;
0.000000,0,0.000000,my $line = @$next ? $next->[0]->{line} : $self->lexer->line;
0.000000,0,0.000000,my $offset = @$next ? $next->[0]->{column} : $self->lexer->offset;
0.000000,0,0.000000,$offset++;
0.000000,0,0.000000,my $next_line = $self->lexer->next_line;
0.000000,0,0.000000,my $remaining = '';
0.000000,0,0.000000,if ($next_line) {
0.000000,0,0.000000,if ($self->lexer->offset > 0) {
0.000000,0,0.000000,$remaining = $next_line->[1] . $next_line->[2];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$remaining = join '', @$next_line;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my $caller = $args{caller} || [ caller(0) ];
0.000000,0,0.000000,my $e = YAML::PP::Exception->new(
0.000000,0,0.000000,got => $args{got},
0.000000,0,0.000000,expected => $args{expected},
0.000000,0,0.000000,line => $line,
0.000000,0,0.000000,column => $offset,
0.000000,0,0.000000,msg => $msg,
0.000000,0,0.000000,next => $next,
0.000000,0,0.000000,where => $caller->[1] . ' line ' . $caller->[2],
0.000000,0,0.000000,yaml => $remaining,
0.000000,0,0.000000,);
0.000000,0,0.000000,croak $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub expected {
0.000000,0,0.000000,my ($self, %args) = @_;
0.000000,0,0.000000,my $expected = $args{expected};
0.000000,0,0.000000,@$expected = sort grep { m/^[A-Z_]+$/ } @$expected;
0.000000,0,0.000000,my $got = $args{got}->{name};
0.000000,0,0.000000,my @caller = caller(0);
0.000000,0,0.000000,$self->exception("Expected (@$expected), but got $got",
0.000000,0,0.000000,caller => \@caller,
0.000000,0,0.000000,expected => $expected,
0.000000,0,0.000000,got => $args{got},
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_tag {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,if (! @$stack or $stack->[-1]->[0] ne 'properties') {
0.000000,0,0.000000,push @$stack, [ properties => {} ];
0.000000,0,0.000000,}
0.000000,0,0.000000,my $last = $stack->[-1]->[1];
0.000000,0,0.000000,my $tag = $self->_read_tag($token->{value}, $self->tagmap);
0.000000,0,0.000000,$last->{inline} ||= [];
0.000000,0,0.000000,push @{ $last->{inline} }, {
0.000000,0,0.000000,type => 'tag',
0.000000,0,0.000000,value => $tag,
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _read_tag {
0.000000,0,0.000000,my ($self, $tag, $map) = @_;
0.000000,0,0.000000,if ($tag eq '!') {
0.000000,0,0.000000,return "!";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($tag =~ m/^!<(.*)>/) {
0.000000,0,0.000000,return $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($tag =~ m/^(![^!]*!|!)(.+)/) {
0.000000,0,0.000000,my $alias = $1;
0.000000,0,0.000000,my $name = $2;
0.000000,0,0.000000,$name =~ s/%([0-9a-fA-F]{2})/chr hex $1/eg;
0.000000,0,0.000000,if (exists $map->{ $alias }) {
0.000000,0,0.000000,$tag = $map->{ $alias }. $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($alias ne '!' and $alias ne '!!') {
0.000000,0,0.000000,die "Found undefined tag handle '$alias'";
0.000000,0,0.000000,}
0.000000,0,0.000000,$tag = "!$name";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die "Invalid tag";
0.000000,0,0.000000,}
0.000000,0,0.000000,return $tag;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_anchor {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $anchor = $token->{value};
0.000000,0,0.000000,$anchor = substr($anchor, 1);
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,if (! @$stack or $stack->[-1]->[0] ne 'properties') {
0.000000,0,0.000000,push @$stack, [ properties => {} ];
0.000000,0,0.000000,}
0.000000,0,0.000000,my $last = $stack->[-1]->[1];
0.000000,0,0.000000,$last->{inline} ||= [];
0.000000,0,0.000000,push @{ $last->{inline} }, {
0.000000,0,0.000000,type => 'anchor',
0.000000,0,0.000000,value => $anchor,
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_property_eol {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $last = $stack->[-1]->[1];
0.000000,0,0.000000,my $inline = delete $last->{inline} or return;
0.000000,0,0.000000,my $newline = $last->{newline} ||= [];
0.000000,0,0.000000,push @$newline, @$inline;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_mapkey {
0.001212,6619,0.000000,my ($self, $token) = @_;
0.004615,6619,0.000001,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.007881,6619,0.000001,};
0.001723,6619,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.012255,6619,0.000002,push @{ $stack }, [ scalar => $info ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_mapkey {
0.000842,6634,0.000000,my ($self, $res) = @_;
0.004846,6634,0.000001,my $last = pop @{ $self->event_stack };
0.004852,6634,0.000001,$self->scalar_event($last->[1]);
0.015871,6634,0.000002,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_scalar {
0.001496,7415,0.000000,my ($self, $res) = @_;
0.005623,7415,0.000001,my $last = pop @{ $self->event_stack };
0.001093,7415,0.000000,return unless $last;
0.004770,7415,0.000001,$self->scalar_event($last->[1]);
0.004345,7415,0.000001,my $e = $self->events;
0.016838,7415,0.000002,if ($e->[-1] eq 'IMAP') {
0.000000,0,0.000000,$self->end_flow_mapping;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_mapkey {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => '',
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_flow_alias {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $alias = substr($token->{value}, 1);
0.000000,0,0.000000,$self->alias_event({ value => $alias });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_alias {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $alias = substr($token->{value}, 1);
0.000000,0,0.000000,$self->alias_event({ value => $alias });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_alias_key {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $alias = substr($token->{value}, 1);
0.000000,0,0.000000,$self->alias_event({ value => $alias });
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_alias_from_stack {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $last = pop @{ $self->event_stack };
0.000000,0,0.000000,$self->alias_event($last->[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_alias {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $alias = substr($token->{value}, 1);
0.000000,0,0.000000,push @{ $self->event_stack }, [ alias => {
0.000000,0,0.000000,value => $alias,
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,}];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_question {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_flow_question {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,$self->set_new_node(2);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_complexvalue {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,$self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_questionstart {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->start_mapping($token->{column});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_complexcolon {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_seqstart {
0.000117,305,0.000000,my ($self, $token) = @_;
0.000123,305,0.000000,my $column = $token->{column};
0.000468,305,0.000002,$self->start_sequence($column);
0.000719,305,0.000002,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_seqitem {
0.000083,299,0.000000,my ($self, $res) = @_;
0.000644,299,0.000002,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_take_quoted {
0.000618,2045,0.000000,my ($self, $token) = @_;
0.000468,2045,0.000000,my $subtokens = $token->{subtokens};
0.001853,2045,0.000001,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => $subtokens->[0]->{value} eq '"'
0.000000,0,0.000000,? YAML_DOUBLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,: YAML_SINGLE_QUOTED_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.003393,2045,0.000002,};
0.000529,2045,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.003763,2045,0.000002,push @{ $stack }, [ scalar => $info ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_quoted_multiline {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $subtokens = $token->{subtokens};
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => $subtokens->[0]->{value} eq '"'
0.000000,0,0.000000,? YAML_DOUBLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,: YAML_SINGLE_QUOTED_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,push @{ $stack }, [ scalar => $info ];
0.000000,0,0.000000,$self->cb_send_scalar;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_take_quoted_key {
0.000004,15,0.000000,my ($self, $token) = @_;
0.000021,15,0.000001,$self->cb_take_quoted($token);
0.000038,15,0.000003,$self->cb_send_mapkey;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_plain_multi {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,push @{ $stack }, [ scalar => $info ];
0.000000,0,0.000000,$self->cb_send_scalar;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_start_plain {
0.001875,12070,0.000000,my ($self, $token) = @_;
0.008525,12070,0.000001,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.014137,12070,0.000001,};
0.002664,12070,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.018474,12070,0.000002,push @{ $stack }, [ scalar => $info ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_start_flowseq {
0.000104,331,0.000000,my ($self, $token) = @_;
0.000960,331,0.000003,$self->start_flow_sequence($token->{column});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_start_flowmap {
0.000099,214,0.000000,my ($self, $token) = @_;
0.000565,214,0.000003,$self->start_flow_mapping($token->{column});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_flowseq {
0.000100,331,0.000000,my ($self, $res) = @_;
0.000269,331,0.000001,$self->cb_send_scalar;
0.000481,331,0.000001,$self->end_flow_sequence;
0.000626,331,0.000002,$self->set_new_node(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_flow_comma {
0.000134,666,0.000000,my ($self) = @_;
0.000435,666,0.000001,my $event_types = $self->events;
0.000412,666,0.000001,$self->set_new_node(0);
0.002492,666,0.000004,if ($event_types->[-1] =~ m/^FLOWSEQ/) {
0.000386,666,0.000001,$self->cb_send_scalar;
0.000311,666,0.000000,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_flow_colon {
0.000006,29,0.000000,my ($self) = @_;
0.000056,29,0.000002,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_flow_mapkey {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => '',
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_flowmap {
0.000059,214,0.000000,my ($self, $res) = @_;
0.000291,214,0.000001,$self->end_flow_mapping;
0.000371,214,0.000002,$self->set_new_node(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_flowmap_empty {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,$self->cb_empty_flowmap_value;
0.000000,0,0.000000,$self->end_flow_mapping;
0.000000,0,0.000000,$self->set_new_node(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_flowkey_plain {
0.000005,29,0.000000,my ($self, $token) = @_;
0.000023,29,0.000001,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.000066,29,0.000002,};
0.000005,29,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000094,29,0.000003,$self->scalar_event($info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_flowkey_quoted {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $subtokens = $token->{subtokens};
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => $subtokens->[0]->{value} eq '"'
0.000000,0,0.000000,? YAML_DOUBLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,: YAML_SINGLE_QUOTED_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_flowmap_key_value {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->cb_empty_flow_mapkey($token);
0.000000,0,0.000000,$self->cb_empty_flowmap_value;
0.000000,0,0.000000,$self->cb_flow_comma;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_empty_flowmap_key_value {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->cb_empty_flow_mapkey($token);
0.000000,0,0.000000,$self->cb_empty_flowmap_value;
0.000000,0,0.000000,$self->cb_flow_comma;
0.000000,0,0.000000,$self->cb_end_flowmap;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_flowmap_value {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => '',
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_flowseq_comma {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->cb_empty_flowmap_value($token);
0.000000,0,0.000000,$self->cb_flow_comma;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_flowseq_end {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->cb_empty_flowmap_value($token);
0.000000,0,0.000000,$self->cb_end_flowseq;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_insert_map_alias {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $scalar = pop @$stack;
0.000000,0,0.000000,my $info = $scalar->[1];
0.000000,0,0.000000,$self->start_mapping($info->{offset});
0.000000,0,0.000000,$self->alias_event($info);
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_insert_map {
0.001420,6686,0.000000,my ($self, $res) = @_;
0.003768,6686,0.000001,my $stack = $self->event_stack;
0.001745,6686,0.000000,my $scalar = pop @$stack;
0.001357,6686,0.000000,my $info = $scalar->[1];
0.006910,6686,0.000001,$self->start_mapping($info->{offset});
0.005095,6686,0.000001,$self->scalar_event($info);
0.017478,6686,0.000003,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_insert_implicit_flowseq_map {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $scalar = pop @$stack;
0.000000,0,0.000000,my $info = $scalar->[1];
0.000000,0,0.000000,$self->start_flow_mapping($info->{offset}, 1);
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_insert_empty_implicit_flowseq_map {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $scalar = pop @$stack;
0.000000,0,0.000000,my $info = $scalar->[1];
0.000000,0,0.000000,$self->start_flow_mapping($info->{offset}, 1);
0.000000,0,0.000000,$self->cb_empty_flowmap_value;
0.000000,0,0.000000,$self->set_new_node(2);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_insert_empty_map {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => '',
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->start_mapping($info->{offset});
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_block_scalar {
0.000000,1,0.000000,my ($self, $token) = @_;
0.000000,1,0.000000,my $type = $token->{subtokens}->[0]->{value};
0.000001,1,0.000001,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => $type eq '|'
0.000000,0,0.000000,? YAML_LITERAL_SCALAR_STYLE
0.000000,0,0.000000,: YAML_FOLDED_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.000001,1,0.000001,};
0.000000,1,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000002,1,0.000002,push @{ $self->event_stack }, [ scalar => $info ];
0.000003,1,0.000003,$self->cb_send_scalar;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_document {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->end_document(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_document_empty {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->end_document(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_doc_start_implicit {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->start_document(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_doc_start_explicit {
0.000000,1,0.000000,my ($self, $token) = @_;
0.000003,1,0.000003,$self->start_document(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_doc_start_document {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->end_document(1);
0.000000,0,0.000000,$self->start_document(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_tag_directive {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my ($name, $tag_alias, $tag_url) = split ' ', $token->{value};
0.000000,0,0.000000,$self->tagmap->{ $tag_alias } = $tag_url;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_reserved_directive {
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_set_yaml_version_directive {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,if ($self->yaml_version_directive) {
0.000000,0,0.000000,croak "Found duplicate YAML directive";
0.000000,0,0.000000,}
0.000000,0,0.000000,my ($version) = $token->{value} =~ m/^%YAML[ \t]+(1\.[12])/;
0.000000,0,0.000000,$self->set_yaml_version($version || '1.2');
0.000000,0,0.000000,$self->set_yaml_version_directive(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000016,1,0.000016,1;
