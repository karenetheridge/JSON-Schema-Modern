# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000022,2,0.000011,use strict;
0.000027,2,0.000013,use warnings;
0.000000,0,0.000000,package YAML::PP::Emitter;
0.000000,0,0.000000,
0.000006,1,0.000006,our $VERSION = '0.035'; # VERSION
0.000023,2,0.000012,use Data::Dumper;
0.000000,0,0.000000,
0.000000,1,0.000000,use YAML::PP::Common qw/
0.000000,0,0.000000,YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,YAML_DOUBLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE
0.000000,0,0.000000,YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE
0.000025,1,0.000025,/;
0.000000,0,0.000000,
0.000022,2,0.000011,use constant DEBUG => $ENV{YAML_PP_EMIT_DEBUG} ? 1 : 0;
0.003479,2,0.001739,use constant DEFAULT_WIDTH => 80;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000002,1,0.000002,my ($class, %args) = @_;
0.000000,0,0.000000,my $self = bless {
0.000000,0,0.000000,indent => $args{indent} || 2,
0.000000,0,0.000000,writer => $args{writer},
0.000001,1,0.000001,width => $args{width} || DEFAULT_WIDTH,
0.000000,0,0.000000,}, $class;
0.000001,1,0.000001,$self->init;
0.000003,1,0.000003,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my $clone = {
0.000000,0,0.000000,indent => $self->indent,
0.000000,0,0.000000,};
0.000000,0,0.000000,return bless $clone, ref $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub event_stack { return $_[0]->{event_stack} }
0.000000,0,0.000000,sub set_event_stack { $_[0]->{event_stack} = $_[1] }
0.000000,0,0.000000,sub indent { return $_[0]->{indent} }
0.000000,0,0.000000,sub width { return $_[0]->{width} }
0.000000,0,0.000000,sub line { return $_[0]->{line} }
0.000000,0,0.000000,sub column { return $_[0]->{column} }
0.000000,0,0.000000,sub set_indent { $_[0]->{indent} = $_[1] }
0.000006,2,0.000003,sub writer { $_[0]->{writer} }
0.000004,1,0.000004,sub set_writer { $_[0]->{writer} = $_[1] }
0.000000,0,0.000000,sub tagmap { return $_[0]->{tagmap} }
0.000003,1,0.000003,sub set_tagmap { $_[0]->{tagmap} = $_[1] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub init {
0.000001,1,0.000001,my ($self) = @_;
0.000004,1,0.000004,unless ($self->writer) {
0.000000,0,0.000000,$self->set_writer(YAML::PP::Writer->new);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->set_tagmap({
0.000002,1,0.000002,'tag:yaml.org,2002:' => '!!',
0.000000,0,0.000000,});
0.000000,1,0.000000,$self->{open_ended} = 0;
0.000001,1,0.000001,$self->{line} = 0;
0.000001,1,0.000001,$self->{column} = 0;
0.000003,1,0.000003,$self->writer->init;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mapping_start_event {
0.000000,0,0.000000,DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ mapping_start_event\n";
0.000000,0,0.000000,my ($self, $info) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $last = $stack->[-1];
0.000000,0,0.000000,my $indent = $last->{indent};
0.000000,0,0.000000,my $new_indent = $indent;
0.000000,0,0.000000,my $yaml = '';
0.000000,0,0.000000,
0.000000,0,0.000000,my $props = '';
0.000000,0,0.000000,my $anchor = $info->{anchor};
0.000000,0,0.000000,my $tag = $info->{tag};
0.000000,0,0.000000,if (defined $anchor) {
0.000000,0,0.000000,$anchor = "&$anchor";
0.000000,0,0.000000,}
0.000000,0,0.000000,if (defined $tag) {
0.000000,0,0.000000,$tag = $self->_emit_tag('map', $tag);
0.000000,0,0.000000,}
0.000000,0,0.000000,$props = join ' ', grep defined, ($anchor, $tag);
0.000000,0,0.000000,
0.000000,0,0.000000,my $flow = $last->{flow} || 0;
0.000000,0,0.000000,$flow++ if ($info->{style} || 0) eq YAML_FLOW_MAPPING_STYLE;
0.000000,0,0.000000,
0.000000,0,0.000000,my $newline = 0;
0.000000,0,0.000000,if ($flow > 1) {
0.000000,0,0.000000,if ($last->{type} eq 'SEQ') {
0.000000,0,0.000000,if ($last->{newline}) {
0.000000,0,0.000000,$yaml .= ' ';
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($last->{index} == 0) {
0.000000,0,0.000000,$yaml .= "[";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$yaml .= ",";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'MAP') {
0.000000,0,0.000000,if ($last->{newline}) {
0.000000,0,0.000000,$yaml .= ' ';
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($last->{index} == 0) {
0.000000,0,0.000000,$yaml .= "{";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$yaml .= ",";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'MAPVALUE') {
0.000000,0,0.000000,if ($last->{index} == 0) {
0.000000,0,0.000000,die "Should not happen (index 0 in MAPVALUE)";
0.000000,0,0.000000,}
0.000000,0,0.000000,$yaml .= ": ";
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($props) {
0.000000,0,0.000000,$yaml .= " $props ";
0.000000,0,0.000000,}
0.000000,0,0.000000,$new_indent .= ' ' x $self->indent;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($last->{type} eq 'DOC') {
0.000000,0,0.000000,$newline = $last->{newline};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($last->{newline}) {
0.000000,0,0.000000,$yaml .= "\n";
0.000000,0,0.000000,$last->{column} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($last->{type} eq 'MAPVALUE') {
0.000000,0,0.000000,$new_indent .= ' ' x $self->indent;
0.000000,0,0.000000,$newline = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$new_indent = $indent;
0.000000,0,0.000000,if (not $props and $self->indent == 1) {
0.000000,0,0.000000,$new_indent .= ' ' x 2;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$new_indent .= ' ' x $self->indent;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($last->{column}) {
0.000000,0,0.000000,my $space = $self->indent > 1 ? ' ' x ($self->indent - 1) : ' ';
0.000000,0,0.000000,$yaml .= $space;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$yaml .= $indent;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($last->{type} eq 'SEQ') {
0.000000,0,0.000000,$yaml .= '-';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'MAP') {
0.000000,0,0.000000,$yaml .= "?";
0.000000,0,0.000000,$last->{type} = 'COMPLEX';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'COMPLEXVALUE') {
0.000000,0,0.000000,$yaml .= ":";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die "Should not happen ($last->{type} in mapping_start)";
0.000000,0,0.000000,}
0.000000,0,0.000000,$last->{column} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,$last->{newline} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($props) {
0.000000,0,0.000000,$yaml .= $last->{column} ? ' ' : $indent;
0.000000,0,0.000000,$yaml .= $props;
0.000000,0,0.000000,$newline = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_write($yaml);
0.000000,0,0.000000,my $new_info = {
0.000000,0,0.000000,index => 0, indent => $new_indent, info => $info,
0.000000,0,0.000000,newline => $newline,
0.000000,0,0.000000,column => $self->column,
0.000000,0,0.000000,flow => $flow,
0.000000,0,0.000000,};
0.000000,0,0.000000,$new_info->{type} = 'MAP';
0.000000,0,0.000000,push @{ $stack }, $new_info;
0.000000,0,0.000000,$last->{index}++;
0.000000,0,0.000000,$self->{open_ended} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mapping_end_event {
0.000000,0,0.000000,DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ mapping_end_event\n";
0.000000,0,0.000000,my ($self, $info) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,
0.000000,0,0.000000,my $last = pop @{ $stack };
0.000000,0,0.000000,if ($last->{index} == 0) {
0.000000,0,0.000000,my $indent = $last->{indent};
0.000000,0,0.000000,my $zero_indent = $last->{zero_indent};
0.000000,0,0.000000,if ($last->{zero_indent}) {
0.000000,0,0.000000,$indent .= ' ' x $self->indent;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($self->column) {
0.000000,0,0.000000,$self->_write(" {}\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->_write("$indent\{}\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{flow}) {
0.000000,0,0.000000,my $yaml = "}";
0.000000,0,0.000000,if ($last->{flow} == 1) {
0.000000,0,0.000000,$yaml .= "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_write("$yaml");
0.000000,0,0.000000,}
0.000000,0,0.000000,$last = $stack->[-1];
0.000000,0,0.000000,$last->{column} = $self->column;
0.000000,0,0.000000,if ($last->{type} eq 'SEQ') {
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'MAP') {
0.000000,0,0.000000,$last->{type} = 'MAPVALUE';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'MAPVALUE') {
0.000000,0,0.000000,$last->{type} = 'MAP';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'COMPLEX') {
0.000000,0,0.000000,$last->{type} = 'COMPLEXVALUE';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'COMPLEXVALUE') {
0.000000,0,0.000000,$last->{type} = 'MAP';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sequence_start_event {
0.000000,0,0.000000,DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ sequence_start_event\n";
0.000000,0,0.000000,my ($self, $info) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $last = $stack->[-1];
0.000000,0,0.000000,my $indent = $last->{indent};
0.000000,0,0.000000,my $new_indent = $indent;
0.000000,0,0.000000,my $yaml = '';
0.000000,0,0.000000,
0.000000,0,0.000000,my $props = '';
0.000000,0,0.000000,my $anchor = $info->{anchor};
0.000000,0,0.000000,my $tag = $info->{tag};
0.000000,0,0.000000,if (defined $anchor) {
0.000000,0,0.000000,$anchor = "&$anchor";
0.000000,0,0.000000,}
0.000000,0,0.000000,if (defined $tag) {
0.000000,0,0.000000,$tag = $self->_emit_tag('seq', $tag);
0.000000,0,0.000000,}
0.000000,0,0.000000,$props = join ' ', grep defined, ($anchor, $tag);
0.000000,0,0.000000,
0.000000,0,0.000000,my $flow = $last->{flow} || 0;
0.000000,0,0.000000,$flow++ if $flow or ($info->{style} || 0) eq YAML_FLOW_SEQUENCE_STYLE;
0.000000,0,0.000000,my $newline = 0;
0.000000,0,0.000000,my $zero_indent = 0;
0.000000,0,0.000000,if ($flow > 1) {
0.000000,0,0.000000,if ($last->{type} eq 'SEQ') {
0.000000,0,0.000000,if ($last->{newline}) {
0.000000,0,0.000000,$yaml .= ' ';
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($last->{index} == 0) {
0.000000,0,0.000000,$yaml .= "[";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$yaml .= ",";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'MAP') {
0.000000,0,0.000000,if ($last->{newline}) {
0.000000,0,0.000000,$yaml .= ' ';
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($last->{index} == 0) {
0.000000,0,0.000000,$yaml .= "{";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$yaml .= ",";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'MAPVALUE') {
0.000000,0,0.000000,if ($last->{index} == 0) {
0.000000,0,0.000000,die "Should not happen (index 0 in MAPVALUE)";
0.000000,0,0.000000,}
0.000000,0,0.000000,$yaml .= ": ";
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($props) {
0.000000,0,0.000000,$yaml .= " $props ";
0.000000,0,0.000000,}
0.000000,0,0.000000,$new_indent .= ' ' x $self->indent;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($last->{type} eq 'DOC') {
0.000000,0,0.000000,$newline = $last->{newline};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($last->{newline}) {
0.000000,0,0.000000,$yaml .= "\n";
0.000000,0,0.000000,$last->{column} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($last->{type} eq 'MAPVALUE') {
0.000000,0,0.000000,$zero_indent = 1;
0.000000,0,0.000000,$newline = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if (not $props and $self->indent == 1) {
0.000000,0,0.000000,$new_indent .= ' ' x 2;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$new_indent .= ' ' x $self->indent;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($last->{column}) {
0.000000,0,0.000000,my $space = $self->indent > 1 ? ' ' x ($self->indent - 1) : ' ';
0.000000,0,0.000000,$yaml .= $space;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$yaml .= $indent;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($last->{type} eq 'SEQ') {
0.000000,0,0.000000,$yaml .= "-";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'MAP') {
0.000000,0,0.000000,$last->{type} = 'COMPLEX';
0.000000,0,0.000000,$zero_indent = 1;
0.000000,0,0.000000,$yaml .= "?";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'COMPLEXVALUE') {
0.000000,0,0.000000,$yaml .= ":";
0.000000,0,0.000000,$zero_indent = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die "Should not happen ($last->{type} in sequence_start)";
0.000000,0,0.000000,}
0.000000,0,0.000000,$last->{column} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,$last->{newline} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($props) {
0.000000,0,0.000000,$yaml .= $last->{column} ? ' ' : $indent;
0.000000,0,0.000000,$yaml .= $props;
0.000000,0,0.000000,$newline = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_write($yaml);
0.000000,0,0.000000,$last->{index}++;
0.000000,0,0.000000,my $new_info = {
0.000000,0,0.000000,index => 0,
0.000000,0,0.000000,indent => $new_indent,
0.000000,0,0.000000,info => $info,
0.000000,0,0.000000,zero_indent => $zero_indent,
0.000000,0,0.000000,newline => $newline,
0.000000,0,0.000000,column => $self->column,
0.000000,0,0.000000,flow => $flow,
0.000000,0,0.000000,};
0.000000,0,0.000000,$new_info->{type} = 'SEQ';
0.000000,0,0.000000,push @{ $stack }, $new_info;
0.000000,0,0.000000,$self->{open_ended} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sequence_end_event {
0.000000,0,0.000000,DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ sequence_end_event\n";
0.000000,0,0.000000,my ($self, $info) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,
0.000000,0,0.000000,my $last = pop @{ $stack };
0.000000,0,0.000000,if ($last->{index} == 0) {
0.000000,0,0.000000,my $indent = $last->{indent};
0.000000,0,0.000000,my $zero_indent = $last->{zero_indent};
0.000000,0,0.000000,if ($last->{zero_indent}) {
0.000000,0,0.000000,$indent .= ' ' x $self->indent;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $yaml .= $self->column ? ' ' : $indent;
0.000000,0,0.000000,$yaml .= "[]";
0.000000,0,0.000000,if ($last->{flow} < 2) {
0.000000,0,0.000000,$yaml .= "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_write($yaml);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{flow}) {
0.000000,0,0.000000,my $yaml = "]";
0.000000,0,0.000000,if ($last->{flow} == 1) {
0.000000,0,0.000000,$yaml .= "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_write($yaml);
0.000000,0,0.000000,}
0.000000,0,0.000000,$last = $stack->[-1];
0.000000,0,0.000000,$last->{column} = $self->column;
0.000000,0,0.000000,if ($last->{type} eq 'SEQ') {
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'MAP') {
0.000000,0,0.000000,$last->{type} = 'MAPVALUE';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'MAPVALUE') {
0.000000,0,0.000000,$last->{type} = 'MAP';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'COMPLEX') {
0.000000,0,0.000000,$last->{type} = 'COMPLEXVALUE';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'COMPLEXVALUE') {
0.000000,0,0.000000,$last->{type} = 'MAP';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000009,1,0.000009,my %forbidden_first = (qw/
0.000000,0,0.000000,! 1 & 1 * 1 { 1 } 1 [ 1 ] 1 | 1 > 1 @ 1 ` 1 " 1 ' 1
0.000000,0,0.000000,/, '#' => 1, '%' => 1, ',' => 1, " " => 1);
0.000001,1,0.000001,my %forbidden_first_plus_space = (qw/
0.000000,0,0.000000,? 1 - 1 : 1
0.000000,0,0.000000,/);
0.000000,0,0.000000,
0.000014,1,0.000014,my %control = (
0.000000,0,0.000000,"\x00" => '\0',
0.000000,0,0.000000,"\x01" => '\x01',
0.000000,0,0.000000,"\x02" => '\x02',
0.000000,0,0.000000,"\x03" => '\x03',
0.000000,0,0.000000,"\x04" => '\x04',
0.000000,0,0.000000,"\x05" => '\x05',
0.000000,0,0.000000,"\x06" => '\x06',
0.000000,0,0.000000,"\x07" => '\a',
0.000000,0,0.000000,"\x08" => '\b',
0.000000,0,0.000000,"\x0b" => '\v',
0.000000,0,0.000000,"\x0c" => '\f',
0.000000,0,0.000000,"\x0e" => '\x0e',
0.000000,0,0.000000,"\x0f" => '\x0f',
0.000000,0,0.000000,"\x10" => '\x10',
0.000000,0,0.000000,"\x11" => '\x11',
0.000000,0,0.000000,"\x12" => '\x12',
0.000000,0,0.000000,"\x13" => '\x13',
0.000000,0,0.000000,"\x14" => '\x14',
0.000000,0,0.000000,"\x15" => '\x15',
0.000000,0,0.000000,"\x16" => '\x16',
0.000000,0,0.000000,"\x17" => '\x17',
0.000000,0,0.000000,"\x18" => '\x18',
0.000000,0,0.000000,"\x19" => '\x19',
0.000000,0,0.000000,"\x1a" => '\x1a',
0.000000,0,0.000000,"\x1b" => '\e',
0.000000,0,0.000000,"\x1c" => '\x1c',
0.000000,0,0.000000,"\x1d" => '\x1d',
0.000000,0,0.000000,"\x1e" => '\x1e',
0.000000,0,0.000000,"\x1f" => '\x1f',
0.000000,0,0.000000,"\x7f" => '\x7f',
0.000000,0,0.000000,"\x80" => '\x80',
0.000000,0,0.000000,"\x81" => '\x81',
0.000000,0,0.000000,"\x82" => '\x82',
0.000000,0,0.000000,"\x83" => '\x83',
0.000000,0,0.000000,"\x84" => '\x84',
0.000000,0,0.000000,"\x86" => '\x86',
0.000000,0,0.000000,"\x87" => '\x87',
0.000000,0,0.000000,"\x88" => '\x88',
0.000000,0,0.000000,"\x89" => '\x89',
0.000000,0,0.000000,"\x8a" => '\x8a',
0.000000,0,0.000000,"\x8b" => '\x8b',
0.000000,0,0.000000,"\x8c" => '\x8c',
0.000000,0,0.000000,"\x8d" => '\x8d',
0.000000,0,0.000000,"\x8e" => '\x8e',
0.000000,0,0.000000,"\x8f" => '\x8f',
0.000000,0,0.000000,"\x90" => '\x90',
0.000000,0,0.000000,"\x91" => '\x91',
0.000000,0,0.000000,"\x92" => '\x92',
0.000000,0,0.000000,"\x93" => '\x93',
0.000000,0,0.000000,"\x94" => '\x94',
0.000000,0,0.000000,"\x95" => '\x95',
0.000000,0,0.000000,"\x96" => '\x96',
0.000000,0,0.000000,"\x97" => '\x97',
0.000000,0,0.000000,"\x98" => '\x98',
0.000000,0,0.000000,"\x99" => '\x99',
0.000000,0,0.000000,"\x9a" => '\x9a',
0.000000,0,0.000000,"\x9b" => '\x9b',
0.000000,0,0.000000,"\x9c" => '\x9c',
0.000000,0,0.000000,"\x9d" => '\x9d',
0.000000,0,0.000000,"\x9e" => '\x9e',
0.000000,0,0.000000,"\x9f" => '\x9f',
0.000000,0,0.000000,"\x{2029}" => '\P',
0.000000,0,0.000000,"\x{2028}" => '\L',
0.000000,0,0.000000,"\x85" => '\N',
0.000000,0,0.000000,"\xa0" => '\_',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,1,0.000000,my $control_re = '\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\x84\x86-\x9f\x{d800}-\x{dfff}\x{fffe}\x{ffff}\x{2028}\x{2029}\x85\xa0';
0.000010,1,0.000010,my %to_escape = (
0.000000,0,0.000000,"\n" => '\n',
0.000000,0,0.000000,"\t" => '\t',
0.000000,0,0.000000,"\r" => '\r',
0.000000,0,0.000000,'\\' => '\\\\',
0.000000,0,0.000000,'"' => '\\"',
0.000000,0,0.000000,%control,
0.000000,0,0.000000,);
0.000001,1,0.000001,my $escape_re = $control_re . '\n\t\r';
0.000000,1,0.000000,my $escape_re_without_lb = $control_re . '\t\r';
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub scalar_event {
0.000000,0,0.000000,DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ scalar_event\n";
0.000000,0,0.000000,my ($self, $info) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $last = $stack->[-1];
0.000000,0,0.000000,my $indent = $last->{indent};
0.000000,0,0.000000,my $value = $info->{value};
0.000000,0,0.000000,my $flow = $last->{flow};
0.000000,0,0.000000,
0.000000,0,0.000000,my $props = '';
0.000000,0,0.000000,my $anchor = $info->{anchor};
0.000000,0,0.000000,my $tag = $info->{tag};
0.000000,0,0.000000,if (defined $anchor) {
0.000000,0,0.000000,$anchor = "&$anchor";
0.000000,0,0.000000,}
0.000000,0,0.000000,if (defined $tag) {
0.000000,0,0.000000,$tag = $self->_emit_tag('scalar', $tag);
0.000000,0,0.000000,}
0.000000,0,0.000000,$props = join ' ', grep defined, ($anchor, $tag);
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and local $Data::Dumper::Useqq = 1;
0.000000,0,0.000000,$value = '' unless defined $value;
0.000000,0,0.000000,
0.000000,0,0.000000,my $style = $self->_find_best_scalar_style(
0.000000,0,0.000000,info => $info,
0.000000,0,0.000000,value => $value,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $open_ended = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($style == YAML_PLAIN_SCALAR_STYLE) {
0.000000,0,0.000000,$value =~ s/\n/\n\n/g;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($style == YAML_SINGLE_QUOTED_SCALAR_STYLE) {
0.000000,0,0.000000,my $new_indent = $last->{indent} . (' ' x $self->indent);
0.000000,0,0.000000,$value =~ s/(\n+)/"\n" x (1 + (length $1))/eg;
0.000000,0,0.000000,my @lines = split m/\n/, $value, -1;
0.000000,0,0.000000,if (@lines > 1) {
0.000000,0,0.000000,for my $line (@lines[1 .. $#lines]) {
0.000000,0,0.000000,$line = $new_indent . $line
0.000000,0,0.000000,if length $line;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$value = join "\n", @lines;
0.000000,0,0.000000,$value =~ s/'/''/g;
0.000000,0,0.000000,$value = "'" . $value . "'";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($style == YAML_LITERAL_SCALAR_STYLE) {
0.000000,0,0.000000,DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$value], ['value']);
0.000000,0,0.000000,my $indicators = '';
0.000000,0,0.000000,if ($value =~ m/\A\n* +/) {
0.000000,0,0.000000,$indicators .= $self->indent;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $indent = $indent . ' ' x $self->indent;
0.000000,0,0.000000,if ($value !~ m/\n\z/) {
0.000000,0,0.000000,$indicators .= '-';
0.000000,0,0.000000,$value .= "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($value =~ m/(\n|\A)\n\z/) {
0.000000,0,0.000000,$indicators .= '+';
0.000000,0,0.000000,$open_ended = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,$value =~ s/^(?=.)/$indent/gm;
0.000000,0,0.000000,$value = "|$indicators\n$value";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($style == YAML_FOLDED_SCALAR_STYLE) {
0.000000,0,0.000000,DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$value], ['value']);
0.000000,0,0.000000,my @lines = split /\n/, $value, -1;
0.000000,0,0.000000,DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\@lines], ['lines']);
0.000000,0,0.000000,my $trailing = -1;
0.000000,0,0.000000,while (@lines) {
0.000000,0,0.000000,last if $lines[-1] ne '';
0.000000,0,0.000000,pop @lines;
0.000000,0,0.000000,$trailing++;
0.000000,0,0.000000,}
0.000000,0,0.000000,my %start_with_space;
0.000000,0,0.000000,for my $i (0 .. $#lines) {
0.000000,0,0.000000,if ($lines[ $i ] =~ m/^[ \t]+/) {
0.000000,0,0.000000,$start_with_space{ $i } = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my $indicators = '';
0.000000,0,0.000000,if ($value =~ m/\A\n* +/) {
0.000000,0,0.000000,$indicators .= $self->indent;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $indent = $indent . ' ' x $self->indent;
0.000000,0,0.000000,if ($trailing > 0) {
0.000000,0,0.000000,$indicators .= '+';
0.000000,0,0.000000,$open_ended = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($trailing < 0) {
0.000000,0,0.000000,$indicators .= '-';
0.000000,0,0.000000,}
0.000000,0,0.000000,$value = ">$indicators\n";
0.000000,0,0.000000,my $got_content = 0;
0.000000,0,0.000000,for my $i (0 .. $#lines) {
0.000000,0,0.000000,my $line = $lines[ $i ];
0.000000,0,0.000000,my $sp = $start_with_space{ $i } || 0;
0.000000,0,0.000000,my $spnext = $i == $#lines ? 1 : $start_with_space{ $i+1 } || 0;
0.000000,0,0.000000,my $spprev = $i == 0 ? 1 : $start_with_space{ $i-1 } || 0;
0.000000,0,0.000000,my $empty = length $line ? 0 : 1;
0.000000,0,0.000000,my $emptynext = $i == $#lines ? '' : length $lines[$i+1] ? 0 : 1;
0.000000,0,0.000000,my $nl = 0;
0.000000,0,0.000000,if ($empty) {
0.000000,0,0.000000,if ($spnext and $spprev) {
0.000000,0,0.000000,$nl = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (not $spnext) {
0.000000,0,0.000000,$nl = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (not $got_content) {
0.000000,0,0.000000,$nl = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$got_content = 1;
0.000000,0,0.000000,$value .= "$indent$line\n";
0.000000,0,0.000000,if (not $sp and not $spnext) {
0.000000,0,0.000000,$nl = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($nl) {
0.000000,0,0.000000,$value .= "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$value .= "\n" x ($trailing) if $trailing > 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$value =~ s/([$escape_re"\\])/$to_escape{ $1 } || sprintf '\\u%04x', ord($1)/eg;
0.000000,0,0.000000,$value = '"' . $value . '"';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and warn __PACKAGE__.':'.__LINE__.": (@$stack)\n";
0.000000,0,0.000000,my $yaml = $self->_emit_scalar(
0.000000,0,0.000000,indent => $indent,
0.000000,0,0.000000,props => $props,
0.000000,0,0.000000,value => $value,
0.000000,0,0.000000,style => $style,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$last->{index}++;
0.000000,0,0.000000,$last->{newline} = 0;
0.000000,0,0.000000,$self->_write($yaml);
0.000000,0,0.000000,$last->{column} = $self->column;
0.000000,0,0.000000,$self->{open_ended} = $open_ended;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _find_best_scalar_style {
0.000000,0,0.000000,my ($self, %args) = @_;
0.000000,0,0.000000,my $info = $args{info};
0.000000,0,0.000000,my $style = $info->{style};
0.000000,0,0.000000,my $value = $args{value};
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $last = $stack->[-1];
0.000000,0,0.000000,my $flow = $last->{flow};
0.000000,0,0.000000,
0.000000,0,0.000000,my $first = substr($value, 0, 1);
0.000000,0,0.000000,if ($value eq '') {
0.000000,0,0.000000,if ($flow and $last->{type} ne 'MAPVALUE' and $last->{type} ne 'MAP') {
0.000000,0,0.000000,$style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (not $style) {
0.000000,0,0.000000,$style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,# no control characters anywhere
0.000000,0,0.000000,elsif ($value =~ m/[$control_re]/) {
0.000000,0,0.000000,$style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,$style ||= YAML_PLAIN_SCALAR_STYLE;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($style == YAML_SINGLE_QUOTED_SCALAR_STYLE) {
0.000000,0,0.000000,if ($value =~ m/ \n/ or $value =~ m/\n / or $value =~ m/^\n/ or $value =~ m/\n$/) {
0.000000,0,0.000000,$style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($value eq "\n") {
0.000000,0,0.000000,$style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($style == YAML_LITERAL_SCALAR_STYLE or $style == YAML_FOLDED_SCALAR_STYLE) {
0.000000,0,0.000000,if ($value eq '') {
0.000000,0,0.000000,$style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($flow) {
0.000000,0,0.000000,# no block scalars in flow
0.000000,0,0.000000,if ($value =~ tr/\n//) {
0.000000,0,0.000000,$style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($style == YAML_PLAIN_SCALAR_STYLE) {
0.000000,0,0.000000,if (not length $value) {
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($value =~ m/[$escape_re_without_lb]/) {
0.000000,0,0.000000,$style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($value eq "\n") {
0.000000,0,0.000000,$style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($value !~ tr/ //c) {
0.000000,0,0.000000,$style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($value !~ tr/ \n//c) {
0.000000,0,0.000000,$style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($value =~ tr/\n//) {
0.000000,0,0.000000,$style = $flow ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_LITERAL_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($forbidden_first{ $first }) {
0.000000,0,0.000000,$style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($flow and $value =~ tr/,[]{}//) {
0.000000,0,0.000000,$style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (substr($value, 0, 3) =~ m/^(?:---|\.\.\.)/) {
0.000000,0,0.000000,$style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($value =~ m/: /) {
0.000000,0,0.000000,$style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($value =~ m/ #/) {
0.000000,0,0.000000,$style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($value =~ m/[: \t]\z/) {
0.000000,0,0.000000,$style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($value =~ m/[^\x20-\x3A\x3B-\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]/) {
0.000000,0,0.000000,$style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($forbidden_first_plus_space{ $first }) {
0.000000,0,0.000000,if (length ($value) == 1 or substr($value, 1, 1) =~ m/^\s/) {
0.000000,0,0.000000,$style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($style == YAML_SINGLE_QUOTED_SCALAR_STYLE and not $info->{style}) {
0.000000,0,0.000000,if ($value =~ tr/'// and $value !~ tr/"//) {
0.000000,0,0.000000,$style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return $style;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _emit_scalar {
0.000000,0,0.000000,my ($self, %args) = @_;
0.000000,0,0.000000,my $props = $args{props};
0.000000,0,0.000000,my $value = $args{value};
0.000000,0,0.000000,my $style = $args{style};
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $last = $stack->[-1];
0.000000,0,0.000000,my $flow = $last->{flow};
0.000000,0,0.000000,
0.000000,0,0.000000,my $yaml = '';
0.000000,0,0.000000,my $pvalue = $props;
0.000000,0,0.000000,if ($props and length $value) {
0.000000,0,0.000000,$pvalue .= " $value";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (length $value) {
0.000000,0,0.000000,$pvalue .= $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($flow) {
0.000000,0,0.000000,if ($props and not length $value) {
0.000000,0,0.000000,$pvalue .= ' ';
0.000000,0,0.000000,}
0.000000,0,0.000000,$yaml = $self->_emit_flow_scalar(
0.000000,0,0.000000,value => $value,
0.000000,0,0.000000,pvalue => $pvalue,
0.000000,0,0.000000,style => $args{style},
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$yaml = $self->_emit_block_scalar(
0.000000,0,0.000000,props => $props,
0.000000,0,0.000000,value => $value,
0.000000,0,0.000000,pvalue => $pvalue,
0.000000,0,0.000000,indent => $args{indent},
0.000000,0,0.000000,style => $args{style},
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $yaml;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _emit_block_scalar {
0.000000,0,0.000000,my ($self, %args) = @_;
0.000000,0,0.000000,my $props = $args{props};
0.000000,0,0.000000,my $value = $args{value};
0.000000,0,0.000000,my $pvalue = $args{pvalue};
0.000000,0,0.000000,my $indent = $args{indent};
0.000000,0,0.000000,my $style = $args{style};
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $last = $stack->[-1];
0.000000,0,0.000000,
0.000000,0,0.000000,my $yaml;
0.000000,0,0.000000,if ($last->{type} eq 'MAP' or $last->{type} eq 'SEQ') {
0.000000,0,0.000000,if ($last->{index} == 0 and $last->{newline}) {
0.000000,0,0.000000,$yaml .= "\n";
0.000000,0,0.000000,$last->{column} = 0;
0.000000,0,0.000000,$last->{newline} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my $space = ' ';
0.000000,0,0.000000,my $multiline = ($style == YAML_LITERAL_SCALAR_STYLE or $style == YAML_FOLDED_SCALAR_STYLE);
0.000000,0,0.000000,if ($last->{type} eq 'MAP') {
0.000000,0,0.000000,
0.000000,0,0.000000,if ($last->{column}) {
0.000000,0,0.000000,my $space = $self->indent > 1 ? ' ' x ($self->indent - 1) : ' ';
0.000000,0,0.000000,$yaml .= $space;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$yaml .= $indent;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($props and not length $value) {
0.000000,0,0.000000,$pvalue .= ' ';
0.000000,0,0.000000,}
0.000000,0,0.000000,$last->{type} = 'MAPVALUE';
0.000000,0,0.000000,if ($multiline) {
0.000000,0,0.000000,# oops, a complex key
0.000000,0,0.000000,$yaml .= "? ";
0.000000,0,0.000000,$last->{type} = 'COMPLEXVALUE';
0.000000,0,0.000000,}
0.000000,0,0.000000,if (not $multiline) {
0.000000,0,0.000000,$pvalue .= ":";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($last->{type} eq 'MAPVALUE') {
0.000000,0,0.000000,$last->{type} = 'MAP';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'DOC') {
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($last->{column}) {
0.000000,0,0.000000,my $space = $self->indent > 1 ? ' ' x ($self->indent - 1) : ' ';
0.000000,0,0.000000,$yaml .= $space;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$yaml .= $indent;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($last->{type} eq 'COMPLEXVALUE') {
0.000000,0,0.000000,$last->{type} = 'MAP';
0.000000,0,0.000000,$yaml .= ":";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'SEQ') {
0.000000,0,0.000000,$yaml .= "-";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die "Should not happen ($last->{type} in scalar_event)";
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,$last->{column} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (length $pvalue) {
0.000000,0,0.000000,if ($last->{column}) {
0.000000,0,0.000000,$pvalue = "$space$pvalue";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if (not $multiline) {
0.000000,0,0.000000,$pvalue .= "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$yaml .= $pvalue;
0.000000,0,0.000000,return $yaml;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _emit_flow_scalar {
0.000000,0,0.000000,my ($self, %args) = @_;
0.000000,0,0.000000,my $value = $args{value};
0.000000,0,0.000000,my $pvalue = $args{pvalue};
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $last = $stack->[-1];
0.000000,0,0.000000,
0.000000,0,0.000000,my $yaml;
0.000000,0,0.000000,if ($last->{type} eq 'SEQ') {
0.000000,0,0.000000,if ($last->{index} == 0) {
0.000000,0,0.000000,if ($self->column) {
0.000000,0,0.000000,$yaml .= ' ';
0.000000,0,0.000000,}
0.000000,0,0.000000,$yaml .= "[";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$yaml .= ", ";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'MAP') {
0.000000,0,0.000000,if ($last->{index} == 0) {
0.000000,0,0.000000,if ($self->column) {
0.000000,0,0.000000,$yaml .= ' ';
0.000000,0,0.000000,}
0.000000,0,0.000000,$yaml .= "{";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$yaml .= ", ";
0.000000,0,0.000000,}
0.000000,0,0.000000,$last->{type} = 'MAPVALUE';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'MAPVALUE') {
0.000000,0,0.000000,if ($last->{index} == 0) {
0.000000,0,0.000000,die "Should not happen (index 0 in MAPVALUE)";
0.000000,0,0.000000,}
0.000000,0,0.000000,$yaml .= ": ";
0.000000,0,0.000000,$last->{type} = 'MAP';
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($self->column + length $pvalue > $self->width) {
0.000000,0,0.000000,$yaml .= "\n";
0.000000,0,0.000000,$yaml .= $last->{indent};
0.000000,0,0.000000,$yaml .= ' ' x $self->indent;
0.000000,0,0.000000,}
0.000000,0,0.000000,$yaml .= $pvalue;
0.000000,0,0.000000,return $yaml;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub alias_event {
0.000000,0,0.000000,DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ alias_event\n";
0.000000,0,0.000000,my ($self, $info) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $last = $stack->[-1];
0.000000,0,0.000000,my $indent = $last->{indent};
0.000000,0,0.000000,my $flow = $last->{flow};
0.000000,0,0.000000,
0.000000,0,0.000000,my $alias = '*' . $info->{value};
0.000000,0,0.000000,
0.000000,0,0.000000,my $yaml = '';
0.000000,0,0.000000,if ($last->{type} eq 'MAP' or $last->{type} eq 'SEQ') {
0.000000,0,0.000000,if ($last->{index} == 0 and $last->{newline}) {
0.000000,0,0.000000,$yaml .= "\n";
0.000000,0,0.000000,$last->{column} = 0;
0.000000,0,0.000000,$last->{newline} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$yaml .= $last->{column} ? ' ' : $indent;
0.000000,0,0.000000,if ($flow) {
0.000000,0,0.000000,my $space = '';
0.000000,0,0.000000,if ($last->{type} eq 'SEQ') {
0.000000,0,0.000000,if ($last->{index} == 0) {
0.000000,0,0.000000,if ($flow == 1) {
0.000000,0,0.000000,$yaml .= ' ';
0.000000,0,0.000000,}
0.000000,0,0.000000,$yaml .= "[";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$yaml .= ", ";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'MAP') {
0.000000,0,0.000000,if ($last->{index} == 0) {
0.000000,0,0.000000,if ($flow == 1) {
0.000000,0,0.000000,$yaml .= ' ';
0.000000,0,0.000000,}
0.000000,0,0.000000,$yaml .= "{";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$yaml .= ", ";
0.000000,0,0.000000,}
0.000000,0,0.000000,$last->{type} = 'MAPVALUE';
0.000000,0,0.000000,$space = ' ';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'MAPVALUE') {
0.000000,0,0.000000,if ($last->{index} == 0) {
0.000000,0,0.000000,die 23;
0.000000,0,0.000000,if ($flow == 1) {
0.000000,0,0.000000,$yaml .= ' ';
0.000000,0,0.000000,}
0.000000,0,0.000000,$yaml .= "{";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$yaml .= ": ";
0.000000,0,0.000000,}
0.000000,0,0.000000,$last->{type} = 'MAP';
0.000000,0,0.000000,}
0.000000,0,0.000000,$yaml .= "$alias$space";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($last->{type} eq 'MAP') {
0.000000,0,0.000000,$yaml .= "$alias :";
0.000000,0,0.000000,$last->{type} = 'MAPVALUE';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,if ($last->{type} eq 'MAPVALUE') {
0.000000,0,0.000000,$last->{type} = 'MAP';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'DOC') {
0.000000,0,0.000000,# TODO an alias at document level isn't actually valid
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($last->{type} eq 'COMPLEXVALUE') {
0.000000,0,0.000000,$last->{type} = 'MAP';
0.000000,0,0.000000,$yaml .= ": ";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'COMPLEX') {
0.000000,0,0.000000,$yaml .= ": ";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($last->{type} eq 'SEQ') {
0.000000,0,0.000000,$yaml .= "- ";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die "Unexpected";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$yaml .= "$alias\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_write("$yaml");
0.000000,0,0.000000,$last->{index}++;
0.000000,0,0.000000,$last->{column} = $self->column;
0.000000,0,0.000000,$self->{open_ended} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub document_start_event {
0.000000,0,0.000000,DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ document_start_event\n";
0.000000,0,0.000000,my ($self, $info) = @_;
0.000000,0,0.000000,my $newline = 0;
0.000000,0,0.000000,my $implicit = $info->{implicit};
0.000000,0,0.000000,if ($info->{version_directive}) {
0.000000,0,0.000000,if ($self->{open_ended}) {
0.000000,0,0.000000,$self->_write("...\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_write("%YAML $info->{version_directive}->{major}.$info->{version_directive}->{minor}\n");
0.000000,0,0.000000,$self->{open_ended} = 0;
0.000000,0,0.000000,$implicit = 0; # we need ---
0.000000,0,0.000000,}
0.000000,0,0.000000,unless ($implicit) {
0.000000,0,0.000000,$newline = 1;
0.000000,0,0.000000,$self->_write("---");
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->set_event_stack([
0.000000,0,0.000000,{
0.000000,0,0.000000,type => 'DOC', index => 0, indent => '', info => $info,
0.000000,0,0.000000,newline => $newline, column => $self->column,
0.000000,0,0.000000,}
0.000000,0,0.000000,]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub document_end_event {
0.000000,0,0.000000,DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ document_end_event\n";
0.000000,0,0.000000,my ($self, $info) = @_;
0.000000,0,0.000000,$self->set_event_stack([]);
0.000000,0,0.000000,if ($self->{open_ended} or not $info->{implicit}) {
0.000000,0,0.000000,$self->_write("...\n");
0.000000,0,0.000000,$self->{open_ended} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->{open_ended} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub stream_start_event {
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub stream_end_event {
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _emit_tag {
0.000000,0,0.000000,my ($self, $type, $tag) = @_;
0.000000,0,0.000000,my $map = $self->tagmap;
0.000000,0,0.000000,for my $key (sort keys %$map) {
0.000000,0,0.000000,if ($tag =~ m/^\Q$key\E(.*)/) {
0.000000,0,0.000000,$tag = $map->{ $key } . $1;
0.000000,0,0.000000,return $tag;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($tag =~ m/^(!.*)/) {
0.000000,0,0.000000,$tag = "$1";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$tag = "!<$tag>";
0.000000,0,0.000000,}
0.000000,0,0.000000,return $tag;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub finish {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,$self->writer->finish;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _write {
0.000000,0,0.000000,my ($self, $yaml) = @_;
0.000000,0,0.000000,return unless length $yaml;
0.000000,0,0.000000,my @lines = split m/\n/, $yaml, -1;
0.000000,0,0.000000,my $newlines = @lines - 1;
0.000000,0,0.000000,$self->{line} += $newlines;
0.000000,0,0.000000,if (length $lines[-1]) {
0.000000,0,0.000000,if ($newlines) {
0.000000,0,0.000000,$self->{column} = length $lines[-1];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->{column} += length $lines[-1];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->{column} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->writer->write($yaml);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000017,1,0.000017,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
