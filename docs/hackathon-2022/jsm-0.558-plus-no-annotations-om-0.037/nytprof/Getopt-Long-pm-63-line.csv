# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,#! perl
0.000000,0,0.000000,
0.000000,0,0.000000,# Getopt::Long.pm -- Universal options parsing
0.000000,0,0.000000,# Author          : Johan Vromans
0.000000,0,0.000000,# Created On      : Tue Sep 11 15:00:12 1990
0.000000,0,0.000000,# Last Modified By: Johan Vromans
0.000000,0,0.000000,# Last Modified On: Tue Aug 18 14:48:05 2020
0.000000,0,0.000000,# Update Count    : 1739
0.000000,0,0.000000,# Status          : Released
0.000000,0,0.000000,
0.000000,0,0.000000,################ Module Preamble ################
0.000000,0,0.000000,
0.000055,2,0.000028,use 5.004;
0.000000,0,0.000000,
0.000021,2,0.000010,use strict;
0.000021,2,0.000011,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,package Getopt::Long;
0.000000,0,0.000000,
0.000020,2,0.000010,use vars qw($VERSION);
0.000001,1,0.000001,$VERSION        =  2.52;
0.000000,0,0.000000,# For testing versions only.
0.000015,2,0.000008,use vars qw($VERSION_STRING);
0.000000,1,0.000000,$VERSION_STRING = "2.52";
0.000000,0,0.000000,
0.000017,2,0.000008,use Exporter;
0.000058,2,0.000029,use vars qw(@ISA @EXPORT @EXPORT_OK);
0.000010,1,0.000010,@ISA = qw(Exporter);
0.000000,0,0.000000,
0.000000,0,0.000000,# Exported subroutines.
0.000000,0,0.000000,sub GetOptions(@);		# always
0.000000,0,0.000000,sub GetOptionsFromArray(@);	# on demand
0.000000,0,0.000000,sub GetOptionsFromString(@);	# on demand
0.000000,0,0.000000,sub Configure(@);		# on demand
0.000000,0,0.000000,sub HelpMessage(@);		# on demand
0.000000,0,0.000000,sub VersionMessage(@);		# in demand
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,# Init immediately so their contents can be used in the 'use vars' below.
0.000001,1,0.000001,@EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
0.000003,1,0.000003,@EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
0.000000,0,0.000000,&GetOptionsFromArray &GetOptionsFromString);
0.000013,1,0.000013,}
0.000000,0,0.000000,
0.000000,0,0.000000,# User visible variables.
0.000014,2,0.000007,use vars @EXPORT, @EXPORT_OK;
0.000014,2,0.000007,use vars qw($error $debug $major_version $minor_version);
0.000000,0,0.000000,# Deprecated visible variables.
0.000000,1,0.000000,use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
0.000012,1,0.000012,$passthrough);
0.000000,0,0.000000,# Official invisible variables.
0.000395,2,0.000198,use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
0.000000,0,0.000000,
0.000000,0,0.000000,# Really invisible variables.
0.000000,1,0.000000,my $bundling_values;
0.000000,0,0.000000,
0.000000,0,0.000000,# Public subroutines.
0.000000,0,0.000000,sub config(@);			# deprecated name
0.000000,0,0.000000,
0.000000,0,0.000000,# Private subroutines.
0.000000,0,0.000000,sub ConfigDefaults();
0.000000,0,0.000000,sub ParseOptionSpec($$);
0.000000,0,0.000000,sub OptCtl($);
0.000000,0,0.000000,sub FindOption($$$$$);
0.000000,0,0.000000,sub ValidValue ($$$$$);
0.000000,0,0.000000,
0.000000,0,0.000000,################ Local Variables ################
0.000000,0,0.000000,
0.000000,0,0.000000,# $requested_version holds the version that was mentioned in the 'use'
0.000000,0,0.000000,# or 'require', if any. It can be used to enable or disable specific
0.000000,0,0.000000,# features.
0.000000,1,0.000000,my $requested_version = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,################ Resident subroutines ################
0.000000,0,0.000000,
0.000000,0,0.000000,sub ConfigDefaults() {
0.000000,0,0.000000,# Handle POSIX compliancy.
0.000001,1,0.000001,if ( defined $ENV{"POSIXLY_CORRECT"} ) {
0.000000,0,0.000000,$genprefix = "(--|-)";
0.000000,0,0.000000,$autoabbrev = 0;		# no automatic abbrev of options
0.000000,0,0.000000,$bundling = 0;			# no bundling of single letter switches
0.000000,0,0.000000,$getopt_compat = 0;		# disallow '+' to start options
0.000000,0,0.000000,$order = $REQUIRE_ORDER;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,1,0.000000,$genprefix = "(--|-|\\+)";
0.000000,1,0.000000,$autoabbrev = 1;		# automatic abbrev of options
0.000000,1,0.000000,$bundling = 0;			# bundling off by default
0.000000,1,0.000000,$getopt_compat = 1;		# allow '+' to start options
0.000000,1,0.000000,$order = $PERMUTE;
0.000000,0,0.000000,}
0.000000,0,0.000000,# Other configurable settings.
0.000001,1,0.000001,$debug = 0;			# for debugging
0.000000,1,0.000000,$error = 0;			# error tally
0.000000,1,0.000000,$ignorecase = 1;		# ignore case when matching options
0.000000,1,0.000000,$passthrough = 0;		# leave unrecognized options alone
0.000000,1,0.000000,$gnu_compat = 0;		# require --opt=val if value is optional
0.000000,1,0.000000,$longprefix = "(--)";       # what does a long prefix look like
0.000002,1,0.000002,$bundling_values = 0;	# no bundling of values
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Override import.
0.000000,0,0.000000,sub import {
0.000000,1,0.000000,my $pkg = shift;		# package
0.000000,1,0.000000,my @syms = ();		# symbols to import
0.000000,1,0.000000,my @config = ();		# configuration
0.000000,1,0.000000,my $dest = \@syms;		# symbols first
0.000000,1,0.000000,for ( @_ ) {
0.000001,1,0.000001,if ( $_ eq ':config' ) {
0.000000,0,0.000000,$dest = \@config;	# config next
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,1,0.000000,push(@$dest, $_);	# push
0.000000,0,0.000000,}
0.000000,0,0.000000,# Hide one level and call super.
0.000000,1,0.000000,local $Exporter::ExportLevel = 1;
0.000000,1,0.000000,push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
0.000000,1,0.000000,$requested_version = 0;
0.000003,1,0.000003,$pkg->SUPER::import(@syms);
0.000000,0,0.000000,# And configure.
0.000003,1,0.000003,Configure(@config) if @config;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,################ Initialization ################
0.000000,0,0.000000,
0.000000,0,0.000000,# Values for $order. See GNU getopt.c for details.
0.000001,1,0.000001,($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
0.000000,0,0.000000,# Version major/minor numbers.
0.000031,1,0.000031,($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
0.000000,0,0.000000,
0.000001,1,0.000001,ConfigDefaults();
0.000000,0,0.000000,
0.000000,0,0.000000,################ OO Interface ################
0.000000,0,0.000000,
0.000000,0,0.000000,package Getopt::Long::Parser;
0.000000,0,0.000000,
0.000000,0,0.000000,# Store a copy of the default configuration. Since ConfigDefaults has
0.000000,0,0.000000,# just been called, what we get from Configure is the default.
0.000000,1,0.000000,my $default_config = do {
0.000000,0,0.000000,Getopt::Long::Configure ()
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my $that = shift;
0.000000,0,0.000000,my $class = ref($that) || $that;
0.000000,0,0.000000,my %atts = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Register the callers package.
0.000000,0,0.000000,my $self = { caller_pkg => (caller)[0] };
0.000000,0,0.000000,
0.000000,0,0.000000,bless ($self, $class);
0.000000,0,0.000000,
0.000000,0,0.000000,# Process config attributes.
0.000000,0,0.000000,if ( defined $atts{config} ) {
0.000000,0,0.000000,my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
0.000000,0,0.000000,$self->{settings} = Getopt::Long::Configure ($save);
0.000000,0,0.000000,delete ($atts{config});
0.000000,0,0.000000,}
0.000000,0,0.000000,# Else use default config.
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->{settings} = $default_config;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( %atts ) {		# Oops
0.000000,0,0.000000,die(__PACKAGE__.": unhandled attributes: ".
0.000000,0,0.000000,join(" ", sort(keys(%atts)))."\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub configure {
0.000000,0,0.000000,my ($self) = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Restore settings, merge new settings in.
0.000000,0,0.000000,my $save = Getopt::Long::Configure ($self->{settings}, @_);
0.000000,0,0.000000,
0.000000,0,0.000000,# Restore orig config and save the new config.
0.000000,0,0.000000,$self->{settings} = Getopt::Long::Configure ($save);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getoptions {
0.000000,0,0.000000,my ($self) = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->getoptionsfromarray(\@ARGV, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getoptionsfromarray {
0.000000,0,0.000000,my ($self) = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Restore config settings.
0.000000,0,0.000000,my $save = Getopt::Long::Configure ($self->{settings});
0.000000,0,0.000000,
0.000000,0,0.000000,# Call main routine.
0.000000,0,0.000000,my $ret = 0;
0.000000,0,0.000000,$Getopt::Long::caller = $self->{caller_pkg};
0.000000,0,0.000000,
0.000000,0,0.000000,eval {
0.000000,0,0.000000,# Locally set exception handler to default, otherwise it will
0.000000,0,0.000000,# be called implicitly here, and again explicitly when we try
0.000000,0,0.000000,# to deliver the messages.
0.000000,0,0.000000,local ($SIG{__DIE__}) = 'DEFAULT';
0.000000,0,0.000000,$ret = Getopt::Long::GetOptionsFromArray (@_);
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,# Restore saved settings.
0.000000,0,0.000000,Getopt::Long::Configure ($save);
0.000000,0,0.000000,
0.000000,0,0.000000,# Handle errors and return value.
0.000000,0,0.000000,die ($@) if $@;
0.000000,0,0.000000,return $ret;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,package Getopt::Long;
0.000000,0,0.000000,
0.000000,0,0.000000,################ Back to Normal ################
0.000000,0,0.000000,
0.000000,0,0.000000,# Indices in option control info.
0.000000,0,0.000000,# Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
0.000020,2,0.000010,use constant CTL_TYPE    => 0;
0.000000,0,0.000000,#use constant   CTL_TYPE_FLAG   => '';
0.000000,0,0.000000,#use constant   CTL_TYPE_NEG    => '!';
0.000000,0,0.000000,#use constant   CTL_TYPE_INCR   => '+';
0.000000,0,0.000000,#use constant   CTL_TYPE_INT    => 'i';
0.000000,0,0.000000,#use constant   CTL_TYPE_INTINC => 'I';
0.000000,0,0.000000,#use constant   CTL_TYPE_XINT   => 'o';
0.000000,0,0.000000,#use constant   CTL_TYPE_FLOAT  => 'f';
0.000000,0,0.000000,#use constant   CTL_TYPE_STRING => 's';
0.000000,0,0.000000,
0.000015,2,0.000008,use constant CTL_CNAME   => 1;
0.000000,0,0.000000,
0.000012,2,0.000006,use constant CTL_DEFAULT => 2;
0.000000,0,0.000000,
0.000012,2,0.000006,use constant CTL_DEST    => 3;
0.000011,2,0.000005,use constant   CTL_DEST_SCALAR => 0;
0.000077,2,0.000039,use constant   CTL_DEST_ARRAY  => 1;
0.000038,2,0.000019,use constant   CTL_DEST_HASH   => 2;
0.000015,2,0.000008,use constant   CTL_DEST_CODE   => 3;
0.000000,0,0.000000,
0.000011,2,0.000005,use constant CTL_AMIN    => 4;
0.000016,2,0.000008,use constant CTL_AMAX    => 5;
0.000000,0,0.000000,
0.000000,0,0.000000,# FFU.
0.000000,0,0.000000,#use constant CTL_RANGE   => ;
0.000000,0,0.000000,#use constant CTL_REPEAT  => ;
0.000000,0,0.000000,
0.000000,0,0.000000,# Rather liberal patterns to match numbers.
0.000027,2,0.000013,use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
0.000000,1,0.000000,use constant PAT_XINT  =>
0.000000,0,0.000000,"(?:".
0.000000,0,0.000000,"[-+]?_*[1-9][0-9_]*".
0.000000,0,0.000000,"|".
0.000000,0,0.000000,"0x_*[0-9a-f][0-9a-f_]*".
0.000000,0,0.000000,"|".
0.000000,0,0.000000,"0b_*[01][01_]*".
0.000000,0,0.000000,"|".
0.000000,0,0.000000,"0[0-7_]*".
0.000029,1,0.000029,")";
0.000000,1,0.000000,use constant PAT_FLOAT =>
0.000000,0,0.000000,"[-+]?".			# optional sign
0.000000,0,0.000000,"(?=[0-9.])".			# must start with digit or dec.point
0.000000,0,0.000000,"[0-9_]*".			# digits before the dec.point
0.000000,0,0.000000,"(\.[0-9_]+)?".		# optional fraction
0.004482,1,0.004482,"([eE][-+]?[0-9_]+)?";	# optional exponent
0.000000,0,0.000000,
0.000000,0,0.000000,sub GetOptions(@) {
0.000000,0,0.000000,# Shift in default array.
0.000000,0,0.000000,unshift(@_, \@ARGV);
0.000000,0,0.000000,# Try to keep caller() and Carp consistent.
0.000000,0,0.000000,goto &GetOptionsFromArray;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub GetOptionsFromString(@) {
0.000000,0,0.000000,my ($string) = shift;
0.000000,0,0.000000,require Text::ParseWords;
0.000000,0,0.000000,my $args = [ Text::ParseWords::shellwords($string) ];
0.000000,0,0.000000,$caller ||= (caller)[0];	# current context
0.000000,0,0.000000,my $ret = GetOptionsFromArray($args, @_);
0.000000,0,0.000000,return ( $ret, $args ) if wantarray;
0.000000,0,0.000000,if ( @$args ) {
0.000000,0,0.000000,$ret = 0;
0.000000,0,0.000000,warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,$ret;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub GetOptionsFromArray(@) {
0.000000,0,0.000000,
0.000000,0,0.000000,my ($argv, @optionlist) = @_;	# local copy of the option descriptions
0.000000,0,0.000000,my $argend = '--';		# option list terminator
0.000000,0,0.000000,my %opctl = ();		# table of option specs
0.000000,0,0.000000,my $pkg = $caller || (caller)[0];	# current context
0.000000,0,0.000000,# Needed if linkage is omitted.
0.000000,0,0.000000,my @ret = ();		# accum for non-options
0.000000,0,0.000000,my %linkage;		# linkage
0.000000,0,0.000000,my $userlinkage;		# user supplied HASH
0.000000,0,0.000000,my $opt;			# current option
0.000000,0,0.000000,my $prefix = $genprefix;	# current prefix
0.000000,0,0.000000,
0.000000,0,0.000000,$error = '';
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $debug ) {
0.000000,0,0.000000,# Avoid some warnings if debugging.
0.000000,0,0.000000,local ($^W) = 0;
0.000000,0,0.000000,print STDERR
0.000000,0,0.000000,("Getopt::Long $Getopt::Long::VERSION_STRING ",
0.000000,0,0.000000,"called from package \"$pkg\".",
0.000000,0,0.000000,"\n  ",
0.000000,0,0.000000,"argv: ",
0.000000,0,0.000000,defined($argv)
0.000000,0,0.000000,? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
0.000000,0,0.000000,: "<undef>",
0.000000,0,0.000000,"\n  ",
0.000000,0,0.000000,"autoabbrev=$autoabbrev,".
0.000000,0,0.000000,"bundling=$bundling,",
0.000000,0,0.000000,"bundling_values=$bundling_values,",
0.000000,0,0.000000,"getopt_compat=$getopt_compat,",
0.000000,0,0.000000,"gnu_compat=$gnu_compat,",
0.000000,0,0.000000,"order=$order,",
0.000000,0,0.000000,"\n  ",
0.000000,0,0.000000,"ignorecase=$ignorecase,",
0.000000,0,0.000000,"requested_version=$requested_version,",
0.000000,0,0.000000,"passthrough=$passthrough,",
0.000000,0,0.000000,"genprefix=\"$genprefix\",",
0.000000,0,0.000000,"longprefix=\"$longprefix\".",
0.000000,0,0.000000,"\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Check for ref HASH as first argument.
0.000000,0,0.000000,# First argument may be an object. It's OK to use this as long
0.000000,0,0.000000,# as it is really a hash underneath.
0.000000,0,0.000000,$userlinkage = undef;
0.000000,0,0.000000,if ( @optionlist && ref($optionlist[0]) and
0.000000,0,0.000000,UNIVERSAL::isa($optionlist[0],'HASH') ) {
0.000000,0,0.000000,$userlinkage = shift (@optionlist);
0.000000,0,0.000000,print STDERR ("=> user linkage: $userlinkage\n") if $debug;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# See if the first element of the optionlist contains option
0.000000,0,0.000000,# starter characters.
0.000000,0,0.000000,# Be careful not to interpret '<>' as option starters.
0.000000,0,0.000000,if ( @optionlist && $optionlist[0] =~ /^\W+$/
0.000000,0,0.000000,&& !($optionlist[0] eq '<>'
0.000000,0,0.000000,&& @optionlist > 0
0.000000,0,0.000000,&& ref($optionlist[1])) ) {
0.000000,0,0.000000,$prefix = shift (@optionlist);
0.000000,0,0.000000,# Turn into regexp. Needs to be parenthesized!
0.000000,0,0.000000,$prefix =~ s/(\W)/\\$1/g;
0.000000,0,0.000000,$prefix = "([" . $prefix . "])";
0.000000,0,0.000000,print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Verify correctness of optionlist.
0.000000,0,0.000000,%opctl = ();
0.000000,0,0.000000,while ( @optionlist ) {
0.000000,0,0.000000,my $opt = shift (@optionlist);
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( defined($opt) ) {
0.000000,0,0.000000,$error .= "Undefined argument in option spec\n";
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Strip leading prefix so people can specify "--foo=i" if they like.
0.000000,0,0.000000,$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $opt eq '<>' ) {
0.000000,0,0.000000,if ( (defined $userlinkage)
0.000000,0,0.000000,&& !(@optionlist > 0 && ref($optionlist[0]))
0.000000,0,0.000000,&& (exists $userlinkage->{$opt})
0.000000,0,0.000000,&& ref($userlinkage->{$opt}) ) {
0.000000,0,0.000000,unshift (@optionlist, $userlinkage->{$opt});
0.000000,0,0.000000,}
0.000000,0,0.000000,unless ( @optionlist > 0
0.000000,0,0.000000,&& ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
0.000000,0,0.000000,$error .= "Option spec <> requires a reference to a subroutine\n";
0.000000,0,0.000000,# Kill the linkage (to avoid another error).
0.000000,0,0.000000,shift (@optionlist)
0.000000,0,0.000000,if @optionlist && ref($optionlist[0]);
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,$linkage{'<>'} = shift (@optionlist);
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Parse option spec.
0.000000,0,0.000000,my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
0.000000,0,0.000000,unless ( defined $name ) {
0.000000,0,0.000000,# Failed. $orig contains the error message. Sorry for the abuse.
0.000000,0,0.000000,$error .= $orig;
0.000000,0,0.000000,# Kill the linkage (to avoid another error).
0.000000,0,0.000000,shift (@optionlist)
0.000000,0,0.000000,if @optionlist && ref($optionlist[0]);
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# If no linkage is supplied in the @optionlist, copy it from
0.000000,0,0.000000,# the userlinkage if available.
0.000000,0,0.000000,if ( defined $userlinkage ) {
0.000000,0,0.000000,unless ( @optionlist > 0 && ref($optionlist[0]) ) {
0.000000,0,0.000000,if ( exists $userlinkage->{$orig} &&
0.000000,0,0.000000,ref($userlinkage->{$orig}) ) {
0.000000,0,0.000000,print STDERR ("=> found userlinkage for \"$orig\": ",
0.000000,0,0.000000,"$userlinkage->{$orig}\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,unshift (@optionlist, $userlinkage->{$orig});
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# Do nothing. Being undefined will be handled later.
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Copy the linkage. If omitted, link to global variable.
0.000000,0,0.000000,if ( @optionlist > 0 && ref($optionlist[0]) ) {
0.000000,0,0.000000,print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,my $rl = ref($linkage{$orig} = shift (@optionlist));
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $rl eq "ARRAY" ) {
0.000000,0,0.000000,$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $rl eq "HASH" ) {
0.000000,0,0.000000,$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
0.000000,0,0.000000,#		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
0.000000,0,0.000000,#		    my $t = $linkage{$orig};
0.000000,0,0.000000,#		    $$t = $linkage{$orig} = [];
0.000000,0,0.000000,#		}
0.000000,0,0.000000,#		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
0.000000,0,0.000000,#		}
0.000000,0,0.000000,#		else {
0.000000,0,0.000000,# Ok.
0.000000,0,0.000000,#		}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $rl eq "CODE" ) {
0.000000,0,0.000000,# Ok.
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$error .= "Invalid option linkage for \"$opt\"\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# Link to global $opt_XXX variable.
0.000000,0,0.000000,# Make sure a valid perl identifier results.
0.000000,0,0.000000,my $ov = $orig;
0.000000,0,0.000000,$ov =~ s/\W/_/g;
0.000000,0,0.000000,if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
0.000000,0,0.000000,print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
0.000000,0,0.000000,print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $opctl{$name}[CTL_TYPE] eq 'I'
0.000000,0,0.000000,&& ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
0.000000,0,0.000000,|| $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
0.000000,0,0.000000,) {
0.000000,0,0.000000,$error .= "Invalid option linkage for \"$opt\"\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
0.000000,0,0.000000,unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
0.000000,0,0.000000,
0.000000,0,0.000000,# Bail out if errors found.
0.000000,0,0.000000,die ($error) if $error;
0.000000,0,0.000000,$error = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,# Supply --version and --help support, if needed and allowed.
0.000000,0,0.000000,if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
0.000000,0,0.000000,if ( !defined($opctl{version}) ) {
0.000000,0,0.000000,$opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
0.000000,0,0.000000,$linkage{version} = \&VersionMessage;
0.000000,0,0.000000,}
0.000000,0,0.000000,$auto_version = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
0.000000,0,0.000000,if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
0.000000,0,0.000000,$opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
0.000000,0,0.000000,$linkage{help} = \&HelpMessage;
0.000000,0,0.000000,}
0.000000,0,0.000000,$auto_help = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Show the options tables if debugging.
0.000000,0,0.000000,if ( $debug ) {
0.000000,0,0.000000,my ($arrow, $k, $v);
0.000000,0,0.000000,$arrow = "=> ";
0.000000,0,0.000000,while ( ($k,$v) = each(%opctl) ) {
0.000000,0,0.000000,print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
0.000000,0,0.000000,$arrow = "   ";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Process argument list
0.000000,0,0.000000,my $goon = 1;
0.000000,0,0.000000,while ( $goon && @$argv > 0 ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Get next argument.
0.000000,0,0.000000,$opt = shift (@$argv);
0.000000,0,0.000000,print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
0.000000,0,0.000000,
0.000000,0,0.000000,# Double dash is option list terminator.
0.000000,0,0.000000,if ( defined($opt) && $opt eq $argend ) {
0.000000,0,0.000000,push (@ret, $argend) if $passthrough;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Look it up.
0.000000,0,0.000000,my $tryopt = $opt;
0.000000,0,0.000000,my $found;		# success status
0.000000,0,0.000000,my $key;		# key (if hash type)
0.000000,0,0.000000,my $arg;		# option argument
0.000000,0,0.000000,my $ctl;		# the opctl entry
0.000000,0,0.000000,
0.000000,0,0.000000,($found, $opt, $ctl, $arg, $key) =
0.000000,0,0.000000,FindOption ($argv, $prefix, $argend, $opt, \%opctl);
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $found ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# FindOption undefines $opt in case of errors.
0.000000,0,0.000000,next unless defined $opt;
0.000000,0,0.000000,
0.000000,0,0.000000,my $argcnt = 0;
0.000000,0,0.000000,while ( defined $arg ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Get the canonical name.
0.000000,0,0.000000,my $given = $opt;
0.000000,0,0.000000,print STDERR ("=> cname for \"$opt\" is ") if $debug;
0.000000,0,0.000000,$opt = $ctl->[CTL_CNAME];
0.000000,0,0.000000,print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( defined $linkage{$opt} ) {
0.000000,0,0.000000,print STDERR ("=> ref(\$L{$opt}) -> ",
0.000000,0,0.000000,ref($linkage{$opt}), "\n") if $debug;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ref($linkage{$opt}) eq 'SCALAR'
0.000000,0,0.000000,|| ref($linkage{$opt}) eq 'REF' ) {
0.000000,0,0.000000,if ( $ctl->[CTL_TYPE] eq '+' ) {
0.000000,0,0.000000,print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,if ( defined ${$linkage{$opt}} ) {
0.000000,0,0.000000,${$linkage{$opt}} += $arg;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,${$linkage{$opt}} = $arg;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
0.000000,0,0.000000,print STDERR ("=> ref(\$L{$opt}) auto-vivified",
0.000000,0,0.000000," to ARRAY\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,my $t = $linkage{$opt};
0.000000,0,0.000000,$$t = $linkage{$opt} = [];
0.000000,0,0.000000,print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,push (@{$linkage{$opt}}, $arg);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
0.000000,0,0.000000,print STDERR ("=> ref(\$L{$opt}) auto-vivified",
0.000000,0,0.000000," to HASH\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,my $t = $linkage{$opt};
0.000000,0,0.000000,$$t = $linkage{$opt} = {};
0.000000,0,0.000000,print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,$linkage{$opt}->{$key} = $arg;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,${$linkage{$opt}} = $arg;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
0.000000,0,0.000000,print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,push (@{$linkage{$opt}}, $arg);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( ref($linkage{$opt}) eq 'HASH' ) {
0.000000,0,0.000000,print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,$linkage{$opt}->{$key} = $arg;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( ref($linkage{$opt}) eq 'CODE' ) {
0.000000,0,0.000000,print STDERR ("=> &L{$opt}(\"$opt\"",
0.000000,0,0.000000,$ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
0.000000,0,0.000000,", \"$arg\")\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,my $eval_error = do {
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,local $SIG{__DIE__}  = 'DEFAULT';
0.000000,0,0.000000,eval {
0.000000,0,0.000000,&{$linkage{$opt}}
0.000000,0,0.000000,(Getopt::Long::CallBack->new
0.000000,0,0.000000,(name    => $opt,
0.000000,0,0.000000,given   => $given,
0.000000,0,0.000000,ctl     => $ctl,
0.000000,0,0.000000,opctl   => \%opctl,
0.000000,0,0.000000,linkage => \%linkage,
0.000000,0,0.000000,prefix  => $prefix,
0.000000,0,0.000000,),
0.000000,0,0.000000,$ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
0.000000,0,0.000000,$arg);
0.000000,0,0.000000,};
0.000000,0,0.000000,$@;
0.000000,0,0.000000,};
0.000000,0,0.000000,print STDERR ("=> die($eval_error)\n")
0.000000,0,0.000000,if $debug && $eval_error ne '';
0.000000,0,0.000000,if ( $eval_error =~ /^!/ ) {
0.000000,0,0.000000,if ( $eval_error =~ /^!FINISH\b/ ) {
0.000000,0,0.000000,$goon = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $eval_error ne '' ) {
0.000000,0,0.000000,warn ($eval_error);
0.000000,0,0.000000,$error++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
0.000000,0,0.000000,"\" in linkage\n");
0.000000,0,0.000000,die("Getopt::Long -- internal error!\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,# No entry in linkage means entry in userlinkage.
0.000000,0,0.000000,elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
0.000000,0,0.000000,if ( defined $userlinkage->{$opt} ) {
0.000000,0,0.000000,print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,push (@{$userlinkage->{$opt}}, $arg);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,$userlinkage->{$opt} = [$arg];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
0.000000,0,0.000000,if ( defined $userlinkage->{$opt} ) {
0.000000,0,0.000000,print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,$userlinkage->{$opt}->{$key} = $arg;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,$userlinkage->{$opt} = {$key => $arg};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ( $ctl->[CTL_TYPE] eq '+' ) {
0.000000,0,0.000000,print STDERR ("=> \$L{$opt} += \"$arg\"\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,if ( defined $userlinkage->{$opt} ) {
0.000000,0,0.000000,$userlinkage->{$opt} += $arg;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$userlinkage->{$opt} = $arg;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
0.000000,0,0.000000,$userlinkage->{$opt} = $arg;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$argcnt++;
0.000000,0,0.000000,last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
0.000000,0,0.000000,undef($arg);
0.000000,0,0.000000,
0.000000,0,0.000000,# Need more args?
0.000000,0,0.000000,if ( $argcnt < $ctl->[CTL_AMIN] ) {
0.000000,0,0.000000,if ( @$argv ) {
0.000000,0,0.000000,if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
0.000000,0,0.000000,$arg = shift(@$argv);
0.000000,0,0.000000,if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
0.000000,0,0.000000,$arg =~ tr/_//d;
0.000000,0,0.000000,$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
0.000000,0,0.000000,? oct($arg)
0.000000,0,0.000000,: 0+$arg
0.000000,0,0.000000,}
0.000000,0,0.000000,($key,$arg) = $arg =~ /^([^=]+)=(.*)/
0.000000,0,0.000000,if $ctl->[CTL_DEST] == CTL_DEST_HASH;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,warn("Value \"$$argv[0]\" invalid for option $opt\n");
0.000000,0,0.000000,$error++;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,warn("Insufficient arguments for option $opt\n");
0.000000,0,0.000000,$error++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Any more args?
0.000000,0,0.000000,if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
0.000000,0,0.000000,$arg = shift(@$argv);
0.000000,0,0.000000,if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
0.000000,0,0.000000,$arg =~ tr/_//d;
0.000000,0,0.000000,$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
0.000000,0,0.000000,? oct($arg)
0.000000,0,0.000000,: 0+$arg
0.000000,0,0.000000,}
0.000000,0,0.000000,($key,$arg) = $arg =~ /^([^=]+)=(.*)/
0.000000,0,0.000000,if $ctl->[CTL_DEST] == CTL_DEST_HASH;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Not an option. Save it if we $PERMUTE and don't have a <>.
0.000000,0,0.000000,elsif ( $order == $PERMUTE ) {
0.000000,0,0.000000,# Try non-options call-back.
0.000000,0,0.000000,my $cb;
0.000000,0,0.000000,if ( defined ($cb = $linkage{'<>'}) ) {
0.000000,0,0.000000,print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,my $eval_error = do {
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,local $SIG{__DIE__}  = 'DEFAULT';
0.000000,0,0.000000,eval {
0.000000,0,0.000000,# The arg to <> cannot be the CallBack object
0.000000,0,0.000000,# since it may be passed to other modules that
0.000000,0,0.000000,# get confused (e.g., Archive::Tar). Well,
0.000000,0,0.000000,# it's not relevant for this callback anyway.
0.000000,0,0.000000,&$cb($tryopt);
0.000000,0,0.000000,};
0.000000,0,0.000000,$@;
0.000000,0,0.000000,};
0.000000,0,0.000000,print STDERR ("=> die($eval_error)\n")
0.000000,0,0.000000,if $debug && $eval_error ne '';
0.000000,0,0.000000,if ( $eval_error =~ /^!/ ) {
0.000000,0,0.000000,if ( $eval_error =~ /^!FINISH\b/ ) {
0.000000,0,0.000000,$goon = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $eval_error ne '' ) {
0.000000,0,0.000000,warn ($eval_error);
0.000000,0,0.000000,$error++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,print STDERR ("=> saving \"$tryopt\" ",
0.000000,0,0.000000,"(not an option, may permute)\n") if $debug;
0.000000,0,0.000000,push (@ret, $tryopt);
0.000000,0,0.000000,}
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# ...otherwise, terminate.
0.000000,0,0.000000,else {
0.000000,0,0.000000,# Push this one back and exit.
0.000000,0,0.000000,unshift (@$argv, $tryopt);
0.000000,0,0.000000,return ($error == 0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Finish.
0.000000,0,0.000000,if ( @ret && ( $order == $PERMUTE || $passthrough ) ) {
0.000000,0,0.000000,#  Push back accumulated arguments
0.000000,0,0.000000,print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,unshift (@$argv, @ret);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ($error == 0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# A readable representation of what's in an optbl.
0.000000,0,0.000000,sub OptCtl ($) {
0.000000,0,0.000000,my ($v) = @_;
0.000000,0,0.000000,my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
0.000000,0,0.000000,"[".
0.000000,0,0.000000,join(",",
0.000000,0,0.000000,"\"$v[CTL_TYPE]\"",
0.000000,0,0.000000,"\"$v[CTL_CNAME]\"",
0.000000,0,0.000000,"\"$v[CTL_DEFAULT]\"",
0.000000,0,0.000000,("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
0.000000,0,0.000000,$v[CTL_AMIN] || '',
0.000000,0,0.000000,$v[CTL_AMAX] || '',
0.000000,0,0.000000,#	   $v[CTL_RANGE] || '',
0.000000,0,0.000000,#	   $v[CTL_REPEAT] || '',
0.000000,0,0.000000,). "]";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Parse an option specification and fill the tables.
0.000000,0,0.000000,sub ParseOptionSpec ($$) {
0.000000,0,0.000000,my ($opt, $opctl) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Match option spec.
0.000000,0,0.000000,if ( $opt !~ m;^
0.000000,0,0.000000,(
0.000000,0,0.000000,# Option name
0.000000,0,0.000000,(?: \w+[-\w]* )
0.000000,0,0.000000,# Aliases
0.000000,0,0.000000,(?: \| (?: . [^|!+=:]* )? )*
0.000000,0,0.000000,)?
0.000000,0,0.000000,(
0.000000,0,0.000000,# Either modifiers ...
0.000000,0,0.000000,[!+]
0.000000,0,0.000000,|
0.000000,0,0.000000,# ... or a value/dest/repeat specification
0.000000,0,0.000000,[=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
0.000000,0,0.000000,|
0.000000,0,0.000000,# ... or an optional-with-default spec
0.000000,0,0.000000,: (?: -?\d+ | \+ ) [@%]?
0.000000,0,0.000000,)?
0.000000,0,0.000000,$;x ) {
0.000000,0,0.000000,return (undef, "Error in option spec: \"$opt\"\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my ($names, $spec) = ($1, $2);
0.000000,0,0.000000,$spec = '' unless defined $spec;
0.000000,0,0.000000,
0.000000,0,0.000000,# $orig keeps track of the primary name the user specified.
0.000000,0,0.000000,# This name will be used for the internal or external linkage.
0.000000,0,0.000000,# In other words, if the user specifies "FoO|BaR", it will
0.000000,0,0.000000,# match any case combinations of 'foo' and 'bar', but if a global
0.000000,0,0.000000,# variable needs to be set, it will be $opt_FoO in the exact case
0.000000,0,0.000000,# as specified.
0.000000,0,0.000000,my $orig;
0.000000,0,0.000000,
0.000000,0,0.000000,my @names;
0.000000,0,0.000000,if ( defined $names ) {
0.000000,0,0.000000,@names =  split (/\|/, $names);
0.000000,0,0.000000,$orig = $names[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,@names = ('');
0.000000,0,0.000000,$orig = '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Construct the opctl entries.
0.000000,0,0.000000,my $entry;
0.000000,0,0.000000,if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
0.000000,0,0.000000,# Fields are hard-wired here.
0.000000,0,0.000000,$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
0.000000,0,0.000000,my $def = $1;
0.000000,0,0.000000,my $dest = $2;
0.000000,0,0.000000,my $type = $def eq '+' ? 'I' : 'i';
0.000000,0,0.000000,$dest ||= '$';
0.000000,0,0.000000,$dest = $dest eq '@' ? CTL_DEST_ARRAY
0.000000,0,0.000000,: $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
0.000000,0,0.000000,# Fields are hard-wired here.
0.000000,0,0.000000,$entry = [$type,$orig,$def eq '+' ? undef : $def,
0.000000,0,0.000000,$dest,0,1];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my ($mand, $type, $dest) =
0.000000,0,0.000000,$spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
0.000000,0,0.000000,return (undef, "Cannot repeat while bundling: \"$opt\"\n")
0.000000,0,0.000000,if $bundling && defined($4);
0.000000,0,0.000000,my ($mi, $cm, $ma) = ($5, $6, $7);
0.000000,0,0.000000,return (undef, "{0} is useless in option spec: \"$opt\"\n")
0.000000,0,0.000000,if defined($mi) && !$mi && !defined($ma) && !defined($cm);
0.000000,0,0.000000,
0.000000,0,0.000000,$type = 'i' if $type eq 'n';
0.000000,0,0.000000,$dest ||= '$';
0.000000,0,0.000000,$dest = $dest eq '@' ? CTL_DEST_ARRAY
0.000000,0,0.000000,: $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
0.000000,0,0.000000,# Default minargs to 1/0 depending on mand status.
0.000000,0,0.000000,$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
0.000000,0,0.000000,# Adjust mand status according to minargs.
0.000000,0,0.000000,$mand = $mi ? '=' : ':';
0.000000,0,0.000000,# Adjust maxargs.
0.000000,0,0.000000,$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
0.000000,0,0.000000,return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
0.000000,0,0.000000,if defined($ma) && !$ma;
0.000000,0,0.000000,return (undef, "Max less than min in option spec: \"$opt\"\n")
0.000000,0,0.000000,if defined($ma) && $ma < $mi;
0.000000,0,0.000000,
0.000000,0,0.000000,# Fields are hard-wired here.
0.000000,0,0.000000,$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Process all names. First is canonical, the rest are aliases.
0.000000,0,0.000000,my $dups = '';
0.000000,0,0.000000,foreach ( @names ) {
0.000000,0,0.000000,
0.000000,0,0.000000,$_ = lc ($_)
0.000000,0,0.000000,if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
0.000000,0,0.000000,
0.000000,0,0.000000,if ( exists $opctl->{$_} ) {
0.000000,0,0.000000,$dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $spec eq '!' ) {
0.000000,0,0.000000,$opctl->{"no$_"} = $entry;
0.000000,0,0.000000,$opctl->{"no-$_"} = $entry;
0.000000,0,0.000000,$opctl->{$_} = [@$entry];
0.000000,0,0.000000,$opctl->{$_}->[CTL_TYPE] = '';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$opctl->{$_} = $entry;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $dups && $^W ) {
0.000000,0,0.000000,foreach ( split(/\n+/, $dups) ) {
0.000000,0,0.000000,warn($_."\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,($names[0], $orig);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Option lookup.
0.000000,0,0.000000,sub FindOption ($$$$$) {
0.000000,0,0.000000,
0.000000,0,0.000000,# returns (1, $opt, $ctl, $arg, $key) if okay,
0.000000,0,0.000000,# returns (1, undef) if option in error,
0.000000,0,0.000000,# returns (0) otherwise.
0.000000,0,0.000000,
0.000000,0,0.000000,my ($argv, $prefix, $argend, $opt, $opctl) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,print STDERR ("=> find \"$opt\"\n") if $debug;
0.000000,0,0.000000,
0.000000,0,0.000000,return (0) unless defined($opt);
0.000000,0,0.000000,return (0) unless $opt =~ /^($prefix)(.*)$/s;
0.000000,0,0.000000,return (0) if $opt eq "-" && !defined $opctl->{''};
0.000000,0,0.000000,
0.000000,0,0.000000,$opt = substr( $opt, length($1) ); # retain taintedness
0.000000,0,0.000000,my $starter = $1;
0.000000,0,0.000000,
0.000000,0,0.000000,print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
0.000000,0,0.000000,
0.000000,0,0.000000,my $optarg;			# value supplied with --opt=value
0.000000,0,0.000000,my $rest;			# remainder from unbundling
0.000000,0,0.000000,
0.000000,0,0.000000,# If it is a long option, it may include the value.
0.000000,0,0.000000,# With getopt_compat, only if not bundling.
0.000000,0,0.000000,if ( ($starter=~/^$longprefix$/
0.000000,0,0.000000,|| ($getopt_compat && ($bundling == 0 || $bundling == 2)))
0.000000,0,0.000000,&& (my $oppos = index($opt, '=', 1)) > 0) {
0.000000,0,0.000000,my $optorg = $opt;
0.000000,0,0.000000,$opt = substr($optorg, 0, $oppos);
0.000000,0,0.000000,$optarg = substr($optorg, $oppos + 1); # retain tainedness
0.000000,0,0.000000,print STDERR ("=> option \"", $opt,
0.000000,0,0.000000,"\", optarg = \"$optarg\"\n") if $debug;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#### Look it up ###
0.000000,0,0.000000,
0.000000,0,0.000000,my $tryopt = $opt;		# option to try
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# To try overrides, obey case ignore.
0.000000,0,0.000000,$tryopt = $ignorecase ? lc($opt) : $opt;
0.000000,0,0.000000,
0.000000,0,0.000000,# If bundling == 2, long options can override bundles.
0.000000,0,0.000000,if ( $bundling == 2 && length($tryopt) > 1
0.000000,0,0.000000,&& defined ($opctl->{$tryopt}) ) {
0.000000,0,0.000000,print STDERR ("=> $starter$tryopt overrides unbundling\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# If bundling_values, option may be followed by the value.
0.000000,0,0.000000,elsif ( $bundling_values ) {
0.000000,0,0.000000,$tryopt = $opt;
0.000000,0,0.000000,# Unbundle single letter option.
0.000000,0,0.000000,$rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
0.000000,0,0.000000,$tryopt = substr ($tryopt, 0, 1);
0.000000,0,0.000000,$tryopt = lc ($tryopt) if $ignorecase > 1;
0.000000,0,0.000000,print STDERR ("=> $starter$tryopt unbundled from ",
0.000000,0,0.000000,"$starter$tryopt$rest\n") if $debug;
0.000000,0,0.000000,# Whatever remains may not be considered an option.
0.000000,0,0.000000,$optarg = $rest eq '' ? undef : $rest;
0.000000,0,0.000000,$rest = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Split off a single letter and leave the rest for
0.000000,0,0.000000,# further processing.
0.000000,0,0.000000,else {
0.000000,0,0.000000,$tryopt = $opt;
0.000000,0,0.000000,# Unbundle single letter option.
0.000000,0,0.000000,$rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
0.000000,0,0.000000,$tryopt = substr ($tryopt, 0, 1);
0.000000,0,0.000000,$tryopt = lc ($tryopt) if $ignorecase > 1;
0.000000,0,0.000000,print STDERR ("=> $starter$tryopt unbundled from ",
0.000000,0,0.000000,"$starter$tryopt$rest\n") if $debug;
0.000000,0,0.000000,$rest = undef unless $rest ne '';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Try auto-abbreviation.
0.000000,0,0.000000,elsif ( $autoabbrev && $opt ne "" ) {
0.000000,0,0.000000,# Sort the possible long option names.
0.000000,0,0.000000,my @names = sort(keys (%$opctl));
0.000000,0,0.000000,# Downcase if allowed.
0.000000,0,0.000000,$opt = lc ($opt) if $ignorecase;
0.000000,0,0.000000,$tryopt = $opt;
0.000000,0,0.000000,# Turn option name into pattern.
0.000000,0,0.000000,my $pat = quotemeta ($opt);
0.000000,0,0.000000,# Look up in option names.
0.000000,0,0.000000,my @hits = grep (/^$pat/, @names);
0.000000,0,0.000000,print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
0.000000,0,0.000000,"out of ", scalar(@names), "\n") if $debug;
0.000000,0,0.000000,
0.000000,0,0.000000,# Check for ambiguous results.
0.000000,0,0.000000,unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
0.000000,0,0.000000,# See if all matches are for the same option.
0.000000,0,0.000000,my %hit;
0.000000,0,0.000000,foreach ( @hits ) {
0.000000,0,0.000000,my $hit = $opctl->{$_}->[CTL_CNAME]
0.000000,0,0.000000,if defined $opctl->{$_}->[CTL_CNAME];
0.000000,0,0.000000,$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
0.000000,0,0.000000,$hit{$hit} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,# Remove auto-supplied options (version, help).
0.000000,0,0.000000,if ( keys(%hit) == 2 ) {
0.000000,0,0.000000,if ( $auto_version && exists($hit{version}) ) {
0.000000,0,0.000000,delete $hit{version};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $auto_help && exists($hit{help}) ) {
0.000000,0,0.000000,delete $hit{help};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,# Now see if it really is ambiguous.
0.000000,0,0.000000,unless ( keys(%hit) == 1 ) {
0.000000,0,0.000000,return (0) if $passthrough;
0.000000,0,0.000000,warn ("Option ", $opt, " is ambiguous (",
0.000000,0,0.000000,join(", ", @hits), ")\n");
0.000000,0,0.000000,$error++;
0.000000,0,0.000000,return (1, undef);
0.000000,0,0.000000,}
0.000000,0,0.000000,@hits = keys(%hit);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Complete the option name, if appropriate.
0.000000,0,0.000000,if ( @hits == 1 && $hits[0] ne $opt ) {
0.000000,0,0.000000,$tryopt = $hits[0];
0.000000,0,0.000000,$tryopt = lc ($tryopt)
0.000000,0,0.000000,if $ignorecase > (($bundling && length($tryopt) == 1) ? 1 : 0);
0.000000,0,0.000000,print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
0.000000,0,0.000000,if $debug;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Map to all lowercase if ignoring case.
0.000000,0,0.000000,elsif ( $ignorecase ) {
0.000000,0,0.000000,$tryopt = lc ($opt);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Check validity by fetching the info.
0.000000,0,0.000000,my $ctl = $opctl->{$tryopt};
0.000000,0,0.000000,unless  ( defined $ctl ) {
0.000000,0,0.000000,return (0) if $passthrough;
0.000000,0,0.000000,# Pretend one char when bundling.
0.000000,0,0.000000,if ( $bundling == 1 && length($starter) == 1 ) {
0.000000,0,0.000000,$opt = substr($opt,0,1);
0.000000,0,0.000000,unshift (@$argv, $starter.$rest) if defined $rest;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( $opt eq "" ) {
0.000000,0,0.000000,warn ("Missing option after ", $starter, "\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,warn ("Unknown option: ", $opt, "\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,$error++;
0.000000,0,0.000000,return (1, undef);
0.000000,0,0.000000,}
0.000000,0,0.000000,# Apparently valid.
0.000000,0,0.000000,$opt = $tryopt;
0.000000,0,0.000000,print STDERR ("=> found ", OptCtl($ctl),
0.000000,0,0.000000," for \"", $opt, "\"\n") if $debug;
0.000000,0,0.000000,
0.000000,0,0.000000,#### Determine argument status ####
0.000000,0,0.000000,
0.000000,0,0.000000,# If it is an option w/o argument, we're almost finished with it.
0.000000,0,0.000000,my $type = $ctl->[CTL_TYPE];
0.000000,0,0.000000,my $arg;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $type eq '' || $type eq '!' || $type eq '+' ) {
0.000000,0,0.000000,if ( defined $optarg ) {
0.000000,0,0.000000,return (0) if $passthrough;
0.000000,0,0.000000,warn ("Option ", $opt, " does not take an argument\n");
0.000000,0,0.000000,$error++;
0.000000,0,0.000000,undef $opt;
0.000000,0,0.000000,undef $optarg if $bundling_values;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $type eq '' || $type eq '+' ) {
0.000000,0,0.000000,# Supply explicit value.
0.000000,0,0.000000,$arg = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$opt =~ s/^no-?//i;	# strip NO prefix
0.000000,0,0.000000,$arg = 0;		# supply explicit value
0.000000,0,0.000000,}
0.000000,0,0.000000,unshift (@$argv, $starter.$rest) if defined $rest;
0.000000,0,0.000000,return (1, $opt, $ctl, $arg);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Get mandatory status and type info.
0.000000,0,0.000000,my $mand = $ctl->[CTL_AMIN];
0.000000,0,0.000000,
0.000000,0,0.000000,# Check if there is an option argument available.
0.000000,0,0.000000,if ( $gnu_compat ) {
0.000000,0,0.000000,my $optargtype = 0; # none, 1 = empty, 2 = nonempty, 3 = aux
0.000000,0,0.000000,if ( defined($optarg) ) {
0.000000,0,0.000000,$optargtype = (length($optarg) == 0) ? 1 : 2;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( defined $rest || @$argv > 0 ) {
0.000000,0,0.000000,# GNU getopt_long() does not accept the (optional)
0.000000,0,0.000000,# argument to be passed to the option without = sign.
0.000000,0,0.000000,# We do, since not doing so breaks existing scripts.
0.000000,0,0.000000,$optargtype = 3;
0.000000,0,0.000000,}
0.000000,0,0.000000,if(($optargtype == 0) && !$mand) {
0.000000,0,0.000000,if ( $type eq 'I' ) {
0.000000,0,0.000000,# Fake incremental type.
0.000000,0,0.000000,my @c = @$ctl;
0.000000,0,0.000000,$c[CTL_TYPE] = '+';
0.000000,0,0.000000,return (1, $opt, \@c, 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,my $val
0.000000,0,0.000000,= defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT]
0.000000,0,0.000000,: $type eq 's'                 ? ''
0.000000,0,0.000000,:                                0;
0.000000,0,0.000000,return (1, $opt, $ctl, $val);
0.000000,0,0.000000,}
0.000000,0,0.000000,return (1, $opt, $ctl, $type eq 's' ? '' : 0)
0.000000,0,0.000000,if $optargtype == 1;  # --foo=  -> return nothing
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Check if there is an option argument available.
0.000000,0,0.000000,if ( defined $optarg
0.000000,0,0.000000,? ($optarg eq '')
0.000000,0,0.000000,: !(defined $rest || @$argv > 0) ) {
0.000000,0,0.000000,# Complain if this option needs an argument.
0.000000,0,0.000000,#	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
0.000000,0,0.000000,if ( $mand || $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
0.000000,0,0.000000,return (0) if $passthrough;
0.000000,0,0.000000,warn ("Option ", $opt, " requires an argument\n");
0.000000,0,0.000000,$error++;
0.000000,0,0.000000,return (1, undef);
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( $type eq 'I' ) {
0.000000,0,0.000000,# Fake incremental type.
0.000000,0,0.000000,my @c = @$ctl;
0.000000,0,0.000000,$c[CTL_TYPE] = '+';
0.000000,0,0.000000,return (1, $opt, \@c, 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,return (1, $opt, $ctl,
0.000000,0,0.000000,defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
0.000000,0,0.000000,$type eq 's' ? '' : 0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Get (possibly optional) argument.
0.000000,0,0.000000,$arg = (defined $rest ? $rest
0.000000,0,0.000000,: (defined $optarg ? $optarg : shift (@$argv)));
0.000000,0,0.000000,
0.000000,0,0.000000,# Get key if this is a "name=value" pair for a hash option.
0.000000,0,0.000000,my $key;
0.000000,0,0.000000,if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
0.000000,0,0.000000,($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
0.000000,0,0.000000,: ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
0.000000,0,0.000000,($mand ? undef : ($type eq 's' ? "" : 1)));
0.000000,0,0.000000,if (! defined $arg) {
0.000000,0,0.000000,warn ("Option $opt, key \"$key\", requires a value\n");
0.000000,0,0.000000,$error++;
0.000000,0,0.000000,# Push back.
0.000000,0,0.000000,unshift (@$argv, $starter.$rest) if defined $rest;
0.000000,0,0.000000,return (1, undef);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#### Check if the argument is valid for this option ####
0.000000,0,0.000000,
0.000000,0,0.000000,my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $type eq 's' ) {	# string
0.000000,0,0.000000,# A mandatory string takes anything.
0.000000,0,0.000000,return (1, $opt, $ctl, $arg, $key) if $mand;
0.000000,0,0.000000,
0.000000,0,0.000000,# Same for optional string as a hash value
0.000000,0,0.000000,return (1, $opt, $ctl, $arg, $key)
0.000000,0,0.000000,if $ctl->[CTL_DEST] == CTL_DEST_HASH;
0.000000,0,0.000000,
0.000000,0,0.000000,# An optional string takes almost anything.
0.000000,0,0.000000,return (1, $opt, $ctl, $arg, $key)
0.000000,0,0.000000,if defined $optarg || defined $rest;
0.000000,0,0.000000,return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
0.000000,0,0.000000,
0.000000,0,0.000000,# Check for option or option list terminator.
0.000000,0,0.000000,if ($arg eq $argend ||
0.000000,0,0.000000,$arg =~ /^$prefix.+/) {
0.000000,0,0.000000,# Push back.
0.000000,0,0.000000,unshift (@$argv, $arg);
0.000000,0,0.000000,# Supply empty value.
0.000000,0,0.000000,$arg = '';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,elsif ( $type eq 'i'	# numeric/integer
0.000000,0,0.000000,|| $type eq 'I'	# numeric/integer w/ incr default
0.000000,0,0.000000,|| $type eq 'o' ) { # dec/oct/hex/bin value
0.000000,0,0.000000,
0.000000,0,0.000000,my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $bundling && defined $rest
0.000000,0,0.000000,&& $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
0.000000,0,0.000000,($key, $arg, $rest) = ($1, $2, $+);
0.000000,0,0.000000,chop($key) if $key;
0.000000,0,0.000000,$arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
0.000000,0,0.000000,unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $arg =~ /^$o_valid$/si ) {
0.000000,0,0.000000,$arg =~ tr/_//d;
0.000000,0,0.000000,$arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ( defined $optarg || $mand ) {
0.000000,0,0.000000,if ( $passthrough ) {
0.000000,0,0.000000,unshift (@$argv, defined $rest ? $starter.$rest : $arg)
0.000000,0,0.000000,unless defined $optarg;
0.000000,0,0.000000,return (0);
0.000000,0,0.000000,}
0.000000,0,0.000000,warn ("Value \"", $arg, "\" invalid for option ",
0.000000,0,0.000000,$opt, " (",
0.000000,0,0.000000,$type eq 'o' ? "extended " : '',
0.000000,0,0.000000,"number expected)\n");
0.000000,0,0.000000,$error++;
0.000000,0,0.000000,# Push back.
0.000000,0,0.000000,unshift (@$argv, $starter.$rest) if defined $rest;
0.000000,0,0.000000,return (1, undef);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# Push back.
0.000000,0,0.000000,unshift (@$argv, defined $rest ? $starter.$rest : $arg);
0.000000,0,0.000000,if ( $type eq 'I' ) {
0.000000,0,0.000000,# Fake incremental type.
0.000000,0,0.000000,my @c = @$ctl;
0.000000,0,0.000000,$c[CTL_TYPE] = '+';
0.000000,0,0.000000,return (1, $opt, \@c, 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,# Supply default value.
0.000000,0,0.000000,$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,elsif ( $type eq 'f' ) { # real number, int is also ok
0.000000,0,0.000000,my $o_valid = PAT_FLOAT;
0.000000,0,0.000000,if ( $bundling && defined $rest &&
0.000000,0,0.000000,$rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
0.000000,0,0.000000,$arg =~ tr/_//d;
0.000000,0,0.000000,($key, $arg, $rest) = ($1, $2, $+);
0.000000,0,0.000000,chop($key) if $key;
0.000000,0,0.000000,unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $arg =~ /^$o_valid$/ ) {
0.000000,0,0.000000,$arg =~ tr/_//d;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ( defined $optarg || $mand ) {
0.000000,0,0.000000,if ( $passthrough ) {
0.000000,0,0.000000,unshift (@$argv, defined $rest ? $starter.$rest : $arg)
0.000000,0,0.000000,unless defined $optarg;
0.000000,0,0.000000,return (0);
0.000000,0,0.000000,}
0.000000,0,0.000000,warn ("Value \"", $arg, "\" invalid for option ",
0.000000,0,0.000000,$opt, " (real number expected)\n");
0.000000,0,0.000000,$error++;
0.000000,0,0.000000,# Push back.
0.000000,0,0.000000,unshift (@$argv, $starter.$rest) if defined $rest;
0.000000,0,0.000000,return (1, undef);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# Push back.
0.000000,0,0.000000,unshift (@$argv, defined $rest ? $starter.$rest : $arg);
0.000000,0,0.000000,# Supply default value.
0.000000,0,0.000000,$arg = 0.0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die("Getopt::Long internal error (Can't happen)\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,return (1, $opt, $ctl, $arg, $key);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ValidValue ($$$$$) {
0.000000,0,0.000000,my ($ctl, $arg, $mand, $argend, $prefix) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
0.000000,0,0.000000,return 0 unless $arg =~ /[^=]+=(.*)/;
0.000000,0,0.000000,$arg = $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $type = $ctl->[CTL_TYPE];
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $type eq 's' ) {	# string
0.000000,0,0.000000,# A mandatory string takes anything.
0.000000,0,0.000000,return (1) if $mand;
0.000000,0,0.000000,
0.000000,0,0.000000,return (1) if $arg eq "-";
0.000000,0,0.000000,
0.000000,0,0.000000,# Check for option or option list terminator.
0.000000,0,0.000000,return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,elsif ( $type eq 'i'	# numeric/integer
0.000000,0,0.000000,|| $type eq 'I'	# numeric/integer w/ incr default
0.000000,0,0.000000,|| $type eq 'o' ) { # dec/oct/hex/bin value
0.000000,0,0.000000,
0.000000,0,0.000000,my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
0.000000,0,0.000000,return $arg =~ /^$o_valid$/si;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,elsif ( $type eq 'f' ) { # real number, int is also ok
0.000000,0,0.000000,my $o_valid = PAT_FLOAT;
0.000000,0,0.000000,return $arg =~ /^$o_valid$/;
0.000000,0,0.000000,}
0.000000,0,0.000000,die("ValidValue: Cannot happen\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Getopt::Long Configuration.
0.000000,0,0.000000,sub Configure (@) {
0.000001,1,0.000001,my (@options) = @_;
0.000000,0,0.000000,
0.000001,1,0.000001,my $prevconfig =
0.000000,0,0.000000,[ $error, $debug, $major_version, $minor_version, $caller,
0.000000,0,0.000000,$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
0.000000,0,0.000000,$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
0.000000,0,0.000000,$longprefix, $bundling_values ];
0.000000,0,0.000000,
0.000001,1,0.000001,if ( ref($options[0]) eq 'ARRAY' ) {
0.000000,0,0.000000,( $error, $debug, $major_version, $minor_version, $caller,
0.000000,0,0.000000,$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
0.000000,0,0.000000,$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
0.000000,0,0.000000,$longprefix, $bundling_values ) = @{shift(@options)};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my $opt;
0.000000,1,0.000000,foreach $opt ( @options ) {
0.000000,0,0.000000,my $try = lc ($opt);
0.000000,0,0.000000,my $action = 1;
0.000000,0,0.000000,if ( $try =~ /^no_?(.*)$/s ) {
0.000000,0,0.000000,$action = 0;
0.000000,0,0.000000,$try = $+;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
0.000000,0,0.000000,ConfigDefaults ();
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
0.000000,0,0.000000,local $ENV{POSIXLY_CORRECT};
0.000000,0,0.000000,$ENV{POSIXLY_CORRECT} = 1 if $action;
0.000000,0,0.000000,ConfigDefaults ();
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
0.000000,0,0.000000,$autoabbrev = $action;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try eq 'getopt_compat' ) {
0.000000,0,0.000000,$getopt_compat = $action;
0.000000,0,0.000000,$genprefix = $action ? "(--|-|\\+)" : "(--|-)";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try eq 'gnu_getopt' ) {
0.000000,0,0.000000,if ( $action ) {
0.000000,0,0.000000,$gnu_compat = 1;
0.000000,0,0.000000,$bundling = 1;
0.000000,0,0.000000,$getopt_compat = 0;
0.000000,0,0.000000,$genprefix = "(--|-)";
0.000000,0,0.000000,$order = $PERMUTE;
0.000000,0,0.000000,$bundling_values = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try eq 'gnu_compat' ) {
0.000000,0,0.000000,$gnu_compat = $action;
0.000000,0,0.000000,$bundling = 0;
0.000000,0,0.000000,$bundling_values = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try =~ /^(auto_?)?version$/ ) {
0.000000,0,0.000000,$auto_version = $action;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try =~ /^(auto_?)?help$/ ) {
0.000000,0,0.000000,$auto_help = $action;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
0.000000,0,0.000000,$ignorecase = $action;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
0.000000,0,0.000000,$ignorecase = $action ? 2 : 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try eq 'bundling' ) {
0.000000,0,0.000000,$bundling = $action;
0.000000,0,0.000000,$bundling_values = 0 if $action;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try eq 'bundling_override' ) {
0.000000,0,0.000000,$bundling = $action ? 2 : 0;
0.000000,0,0.000000,$bundling_values = 0 if $action;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try eq 'bundling_values' ) {
0.000000,0,0.000000,$bundling_values = $action;
0.000000,0,0.000000,$bundling = 0 if $action;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try eq 'require_order' ) {
0.000000,0,0.000000,$order = $action ? $REQUIRE_ORDER : $PERMUTE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try eq 'permute' ) {
0.000000,0,0.000000,$order = $action ? $PERMUTE : $REQUIRE_ORDER;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
0.000000,0,0.000000,$passthrough = $action;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
0.000000,0,0.000000,$genprefix = $1;
0.000000,0,0.000000,# Turn into regexp. Needs to be parenthesized!
0.000000,0,0.000000,$genprefix = "(" . quotemeta($genprefix) . ")";
0.000000,0,0.000000,eval { '' =~ /$genprefix/; };
0.000000,0,0.000000,die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
0.000000,0,0.000000,$genprefix = $1;
0.000000,0,0.000000,# Parenthesize if needed.
0.000000,0,0.000000,$genprefix = "(" . $genprefix . ")"
0.000000,0,0.000000,unless $genprefix =~ /^\(.*\)$/;
0.000000,0,0.000000,eval { '' =~ m"$genprefix"; };
0.000000,0,0.000000,die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
0.000000,0,0.000000,$longprefix = $1;
0.000000,0,0.000000,# Parenthesize if needed.
0.000000,0,0.000000,$longprefix = "(" . $longprefix . ")"
0.000000,0,0.000000,unless $longprefix =~ /^\(.*\)$/;
0.000000,0,0.000000,eval { '' =~ m"$longprefix"; };
0.000000,0,0.000000,die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $try eq 'debug' ) {
0.000000,0,0.000000,$debug = $action;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000002,1,0.000002,$prevconfig;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Deprecated name.
0.000000,0,0.000000,sub config (@) {
0.000000,0,0.000000,Configure (@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Issue a standard message for --version.
0.000000,0,0.000000,#
0.000000,0,0.000000,# The arguments are mostly the same as for Pod::Usage::pod2usage:
0.000000,0,0.000000,#
0.000000,0,0.000000,#  - a number (exit value)
0.000000,0,0.000000,#  - a string (lead in message)
0.000000,0,0.000000,#  - a hash with options. See Pod::Usage for details.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub VersionMessage(@) {
0.000000,0,0.000000,# Massage args.
0.000000,0,0.000000,my $pa = setup_pa_args("version", @_);
0.000000,0,0.000000,
0.000000,0,0.000000,my $v = $main::VERSION;
0.000000,0,0.000000,my $fh = $pa->{-output} ||
0.000000,0,0.000000,( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
0.000000,0,0.000000,
0.000000,0,0.000000,print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
0.000000,0,0.000000,$0, defined $v ? " version $v" : (),
0.000000,0,0.000000,"\n",
0.000000,0,0.000000,"(", __PACKAGE__, "::", "GetOptions",
0.000000,0,0.000000," version ",
0.000000,0,0.000000,defined($Getopt::Long::VERSION_STRING)
0.000000,0,0.000000,? $Getopt::Long::VERSION_STRING : $VERSION, ";",
0.000000,0,0.000000," Perl version ",
0.000000,0,0.000000,$] >= 5.006 ? sprintf("%vd", $^V) : $],
0.000000,0,0.000000,")\n");
0.000000,0,0.000000,exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Issue a standard message for --help.
0.000000,0,0.000000,#
0.000000,0,0.000000,# The arguments are the same as for Pod::Usage::pod2usage:
0.000000,0,0.000000,#
0.000000,0,0.000000,#  - a number (exit value)
0.000000,0,0.000000,#  - a string (lead in message)
0.000000,0,0.000000,#  - a hash with options. See Pod::Usage for details.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub HelpMessage(@) {
0.000000,0,0.000000,eval {
0.000000,0,0.000000,require Pod::Usage;
0.000000,0,0.000000,import Pod::Usage;
0.000000,0,0.000000,1;
0.000000,0,0.000000,} || die("Cannot provide help: cannot load Pod::Usage\n");
0.000000,0,0.000000,
0.000000,0,0.000000,# Note that pod2usage will issue a warning if -exitval => NOEXIT.
0.000000,0,0.000000,pod2usage(setup_pa_args("help", @_));
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Helper routine to set up a normalized hash ref to be used as
0.000000,0,0.000000,# argument to pod2usage.
0.000000,0,0.000000,sub setup_pa_args($@) {
0.000000,0,0.000000,my $tag = shift;		# who's calling
0.000000,0,0.000000,
0.000000,0,0.000000,# If called by direct binding to an option, it will get the option
0.000000,0,0.000000,# name and value as arguments. Remove these, if so.
0.000000,0,0.000000,@_ = () if @_ == 2 && $_[0] eq $tag;
0.000000,0,0.000000,
0.000000,0,0.000000,my $pa;
0.000000,0,0.000000,if ( @_ > 1 ) {
0.000000,0,0.000000,$pa = { @_ };
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$pa = shift || {};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# At this point, $pa can be a number (exit value), string
0.000000,0,0.000000,# (message) or hash with options.
0.000000,0,0.000000,
0.000000,0,0.000000,if ( UNIVERSAL::isa($pa, 'HASH') ) {
0.000000,0,0.000000,# Get rid of -msg vs. -message ambiguity.
0.000000,0,0.000000,$pa->{-message} = $pa->{-msg};
0.000000,0,0.000000,delete($pa->{-msg});
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $pa =~ /^-?\d+$/ ) {
0.000000,0,0.000000,$pa = { -exitval => $pa };
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$pa = { -message => $pa };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# These are _our_ defaults.
0.000000,0,0.000000,$pa->{-verbose} = 0 unless exists($pa->{-verbose});
0.000000,0,0.000000,$pa->{-exitval} = 0 unless exists($pa->{-exitval});
0.000000,0,0.000000,$pa;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Sneak way to know what version the user requested.
0.000000,0,0.000000,sub VERSION {
0.000000,0,0.000000,$requested_version = $_[1] if @_ > 1;
0.000000,0,0.000000,shift->SUPER::VERSION(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,package Getopt::Long::CallBack;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my ($pkg, %atts) = @_;
0.000000,0,0.000000,bless { %atts }, $pkg;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub name {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,''.$self->{name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub given {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->{given};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,use overload
0.000000,0,0.000000,# Treat this object as an ordinary string for legacy API.
0.000001,1,0.000001,'""'	   => \&name,
0.000440,1,0.000440,fallback => 1;
0.000000,0,0.000000,
0.000010,1,0.000010,1;
0.000000,0,0.000000,
0.000000,0,0.000000,################ Documentation ################
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,Getopt::Long - Extended processing of command line options
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use Getopt::Long;
0.000000,0,0.000000,my $data   = "file.dat";
0.000000,0,0.000000,my $length = 24;
0.000000,0,0.000000,my $verbose;
0.000000,0,0.000000,GetOptions ("length=i" => \$length,    # numeric
0.000000,0,0.000000,"file=s"   => \$data,      # string
0.000000,0,0.000000,"verbose"  => \$verbose)   # flag
0.000000,0,0.000000,or die("Error in command line arguments\n");
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,The Getopt::Long module implements an extended getopt function called
0.000000,0,0.000000,GetOptions(). It parses the command line from C<@ARGV>, recognizing
0.000000,0,0.000000,and removing specified options and their possible values.
0.000000,0,0.000000,
0.000000,0,0.000000,This function adheres to the POSIX syntax for command
0.000000,0,0.000000,line options, with GNU extensions. In general, this means that options
0.000000,0,0.000000,have long names instead of single letters, and are introduced with a
0.000000,0,0.000000,double dash "--". Support for bundling of command line options, as was
0.000000,0,0.000000,the case with the more traditional single-letter approach, is provided
0.000000,0,0.000000,but not enabled by default.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 Command Line Options, an Introduction
0.000000,0,0.000000,
0.000000,0,0.000000,Command line operated programs traditionally take their arguments from
0.000000,0,0.000000,the command line, for example filenames or other information that the
0.000000,0,0.000000,program needs to know. Besides arguments, these programs often take
0.000000,0,0.000000,command line I<options> as well. Options are not necessary for the
0.000000,0,0.000000,program to work, hence the name 'option', but are used to modify its
0.000000,0,0.000000,default behaviour. For example, a program could do its job quietly,
0.000000,0,0.000000,but with a suitable option it could provide verbose information about
0.000000,0,0.000000,what it did.
0.000000,0,0.000000,
0.000000,0,0.000000,Command line options come in several flavours. Historically, they are
0.000000,0,0.000000,preceded by a single dash C<->, and consist of a single letter.
0.000000,0,0.000000,
0.000000,0,0.000000,-l -a -c
0.000000,0,0.000000,
0.000000,0,0.000000,Usually, these single-character options can be bundled:
0.000000,0,0.000000,
0.000000,0,0.000000,-lac
0.000000,0,0.000000,
0.000000,0,0.000000,Options can have values, the value is placed after the option
0.000000,0,0.000000,character. Sometimes with whitespace in between, sometimes not:
0.000000,0,0.000000,
0.000000,0,0.000000,-s 24 -s24
0.000000,0,0.000000,
0.000000,0,0.000000,Due to the very cryptic nature of these options, another style was
0.000000,0,0.000000,developed that used long names. So instead of a cryptic C<-l> one
0.000000,0,0.000000,could use the more descriptive C<--long>. To distinguish between a
0.000000,0,0.000000,bundle of single-character options and a long one, two dashes are used
0.000000,0,0.000000,to precede the option name. Early implementations of long options used
0.000000,0,0.000000,a plus C<+> instead. Also, option values could be specified either
0.000000,0,0.000000,like
0.000000,0,0.000000,
0.000000,0,0.000000,--size=24
0.000000,0,0.000000,
0.000000,0,0.000000,or
0.000000,0,0.000000,
0.000000,0,0.000000,--size 24
0.000000,0,0.000000,
0.000000,0,0.000000,The C<+> form is now obsolete and strongly deprecated.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 Getting Started with Getopt::Long
0.000000,0,0.000000,
0.000000,0,0.000000,Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
0.000000,0,0.000000,first Perl module that provided support for handling the new style of
0.000000,0,0.000000,command line options, in particular long option names, hence the Perl5
0.000000,0,0.000000,name Getopt::Long. This module also supports single-character options
0.000000,0,0.000000,and bundling.
0.000000,0,0.000000,
0.000000,0,0.000000,To use Getopt::Long from a Perl program, you must include the
0.000000,0,0.000000,following line in your Perl program:
0.000000,0,0.000000,
0.000000,0,0.000000,use Getopt::Long;
0.000000,0,0.000000,
0.000000,0,0.000000,This will load the core of the Getopt::Long module and prepare your
0.000000,0,0.000000,program for using it. Most of the actual Getopt::Long code is not
0.000000,0,0.000000,loaded until you really call one of its functions.
0.000000,0,0.000000,
0.000000,0,0.000000,In the default configuration, options names may be abbreviated to
0.000000,0,0.000000,uniqueness, case does not matter, and a single dash is sufficient,
0.000000,0,0.000000,even for long option names. Also, options may be placed between
0.000000,0,0.000000,non-option arguments. See L<Configuring Getopt::Long> for more
0.000000,0,0.000000,details on how to configure Getopt::Long.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Simple options
0.000000,0,0.000000,
0.000000,0,0.000000,The most simple options are the ones that take no values. Their mere
0.000000,0,0.000000,presence on the command line enables the option. Popular examples are:
0.000000,0,0.000000,
0.000000,0,0.000000,--all --verbose --quiet --debug
0.000000,0,0.000000,
0.000000,0,0.000000,Handling simple options is straightforward:
0.000000,0,0.000000,
0.000000,0,0.000000,my $verbose = '';	# option variable with default value (false)
0.000000,0,0.000000,my $all = '';	# option variable with default value (false)
0.000000,0,0.000000,GetOptions ('verbose' => \$verbose, 'all' => \$all);
0.000000,0,0.000000,
0.000000,0,0.000000,The call to GetOptions() parses the command line arguments that are
0.000000,0,0.000000,present in C<@ARGV> and sets the option variable to the value C<1> if
0.000000,0,0.000000,the option did occur on the command line. Otherwise, the option
0.000000,0,0.000000,variable is not touched. Setting the option value to true is often
0.000000,0,0.000000,called I<enabling> the option.
0.000000,0,0.000000,
0.000000,0,0.000000,The option name as specified to the GetOptions() function is called
0.000000,0,0.000000,the option I<specification>. Later we'll see that this specification
0.000000,0,0.000000,can contain more than just the option name. The reference to the
0.000000,0,0.000000,variable is called the option I<destination>.
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions() will return a true value if the command line could be
0.000000,0,0.000000,processed successfully. Otherwise, it will write error messages using
0.000000,0,0.000000,die() and warn(), and return a false result.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 A little bit less simple options
0.000000,0,0.000000,
0.000000,0,0.000000,Getopt::Long supports two useful variants of simple options:
0.000000,0,0.000000,I<negatable> options and I<incremental> options.
0.000000,0,0.000000,
0.000000,0,0.000000,A negatable option is specified with an exclamation mark C<!> after the
0.000000,0,0.000000,option name:
0.000000,0,0.000000,
0.000000,0,0.000000,my $verbose = '';	# option variable with default value (false)
0.000000,0,0.000000,GetOptions ('verbose!' => \$verbose);
0.000000,0,0.000000,
0.000000,0,0.000000,Now, using C<--verbose> on the command line will enable C<$verbose>,
0.000000,0,0.000000,as expected. But it is also allowed to use C<--noverbose>, which will
0.000000,0,0.000000,disable C<$verbose> by setting its value to C<0>. Using a suitable
0.000000,0,0.000000,default value, the program can find out whether C<$verbose> is false
0.000000,0,0.000000,by default, or disabled by using C<--noverbose>.
0.000000,0,0.000000,
0.000000,0,0.000000,An incremental option is specified with a plus C<+> after the
0.000000,0,0.000000,option name:
0.000000,0,0.000000,
0.000000,0,0.000000,my $verbose = '';	# option variable with default value (false)
0.000000,0,0.000000,GetOptions ('verbose+' => \$verbose);
0.000000,0,0.000000,
0.000000,0,0.000000,Using C<--verbose> on the command line will increment the value of
0.000000,0,0.000000,C<$verbose>. This way the program can keep track of how many times the
0.000000,0,0.000000,option occurred on the command line. For example, each occurrence of
0.000000,0,0.000000,C<--verbose> could increase the verbosity level of the program.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Mixing command line option with other arguments
0.000000,0,0.000000,
0.000000,0,0.000000,Usually programs take command line options as well as other arguments,
0.000000,0,0.000000,for example, file names. It is good practice to always specify the
0.000000,0,0.000000,options first, and the other arguments last. Getopt::Long will,
0.000000,0,0.000000,however, allow the options and arguments to be mixed and 'filter out'
0.000000,0,0.000000,all the options before passing the rest of the arguments to the
0.000000,0,0.000000,program. To stop Getopt::Long from processing further arguments,
0.000000,0,0.000000,insert a double dash C<--> on the command line:
0.000000,0,0.000000,
0.000000,0,0.000000,--size 24 -- --all
0.000000,0,0.000000,
0.000000,0,0.000000,In this example, C<--all> will I<not> be treated as an option, but
0.000000,0,0.000000,passed to the program unharmed, in C<@ARGV>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Options with values
0.000000,0,0.000000,
0.000000,0,0.000000,For options that take values it must be specified whether the option
0.000000,0,0.000000,value is required or not, and what kind of value the option expects.
0.000000,0,0.000000,
0.000000,0,0.000000,Three kinds of values are supported: integer numbers, floating point
0.000000,0,0.000000,numbers, and strings.
0.000000,0,0.000000,
0.000000,0,0.000000,If the option value is required, Getopt::Long will take the
0.000000,0,0.000000,command line argument that follows the option and assign this to the
0.000000,0,0.000000,option variable. If, however, the option value is specified as
0.000000,0,0.000000,optional, this will only be done if that value does not look like a
0.000000,0,0.000000,valid command line option itself.
0.000000,0,0.000000,
0.000000,0,0.000000,my $tag = '';	# option variable with default value
0.000000,0,0.000000,GetOptions ('tag=s' => \$tag);
0.000000,0,0.000000,
0.000000,0,0.000000,In the option specification, the option name is followed by an equals
0.000000,0,0.000000,sign C<=> and the letter C<s>. The equals sign indicates that this
0.000000,0,0.000000,option requires a value. The letter C<s> indicates that this value is
0.000000,0,0.000000,an arbitrary string. Other possible value types are C<i> for integer
0.000000,0,0.000000,values, and C<f> for floating point values. Using a colon C<:> instead
0.000000,0,0.000000,of the equals sign indicates that the option value is optional. In
0.000000,0,0.000000,this case, if no suitable value is supplied, string valued options get
0.000000,0,0.000000,an empty string C<''> assigned, while numeric options are set to C<0>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Options with multiple values
0.000000,0,0.000000,
0.000000,0,0.000000,Options sometimes take several values. For example, a program could
0.000000,0,0.000000,use multiple directories to search for library files:
0.000000,0,0.000000,
0.000000,0,0.000000,--library lib/stdlib --library lib/extlib
0.000000,0,0.000000,
0.000000,0,0.000000,To accomplish this behaviour, simply specify an array reference as the
0.000000,0,0.000000,destination for the option:
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions ("library=s" => \@libfiles);
0.000000,0,0.000000,
0.000000,0,0.000000,Alternatively, you can specify that the option can have multiple
0.000000,0,0.000000,values by adding a "@", and pass a reference to a scalar as the
0.000000,0,0.000000,destination:
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions ("library=s@" => \$libfiles);
0.000000,0,0.000000,
0.000000,0,0.000000,Used with the example above, C<@libfiles> c.q. C<@$libfiles> would
0.000000,0,0.000000,contain two strings upon completion: C<"lib/stdlib"> and
0.000000,0,0.000000,C<"lib/extlib">, in that order. It is also possible to specify that
0.000000,0,0.000000,only integer or floating point numbers are acceptable values.
0.000000,0,0.000000,
0.000000,0,0.000000,Often it is useful to allow comma-separated lists of values as well as
0.000000,0,0.000000,multiple occurrences of the options. This is easy using Perl's split()
0.000000,0,0.000000,and join() operators:
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions ("library=s" => \@libfiles);
0.000000,0,0.000000,@libfiles = split(/,/,join(',',@libfiles));
0.000000,0,0.000000,
0.000000,0,0.000000,Of course, it is important to choose the right separator string for
0.000000,0,0.000000,each purpose.
0.000000,0,0.000000,
0.000000,0,0.000000,Warning: What follows is an experimental feature.
0.000000,0,0.000000,
0.000000,0,0.000000,Options can take multiple values at once, for example
0.000000,0,0.000000,
0.000000,0,0.000000,--coordinates 52.2 16.4 --rgbcolor 255 255 149
0.000000,0,0.000000,
0.000000,0,0.000000,This can be accomplished by adding a repeat specifier to the option
0.000000,0,0.000000,specification. Repeat specifiers are very similar to the C<{...}>
0.000000,0,0.000000,repeat specifiers that can be used with regular expression patterns.
0.000000,0,0.000000,For example, the above command line would be handled as follows:
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
0.000000,0,0.000000,
0.000000,0,0.000000,The destination for the option must be an array or array reference.
0.000000,0,0.000000,
0.000000,0,0.000000,It is also possible to specify the minimal and maximal number of
0.000000,0,0.000000,arguments an option takes. C<foo=s{2,4}> indicates an option that
0.000000,0,0.000000,takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
0.000000,0,0.000000,or more values; C<foo:s{,}> indicates zero or more option values.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Options with hash values
0.000000,0,0.000000,
0.000000,0,0.000000,If the option destination is a reference to a hash, the option will
0.000000,0,0.000000,take, as value, strings of the form I<key>C<=>I<value>. The value will
0.000000,0,0.000000,be stored with the specified key in the hash.
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions ("define=s" => \%defines);
0.000000,0,0.000000,
0.000000,0,0.000000,Alternatively you can use:
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions ("define=s%" => \$defines);
0.000000,0,0.000000,
0.000000,0,0.000000,When used with command line options:
0.000000,0,0.000000,
0.000000,0,0.000000,--define os=linux --define vendor=redhat
0.000000,0,0.000000,
0.000000,0,0.000000,the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
0.000000,0,0.000000,with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
0.000000,0,0.000000,also possible to specify that only integer or floating point numbers
0.000000,0,0.000000,are acceptable values. The keys are always taken to be strings.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 User-defined subroutines to handle options
0.000000,0,0.000000,
0.000000,0,0.000000,Ultimate control over what should be done when (actually: each time)
0.000000,0,0.000000,an option is encountered on the command line can be achieved by
0.000000,0,0.000000,designating a reference to a subroutine (or an anonymous subroutine)
0.000000,0,0.000000,as the option destination. When GetOptions() encounters the option, it
0.000000,0,0.000000,will call the subroutine with two or three arguments. The first
0.000000,0,0.000000,argument is the name of the option. (Actually, it is an object that
0.000000,0,0.000000,stringifies to the name of the option.) For a scalar or array destination,
0.000000,0,0.000000,the second argument is the value to be stored. For a hash destination,
0.000000,0,0.000000,the second argument is the key to the hash, and the third argument
0.000000,0,0.000000,the value to be stored. It is up to the subroutine to store the value,
0.000000,0,0.000000,or do whatever it thinks is appropriate.
0.000000,0,0.000000,
0.000000,0,0.000000,A trivial application of this mechanism is to implement options that
0.000000,0,0.000000,are related to each other. For example:
0.000000,0,0.000000,
0.000000,0,0.000000,my $verbose = '';	# option variable with default value (false)
0.000000,0,0.000000,GetOptions ('verbose' => \$verbose,
0.000000,0,0.000000,'quiet'   => sub { $verbose = 0 });
0.000000,0,0.000000,
0.000000,0,0.000000,Here C<--verbose> and C<--quiet> control the same variable
0.000000,0,0.000000,C<$verbose>, but with opposite values.
0.000000,0,0.000000,
0.000000,0,0.000000,If the subroutine needs to signal an error, it should call die() with
0.000000,0,0.000000,the desired error message as its argument. GetOptions() will catch the
0.000000,0,0.000000,die(), issue the error message, and record that an error result must
0.000000,0,0.000000,be returned upon completion.
0.000000,0,0.000000,
0.000000,0,0.000000,If the text of the error message starts with an exclamation mark C<!>
0.000000,0,0.000000,it is interpreted specially by GetOptions(). There is currently one
0.000000,0,0.000000,special command implemented: C<die("!FINISH")> will cause GetOptions()
0.000000,0,0.000000,to stop processing options, as if it encountered a double dash C<-->.
0.000000,0,0.000000,
0.000000,0,0.000000,Here is an example of how to access the option name and value from within
0.000000,0,0.000000,a subroutine:
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions ('opt=i' => \&handler);
0.000000,0,0.000000,sub handler {
0.000000,0,0.000000,my ($opt_name, $opt_value) = @_;
0.000000,0,0.000000,print("Option name is $opt_name and value is $opt_value\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Options with multiple names
0.000000,0,0.000000,
0.000000,0,0.000000,Often it is user friendly to supply alternate mnemonic names for
0.000000,0,0.000000,options. For example C<--height> could be an alternate name for
0.000000,0,0.000000,C<--length>. Alternate names can be included in the option
0.000000,0,0.000000,specification, separated by vertical bar C<|> characters. To implement
0.000000,0,0.000000,the above example:
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions ('length|height=f' => \$length);
0.000000,0,0.000000,
0.000000,0,0.000000,The first name is called the I<primary> name, the other names are
0.000000,0,0.000000,called I<aliases>. When using a hash to store options, the key will
0.000000,0,0.000000,always be the primary name.
0.000000,0,0.000000,
0.000000,0,0.000000,Multiple alternate names are possible.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Case and abbreviations
0.000000,0,0.000000,
0.000000,0,0.000000,Without additional configuration, GetOptions() will ignore the case of
0.000000,0,0.000000,option names, and allow the options to be abbreviated to uniqueness.
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions ('length|height=f' => \$length, "head" => \$head);
0.000000,0,0.000000,
0.000000,0,0.000000,This call will allow C<--l> and C<--L> for the length option, but
0.000000,0,0.000000,requires a least C<--hea> and C<--hei> for the head and height options.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Summary of Option Specifications
0.000000,0,0.000000,
0.000000,0,0.000000,Each option specifier consists of two parts: the name specification
0.000000,0,0.000000,and the argument specification.
0.000000,0,0.000000,
0.000000,0,0.000000,The name specification contains the name of the option, optionally
0.000000,0,0.000000,followed by a list of alternative names separated by vertical bar
0.000000,0,0.000000,characters.
0.000000,0,0.000000,
0.000000,0,0.000000,length	      option name is "length"
0.000000,0,0.000000,length|size|l     name is "length", aliases are "size" and "l"
0.000000,0,0.000000,
0.000000,0,0.000000,The argument specification is optional. If omitted, the option is
0.000000,0,0.000000,considered boolean, a value of 1 will be assigned when the option is
0.000000,0,0.000000,used on the command line.
0.000000,0,0.000000,
0.000000,0,0.000000,The argument specification can be
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item !
0.000000,0,0.000000,
0.000000,0,0.000000,The option does not take an argument and may be negated by prefixing
0.000000,0,0.000000,it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
0.000000,0,0.000000,1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
0.000000,0,0.000000,0 will be assigned). If the option has aliases, this applies to the
0.000000,0,0.000000,aliases as well.
0.000000,0,0.000000,
0.000000,0,0.000000,Using negation on a single letter option when bundling is in effect is
0.000000,0,0.000000,pointless and will result in a warning.
0.000000,0,0.000000,
0.000000,0,0.000000,=item +
0.000000,0,0.000000,
0.000000,0,0.000000,The option does not take an argument and will be incremented by 1
0.000000,0,0.000000,every time it appears on the command line. E.g. C<"more+">, when used
0.000000,0,0.000000,with C<--more --more --more>, will increment the value three times,
0.000000,0,0.000000,resulting in a value of 3 (provided it was 0 or undefined at first).
0.000000,0,0.000000,
0.000000,0,0.000000,The C<+> specifier is ignored if the option destination is not a scalar.
0.000000,0,0.000000,
0.000000,0,0.000000,=item = I<type> [ I<desttype> ] [ I<repeat> ]
0.000000,0,0.000000,
0.000000,0,0.000000,The option requires an argument of the given type. Supported types
0.000000,0,0.000000,are:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item s
0.000000,0,0.000000,
0.000000,0,0.000000,String. An arbitrary sequence of characters. It is valid for the
0.000000,0,0.000000,argument to start with C<-> or C<-->.
0.000000,0,0.000000,
0.000000,0,0.000000,=item i
0.000000,0,0.000000,
0.000000,0,0.000000,Integer. An optional leading plus or minus sign, followed by a
0.000000,0,0.000000,sequence of digits.
0.000000,0,0.000000,
0.000000,0,0.000000,=item o
0.000000,0,0.000000,
0.000000,0,0.000000,Extended integer, Perl style. This can be either an optional leading
0.000000,0,0.000000,plus or minus sign, followed by a sequence of digits, or an octal
0.000000,0,0.000000,string (a zero, optionally followed by '0', '1', .. '7'), or a
0.000000,0,0.000000,hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
0.000000,0,0.000000,insensitive), or a binary string (C<0b> followed by a series of '0'
0.000000,0,0.000000,and '1').
0.000000,0,0.000000,
0.000000,0,0.000000,=item f
0.000000,0,0.000000,
0.000000,0,0.000000,Real number. For example C<3.14>, C<-6.23E24> and so on.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,The I<desttype> can be C<@> or C<%> to specify that the option is
0.000000,0,0.000000,list or a hash valued. This is only needed when the destination for
0.000000,0,0.000000,the option value is not otherwise specified. It should be omitted when
0.000000,0,0.000000,not needed.
0.000000,0,0.000000,
0.000000,0,0.000000,The I<repeat> specifies the number of values this option takes per
0.000000,0,0.000000,occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
0.000000,0,0.000000,
0.000000,0,0.000000,I<min> denotes the minimal number of arguments. It defaults to 1 for
0.000000,0,0.000000,options with C<=> and to 0 for options with C<:>, see below. Note that
0.000000,0,0.000000,I<min> overrules the C<=> / C<:> semantics.
0.000000,0,0.000000,
0.000000,0,0.000000,I<max> denotes the maximum number of arguments. It must be at least
0.000000,0,0.000000,I<min>. If I<max> is omitted, I<but the comma is not>, there is no
0.000000,0,0.000000,upper bound to the number of argument values taken.
0.000000,0,0.000000,
0.000000,0,0.000000,=item : I<type> [ I<desttype> ]
0.000000,0,0.000000,
0.000000,0,0.000000,Like C<=>, but designates the argument as optional.
0.000000,0,0.000000,If omitted, an empty string will be assigned to string values options,
0.000000,0,0.000000,and the value zero to numeric options.
0.000000,0,0.000000,
0.000000,0,0.000000,Note that if a string argument starts with C<-> or C<-->, it will be
0.000000,0,0.000000,considered an option on itself.
0.000000,0,0.000000,
0.000000,0,0.000000,=item : I<number> [ I<desttype> ]
0.000000,0,0.000000,
0.000000,0,0.000000,Like C<:i>, but if the value is omitted, the I<number> will be assigned.
0.000000,0,0.000000,
0.000000,0,0.000000,=item : + [ I<desttype> ]
0.000000,0,0.000000,
0.000000,0,0.000000,Like C<:i>, but if the value is omitted, the current value for the
0.000000,0,0.000000,option will be incremented.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 Advanced Possibilities
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Object oriented interface
0.000000,0,0.000000,
0.000000,0,0.000000,Getopt::Long can be used in an object oriented way as well:
0.000000,0,0.000000,
0.000000,0,0.000000,use Getopt::Long;
0.000000,0,0.000000,$p = Getopt::Long::Parser->new;
0.000000,0,0.000000,$p->configure(...configuration options...);
0.000000,0,0.000000,if ($p->getoptions(...options descriptions...)) ...
0.000000,0,0.000000,if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
0.000000,0,0.000000,
0.000000,0,0.000000,Configuration options can be passed to the constructor:
0.000000,0,0.000000,
0.000000,0,0.000000,$p = new Getopt::Long::Parser
0.000000,0,0.000000,config => [...configuration options...];
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Callback object
0.000000,0,0.000000,
0.000000,0,0.000000,In version 2.37 the first argument to the callback function was
0.000000,0,0.000000,changed from string to object. This was done to make room for
0.000000,0,0.000000,extensions and more detailed control. The object stringifies to the
0.000000,0,0.000000,option name so this change should not introduce compatibility
0.000000,0,0.000000,problems.
0.000000,0,0.000000,
0.000000,0,0.000000,The callback object has the following methods:
0.000000,0,0.000000,
0.000000,0,0.000000,=over
0.000000,0,0.000000,
0.000000,0,0.000000,=item name
0.000000,0,0.000000,
0.000000,0,0.000000,The name of the option, unabbreviated. For an option with multiple
0.000000,0,0.000000,names it return the first (canonical) name.
0.000000,0,0.000000,
0.000000,0,0.000000,=item given
0.000000,0,0.000000,
0.000000,0,0.000000,The name of the option as actually used, unabbreveated.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Thread Safety
0.000000,0,0.000000,
0.000000,0,0.000000,Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
0.000000,0,0.000000,I<not> thread safe when using the older (experimental and now
0.000000,0,0.000000,obsolete) threads implementation that was added to Perl 5.005.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Documentation and help texts
0.000000,0,0.000000,
0.000000,0,0.000000,Getopt::Long encourages the use of Pod::Usage to produce help
0.000000,0,0.000000,messages. For example:
0.000000,0,0.000000,
0.000000,0,0.000000,use Getopt::Long;
0.000000,0,0.000000,use Pod::Usage;
0.000000,0,0.000000,
0.000000,0,0.000000,my $man = 0;
0.000000,0,0.000000,my $help = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
0.000000,0,0.000000,pod2usage(1) if $help;
0.000000,0,0.000000,pod2usage(-exitval => 0, -verbose => 2) if $man;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,sample - Using Getopt::Long and Pod::Usage
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,sample [options] [file ...]
0.000000,0,0.000000,
0.000000,0,0.000000,Options:
0.000000,0,0.000000,-help            brief help message
0.000000,0,0.000000,-man             full documentation
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 OPTIONS
0.000000,0,0.000000,
0.000000,0,0.000000,=over 8
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<-help>
0.000000,0,0.000000,
0.000000,0,0.000000,Print a brief help message and exits.
0.000000,0,0.000000,
0.000000,0,0.000000,=item B<-man>
0.000000,0,0.000000,
0.000000,0,0.000000,Prints the manual page and exits.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,B<This program> will read the given input file(s) and do something
0.000000,0,0.000000,useful with the contents thereof.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,See L<Pod::Usage> for details.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Parsing options from an arbitrary array
0.000000,0,0.000000,
0.000000,0,0.000000,By default, GetOptions parses the options that are present in the
0.000000,0,0.000000,global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
0.000000,0,0.000000,used to parse options from an arbitrary array.
0.000000,0,0.000000,
0.000000,0,0.000000,use Getopt::Long qw(GetOptionsFromArray);
0.000000,0,0.000000,$ret = GetOptionsFromArray(\@myopts, ...);
0.000000,0,0.000000,
0.000000,0,0.000000,When used like this, options and their possible values are removed
0.000000,0,0.000000,from C<@myopts>, the global C<@ARGV> is not touched at all.
0.000000,0,0.000000,
0.000000,0,0.000000,The following two calls behave identically:
0.000000,0,0.000000,
0.000000,0,0.000000,$ret = GetOptions( ... );
0.000000,0,0.000000,$ret = GetOptionsFromArray(\@ARGV, ... );
0.000000,0,0.000000,
0.000000,0,0.000000,This also means that a first argument hash reference now becomes the
0.000000,0,0.000000,second argument:
0.000000,0,0.000000,
0.000000,0,0.000000,$ret = GetOptions(\%opts, ... );
0.000000,0,0.000000,$ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Parsing options from an arbitrary string
0.000000,0,0.000000,
0.000000,0,0.000000,A special entry C<GetOptionsFromString> can be used to parse options
0.000000,0,0.000000,from an arbitrary string.
0.000000,0,0.000000,
0.000000,0,0.000000,use Getopt::Long qw(GetOptionsFromString);
0.000000,0,0.000000,$ret = GetOptionsFromString($string, ...);
0.000000,0,0.000000,
0.000000,0,0.000000,The contents of the string are split into arguments using a call to
0.000000,0,0.000000,C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
0.000000,0,0.000000,global C<@ARGV> is not touched.
0.000000,0,0.000000,
0.000000,0,0.000000,It is possible that, upon completion, not all arguments in the string
0.000000,0,0.000000,have been processed. C<GetOptionsFromString> will, when called in list
0.000000,0,0.000000,context, return both the return status and an array reference to any
0.000000,0,0.000000,remaining arguments:
0.000000,0,0.000000,
0.000000,0,0.000000,($ret, $args) = GetOptionsFromString($string, ... );
0.000000,0,0.000000,
0.000000,0,0.000000,If any arguments remain, and C<GetOptionsFromString> was not called in
0.000000,0,0.000000,list context, a message will be given and C<GetOptionsFromString> will
0.000000,0,0.000000,return failure.
0.000000,0,0.000000,
0.000000,0,0.000000,As with GetOptionsFromArray, a first argument hash reference now
0.000000,0,0.000000,becomes the second argument. See the next section.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Storing options values in a hash
0.000000,0,0.000000,
0.000000,0,0.000000,Sometimes, for example when there are a lot of options, having a
0.000000,0,0.000000,separate variable for each of them can be cumbersome. GetOptions()
0.000000,0,0.000000,supports, as an alternative mechanism, storing options values in a
0.000000,0,0.000000,hash.
0.000000,0,0.000000,
0.000000,0,0.000000,To obtain this, a reference to a hash must be passed I<as the first
0.000000,0,0.000000,argument> to GetOptions(). For each option that is specified on the
0.000000,0,0.000000,command line, the option value will be stored in the hash with the
0.000000,0,0.000000,option name as key. Options that are not actually used on the command
0.000000,0,0.000000,line will not be put in the hash, on other words,
0.000000,0,0.000000,C<exists($h{option})> (or defined()) can be used to test if an option
0.000000,0,0.000000,was used. The drawback is that warnings will be issued if the program
0.000000,0,0.000000,runs under C<use strict> and uses C<$h{option}> without testing with
0.000000,0,0.000000,exists() or defined() first.
0.000000,0,0.000000,
0.000000,0,0.000000,my %h = ();
0.000000,0,0.000000,GetOptions (\%h, 'length=i');	# will store in $h{length}
0.000000,0,0.000000,
0.000000,0,0.000000,For options that take list or hash values, it is necessary to indicate
0.000000,0,0.000000,this by appending an C<@> or C<%> sign after the type:
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
0.000000,0,0.000000,
0.000000,0,0.000000,To make things more complicated, the hash may contain references to
0.000000,0,0.000000,the actual destinations, for example:
0.000000,0,0.000000,
0.000000,0,0.000000,my $len = 0;
0.000000,0,0.000000,my %h = ('length' => \$len);
0.000000,0,0.000000,GetOptions (\%h, 'length=i');	# will store in $len
0.000000,0,0.000000,
0.000000,0,0.000000,This example is fully equivalent with:
0.000000,0,0.000000,
0.000000,0,0.000000,my $len = 0;
0.000000,0,0.000000,GetOptions ('length=i' => \$len);	# will store in $len
0.000000,0,0.000000,
0.000000,0,0.000000,Any mixture is possible. For example, the most frequently used options
0.000000,0,0.000000,could be stored in variables while all other options get stored in the
0.000000,0,0.000000,hash:
0.000000,0,0.000000,
0.000000,0,0.000000,my $verbose = 0;			# frequently referred
0.000000,0,0.000000,my $debug = 0;			# frequently referred
0.000000,0,0.000000,my %h = ('verbose' => \$verbose, 'debug' => \$debug);
0.000000,0,0.000000,GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
0.000000,0,0.000000,if ( $verbose ) { ... }
0.000000,0,0.000000,if ( exists $h{filter} ) { ... option 'filter' was specified ... }
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Bundling
0.000000,0,0.000000,
0.000000,0,0.000000,With bundling it is possible to set several single-character options
0.000000,0,0.000000,at once. For example if C<a>, C<v> and C<x> are all valid options,
0.000000,0,0.000000,
0.000000,0,0.000000,-vax
0.000000,0,0.000000,
0.000000,0,0.000000,will set all three.
0.000000,0,0.000000,
0.000000,0,0.000000,Getopt::Long supports three styles of bundling. To enable bundling, a
0.000000,0,0.000000,call to Getopt::Long::Configure is required.
0.000000,0,0.000000,
0.000000,0,0.000000,The simplest style of bundling can be enabled with:
0.000000,0,0.000000,
0.000000,0,0.000000,Getopt::Long::Configure ("bundling");
0.000000,0,0.000000,
0.000000,0,0.000000,Configured this way, single-character options can be bundled but long
0.000000,0,0.000000,options (and any of their auto-abbreviated shortened forms) B<must>
0.000000,0,0.000000,always start with a double dash C<--> to avoid ambiguity. For example,
0.000000,0,0.000000,when C<vax>, C<a>, C<v> and C<x> are all valid options,
0.000000,0,0.000000,
0.000000,0,0.000000,-vax
0.000000,0,0.000000,
0.000000,0,0.000000,will set C<a>, C<v> and C<x>, but
0.000000,0,0.000000,
0.000000,0,0.000000,--vax
0.000000,0,0.000000,
0.000000,0,0.000000,will set C<vax>.
0.000000,0,0.000000,
0.000000,0,0.000000,The second style of bundling lifts this restriction. It can be enabled
0.000000,0,0.000000,with:
0.000000,0,0.000000,
0.000000,0,0.000000,Getopt::Long::Configure ("bundling_override");
0.000000,0,0.000000,
0.000000,0,0.000000,Now, C<-vax> will set the option C<vax>.
0.000000,0,0.000000,
0.000000,0,0.000000,In all of the above cases, option values may be inserted in the
0.000000,0,0.000000,bundle. For example:
0.000000,0,0.000000,
0.000000,0,0.000000,-h24w80
0.000000,0,0.000000,
0.000000,0,0.000000,is equivalent to
0.000000,0,0.000000,
0.000000,0,0.000000,-h 24 -w 80
0.000000,0,0.000000,
0.000000,0,0.000000,A third style of bundling allows only values to be bundled with
0.000000,0,0.000000,options. It can be enabled with:
0.000000,0,0.000000,
0.000000,0,0.000000,Getopt::Long::Configure ("bundling_values");
0.000000,0,0.000000,
0.000000,0,0.000000,Now, C<-h24> will set the option C<h> to C<24>, but option bundles
0.000000,0,0.000000,like C<-vxa> and C<-h24w80> are flagged as errors.
0.000000,0,0.000000,
0.000000,0,0.000000,Enabling C<bundling_values> will disable the other two styles of
0.000000,0,0.000000,bundling.
0.000000,0,0.000000,
0.000000,0,0.000000,When configured for bundling, single-character options are matched
0.000000,0,0.000000,case sensitive while long options are matched case insensitive. To
0.000000,0,0.000000,have the single-character options matched case insensitive as well,
0.000000,0,0.000000,use:
0.000000,0,0.000000,
0.000000,0,0.000000,Getopt::Long::Configure ("bundling", "ignorecase_always");
0.000000,0,0.000000,
0.000000,0,0.000000,It goes without saying that bundling can be quite confusing.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 The lonesome dash
0.000000,0,0.000000,
0.000000,0,0.000000,Normally, a lone dash C<-> on the command line will not be considered
0.000000,0,0.000000,an option. Option processing will terminate (unless "permute" is
0.000000,0,0.000000,configured) and the dash will be left in C<@ARGV>.
0.000000,0,0.000000,
0.000000,0,0.000000,It is possible to get special treatment for a lone dash. This can be
0.000000,0,0.000000,achieved by adding an option specification with an empty name, for
0.000000,0,0.000000,example:
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions ('' => \$stdio);
0.000000,0,0.000000,
0.000000,0,0.000000,A lone dash on the command line will now be a legal option, and using
0.000000,0,0.000000,it will set variable C<$stdio>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Argument callback
0.000000,0,0.000000,
0.000000,0,0.000000,A special option 'name' C<< <> >> can be used to designate a subroutine
0.000000,0,0.000000,to handle non-option arguments. When GetOptions() encounters an
0.000000,0,0.000000,argument that does not look like an option, it will immediately call this
0.000000,0,0.000000,subroutine and passes it one parameter: the argument name.
0.000000,0,0.000000,
0.000000,0,0.000000,For example:
0.000000,0,0.000000,
0.000000,0,0.000000,my $width = 80;
0.000000,0,0.000000,sub process { ... }
0.000000,0,0.000000,GetOptions ('width=i' => \$width, '<>' => \&process);
0.000000,0,0.000000,
0.000000,0,0.000000,When applied to the following command line:
0.000000,0,0.000000,
0.000000,0,0.000000,arg1 --width=72 arg2 --width=60 arg3
0.000000,0,0.000000,
0.000000,0,0.000000,This will call
0.000000,0,0.000000,C<process("arg1")> while C<$width> is C<80>,
0.000000,0,0.000000,C<process("arg2")> while C<$width> is C<72>, and
0.000000,0,0.000000,C<process("arg3")> while C<$width> is C<60>.
0.000000,0,0.000000,
0.000000,0,0.000000,This feature requires configuration option B<permute>, see section
0.000000,0,0.000000,L<Configuring Getopt::Long>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 Configuring Getopt::Long
0.000000,0,0.000000,
0.000000,0,0.000000,Getopt::Long can be configured by calling subroutine
0.000000,0,0.000000,Getopt::Long::Configure(). This subroutine takes a list of quoted
0.000000,0,0.000000,strings, each specifying a configuration option to be enabled, e.g.
0.000000,0,0.000000,C<ignore_case>. To disable, prefix with C<no> or C<no_>, e.g.
0.000000,0,0.000000,C<no_ignore_case>. Case does not matter. Multiple calls to Configure()
0.000000,0,0.000000,are possible.
0.000000,0,0.000000,
0.000000,0,0.000000,Alternatively, as of version 2.24, the configuration options may be
0.000000,0,0.000000,passed together with the C<use> statement:
0.000000,0,0.000000,
0.000000,0,0.000000,use Getopt::Long qw(:config no_ignore_case bundling);
0.000000,0,0.000000,
0.000000,0,0.000000,The following options are available:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 12
0.000000,0,0.000000,
0.000000,0,0.000000,=item default
0.000000,0,0.000000,
0.000000,0,0.000000,This option causes all configuration options to be reset to their
0.000000,0,0.000000,default values.
0.000000,0,0.000000,
0.000000,0,0.000000,=item posix_default
0.000000,0,0.000000,
0.000000,0,0.000000,This option causes all configuration options to be reset to their
0.000000,0,0.000000,default values as if the environment variable POSIXLY_CORRECT had
0.000000,0,0.000000,been set.
0.000000,0,0.000000,
0.000000,0,0.000000,=item auto_abbrev
0.000000,0,0.000000,
0.000000,0,0.000000,Allow option names to be abbreviated to uniqueness.
0.000000,0,0.000000,Default is enabled unless environment variable
0.000000,0,0.000000,POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
0.000000,0,0.000000,
0.000000,0,0.000000,=item getopt_compat
0.000000,0,0.000000,
0.000000,0,0.000000,Allow C<+> to start options.
0.000000,0,0.000000,Default is enabled unless environment variable
0.000000,0,0.000000,POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
0.000000,0,0.000000,
0.000000,0,0.000000,=item gnu_compat
0.000000,0,0.000000,
0.000000,0,0.000000,C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
0.000000,0,0.000000,do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
0.000000,0,0.000000,C<--opt=> will give option C<opt> and empty value.
0.000000,0,0.000000,This is the way GNU getopt_long() does it.
0.000000,0,0.000000,
0.000000,0,0.000000,Note that C<--opt value> is still accepted, even though GNU
0.000000,0,0.000000,getopt_long() doesn't.
0.000000,0,0.000000,
0.000000,0,0.000000,=item gnu_getopt
0.000000,0,0.000000,
0.000000,0,0.000000,This is a short way of setting C<gnu_compat> C<bundling> C<permute>
0.000000,0,0.000000,C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
0.000000,0,0.000000,reasonably compatible with GNU getopt_long().
0.000000,0,0.000000,
0.000000,0,0.000000,=item require_order
0.000000,0,0.000000,
0.000000,0,0.000000,Whether command line arguments are allowed to be mixed with options.
0.000000,0,0.000000,Default is disabled unless environment variable
0.000000,0,0.000000,POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
0.000000,0,0.000000,
0.000000,0,0.000000,See also C<permute>, which is the opposite of C<require_order>.
0.000000,0,0.000000,
0.000000,0,0.000000,=item permute
0.000000,0,0.000000,
0.000000,0,0.000000,Whether command line arguments are allowed to be mixed with options.
0.000000,0,0.000000,Default is enabled unless environment variable
0.000000,0,0.000000,POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
0.000000,0,0.000000,Note that C<permute> is the opposite of C<require_order>.
0.000000,0,0.000000,
0.000000,0,0.000000,If C<permute> is enabled, this means that
0.000000,0,0.000000,
0.000000,0,0.000000,--foo arg1 --bar arg2 arg3
0.000000,0,0.000000,
0.000000,0,0.000000,is equivalent to
0.000000,0,0.000000,
0.000000,0,0.000000,--foo --bar arg1 arg2 arg3
0.000000,0,0.000000,
0.000000,0,0.000000,If an argument callback routine is specified, C<@ARGV> will always be
0.000000,0,0.000000,empty upon successful return of GetOptions() since all options have been
0.000000,0,0.000000,processed. The only exception is when C<--> is used:
0.000000,0,0.000000,
0.000000,0,0.000000,--foo arg1 --bar arg2 -- arg3
0.000000,0,0.000000,
0.000000,0,0.000000,This will call the callback routine for arg1 and arg2, and then
0.000000,0,0.000000,terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
0.000000,0,0.000000,
0.000000,0,0.000000,If C<require_order> is enabled, options processing
0.000000,0,0.000000,terminates when the first non-option is encountered.
0.000000,0,0.000000,
0.000000,0,0.000000,--foo arg1 --bar arg2 arg3
0.000000,0,0.000000,
0.000000,0,0.000000,is equivalent to
0.000000,0,0.000000,
0.000000,0,0.000000,--foo -- arg1 --bar arg2 arg3
0.000000,0,0.000000,
0.000000,0,0.000000,If C<pass_through> is also enabled, options processing will terminate
0.000000,0,0.000000,at the first unrecognized option, or non-option, whichever comes
0.000000,0,0.000000,first.
0.000000,0,0.000000,
0.000000,0,0.000000,=item bundling (default: disabled)
0.000000,0,0.000000,
0.000000,0,0.000000,Enabling this option will allow single-character options to be
0.000000,0,0.000000,bundled. To distinguish bundles from long option names, long options
0.000000,0,0.000000,(and any of their auto-abbreviated shortened forms) I<must> be
0.000000,0,0.000000,introduced with C<--> and bundles with C<->.
0.000000,0,0.000000,
0.000000,0,0.000000,Note that, if you have options C<a>, C<l> and C<all>, and
0.000000,0,0.000000,auto_abbrev enabled, possible arguments and option settings are:
0.000000,0,0.000000,
0.000000,0,0.000000,using argument               sets option(s)
0.000000,0,0.000000,------------------------------------------
0.000000,0,0.000000,-a, --a                      a
0.000000,0,0.000000,-l, --l                      l
0.000000,0,0.000000,-al, -la, -ala, -all,...     a, l
0.000000,0,0.000000,--al, --all                  all
0.000000,0,0.000000,
0.000000,0,0.000000,The surprising part is that C<--a> sets option C<a> (due to auto
0.000000,0,0.000000,completion), not C<all>.
0.000000,0,0.000000,
0.000000,0,0.000000,Note: disabling C<bundling> also disables C<bundling_override>.
0.000000,0,0.000000,
0.000000,0,0.000000,=item bundling_override (default: disabled)
0.000000,0,0.000000,
0.000000,0,0.000000,If C<bundling_override> is enabled, bundling is enabled as with
0.000000,0,0.000000,C<bundling> but now long option names override option bundles.
0.000000,0,0.000000,
0.000000,0,0.000000,Note: disabling C<bundling_override> also disables C<bundling>.
0.000000,0,0.000000,
0.000000,0,0.000000,B<Note:> Using option bundling can easily lead to unexpected results,
0.000000,0,0.000000,especially when mixing long options and bundles. Caveat emptor.
0.000000,0,0.000000,
0.000000,0,0.000000,=item ignore_case  (default: enabled)
0.000000,0,0.000000,
0.000000,0,0.000000,If enabled, case is ignored when matching option names. If, however,
0.000000,0,0.000000,bundling is enabled as well, single character options will be treated
0.000000,0,0.000000,case-sensitive.
0.000000,0,0.000000,
0.000000,0,0.000000,With C<ignore_case>, option specifications for options that only
0.000000,0,0.000000,differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
0.000000,0,0.000000,duplicates.
0.000000,0,0.000000,
0.000000,0,0.000000,Note: disabling C<ignore_case> also disables C<ignore_case_always>.
0.000000,0,0.000000,
0.000000,0,0.000000,=item ignore_case_always (default: disabled)
0.000000,0,0.000000,
0.000000,0,0.000000,When bundling is in effect, case is ignored on single-character
0.000000,0,0.000000,options also.
0.000000,0,0.000000,
0.000000,0,0.000000,Note: disabling C<ignore_case_always> also disables C<ignore_case>.
0.000000,0,0.000000,
0.000000,0,0.000000,=item auto_version (default:disabled)
0.000000,0,0.000000,
0.000000,0,0.000000,Automatically provide support for the B<--version> option if
0.000000,0,0.000000,the application did not specify a handler for this option itself.
0.000000,0,0.000000,
0.000000,0,0.000000,Getopt::Long will provide a standard version message that includes the
0.000000,0,0.000000,program name, its version (if $main::VERSION is defined), and the
0.000000,0,0.000000,versions of Getopt::Long and Perl. The message will be written to
0.000000,0,0.000000,standard output and processing will terminate.
0.000000,0,0.000000,
0.000000,0,0.000000,C<auto_version> will be enabled if the calling program explicitly
0.000000,0,0.000000,specified a version number higher than 2.32 in the C<use> or
0.000000,0,0.000000,C<require> statement.
0.000000,0,0.000000,
0.000000,0,0.000000,=item auto_help (default:disabled)
0.000000,0,0.000000,
0.000000,0,0.000000,Automatically provide support for the B<--help> and B<-?> options if
0.000000,0,0.000000,the application did not specify a handler for this option itself.
0.000000,0,0.000000,
0.000000,0,0.000000,Getopt::Long will provide a help message using module L<Pod::Usage>. The
0.000000,0,0.000000,message, derived from the SYNOPSIS POD section, will be written to
0.000000,0,0.000000,standard output and processing will terminate.
0.000000,0,0.000000,
0.000000,0,0.000000,C<auto_help> will be enabled if the calling program explicitly
0.000000,0,0.000000,specified a version number higher than 2.32 in the C<use> or
0.000000,0,0.000000,C<require> statement.
0.000000,0,0.000000,
0.000000,0,0.000000,=item pass_through (default: disabled)
0.000000,0,0.000000,
0.000000,0,0.000000,With C<pass_through> anything that is unknown, ambiguous or supplied with
0.000000,0,0.000000,an invalid option will not be flagged as an error. Instead the unknown
0.000000,0,0.000000,option(s) will be passed to the catchall C<< <> >> if present, otherwise
0.000000,0,0.000000,through to C<@ARGV>. This makes it possible to write wrapper scripts that
0.000000,0,0.000000,process only part of the user supplied command line arguments, and pass the
0.000000,0,0.000000,remaining options to some other program.
0.000000,0,0.000000,
0.000000,0,0.000000,If C<require_order> is enabled, options processing will terminate at the
0.000000,0,0.000000,first unrecognized option, or non-option, whichever comes first and all
0.000000,0,0.000000,remaining arguments are passed to C<@ARGV> instead of the catchall
0.000000,0,0.000000,C<< <> >> if present.  However, if C<permute> is enabled instead, results
0.000000,0,0.000000,can become confusing.
0.000000,0,0.000000,
0.000000,0,0.000000,Note that the options terminator (default C<-->), if present, will
0.000000,0,0.000000,also be passed through in C<@ARGV>.
0.000000,0,0.000000,
0.000000,0,0.000000,=item prefix
0.000000,0,0.000000,
0.000000,0,0.000000,The string that starts options. If a constant string is not
0.000000,0,0.000000,sufficient, see C<prefix_pattern>.
0.000000,0,0.000000,
0.000000,0,0.000000,=item prefix_pattern
0.000000,0,0.000000,
0.000000,0,0.000000,A Perl pattern that identifies the strings that introduce options.
0.000000,0,0.000000,Default is C<--|-|\+> unless environment variable
0.000000,0,0.000000,POSIXLY_CORRECT has been set, in which case it is C<--|->.
0.000000,0,0.000000,
0.000000,0,0.000000,=item long_prefix_pattern
0.000000,0,0.000000,
0.000000,0,0.000000,A Perl pattern that allows the disambiguation of long and short
0.000000,0,0.000000,prefixes. Default is C<-->.
0.000000,0,0.000000,
0.000000,0,0.000000,Typically you only need to set this if you are using nonstandard
0.000000,0,0.000000,prefixes and want some or all of them to have the same semantics as
0.000000,0,0.000000,'--' does under normal circumstances.
0.000000,0,0.000000,
0.000000,0,0.000000,For example, setting prefix_pattern to C<--|-|\+|\/> and
0.000000,0,0.000000,long_prefix_pattern to C<--|\/> would add Win32 style argument
0.000000,0,0.000000,handling.
0.000000,0,0.000000,
0.000000,0,0.000000,=item debug (default: disabled)
0.000000,0,0.000000,
0.000000,0,0.000000,Enable debugging output.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 Exportable Methods
0.000000,0,0.000000,
0.000000,0,0.000000,=over
0.000000,0,0.000000,
0.000000,0,0.000000,=item VersionMessage
0.000000,0,0.000000,
0.000000,0,0.000000,This subroutine provides a standard version message. Its argument can be:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item *
0.000000,0,0.000000,
0.000000,0,0.000000,A string containing the text of a message to print I<before> printing
0.000000,0,0.000000,the standard message.
0.000000,0,0.000000,
0.000000,0,0.000000,=item *
0.000000,0,0.000000,
0.000000,0,0.000000,A numeric value corresponding to the desired exit status.
0.000000,0,0.000000,
0.000000,0,0.000000,=item *
0.000000,0,0.000000,
0.000000,0,0.000000,A reference to a hash.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,If more than one argument is given then the entire argument list is
0.000000,0,0.000000,assumed to be a hash.  If a hash is supplied (either as a reference or
0.000000,0,0.000000,as a list) it should contain one or more elements with the following
0.000000,0,0.000000,keys:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item C<-message>
0.000000,0,0.000000,
0.000000,0,0.000000,=item C<-msg>
0.000000,0,0.000000,
0.000000,0,0.000000,The text of a message to print immediately prior to printing the
0.000000,0,0.000000,program's usage message.
0.000000,0,0.000000,
0.000000,0,0.000000,=item C<-exitval>
0.000000,0,0.000000,
0.000000,0,0.000000,The desired exit status to pass to the B<exit()> function.
0.000000,0,0.000000,This should be an integer, or else the string "NOEXIT" to
0.000000,0,0.000000,indicate that control should simply be returned without
0.000000,0,0.000000,terminating the invoking process.
0.000000,0,0.000000,
0.000000,0,0.000000,=item C<-output>
0.000000,0,0.000000,
0.000000,0,0.000000,A reference to a filehandle, or the pathname of a file to which the
0.000000,0,0.000000,usage message should be written. The default is C<\*STDERR> unless the
0.000000,0,0.000000,exit value is less than 2 (in which case the default is C<\*STDOUT>).
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,You cannot tie this routine directly to an option, e.g.:
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions("version" => \&VersionMessage);
0.000000,0,0.000000,
0.000000,0,0.000000,Use this instead:
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions("version" => sub { VersionMessage() });
0.000000,0,0.000000,
0.000000,0,0.000000,=item HelpMessage
0.000000,0,0.000000,
0.000000,0,0.000000,This subroutine produces a standard help message, derived from the
0.000000,0,0.000000,program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
0.000000,0,0.000000,arguments as VersionMessage(). In particular, you cannot tie it
0.000000,0,0.000000,directly to an option, e.g.:
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions("help" => \&HelpMessage);
0.000000,0,0.000000,
0.000000,0,0.000000,Use this instead:
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions("help" => sub { HelpMessage() });
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 Return values and Errors
0.000000,0,0.000000,
0.000000,0,0.000000,Configuration errors and errors in the option definitions are
0.000000,0,0.000000,signalled using die() and will terminate the calling program unless
0.000000,0,0.000000,the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
0.000000,0,0.000000,}>, or die() was trapped using C<$SIG{__DIE__}>.
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions returns true to indicate success.
0.000000,0,0.000000,It returns false when the function detected one or more errors during
0.000000,0,0.000000,option parsing. These errors are signalled using warn() and can be
0.000000,0,0.000000,trapped with C<$SIG{__WARN__}>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 Legacy
0.000000,0,0.000000,
0.000000,0,0.000000,The earliest development of C<newgetopt.pl> started in 1990, with Perl
0.000000,0,0.000000,version 4. As a result, its development, and the development of
0.000000,0,0.000000,Getopt::Long, has gone through several stages. Since backward
0.000000,0,0.000000,compatibility has always been extremely important, the current version
0.000000,0,0.000000,of Getopt::Long still supports a lot of constructs that nowadays are
0.000000,0,0.000000,no longer necessary or otherwise unwanted. This section describes
0.000000,0,0.000000,briefly some of these 'features'.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Default destinations
0.000000,0,0.000000,
0.000000,0,0.000000,When no destination is specified for an option, GetOptions will store
0.000000,0,0.000000,the resultant value in a global variable named C<opt_>I<XXX>, where
0.000000,0,0.000000,I<XXX> is the primary name of this option. When a program executes
0.000000,0,0.000000,under C<use strict> (recommended), these variables must be
0.000000,0,0.000000,pre-declared with our() or C<use vars>.
0.000000,0,0.000000,
0.000000,0,0.000000,our $opt_length = 0;
0.000000,0,0.000000,GetOptions ('length=i');	# will store in $opt_length
0.000000,0,0.000000,
0.000000,0,0.000000,To yield a usable Perl variable, characters that are not part of the
0.000000,0,0.000000,syntax for variables are translated to underscores. For example,
0.000000,0,0.000000,C<--fpp-struct-return> will set the variable
0.000000,0,0.000000,C<$opt_fpp_struct_return>. Note that this variable resides in the
0.000000,0,0.000000,namespace of the calling program, not necessarily C<main>. For
0.000000,0,0.000000,example:
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions ("size=i", "sizes=i@");
0.000000,0,0.000000,
0.000000,0,0.000000,with command line "-size 10 -sizes 24 -sizes 48" will perform the
0.000000,0,0.000000,equivalent of the assignments
0.000000,0,0.000000,
0.000000,0,0.000000,$opt_size = 10;
0.000000,0,0.000000,@opt_sizes = (24, 48);
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Alternative option starters
0.000000,0,0.000000,
0.000000,0,0.000000,A string of alternative option starter characters may be passed as the
0.000000,0,0.000000,first argument (or the first argument after a leading hash reference
0.000000,0,0.000000,argument).
0.000000,0,0.000000,
0.000000,0,0.000000,my $len = 0;
0.000000,0,0.000000,GetOptions ('/', 'length=i' => $len);
0.000000,0,0.000000,
0.000000,0,0.000000,Now the command line may look like:
0.000000,0,0.000000,
0.000000,0,0.000000,/length 24 -- arg
0.000000,0,0.000000,
0.000000,0,0.000000,Note that to terminate options processing still requires a double dash
0.000000,0,0.000000,C<-->.
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions() will not interpret a leading C<< "<>" >> as option starters
0.000000,0,0.000000,if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
0.000000,0,0.000000,option starters, use C<< "><" >>. Confusing? Well, B<using a starter
0.000000,0,0.000000,argument is strongly deprecated> anyway.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Configuration variables
0.000000,0,0.000000,
0.000000,0,0.000000,Previous versions of Getopt::Long used variables for the purpose of
0.000000,0,0.000000,configuring. Although manipulating these variables still work, it is
0.000000,0,0.000000,strongly encouraged to use the C<Configure> routine that was introduced
0.000000,0,0.000000,in version 2.17. Besides, it is much easier.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 Tips and Techniques
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Pushing multiple values in a hash option
0.000000,0,0.000000,
0.000000,0,0.000000,Sometimes you want to combine the best of hashes and arrays. For
0.000000,0,0.000000,example, the command line:
0.000000,0,0.000000,
0.000000,0,0.000000,--list add=first --list add=second --list add=third
0.000000,0,0.000000,
0.000000,0,0.000000,where each successive 'list add' option will push the value of add
0.000000,0,0.000000,into array ref $list->{'add'}. The result would be like
0.000000,0,0.000000,
0.000000,0,0.000000,$list->{add} = [qw(first second third)];
0.000000,0,0.000000,
0.000000,0,0.000000,This can be accomplished with a destination routine:
0.000000,0,0.000000,
0.000000,0,0.000000,GetOptions('list=s%' =>
0.000000,0,0.000000,sub { push(@{$list{$_[1]}}, $_[2]) });
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 Troubleshooting
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 GetOptions does not return a false result when an option is not supplied
0.000000,0,0.000000,
0.000000,0,0.000000,That's why they're called 'options'.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 GetOptions does not split the command line correctly
0.000000,0,0.000000,
0.000000,0,0.000000,The command line is not split by GetOptions, but by the command line
0.000000,0,0.000000,interpreter (CLI). On Unix, this is the shell. On Windows, it is
0.000000,0,0.000000,COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
0.000000,0,0.000000,
0.000000,0,0.000000,It is important to know that these CLIs may behave different when the
0.000000,0,0.000000,command line contains special characters, in particular quotes or
0.000000,0,0.000000,backslashes. For example, with Unix shells you can use single quotes
0.000000,0,0.000000,(C<'>) and double quotes (C<">) to group words together. The following
0.000000,0,0.000000,alternatives are equivalent on Unix:
0.000000,0,0.000000,
0.000000,0,0.000000,"two words"
0.000000,0,0.000000,'two words'
0.000000,0,0.000000,two\ words
0.000000,0,0.000000,
0.000000,0,0.000000,In case of doubt, insert the following statement in front of your Perl
0.000000,0,0.000000,program:
0.000000,0,0.000000,
0.000000,0,0.000000,print STDERR (join("|",@ARGV),"\n");
0.000000,0,0.000000,
0.000000,0,0.000000,to verify how your CLI passes the arguments to the program.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Undefined subroutine &main::GetOptions called
0.000000,0,0.000000,
0.000000,0,0.000000,Are you running Windows, and did you write
0.000000,0,0.000000,
0.000000,0,0.000000,use GetOpt::Long;
0.000000,0,0.000000,
0.000000,0,0.000000,(note the capital 'O')?
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 How do I put a "-?" option into a Getopt::Long?
0.000000,0,0.000000,
0.000000,0,0.000000,You can only obtain this using an alias, and Getopt::Long of at least
0.000000,0,0.000000,version 2.13.
0.000000,0,0.000000,
0.000000,0,0.000000,use Getopt::Long;
0.000000,0,0.000000,GetOptions ("help|?");    # -help and -? will both set $opt_help
0.000000,0,0.000000,
0.000000,0,0.000000,Other characters that can't appear in Perl identifiers are also
0.000000,0,0.000000,supported in aliases with Getopt::Long of at version 2.39. Note that
0.000000,0,0.000000,the characters C<!>, C<|>, C<+>, C<=>, and C<:> can only appear as the
0.000000,0,0.000000,first (or only) character of an alias.
0.000000,0,0.000000,
0.000000,0,0.000000,As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
0.000000,0,0.000000,to add the options --help and -? to your program, and handle them.
0.000000,0,0.000000,
0.000000,0,0.000000,See C<auto_help> in section L<Configuring Getopt::Long>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHOR
0.000000,0,0.000000,
0.000000,0,0.000000,Johan Vromans <jvromans@squirrel.nl>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT AND DISCLAIMER
0.000000,0,0.000000,
0.000000,0,0.000000,This program is Copyright 1990,2015 by Johan Vromans.
0.000000,0,0.000000,This program is free software; you can redistribute it and/or
0.000000,0,0.000000,modify it under the terms of the Perl Artistic License or the
0.000000,0,0.000000,GNU General Public License as published by the Free Software
0.000000,0,0.000000,Foundation; either version 2 of the License, or (at your option) any
0.000000,0,0.000000,later version.
0.000000,0,0.000000,
0.000000,0,0.000000,This program is distributed in the hope that it will be useful,
0.000000,0,0.000000,but WITHOUT ANY WARRANTY; without even the implied warranty of
0.000000,0,0.000000,MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
0.000000,0,0.000000,GNU General Public License for more details.
0.000000,0,0.000000,
0.000000,0,0.000000,If you do not have a copy of the GNU General Public License write to
0.000000,0,0.000000,the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
0.000000,0,0.000000,MA 02139, USA.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
