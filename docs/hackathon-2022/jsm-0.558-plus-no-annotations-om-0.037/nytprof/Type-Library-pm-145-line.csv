# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Type::Library;
0.000000,0,0.000000,
0.000034,2,0.000017,use 5.008001;
0.000025,2,0.000013,use strict;
0.000029,2,0.000015,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,$Type::Library::AUTHORITY = 'cpan:TOBYINK';
0.000002,1,0.000002,$Type::Library::VERSION   = '2.000001';
0.000026,1,0.000026,}
0.000000,0,0.000000,
0.000001,1,0.000001,$Type::Library::VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.001008,2,0.000504,use Eval::TypeTiny qw< eval_closure set_subname type_to_coderef NICE_PROTOTYPES >;
0.000018,2,0.000009,use Scalar::Util qw< blessed refaddr >;
0.000589,2,0.000295,use Type::Tiny      ();
0.000593,2,0.000296,use Types::TypeTiny ();
0.000000,0,0.000000,
0.000001,1,0.000001,require Exporter::Tiny;
0.000008,1,0.000008,our @ISA = 'Exporter::Tiny';
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
0.000000,0,0.000000,
0.000000,0,0.000000,####
0.000000,0,0.000000,#### Hooks for Exporter::Tiny
0.000000,0,0.000000,####
0.000000,0,0.000000,
0.000000,0,0.000000,# Handling for -base, -extends, and -utils tags.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub _exporter_validate_opts {
0.000005,8,0.000001,my ( $class, $opts ) = ( shift, @_ );
0.000000,0,0.000000,
0.000000,0,0.000000,$class->setup_type_library( @{$opts}{qw/ into utils extends /} )
0.000011,8,0.000001,if $_[0]{base} || $_[0]{extends};
0.000000,0,0.000000,
0.000031,8,0.000004,return $class->SUPER::_exporter_validate_opts( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# In Exporter::Tiny, this method takes a sub name, a 'value' (i.e.
0.000000,0,0.000000,# potentially an options hashref for the export), and some global
0.000000,0,0.000000,# options, and returns a list of name+coderef pairs to actually
0.000000,0,0.000000,# export. We override it to provide some useful features.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub _exporter_expand_sub {
0.000009,40,0.000000,my $class = shift;
0.000010,40,0.000000,my ( $name, $value, $globals ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Handle exporting '+Type'.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Note that this recurses, so if used in conjunction with the other
0.000000,0,0.000000,# special cases handled by this method, will still work.
0.000000,0,0.000000,#
0.000054,40,0.000001,if ( $name =~ /^\+(.+)/ and $class->has_type( "$1" ) ) {
0.000000,0,0.000000,my $type     = $class->get_type( "$1" );
0.000000,0,0.000000,my $exported = $type->exportables;
0.000000,0,0.000000,return map $class->_exporter_expand_sub(
0.000000,0,0.000000,$_->{name},
0.000000,0,0.000000,+{ %{ $value || {} } },
0.000000,0,0.000000,$globals,
0.000000,0,0.000000,), @$exported;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Is the function being exported one which is associated with a
0.000000,0,0.000000,# type constraint? If so, which one. If not, then forget the rest
0.000000,0,0.000000,# and just use the superclass method.
0.000000,0,0.000000,#
0.000101,40,0.000003,if ( my $f = $class->meta->{'functions'}{$name}
0.000000,0,0.000000,and  defined $class->meta->{'functions'}{$name}{'type'} ) {
0.000000,0,0.000000,
0.000007,40,0.000000,my $type      = $f->{type};
0.000020,40,0.000001,my $tag       = $f->{tags}[0];
0.000041,40,0.000001,my $typename  = $type->name;
0.000000,0,0.000000,
0.000000,0,0.000000,# If $value has `of` or `where` options, then this is a
0.000000,0,0.000000,# custom type.
0.000000,0,0.000000,#
0.000001,40,0.000000,my $custom_type = 0;
0.000021,40,0.000001,for my $param ( qw/ of where / ) {
0.000013,80,0.000000,exists $value->{$param} or next;
0.000000,0,0.000000,defined $value->{-as} or _croak( "Parameter '-as' not supplied" );
0.000000,0,0.000000,$type = $type->$param( $value->{$param} );
0.000000,0,0.000000,$name = $value->{-as};
0.000000,0,0.000000,++$custom_type;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# If we're exporting a type itself, then export a custom
0.000000,0,0.000000,# function if they customized the type or want a Moose/Mouse
0.000000,0,0.000000,# type constraint.
0.000000,0,0.000000,#
0.000015,40,0.000000,if ( $tag eq 'types' ) {
0.000009,40,0.000000,my $post_method = q();
0.000007,40,0.000000,$post_method = '->mouse_type' if $globals->{mouse};
0.000005,40,0.000000,$post_method = '->moose_type' if $globals->{moose};
0.000013,40,0.000000,return ( $name => type_to_coderef( $type, post_method => $post_method ) )
0.000000,0,0.000000,if $post_method || $custom_type;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# If they're exporting some other type of function, like
0.000000,0,0.000000,# 'to', 'is', or 'assert', then find the correct exportable
0.000000,0,0.000000,# by tag name, and return that.
0.000000,0,0.000000,#
0.000000,0,0.000000,# XXX: this will fail for tags like 'constants' where there
0.000000,0,0.000000,# will be multiple exportables which match!
0.000000,0,0.000000,#
0.000013,40,0.000000,if ( $custom_type and $tag ne 'types' ) {
0.000000,0,0.000000,my $exportable = $type->exportables_by_tag( $tag, $typename );
0.000000,0,0.000000,return ( $value->{-as} || $exportable->{name}, $exportable->{code} );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# In all other cases, the superclass method will work.
0.000000,0,0.000000,#
0.000081,40,0.000002,return $class->SUPER::_exporter_expand_sub( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Mostly just rely on superclass to do the actual export, but add
0.000000,0,0.000000,# a couple of useful behaviours.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub _exporter_install_sub {
0.000007,40,0.000000,my $class = shift;
0.000011,40,0.000000,my ( $name, $value, $globals, $sym ) = @_;
0.000000,0,0.000000,
0.000015,40,0.000000,my $into = $globals->{into};
0.000026,40,0.000001,my $type = $class->meta->{'functions'}{$name}{'type'};
0.000028,40,0.000001,my $tags = $class->meta->{'functions'}{$name}{'tags'};
0.000000,0,0.000000,
0.000000,0,0.000000,# Issue a warning if exporting a deprecated type constraint.
0.000000,0,0.000000,# 
0.000000,0,0.000000,Exporter::Tiny::_carp(
0.000000,0,0.000000,"Exporting deprecated type %s to %s",
0.000000,0,0.000000,$type->qualified_name,
0.000000,0,0.000000,ref( $into ) ? "reference" : "package $into",
0.000031,40,0.000001,) if ( defined $type and $type->deprecated and not $globals->{allow_deprecated} );
0.000000,0,0.000000,
0.000000,0,0.000000,# If exporting a type constraint into a real package, then
0.000000,0,0.000000,# add it to the package's type registry.
0.000000,0,0.000000,# 
0.000031,40,0.000001,if ( !ref $into
0.000000,0,0.000000,and  $into ne '-lexical'
0.000000,0,0.000000,and  defined $type
0.000000,0,0.000000,and  grep $_ eq 'types', @$tags ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# If they're renaming it, figure out what name, and use that.
0.000000,0,0.000000,# XXX: `-as` can be a coderef, and can be in $globals in that case.
0.000031,40,0.000001,my ( $prefix ) = grep defined, $value->{-prefix}, $globals->{prefix}, q();
0.000018,40,0.000000,my ( $suffix ) = grep defined, $value->{-suffix}, $globals->{suffix}, q();
0.000012,40,0.000000,my $as         = $prefix . ( $value->{-as} || $name ) . $suffix;
0.000000,0,0.000000,
0.000000,0,0.000000,$INC{'Type/Registry.pm'}
0.000000,0,0.000000,? 'Type::Registry'->for_class( $into )->add_type( $type, $as )
0.000029,40,0.000001,: ( $Type::Registry::DELAYED{$into}{$as} = $type );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000080,40,0.000002,$class->SUPER::_exporter_install_sub( @_ );
0.000000,0,0.000000,} #/ sub _exporter_install_sub
0.000000,0,0.000000,
0.000000,0,0.000000,sub _exporter_fail {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my ( $name, $value, $globals ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Passing the `-declare` flag means that if a type isn't found, then
0.000000,0,0.000000,# we export a placeholder function instead of failing.
0.000000,0,0.000000,if ( $globals->{declare} ) {
0.000000,0,0.000000,return (
0.000000,0,0.000000,$name,
0.000000,0,0.000000,type_to_coderef(
0.000000,0,0.000000,undef,
0.000000,0,0.000000,type_name    => $name,
0.000000,0,0.000000,type_library => $globals->{into} || _croak( "Parameter 'into' not supplied" ),
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ if ( $globals->{declare...})
0.000000,0,0.000000,
0.000000,0,0.000000,return $class->SUPER::_exporter_fail( @_ );
0.000000,0,0.000000,} #/ sub _exporter_fail
0.000000,0,0.000000,
0.000000,0,0.000000,####
0.000000,0,0.000000,#### Type library functionality
0.000000,0,0.000000,####
0.000000,0,0.000000,
0.000000,0,0.000000,sub setup_type_library {
0.000000,1,0.000000,my ( $class, $type_library, $install_utils, $extends ) = @_;
0.000000,0,0.000000,
0.000000,1,0.000000,my @extends = ref( $extends ) ? @$extends : $extends ? $extends : ();
0.000000,1,0.000000,unshift @extends, $class if $class ne __PACKAGE__;
0.000000,0,0.000000,
0.000000,1,0.000000,if ( not ref $type_library ) {
0.000116,2,0.000058,no strict "refs";
0.000006,1,0.000006,push @{"$type_library\::ISA"}, $class;
0.000005,1,0.000005,( my $file = $type_library ) =~ s{::}{/}g;
0.000001,1,0.000001,$INC{"$file.pm"} ||= __FILE__;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,if ( $install_utils ) {
0.000000,0,0.000000,require Type::Utils;
0.000000,0,0.000000,'Type::Utils'->import( { into => $type_library }, '-default' );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,if ( @extends and not ref $type_library ) {
0.000000,0,0.000000,require Type::Utils;
0.000000,0,0.000000,my $wrapper = eval "sub { package $type_library; &Type::Utils::extends; }";
0.000000,0,0.000000,$wrapper->( @extends );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub meta {
0.000020,2,0.000010,no strict "refs";
0.000131,2,0.000065,no warnings "once";
0.000578,295,0.000002,return $_[0] if blessed $_[0];
0.000284,163,0.000002,${"$_[0]\::META"} ||= bless {}, $_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_type {
0.000028,37,0.000001,my $meta  = shift->meta;
0.000057,37,0.000002,my $class = blessed( $meta ) ;
0.000000,0,0.000000,
0.000011,37,0.000000,_croak( 'Type library is immutable' ) if $meta->{immutable};
0.000000,0,0.000000,
0.000000,0,0.000000,my $type =
0.000000,0,0.000000,ref( $_[0] ) =~ /^Type::Tiny\b/ ? $_[0] :
0.000000,0,0.000000,blessed( $_[0] )                ? Types::TypeTiny::to_TypeTiny( $_[0] ) :
0.000179,37,0.000005,ref( $_[0] ) eq q(HASH)         ? 'Type::Tiny'->new( library => $class, %{ $_[0] } ) :
0.000000,0,0.000000,"Type::Tiny"->new( library => $class, @_ );
0.000021,37,0.000001,my $name = $type->{name};
0.000000,0,0.000000,
0.000028,37,0.000001,_croak( 'Type %s already exists in this library', $name )       if $meta->has_type( $name );
0.000020,37,0.000001,_croak( 'Type %s conflicts with coercion of same name', $name ) if $meta->has_coercion( $name );
0.000027,37,0.000001,_croak( 'Cannot add anonymous type to a library' )              if $type->is_anon;
0.000009,37,0.000000,$meta->{types} ||= {};
0.000021,37,0.000001,$meta->{types}{$name} = $type;
0.000000,0,0.000000,
0.000022,2,0.000011,no strict "refs";
0.000665,2,0.000333,no warnings "redefine", "prototype";
0.000000,0,0.000000,
0.000077,37,0.000002,for my $exportable ( @{ $type->exportables } ) {
0.000032,148,0.000000,my $name = $exportable->{name};
0.000021,148,0.000000,my $code = $exportable->{code};
0.000018,148,0.000000,my $tags = $exportable->{tags};
0.000289,148,0.000002,*{"$class\::$name"} = set_subname( "$class\::$name", $code );
0.000071,148,0.000000,push @{"$class\::EXPORT_OK"}, $name;
0.000150,148,0.000001,push @{ ${"$class\::EXPORT_TAGS"}{$_} ||= [] }, $name for @$tags;
0.000279,148,0.000002,$meta->{'functions'}{$name} = { type => $type, tags => $tags };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$INC{'Type/Registry.pm'}
0.000000,0,0.000000,? 'Type::Registry'->for_class( $class )->add_type( $type, $name )
0.000024,37,0.000001,: ( $Type::Registry::DELAYED{$class}{$name} = $type );
0.000000,0,0.000000,
0.000073,37,0.000002,return $type;
0.000000,0,0.000000,} #/ sub add_type
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_type {
0.000018,11,0.000002,my $meta = shift->meta;
0.000028,11,0.000003,$meta->{types}{ $_[0] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_type {
0.000022,40,0.000001,my $meta = shift->meta;
0.000057,40,0.000001,exists $meta->{types}{ $_[0] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub type_names {
0.000000,0,0.000000,my $meta = shift->meta;
0.000000,0,0.000000,keys %{ $meta->{types} };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_coercion {
0.000001,3,0.000000,my $meta  = shift->meta;
0.000004,3,0.000001,my $class = blessed( $meta );
0.000000,0,0.000000,
0.000001,3,0.000000,_croak( 'Type library is immutable' ) if $meta->{immutable};
0.000000,0,0.000000,
0.000003,3,0.000001,require Type::Coercion;
0.000010,3,0.000003,my $c     = blessed( $_[0] ) ? $_[0] : "Type::Coercion"->new( @_ );
0.000002,3,0.000001,my $name  = $c->name;
0.000000,0,0.000000,
0.000003,3,0.000001,_croak( 'Coercion %s already exists in this library', $name )   if $meta->has_coercion( $name );
0.000001,3,0.000000,_croak( 'Coercion %s conflicts with type of same name', $name ) if $meta->has_type( $name );
0.000002,3,0.000001,_croak( 'Cannot add anonymous type to a library' )              if $c->is_anon;
0.000000,0,0.000000,
0.000001,3,0.000000,$meta->{coercions} ||= {};
0.000001,3,0.000000,$meta->{coercions}{$name} = $c;
0.000000,0,0.000000,
0.000025,2,0.000012,no strict "refs";
0.000146,2,0.000073,no warnings "redefine", "prototype";
0.000000,0,0.000000,
0.000006,3,0.000002,*{"$class\::$name"} = type_to_coderef( $c );
0.000002,3,0.000001,push @{"$class\::EXPORT_OK"}, $name;
0.000004,3,0.000001,push @{ ${"$class\::EXPORT_TAGS"}{'coercions'} ||= [] }, $name;
0.000007,3,0.000002,$meta->{'functions'}{$name} = { coercion => $c, tags => [ 'coercions' ] };
0.000000,0,0.000000,
0.000006,3,0.000002,return $c;
0.000000,0,0.000000,} #/ sub add_coercion
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_coercion {
0.000000,0,0.000000,my $meta = shift->meta;
0.000000,0,0.000000,$meta->{coercions}{ $_[0] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_coercion {
0.000019,40,0.000000,my $meta = shift->meta;
0.000052,40,0.000001,exists $meta->{coercions}{ $_[0] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub coercion_names {
0.000000,0,0.000000,my $meta = shift->meta;
0.000000,0,0.000000,keys %{ $meta->{coercions} };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub make_immutable {
0.000001,1,0.000001,my $meta  = shift->meta;
0.000001,1,0.000001,my $class = ref( $meta );
0.000000,0,0.000000,
0.000023,2,0.000012,no strict "refs";
0.000132,2,0.000066,no warnings "redefine", "prototype";
0.000000,0,0.000000,
0.000105,1,0.000105,for my $type ( values %{ $meta->{types} } ) {
0.000043,37,0.000001,$type->coercion->freeze;
0.000022,37,0.000001,next unless $type->has_coercion && $type->coercion->frozen;
0.000029,1,0.000029,for my $e ( $type->exportables_by_tag( 'to' ) ) {
0.000001,1,0.000001,my $qualified_name = $class . '::' . $e->{name};
0.000006,1,0.000006,*$qualified_name = set_subname( $qualified_name, $e->{code} );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,$meta->{immutable} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
