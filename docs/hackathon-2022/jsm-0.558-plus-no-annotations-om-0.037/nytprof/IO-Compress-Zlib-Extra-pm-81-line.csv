# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package IO::Compress::Zlib::Extra;
0.000000,0,0.000000,
0.000007,1,0.000007,require 5.006 ;
0.000000,0,0.000000,
0.000019,2,0.000010,use strict ;
0.000011,2,0.000005,use warnings;
0.000031,2,0.000016,use bytes;
0.000000,0,0.000000,
0.000000,0,0.000000,our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS);
0.000000,0,0.000000,
0.000001,1,0.000001,$VERSION = '2.106';
0.000000,0,0.000000,
0.000542,3,0.000181,use IO::Compress::Gzip::Constants 2.106 ;
0.000000,0,0.000000,
0.000000,0,0.000000,sub ExtraFieldError
0.000000,0,0.000000,{
0.000000,0,0.000000,return $_[0];
0.000000,0,0.000000,return "Error with ExtraField Parameter: $_[0]" ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub validateExtraFieldPair
0.000000,0,0.000000,{
0.000000,0,0.000000,my $pair = shift ;
0.000000,0,0.000000,my $strict = shift;
0.000000,0,0.000000,my $gzipMode = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return ExtraFieldError("Not an array ref")
0.000000,0,0.000000,unless ref $pair &&  ref $pair eq 'ARRAY';
0.000000,0,0.000000,
0.000000,0,0.000000,return ExtraFieldError("SubField must have two parts")
0.000000,0,0.000000,unless @$pair == 2 ;
0.000000,0,0.000000,
0.000000,0,0.000000,return ExtraFieldError("SubField ID is a reference")
0.000000,0,0.000000,if ref $pair->[0] ;
0.000000,0,0.000000,
0.000000,0,0.000000,return ExtraFieldError("SubField Data is a reference")
0.000000,0,0.000000,if ref $pair->[1] ;
0.000000,0,0.000000,
0.000000,0,0.000000,# ID is exactly two chars
0.000000,0,0.000000,return ExtraFieldError("SubField ID not two chars long")
0.000000,0,0.000000,unless length $pair->[0] == GZIP_FEXTRA_SUBFIELD_ID_SIZE ;
0.000000,0,0.000000,
0.000000,0,0.000000,# Check that the 2nd byte of the ID isn't 0
0.000000,0,0.000000,return ExtraFieldError("SubField ID 2nd byte is 0x00")
0.000000,0,0.000000,if $strict && $gzipMode && substr($pair->[0], 1, 1) eq "\x00" ;
0.000000,0,0.000000,
0.000000,0,0.000000,return ExtraFieldError("SubField Data too long")
0.000000,0,0.000000,if length $pair->[1] > GZIP_FEXTRA_SUBFIELD_MAX_SIZE ;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parseRawExtra
0.000000,0,0.000000,{
0.000000,0,0.000000,my $data     = shift ;
0.000000,0,0.000000,my $extraRef = shift;
0.000000,0,0.000000,my $strict   = shift;
0.000000,0,0.000000,my $gzipMode = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,#my $lax = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,#return undef
0.000000,0,0.000000,#    if $lax ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $XLEN = length $data ;
0.000000,0,0.000000,
0.000000,0,0.000000,return ExtraFieldError("Too Large")
0.000000,0,0.000000,if $XLEN > GZIP_FEXTRA_MAX_SIZE;
0.000000,0,0.000000,
0.000000,0,0.000000,my $offset = 0 ;
0.000000,0,0.000000,while ($offset < $XLEN) {
0.000000,0,0.000000,
0.000000,0,0.000000,return ExtraFieldError("Truncated in FEXTRA Body Section")
0.000000,0,0.000000,if $offset + GZIP_FEXTRA_SUBFIELD_HEADER_SIZE  > $XLEN ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $id = substr($data, $offset, GZIP_FEXTRA_SUBFIELD_ID_SIZE);
0.000000,0,0.000000,$offset += GZIP_FEXTRA_SUBFIELD_ID_SIZE;
0.000000,0,0.000000,
0.000000,0,0.000000,my $subLen =  unpack("v", substr($data, $offset,
0.000000,0,0.000000,GZIP_FEXTRA_SUBFIELD_LEN_SIZE));
0.000000,0,0.000000,$offset += GZIP_FEXTRA_SUBFIELD_LEN_SIZE ;
0.000000,0,0.000000,
0.000000,0,0.000000,return ExtraFieldError("Truncated in FEXTRA Body Section")
0.000000,0,0.000000,if $offset + $subLen > $XLEN ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $bad = validateExtraFieldPair( [$id,
0.000000,0,0.000000,substr($data, $offset, $subLen)],
0.000000,0,0.000000,$strict, $gzipMode );
0.000000,0,0.000000,return $bad if $bad ;
0.000000,0,0.000000,push @$extraRef, [$id => substr($data, $offset, $subLen)]
0.000000,0,0.000000,if defined $extraRef;;
0.000000,0,0.000000,
0.000000,0,0.000000,$offset += $subLen ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub findID
0.000000,0,0.000000,{
0.000000,0,0.000000,my $id_want = shift ;
0.000000,0,0.000000,my $data    = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $XLEN = length $data ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $offset = 0 ;
0.000000,0,0.000000,while ($offset < $XLEN) {
0.000000,0,0.000000,
0.000000,0,0.000000,return undef
0.000000,0,0.000000,if $offset + GZIP_FEXTRA_SUBFIELD_HEADER_SIZE  > $XLEN ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $id = substr($data, $offset, GZIP_FEXTRA_SUBFIELD_ID_SIZE);
0.000000,0,0.000000,$offset += GZIP_FEXTRA_SUBFIELD_ID_SIZE;
0.000000,0,0.000000,
0.000000,0,0.000000,my $subLen =  unpack("v", substr($data, $offset,
0.000000,0,0.000000,GZIP_FEXTRA_SUBFIELD_LEN_SIZE));
0.000000,0,0.000000,$offset += GZIP_FEXTRA_SUBFIELD_LEN_SIZE ;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef
0.000000,0,0.000000,if $offset + $subLen > $XLEN ;
0.000000,0,0.000000,
0.000000,0,0.000000,return substr($data, $offset, $subLen)
0.000000,0,0.000000,if $id eq $id_want ;
0.000000,0,0.000000,
0.000000,0,0.000000,$offset += $subLen ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub mkSubField
0.000000,0,0.000000,{
0.000000,0,0.000000,my $id = shift ;
0.000000,0,0.000000,my $data = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $id . pack("v", length $data) . $data ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parseExtraField
0.000000,0,0.000000,{
0.000000,0,0.000000,my $dataRef  = $_[0];
0.000000,0,0.000000,my $strict   = $_[1];
0.000000,0,0.000000,my $gzipMode = $_[2];
0.000000,0,0.000000,#my $lax     = @_ == 2 ? $_[1] : 1;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# ExtraField can be any of
0.000000,0,0.000000,#
0.000000,0,0.000000,#    -ExtraField => $data
0.000000,0,0.000000,#
0.000000,0,0.000000,#    -ExtraField => [$id1, $data1,
0.000000,0,0.000000,#                    $id2, $data2]
0.000000,0,0.000000,#                     ...
0.000000,0,0.000000,#                   ]
0.000000,0,0.000000,#
0.000000,0,0.000000,#    -ExtraField => [ [$id1 => $data1],
0.000000,0,0.000000,#                     [$id2 => $data2],
0.000000,0,0.000000,#                     ...
0.000000,0,0.000000,#                   ]
0.000000,0,0.000000,#
0.000000,0,0.000000,#    -ExtraField => { $id1 => $data1,
0.000000,0,0.000000,#                     $id2 => $data2,
0.000000,0,0.000000,#                     ...
0.000000,0,0.000000,#                   }
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ! ref $dataRef ) {
0.000000,0,0.000000,
0.000000,0,0.000000,return undef
0.000000,0,0.000000,if ! $strict;
0.000000,0,0.000000,
0.000000,0,0.000000,return parseRawExtra($dataRef, undef, 1, $gzipMode);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $data = $dataRef;
0.000000,0,0.000000,my $out = '' ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref $data eq 'ARRAY') {
0.000000,0,0.000000,if (ref $data->[0]) {
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $pair (@$data) {
0.000000,0,0.000000,return ExtraFieldError("Not list of lists")
0.000000,0,0.000000,unless ref $pair eq 'ARRAY' ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $bad = validateExtraFieldPair($pair, $strict, $gzipMode) ;
0.000000,0,0.000000,return $bad if $bad ;
0.000000,0,0.000000,
0.000000,0,0.000000,$out .= mkSubField(@$pair);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return ExtraFieldError("Not even number of elements")
0.000000,0,0.000000,unless @$data % 2  == 0;
0.000000,0,0.000000,
0.000000,0,0.000000,for (my $ix = 0; $ix <= @$data -1 ; $ix += 2) {
0.000000,0,0.000000,my $bad = validateExtraFieldPair([$data->[$ix],
0.000000,0,0.000000,$data->[$ix+1]],
0.000000,0,0.000000,$strict, $gzipMode) ;
0.000000,0,0.000000,return $bad if $bad ;
0.000000,0,0.000000,
0.000000,0,0.000000,$out .= mkSubField($data->[$ix], $data->[$ix+1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (ref $data eq 'HASH') {
0.000000,0,0.000000,while (my ($id, $info) = each %$data) {
0.000000,0,0.000000,my $bad = validateExtraFieldPair([$id, $info], $strict, $gzipMode);
0.000000,0,0.000000,return $bad if $bad ;
0.000000,0,0.000000,
0.000000,0,0.000000,$out .= mkSubField($id, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return ExtraFieldError("Not a scalar, array ref or hash ref") ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ExtraFieldError("Too Large")
0.000000,0,0.000000,if length $out > GZIP_FEXTRA_MAX_SIZE;
0.000000,0,0.000000,
0.000000,0,0.000000,$_[0] = $out ;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
