# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Moo;
0.000022,2,0.000011,use strict;
0.000015,2,0.000008,use warnings;
0.000025,2,0.000012,no warnings 'once';
0.000000,0,0.000000,
0.000468,1,0.000468,use Moo::_Utils qw(
0.000000,0,0.000000,_check_tracked
0.000000,0,0.000000,_getglob
0.000000,0,0.000000,_getstash
0.000000,0,0.000000,_install_coderef
0.000000,0,0.000000,_install_modifier
0.000000,0,0.000000,_install_tracked
0.000000,0,0.000000,_linear_isa
0.000000,0,0.000000,_load_module
0.000000,0,0.000000,_set_loaded
0.000000,0,0.000000,_unimport_coderefs
0.000023,1,0.000023,);
0.000026,2,0.000013,use Carp qw(croak);
0.000000,0,0.000000,BEGIN {
0.000002,1,0.000002,our @CARP_NOT = qw(
0.000000,0,0.000000,Method::Generate::Constructor
0.000000,0,0.000000,Method::Generate::Accessor
0.000000,0,0.000000,Moo::sification
0.000000,0,0.000000,Moo::_Utils
0.000000,0,0.000000,Moo::Role
0.000000,0,0.000000,);
0.000170,1,0.000170,}
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '2.005004';
0.000001,1,0.000001,$VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000535,1,0.000535,require Moo::sification;
0.000002,1,0.000002,Moo::sification->import;
0.000000,0,0.000000,
0.000000,0,0.000000,our %MAKERS;
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000013,17,0.000001,my $target = caller;
0.000009,17,0.000001,my $class = shift;
0.000046,17,0.000003,if ($INC{'Role/Tiny.pm'} and Role::Tiny->is_role($target)) {
0.000000,0,0.000000,croak "Cannot import Moo into a role";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000083,17,0.000005,_set_loaded(caller);
0.000000,0,0.000000,
0.000059,17,0.000003,strict->import;
0.000017,17,0.000001,warnings->import;
0.000000,0,0.000000,
0.000037,17,0.000002,$class->_install_subs($target, @_);
0.000029,17,0.000002,$class->make_class($target);
0.000050,17,0.000003,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub make_class {
0.000006,17,0.000000,my ($me, $target) = @_;
0.000000,0,0.000000,
0.000022,17,0.000001,my $makers = $MAKERS{$target} ||= {};
0.000004,17,0.000000,return $target if $makers->{is_class};
0.000000,0,0.000000,
0.000052,17,0.000003,my $stash = _getstash($target);
0.000000,0,0.000000,$makers->{non_methods} = {
0.000000,0,0.000000,map +($_ => \&{"${target}::${_}"}),
0.000498,17,0.000029,grep exists &{"${target}::${_}"},
0.000000,0,0.000000,grep !/::\z/ && !/\A\(/,
0.000000,0,0.000000,keys %$stash
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000004,17,0.000000,$makers->{is_class} = 1;
0.000000,0,0.000000,{
0.000444,19,0.000023,no strict 'refs';
0.000000,0,0.000000,@{"${target}::ISA"} = do {
0.000430,34,0.000013,require Moo::Object; ('Moo::Object');
0.000186,17,0.000011,} unless @{"${target}::ISA"};
0.000000,0,0.000000,}
0.000006,17,0.000000,if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
0.000000,0,0.000000,Moo::HandleMoose::inject_fake_metaclass_for($target);
0.000000,0,0.000000,}
0.000036,17,0.000002,return $target;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_class {
0.000006,7,0.000001,my ($me, $class) = @_;
0.000026,7,0.000004,return $MAKERS{$class} && $MAKERS{$class}{is_class};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_subs {
0.000009,17,0.000001,my ($me, $target) = @_;
0.000079,17,0.000005,my %install = $me->_gen_subs($target);
0.000000,0,0.000000,_install_tracked $target => $_ => $install{$_}
0.000249,17,0.000015,for sort keys %install;
0.000042,17,0.000002,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _gen_subs {
0.000009,17,0.000001,my ($me, $target) = @_;
0.000000,0,0.000000,return (
0.000000,0,0.000000,extends => sub {
0.000002,2,0.000001,$me->_set_superclasses($target, @_);
0.000002,2,0.000001,$me->_maybe_reset_handlemoose($target);
0.000012,2,0.000006,return;
0.000000,0,0.000000,},
0.000000,0,0.000000,with => sub {
0.000013,9,0.000001,require Moo::Role;
0.000039,9,0.000004,Moo::Role->apply_roles_to_package($target, @_);
0.000047,9,0.000005,$me->_maybe_reset_handlemoose($target);
0.000000,0,0.000000,},
0.000000,0,0.000000,has => sub {
0.000017,45,0.000000,my $name_proto = shift;
0.000038,45,0.000001,my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
0.000032,45,0.000001,if (@_ % 2 != 0) {
0.000000,0,0.000000,croak "Invalid options for " . join(', ', map "'$_'", @name_proto)
0.000000,0,0.000000,. " attribute(s): even number of arguments expected, got " . scalar @_;
0.000000,0,0.000000,}
0.000070,45,0.000002,my %spec = @_;
0.000017,45,0.000000,foreach my $name (@name_proto) {
0.000000,0,0.000000,# Note that when multiple attributes specified, each attribute
0.000000,0,0.000000,# needs a separate \%specs hashref
0.000031,49,0.000001,my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
0.000094,49,0.000002,$me->_constructor_maker_for($target)
0.000000,0,0.000000,->register_attribute_specs($name, $spec_ref);
0.000143,49,0.000003,$me->_accessor_maker_for($target)
0.000000,0,0.000000,->generate_method($target, $name, $spec_ref);
0.000111,49,0.000002,$me->_maybe_reset_handlemoose($target);
0.000000,0,0.000000,}
0.000103,45,0.000002,return;
0.000000,0,0.000000,},
0.000000,0,0.000000,(map {
0.000186,68,0.000003,my $type = $_;
0.000000,0,0.000000,(
0.000000,0,0.000000,$type => sub {
0.000017,8,0.000002,_install_modifier($target, $type, @_);
0.000020,8,0.000002,return;
0.000000,0,0.000000,},
0.000000,0,0.000000,)
0.000056,51,0.000001,} qw(before after around)),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unimport {
0.000000,0,0.000000,my $target = caller;
0.000000,0,0.000000,_unimport_coderefs($target);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _set_superclasses {
0.000001,2,0.000000,my $class = shift;
0.000000,2,0.000000,my $target = shift;
0.000002,2,0.000001,foreach my $superclass (@_) {
0.000002,2,0.000001,_load_module($superclass);
0.000006,2,0.000003,if ($INC{'Role/Tiny.pm'} && Role::Tiny->is_role($superclass)) {
0.000000,0,0.000000,croak "Can't extend role '$superclass'";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000020,2,0.000010,@{*{_getglob("${target}::ISA")}} = @_;
0.000003,2,0.000002,if (my $old = delete $Moo::MAKERS{$target}{constructor}) {
0.000001,2,0.000000,$old->assert_constructor;
0.000024,2,0.000012,delete _getstash($target)->{new};
0.000000,0,0.000000,Moo->_constructor_maker_for($target)
0.000007,2,0.000003,->register_attribute_specs(%{$old->all_attribute_specs});
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (!$target->isa('Moo::Object')) {
0.000000,0,0.000000,Moo->_constructor_maker_for($target);
0.000000,0,0.000000,}
0.000018,2,0.000009,$Moo::HandleMoose::MOUSE{$target} = [
0.000000,0,0.000000,grep defined, map Mouse::Util::find_meta($_), @_
0.000000,0,0.000000,] if Mouse::Util->can('find_meta');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _maybe_reset_handlemoose {
0.000025,60,0.000000,my ($class, $target) = @_;
0.000130,60,0.000002,if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
0.000000,0,0.000000,Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _accessor_maker_for {
0.000047,116,0.000000,my ($class, $target) = @_;
0.000047,116,0.000000,return unless $MAKERS{$target};
0.000230,116,0.000002,$MAKERS{$target}{accessor} ||= do {
0.000006,18,0.000000,my $maker_class = do {
0.000175,2,0.000087,no strict 'refs';
0.000015,18,0.000001,if (my $m = do {
0.000106,18,0.000006,my @isa = @{_linear_isa($target)};
0.000008,18,0.000000,shift @isa;
0.000060,18,0.000003,if (my ($parent_new) = grep +(defined &{$_.'::new'}), @isa) {
0.000000,0,0.000000,$MAKERS{$parent_new} && $MAKERS{$parent_new}{accessor};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,}) {
0.000000,0,0.000000,ref($m);
0.000000,0,0.000000,} else {
0.000330,18,0.000018,require Method::Generate::Accessor;
0.000003,18,0.000000,'Method::Generate::Accessor'
0.000000,0,0.000000,}
0.000000,0,0.000000,};
0.000044,18,0.000002,$maker_class->new;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _constructor_maker_for {
0.000026,99,0.000000,my ($class, $target) = @_;
0.000031,99,0.000000,return unless $MAKERS{$target};
0.000172,99,0.000002,$MAKERS{$target}{constructor} ||= do {
0.000735,10,0.000074,require Method::Generate::Constructor;
0.000000,0,0.000000,
0.000055,10,0.000005,my %construct_opts = (
0.000000,0,0.000000,package => $target,
0.000000,0,0.000000,accessor_generator => $class->_accessor_maker_for($target),
0.000000,0,0.000000,subconstructor_handler => (
0.000000,0,0.000000,'      if ($Moo::MAKERS{$class}) {'."\n"
0.000000,0,0.000000,.'        if ($Moo::MAKERS{$class}{constructor}) {'."\n"
0.000000,0,0.000000,.'          package '.$target.';'."\n"
0.000000,0,0.000000,.'          return $invoker->SUPER::new(@_);'."\n"
0.000000,0,0.000000,.'        }'."\n"
0.000000,0,0.000000,.'        '.$class.'->_constructor_maker_for($class);'."\n"
0.000000,0,0.000000,.'        return $invoker->new(@_)'.";\n"
0.000000,0,0.000000,.'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n"
0.000000,0,0.000000,.'        return $meta->new_object('."\n"
0.000000,0,0.000000,.'          $class->can("BUILDARGS") ? $class->BUILDARGS(@_)'."\n"
0.000000,0,0.000000,.'                      : $class->Moo::Object::BUILDARGS(@_)'."\n"
0.000000,0,0.000000,.'        );'."\n"
0.000000,0,0.000000,.'      }'."\n"
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000002,10,0.000000,my $con;
0.000031,10,0.000003,my @isa = @{_linear_isa($target)};
0.000004,10,0.000000,shift @isa;
0.000249,2,0.000124,no strict 'refs';
0.000055,10,0.000005,if (my ($parent_new) = grep +(defined &{$_.'::new'}), @isa) {
0.000013,10,0.000001,if ($parent_new eq 'Moo::Object') {
0.000000,0,0.000000,# no special constructor needed
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (my $makers = $MAKERS{$parent_new}) {
0.000001,1,0.000001,$con = $makers->{constructor};
0.000001,1,0.000001,$construct_opts{construction_string} = $con->construction_string
0.000000,0,0.000000,if $con;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($parent_new->can('BUILDALL')) {
0.000000,0,0.000000,$construct_opts{construction_builder} = sub {
0.000000,0,0.000000,my $inv = $target->can('BUILDARGS') ? '' : 'Moo::Object::';
0.000000,0,0.000000,'do {'
0.000000,0,0.000000,.'  my $args = $class->'.$inv.'BUILDARGS(@_);'
0.000000,0,0.000000,.'  $args->{__no_BUILD__} = 1;'
0.000000,0,0.000000,.'  $invoker->'.$target.'::SUPER::new($args);'
0.000000,0,0.000000,.'}'
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$construct_opts{construction_builder} = sub {
0.000009,1,0.000009,'$invoker->'.$target.'::SUPER::new('
0.000000,0,0.000000,.($target->can('FOREIGNBUILDARGS') ?
0.000000,0,0.000000,'$class->FOREIGNBUILDARGS(@_)' : '@_')
0.000000,0,0.000000,.')'
0.000002,1,0.000002,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,($con ? ref($con) : 'Method::Generate::Constructor')
0.000000,0,0.000000,->new(%construct_opts)
0.000000,0,0.000000,->install_delayed
0.000078,10,0.000008,->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _concrete_methods_of {
0.000000,0,0.000000,my ($me, $class) = @_;
0.000000,0,0.000000,my $makers = $MAKERS{$class};
0.000000,0,0.000000,
0.000000,0,0.000000,my $non_methods = $makers->{non_methods} || {};
0.000000,0,0.000000,my $stash = _getstash($class);
0.000000,0,0.000000,
0.000000,0,0.000000,my $subs = {
0.000000,0,0.000000,map {;
0.000144,2,0.000072,no strict 'refs';
0.000000,0,0.000000,${"${class}::${_}"} = ${"${class}::${_}"};
0.000000,0,0.000000,($_ => \&{"${class}::${_}"});
0.000000,0,0.000000,}
0.000000,0,0.000000,grep exists &{"${class}::${_}"},
0.000000,0,0.000000,grep !/::\z/,
0.000000,0,0.000000,keys %$stash
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,my %tracked = map +($_ => 1), _check_tracked($class, [ keys %$subs ]);
0.000000,0,0.000000,
0.000000,0,0.000000,return {
0.000000,0,0.000000,map +($_ => \&{"${class}::${_}"}),
0.000000,0,0.000000,grep !($non_methods->{$_} && $non_methods->{$_} == $subs->{$_}),
0.000000,0,0.000000,grep !exists $tracked{$_},
0.000000,0,0.000000,keys %$subs
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,1;
0.000000,0,0.000000,__END__
