# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000031,2,0.000016,use strict;
0.000070,2,0.000035,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Vocabulary::Core;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Implementation of the JSON Schema Core vocabulary
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.559';
0.000000,0,0.000000,
0.000028,2,0.000014,use 5.020;
0.000024,2,0.000012,use Moo;
0.000159,3,0.000053,use strictures 2;
0.000030,2,0.000015,use experimental qw(signatures postderef);
0.000023,2,0.000012,use if "$]" >= 5.022, experimental => 're_strict';
0.000022,2,0.000011,no if "$]" >= 5.031009, feature => 'indirect';
0.000016,2,0.000008,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000020,2,0.000010,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000017,2,0.000008,use JSON::Schema::Modern::Utilities qw(is_type abort assert_keyword_type canonical_uri E assert_uri_reference assert_uri jsonp);
0.002124,2,0.001062,use namespace::clean;
0.000000,0,0.000000,
0.000001,1,0.000001,with 'JSON::Schema::Modern::Vocabulary';
0.000000,0,0.000000,
0.000000,0,0.000000,sub vocabulary {
0.000003,1,0.000003,'https://json-schema.org/draft/2019-09/vocab/core' => 'draft2019-09',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/vocab/core' => 'draft2020-12';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,3,0.000001,sub evaluation_order { 0 }
0.000000,0,0.000000,
0.000002,6,0.000000,sub keywords ($self, $spec_version) {
0.000000,0,0.000000,return (
0.000013,2,0.000007,qw($id $schema),
0.000000,0,0.000000,$spec_version ne 'draft7' ? '$anchor' : (),
0.000000,0,0.000000,$spec_version eq 'draft2019-09' ? '$recursiveAnchor' : (),
0.000000,0,0.000000,$spec_version eq 'draft2020-12' ? '$dynamicAnchor' : (),
0.000000,0,0.000000,'$ref',
0.000000,0,0.000000,$spec_version eq 'draft2019-09' ? '$recursiveRef' : (),
0.000000,0,0.000000,$spec_version eq 'draft2020-12' ? '$dynamicRef' : (),
0.000000,0,0.000000,$spec_version eq 'draft7' ? 'definitions' : qw($vocabulary $comment $defs),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# adds the following keys to $state during traversal:
0.000000,0,0.000000,# - identifiers: an arrayref of tuples:
0.000000,0,0.000000,#   $uri => { path => $path_to_identifier, canonical_uri => Mojo::URL (absolute when possible) }
0.000000,0,0.000000,# this is used by the Document constructor to build its resource_index.
0.000000,0,0.000000,
0.000009,56,0.000000,sub _traverse_keyword_id ($self, $schema, $state) {
0.000077,14,0.000005,return if not assert_keyword_type($state, $schema, 'string')
0.000000,0,0.000000,or not assert_uri_reference($state, $schema);
0.000000,0,0.000000,
0.000017,14,0.000001,my $uri = Mojo::URL->new($schema->{'$id'});
0.000000,0,0.000000,
0.000053,14,0.000004,if ($state->{spec_version} eq 'draft7') {
0.000000,0,0.000000,if (length($uri->fragment)) {
0.000000,0,0.000000,return E($state, '$id cannot change the base uri at the same time as declaring an anchor')
0.000000,0,0.000000,if length($uri->clone->fragment(undef));
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->_traverse_keyword_anchor({ %$schema, $state->{keyword} => $uri->fragment }, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000017,14,0.000001,return E($state, '$id value "%s" cannot have a non-empty fragment', $schema->{'$id'})
0.000000,0,0.000000,if length $uri->fragment;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000015,14,0.000001,$uri->fragment(undef);
0.000026,14,0.000002,return E($state, '$id cannot be empty') if not length $uri;
0.000000,0,0.000000,
0.000023,14,0.000002,$state->{initial_schema_uri} = $uri->is_abs ? $uri : $uri->to_abs($state->{initial_schema_uri});
0.000011,14,0.000001,$state->{traversed_schema_path} = $state->{traversed_schema_path}.$state->{schema_path};
0.000000,0,0.000000,# we don't set or update document_path because it is identical to traversed_schema_path
0.000006,14,0.000000,$state->{schema_path} = '';
0.000000,0,0.000000,
0.000000,0,0.000000,push $state->{identifiers}->@*,
0.000000,0,0.000000,$state->{initial_schema_uri} => {
0.000000,0,0.000000,path => $state->{traversed_schema_path},
0.000000,0,0.000000,canonical_uri => $state->{initial_schema_uri}->clone,
0.000000,0,0.000000,specification_version => $state->{spec_version}, # note! $schema keyword can change this
0.000000,0,0.000000,vocabularies => $state->{vocabularies}, # reference, not copy
0.000000,0,0.000000,configs => $state->{configs},
0.000094,14,0.000007,};
0.000030,14,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.019870,127810,0.000000,sub _eval_keyword_id ($self, $data, $schema, $state) {
0.062008,25562,0.000002,my $schema_info = $state->{document}->path_to_resource($state->{document_path}.$state->{schema_path});
0.000000,0,0.000000,# this should never happen, if the pre-evaluation traversal was performed correctly
0.006339,25562,0.000000,abort($state, 'failed to resolve %s to canonical uri', $state->{keyword}) if not $schema_info;
0.000000,0,0.000000,
0.036319,25562,0.000001,$state->{initial_schema_uri} = $schema_info->{canonical_uri}->clone;
0.023275,25562,0.000001,$state->{traversed_schema_path} = $state->{traversed_schema_path}.$state->{schema_path};
0.009662,25562,0.000000,$state->{document_path} = $state->{document_path}.$state->{schema_path};
0.008212,25562,0.000000,$state->{schema_path} = '';
0.009411,25562,0.000000,$state->{spec_version} = $schema_info->{specification_version};
0.007939,25562,0.000000,$state->{vocabularies} = $schema_info->{vocabularies};
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX this code doesn't belong here - but rather in eval_subschema_at_uri
0.000000,0,0.000000,# it's possible that a different schema resource has its own set of configs, different from the
0.000000,0,0.000000,# JSM attribute value
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX come up with a test!
0.000000,0,0.000000,# it involves processing a 'format' after going through a $ref.
0.000000,0,0.000000,
0.010174,25562,0.000000,if ($state->{validate_formats}) {
0.000000,0,0.000000,$state->{vocabularies} = [
0.000000,0,0.000000,map s/^JSON::Schema::Modern::Vocabulary::Format\KAnnotation$/Assertion/r, $state->{vocabularies}->@*
0.297976,25562,0.000012,];
0.010560,25562,0.000000,require JSON::Schema::Modern::Vocabulary::FormatAssertion;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.019112,25562,0.000001,$state->@{keys $state->{configs}->%*} = values $state->{configs}->%*;
0.022892,25562,0.000001,push $state->{dynamic_scope}->@*, $state->{initial_schema_uri};
0.000000,0,0.000000,
0.045877,25562,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000013,60,0.000000,sub _traverse_keyword_schema ($self, $schema, $state) {
0.000076,15,0.000005,return if not assert_keyword_type($state, $schema, 'string') or not assert_uri($state, $schema);
0.000000,0,0.000000,
0.000000,0,0.000000,# "A JSON Schema resource is a schema which is canonically identified by an absolute URI."
0.000000,0,0.000000,# "A resource's root schema is its top-level schema object."
0.000000,0,0.000000,# note: we need not be at the document root, but simply adjacent to an $id (or be the at the
0.000000,0,0.000000,# document root)
0.000000,0,0.000000,return E($state, '$schema can only appear at the schema resource root')
0.000007,15,0.000000,if length($state->{schema_path});
0.000000,0,0.000000,
0.000005,15,0.000000,my ($spec_version, $vocabularies);
0.000000,0,0.000000,
0.000037,15,0.000002,if (my $metaschema_info = $state->{evaluator}->_get_metaschema_vocabulary_classes($schema->{'$schema'})) {
0.000000,0,0.000000,($spec_version, $vocabularies) = @$metaschema_info;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000003,1,0.000003,my $schema_info = $state->{evaluator}->_fetch_from_uri($schema->{'$schema'});
0.000000,1,0.000000,return E($state, 'EXCEPTION: unable to find resource %s', $schema->{'$schema'}) if not $schema_info;
0.000000,0,0.000000,
0.000000,0,0.000000,($spec_version, $vocabularies) = $self->__fetch_vocabulary_data({ %$state,
0.000000,0,0.000000,keyword => '$vocabulary', initial_schema_uri => Mojo::URL->new($schema->{'$schema'}),
0.000012,1,0.000012,traversed_schema_path => jsonp($state->{schema_path}, '$schema'),
0.000000,0,0.000000,}, $schema_info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,15,0.000000,return E($state, '"%s" is not a valid metaschema', $schema->{'$schema'}) if not @$vocabularies;
0.000000,0,0.000000,
0.000000,0,0.000000,# we special-case this because the check in _eval_subschema for older drafts + $ref has already happened
0.000000,0,0.000000,return E($state, '$schema and $ref cannot be used together in older drafts')
0.000007,15,0.000000,if exists $schema->{'$ref'} and $spec_version eq 'draft7';
0.000000,0,0.000000,
0.000014,15,0.000001,$state->@{qw(spec_version vocabularies)} = ($spec_version, $vocabularies);
0.000000,0,0.000000,
0.000000,0,0.000000,# remember, if we don't have a sibling $id, we must be at the document root with no identifiers
0.000020,15,0.000001,if ($state->{identifiers}->@*) {
0.000000,0,0.000000,$state->{identifiers}[-1]->@{qw(specification_version vocabularies)} = $state->@{qw(spec_version vocabularies)};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000029,15,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000028,60,0.000000,sub _traverse_keyword_anchor ($self, $schema, $state) {
0.000017,15,0.000001,return if not assert_keyword_type($state, $schema, 'string');
0.000000,0,0.000000,
0.000000,0,0.000000,return E($state, '%s value "%s" does not match required syntax',
0.000000,0,0.000000,$state->{keyword}, ($state->{keyword} eq '$id' ? '#' : '').$schema->{$state->{keyword}})
0.000000,0,0.000000,if $state->{spec_version} =~ /^draft(?:7|2019-09)$/
0.000000,0,0.000000,and $schema->{$state->{keyword}} !~ /^[A-Za-z][A-Za-z0-9_:.-]*$/
0.000000,0,0.000000,or $state->{spec_version} eq 'draft2020-12'
0.000106,15,0.000007,and $schema->{$state->{keyword}} !~ /^[A-Za-z_][A-Za-z0-9._-]*$/;
0.000000,0,0.000000,
0.000035,15,0.000002,my $canonical_uri = canonical_uri($state);
0.000000,0,0.000000,
0.000000,0,0.000000,push $state->{identifiers}->@*,
0.000000,0,0.000000,Mojo::URL->new->to_abs($canonical_uri)->fragment($schema->{$state->{keyword}}) => {
0.000000,0,0.000000,path => $state->{traversed_schema_path}.$state->{schema_path},
0.000000,0,0.000000,canonical_uri => $canonical_uri,
0.000000,0,0.000000,specification_version => $state->{spec_version},
0.000000,0,0.000000,vocabularies => $state->{vocabularies}, # reference, not copy
0.000000,0,0.000000,configs => $state->{configs},
0.000156,15,0.000010,};
0.000030,15,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# we already indexed the $anchor uri, so there is nothing more to do at evaluation time.
0.000000,0,0.000000,# we explicitly do NOT set $state->{initial_schema_uri}.
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_recursiveAnchor ($self, $schema, $state) {
0.000000,0,0.000000,return if not assert_keyword_type($state, $schema, 'boolean');
0.000000,0,0.000000,
0.000000,0,0.000000,# this is required because the location is used as the base URI for future resolution
0.000000,0,0.000000,# of $recursiveRef, and the fragment would be disregarded in the base
0.000000,0,0.000000,return E($state, '"$recursiveAnchor" keyword used without "$id"')
0.000000,0,0.000000,if length($state->{schema_path});
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_recursiveAnchor ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not $schema->{'$recursiveAnchor'} or exists $state->{recursive_anchor_uri};
0.000000,0,0.000000,
0.000000,0,0.000000,# record the canonical location of the current position, to be used against future resolution
0.000000,0,0.000000,# of a $recursiveRef uri -- as if it was the current location when we encounter a $ref.
0.000000,0,0.000000,$state->{recursive_anchor_uri} = canonical_uri($state);
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000066,14,0.000005,sub _traverse_keyword_dynamicAnchor { shift->_traverse_keyword_anchor(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,# we already indexed the $dynamicAnchor uri, so there is nothing more to do at evaluation time.
0.000000,0,0.000000,# we explicitly do NOT set $state->{initial_schema_uri}.
0.000000,0,0.000000,
0.000352,2904,0.000000,sub _traverse_keyword_ref ($self, $schema, $state) {
0.001527,726,0.000002,return if not assert_keyword_type($state, $schema, 'string')
0.000000,0,0.000000,or not assert_uri_reference($state, $schema);
0.001316,726,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.033675,193905,0.000000,sub _eval_keyword_ref ($self, $data, $schema, $state) {
0.143386,38781,0.000004,my $uri = Mojo::URL->new($schema->{'$ref'})->to_abs($state->{initial_schema_uri});
0.378287,38781,0.000010,$self->eval_subschema_at_uri($data, $schema, $state, $uri);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_recursiveRef { shift->_traverse_keyword_ref(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_recursiveRef ($self, $data, $schema, $state) {
0.000000,0,0.000000,my $uri = Mojo::URL->new($schema->{'$recursiveRef'})->to_abs($state->{initial_schema_uri});
0.000000,0,0.000000,my $schema_info = $state->{evaluator}->_fetch_from_uri($uri);
0.000000,0,0.000000,abort($state, 'EXCEPTION: unable to find resource %s', $uri) if not $schema_info;
0.000000,0,0.000000,
0.000000,0,0.000000,if (is_type('boolean', $schema_info->{schema}{'$recursiveAnchor'}) and $schema_info->{schema}{'$recursiveAnchor'}) {
0.000000,0,0.000000,$uri = Mojo::URL->new($schema->{'$recursiveRef'})
0.000000,0,0.000000,->to_abs($state->{recursive_anchor_uri} // $state->{initial_schema_uri});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->eval_subschema_at_uri($data, $schema, $state, $uri);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000052,22,0.000002,sub _traverse_keyword_dynamicRef { shift->_traverse_keyword_ref(@_) }
0.000000,0,0.000000,
0.003115,12780,0.000000,sub _eval_keyword_dynamicRef ($self, $data, $schema, $state) {
0.010775,2556,0.000004,my $uri = Mojo::URL->new($schema->{'$dynamicRef'})->to_abs($state->{initial_schema_uri});
0.005583,2556,0.000002,my $schema_info = $state->{evaluator}->_fetch_from_uri($uri);
0.001061,2556,0.000000,abort($state, 'EXCEPTION: unable to find resource %s', $uri) if not $schema_info;
0.000000,0,0.000000,
0.000000,0,0.000000,# If the initially resolved starting point URI includes a fragment that was created by the
0.000000,0,0.000000,# "$dynamicAnchor" keyword, ...
0.008221,2556,0.000003,if (length $uri->fragment and exists $schema_info->{schema}{'$dynamicAnchor'}
0.000000,0,0.000000,and $uri->fragment eq (my $anchor = $schema_info->{schema}{'$dynamicAnchor'})) {
0.000000,0,0.000000,# ...the initial URI MUST be replaced by the URI (including the fragment) for the outermost
0.000000,0,0.000000,# schema resource in the dynamic scope that defines an identically named fragment with
0.000000,0,0.000000,# "$dynamicAnchor".
0.001450,2556,0.000001,foreach my $base_scope ($state->{dynamic_scope}->@*) {
0.003963,2556,0.000002,my $test_uri = Mojo::URL->new($base_scope)->fragment($anchor);
0.003480,2556,0.000001,my $dynamic_anchor_subschema_info = $state->{evaluator}->_fetch_from_uri($test_uri);
0.001966,2556,0.000001,if (($dynamic_anchor_subschema_info->{schema}->{'$dynamicAnchor'}//'') eq $anchor) {
0.007623,2556,0.000003,$uri = $test_uri;
0.005229,2556,0.000002,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.037620,2556,0.000015,return $self->eval_subschema_at_uri($data, $schema, $state, $uri);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000024,44,0.000001,sub _traverse_keyword_vocabulary ($self, $schema, $state) {
0.000020,11,0.000002,return if not assert_keyword_type($state, $schema, 'object');
0.000000,0,0.000000,
0.000000,0,0.000000,return E($state, '$vocabulary can only appear at the schema resource root')
0.000003,11,0.000000,if length($state->{schema_path});
0.000000,0,0.000000,
0.000007,11,0.000001,my $valid = 1;
0.000000,0,0.000000,
0.000002,11,0.000000,my @vocabulary_classes;
0.000054,11,0.000005,foreach my $uri (sort keys $schema->{'$vocabulary'}->%*) {
0.000149,31,0.000005,$valid = 0, next if not assert_keyword_type({ %$state, _schema_path_suffix => $uri }, $schema, 'boolean');
0.000108,31,0.000003,$valid = 0, next if not assert_uri({ %$state, _schema_path_suffix => $uri }, undef, $uri);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# we cannot return an error here for invalid or incomplete vocabulary lists, because
0.000000,0,0.000000,# - the specification vocabulary schemas themselves don't list Core,
0.000000,0,0.000000,# - it is possible for a metaschema to $ref to another metaschema that uses an unrecognized
0.000000,0,0.000000,#   vocabulary uri while still validating those vocabulary keywords (e.g.
0.000000,0,0.000000,#   https://spec.openapis.org/oas/3.1/schema-base/2021-05-20)
0.000000,0,0.000000,# Instead, we will verify these constraints when we actually use the metaschema, in
0.000000,0,0.000000,# _traverse_keyword_schema -> __fetch_vocabulary_data
0.000000,0,0.000000,
0.000024,11,0.000002,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# we do nothing with $vocabulary yet at evaluation time. When we know we are in a metaschema,
0.000000,0,0.000000,# we can scan the URIs included here and either abort if a vocabulary is enabled that we do not
0.000000,0,0.000000,# understand, or turn on and off certain keyword behaviours based on the boolean values seen.
0.000000,0,0.000000,
0.000087,448,0.000000,sub _traverse_keyword_comment ($self, $schema, $state) {
0.000117,112,0.000001,return if not assert_keyword_type($state, $schema, 'string');
0.000199,112,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# we do nothing with $comment at evaluation time, including not collecting its value for annotations.
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_definitions { shift->traverse_object_schemas(@_) }
0.000064,12,0.000005,sub _traverse_keyword_defs { shift->traverse_object_schemas(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,# we do nothing directly with $defs at evaluation time, including not collecting its value for
0.000000,0,0.000000,# annotations.
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# translate vocabulary URIs into classes, caching the results (if any)
0.000000,4,0.000000,sub __fetch_vocabulary_data ($self, $state, $schema_info) {
0.000001,1,0.000001,if (not exists $schema_info->{schema}{'$vocabulary'}) {
0.000000,0,0.000000,# "If "$vocabulary" is absent, an implementation MAY determine behavior based on the meta-schema
0.000000,0,0.000000,# if it is recognized from the URI value of the referring schema's "$schema" keyword."
0.000000,0,0.000000,my $metaschema_uri = $state->{evaluator}->METASCHEMA_URIS->{$schema_info->{specification_version}};
0.000000,0,0.000000,return $state->{evaluator}->_get_metaschema_vocabulary_classes($metaschema_uri)->@*;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my $valid = 1;
0.000001,1,0.000001,$valid = E($state, '$vocabulary can only appear at the document root') if length $schema_info->{document_path};
0.000000,1,0.000000,$valid = E($state, 'metaschemas must have an $id') if not exists $schema_info->{schema}{'$id'};
0.000000,0,0.000000,
0.000001,1,0.000001,return (undef, []) if not $valid;
0.000000,0,0.000000,
0.000000,1,0.000000,my @vocabulary_classes;
0.000000,0,0.000000,
0.000008,1,0.000008,foreach my $uri (sort keys $schema_info->{schema}{'$vocabulary'}->%*) {
0.000006,8,0.000001,my $class_info = $state->{evaluator}->_get_vocabulary_class($uri);
0.000000,0,0.000000,$valid = E({ %$state, _schema_path_suffix => $uri }, '"%s" is not a known vocabulary', $uri), next
0.000044,8,0.000005,if $schema_info->{schema}{'$vocabulary'}{$uri} and not $class_info;
0.000000,0,0.000000,
0.000000,8,0.000000,next if not $class_info;  # vocabulary is not known, but marked as false in the metaschema
0.000000,0,0.000000,
0.000004,8,0.000000,my ($spec_version, $class) = @$class_info;
0.000000,0,0.000000,$valid = E({ %$state, _schema_path_suffix => $uri }, '"%s" uses %s, but the metaschema itself uses %s',
0.000000,0,0.000000,$uri, $spec_version, $schema_info->{specification_version}), next
0.000003,8,0.000000,if $spec_version ne $schema_info->{specification_version};
0.000000,0,0.000000,
0.000003,8,0.000000,push @vocabulary_classes, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,@vocabulary_classes = sort {
0.000033,16,0.000002,$a->evaluation_order <=> $b->evaluation_order
0.000000,0,0.000000,|| ($a->evaluation_order == 999 ? 0
0.000000,0,0.000000,: ($valid = E($state, '%s and %s have a conflicting evaluation_order', sort $a, $b)))
0.000000,0,0.000000,} @vocabulary_classes;
0.000000,0,0.000000,
0.000000,1,0.000000,$valid = E($state, 'the first vocabulary (by evaluation_order) must be Core')
0.000000,0,0.000000,if ($vocabulary_classes[0]//'') ne 'JSON::Schema::Modern::Vocabulary::Core';
0.000000,0,0.000000,
0.000000,0,0.000000,$state->{evaluator}->_set_metaschema_vocabulary_classes($schema_info->{canonical_uri},
0.000002,1,0.000002,[ $schema_info->{specification_version}, \@vocabulary_classes ]) if $valid;
0.000000,0,0.000000,
0.000002,1,0.000002,return ($schema_info->{specification_version}, $valid ? \@vocabulary_classes : []);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,1;
0.000022,1,0.000022,__END__
