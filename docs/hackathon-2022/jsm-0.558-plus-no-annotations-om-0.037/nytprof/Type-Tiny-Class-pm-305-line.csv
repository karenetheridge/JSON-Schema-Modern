# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Type::Tiny::Class;
0.000000,0,0.000000,
0.000067,2,0.000034,use 5.008001;
0.000049,2,0.000024,use strict;
0.000043,2,0.000022,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,$Type::Tiny::Class::AUTHORITY = 'cpan:TOBYINK';
0.000002,1,0.000002,$Type::Tiny::Class::VERSION   = '2.000001';
0.000029,1,0.000029,}
0.000000,0,0.000000,
0.000000,1,0.000000,$Type::Tiny::Class::VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000041,2,0.000021,use Scalar::Util qw< blessed >;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
0.000000,0,0.000000,
0.000030,3,0.000010,use Exporter::Tiny 1.004001 ();
0.000861,2,0.000431,use Type::Tiny::ConstrainedObject ();
0.000009,1,0.000009,our @ISA = qw( Type::Tiny::ConstrainedObject Exporter::Tiny );
0.000000,0,0.000000,
0.000000,0,0.000000,sub _short_name { 'Class' }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _exporter_fail {
0.000000,0,0.000000,my ( $class, $name, $opts, $globals ) = @_;
0.000000,0,0.000000,my $caller = $globals->{into};
0.000000,0,0.000000,
0.000000,0,0.000000,$opts->{name}  = $name unless exists $opts->{name}; $opts->{name} =~ s/:://g;
0.000000,0,0.000000,$opts->{class} = $name unless exists $opts->{class};
0.000000,0,0.000000,my $type = $class->new($opts);
0.000000,0,0.000000,
0.000000,0,0.000000,$INC{'Type/Registry.pm'}
0.000000,0,0.000000,? 'Type::Registry'->for_class( $caller )->add_type( $type )
0.000000,0,0.000000,: ( $Type::Registry::DELAYED{$caller}{$type->name} = $type )
0.000000,0,0.000000,unless( ref($caller) or $caller eq '-lexical' or $globals->{'lexical'} );
0.000000,0,0.000000,return map +( $_->{name} => $_->{code} ), @{ $type->exportables };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000002,10,0.000000,my $proto = shift;
0.000018,10,0.000002,return $proto->class->new( @_ ) if blessed $proto;    # DWIM
0.000000,0,0.000000,
0.000014,10,0.000001,my %opts = ( @_ == 1 ) ? %{ $_[0] } : @_;
0.000004,10,0.000000,_croak "Need to supply class name" unless exists $opts{class};
0.000000,0,0.000000,
0.000016,10,0.000002,if ( Type::Tiny::_USE_XS ) {
0.000000,0,0.000000,my $xsub =
0.000000,0,0.000000,Type::Tiny::XS::get_coderef_for( "InstanceOf[" . $opts{class} . "]" );
0.000000,0,0.000000,$opts{compiled_type_constraint} = $xsub if $xsub;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( Type::Tiny::_USE_MOUSE ) {
0.000000,0,0.000000,require Mouse::Util::TypeConstraints;
0.000000,0,0.000000,my $maker = "Mouse::Util::TypeConstraints"->can( "generate_isa_predicate_for" );
0.000000,0,0.000000,$opts{compiled_type_constraint} = $maker->( $opts{class} ) if $maker;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000036,10,0.000004,return $proto->SUPER::new( %opts );
0.000000,0,0.000000,} #/ sub new
0.000000,0,0.000000,
0.000019,12,0.000002,sub class   { $_[0]{class} }
0.000133,58,0.000002,sub inlined { $_[0]{inlined} ||= $_[0]->_build_inlined }
0.000000,0,0.000000,
0.000175,96,0.000002,sub has_inlined { !!1 }
0.000000,0,0.000000,
0.000158,161,0.000001,sub _is_null_constraint { 0 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_constraint {
0.000000,0,0.000000,my $self  = shift;
0.000000,0,0.000000,my $class = $self->class;
0.000000,0,0.000000,return sub { blessed( $_ ) and $_->isa( $class ) };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_inlined {
0.000002,7,0.000000,my $self  = shift;
0.000008,7,0.000001,my $class = $self->class;
0.000000,0,0.000000,
0.000002,7,0.000000,my $xsub;
0.000000,0,0.000000,$xsub = Type::Tiny::XS::get_subname_for( "InstanceOf[$class]" )
0.000000,0,0.000000,if Type::Tiny::_USE_XS;
0.000000,0,0.000000,
0.000000,0,0.000000,sub {
0.000032,58,0.000001,my $var = $_[1];
0.000000,0,0.000000,return
0.000011,58,0.000000,qq{do { use Scalar::Util (); Scalar::Util::blessed($var) and $var->isa(q[$class]) }}
0.000000,0,0.000000,if $Type::Tiny::AvoidCallbacks;
0.000016,58,0.000000,return "$xsub\($var\)"
0.000000,0,0.000000,if $xsub;
0.000148,58,0.000003,qq{Scalar::Util::blessed($var) and $var->isa(q[$class])};
0.000043,7,0.000006,};
0.000000,0,0.000000,} #/ sub _build_inlined
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_default_message {
0.000253,2,0.000126,no warnings 'uninitialized';
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $c    = $self->class;
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,sprintf '%s did not pass type constraint (not isa %s)',
0.000000,0,0.000000,Type::Tiny::_dd( $_[0] ), $c;
0.000000,0,0.000000,}
0.000000,0,0.000000,if $self->is_anon;
0.000000,0,0.000000,my $name = "$self";
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,sprintf '%s did not pass type constraint "%s" (not isa %s)',
0.000000,0,0.000000,Type::Tiny::_dd( $_[0] ), $name, $c;
0.000000,0,0.000000,};
0.000000,0,0.000000,} #/ sub _build_default_message
0.000000,0,0.000000,
0.000000,0,0.000000,sub _instantiate_moose_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %opts = @_;
0.000000,0,0.000000,delete $opts{parent};
0.000000,0,0.000000,delete $opts{constraint};
0.000000,0,0.000000,delete $opts{inlined};
0.000000,0,0.000000,require Moose::Meta::TypeConstraint::Class;
0.000000,0,0.000000,return "Moose::Meta::TypeConstraint::Class"
0.000000,0,0.000000,->new( %opts, class => $self->class );
0.000000,0,0.000000,} #/ sub _instantiate_moose_type
0.000000,0,0.000000,
0.000000,0,0.000000,sub plus_constructors {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( @_ ) {
0.000000,0,0.000000,require Types::Standard;
0.000000,0,0.000000,push @_, Types::Standard::HashRef(), "new";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,require B;
0.000000,0,0.000000,require Types::TypeTiny;
0.000000,0,0.000000,
0.000000,0,0.000000,my $class = B::perlstring( $self->class );
0.000000,0,0.000000,
0.000000,0,0.000000,my @r;
0.000000,0,0.000000,while ( @_ ) {
0.000000,0,0.000000,my $source = shift;
0.000000,0,0.000000,Types::TypeTiny::is_TypeTiny( $source )
0.000000,0,0.000000,or _croak "Expected type constraint; got $source";
0.000000,0,0.000000,
0.000000,0,0.000000,my $constructor = shift;
0.000000,0,0.000000,Types::TypeTiny::is_StringLike( $constructor )
0.000000,0,0.000000,or _croak "Expected string; got $constructor";
0.000000,0,0.000000,
0.000000,0,0.000000,push @r, $source, sprintf( '%s->%s($_)', $class, $constructor );
0.000000,0,0.000000,} #/ while ( @_ )
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->plus_coercions( \@r );
0.000000,0,0.000000,} #/ sub plus_constructors
0.000000,0,0.000000,
0.000000,0,0.000000,sub parent {
0.000188,84,0.000002,$_[0]{parent} ||= $_[0]->_build_parent;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_parent {
0.000001,5,0.000000,my $self  = shift;
0.000005,5,0.000001,my $class = $self->class;
0.000000,0,0.000000,
0.000000,0,0.000000,# Some classes (I'm looking at you, Math::BigFloat) include a class in
0.000000,0,0.000000,# their @ISA to inherit methods, but then override isa() to return false,
0.000000,0,0.000000,# so that they don't appear to be a subclass.
0.000000,0,0.000000,#
0.000000,0,0.000000,# In these cases, we don't want to list the parent class as a parent
0.000000,0,0.000000,# type constraint.
0.000000,0,0.000000,#
0.000000,0,0.000000,my @isa = grep $class->isa( $_ ),
0.000143,14,0.000010,do { no strict "refs"; no warnings; @{"$class\::ISA"} };
0.000000,0,0.000000,
0.000002,5,0.000000,if ( @isa == 0 ) {
0.000003,2,0.000002,require Types::Standard;
0.000010,2,0.000005,return Types::Standard::Object();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000012,3,0.000004,if ( @isa == 1 ) {
0.000000,0,0.000000,return ref( $self )->new( class => $isa[0] );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,require Type::Tiny::Intersection;
0.000000,0,0.000000,"Type::Tiny::Intersection"->new(
0.000000,0,0.000000,type_constraints => [ map ref( $self )->new( class => $_ ), @isa ],
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ sub _build_parent
0.000000,0,0.000000,
0.000000,0,0.000000,*__get_linear_isa_dfs =
0.000001,1,0.000001,eval { require mro }
0.000000,0,0.000000,? \&mro::get_linear_isa
0.000000,0,0.000000,: sub {
0.000175,2,0.000087,no strict 'refs';
0.000000,0,0.000000,
0.000000,0,0.000000,my $classname = shift;
0.000000,0,0.000000,my @lin       = ( $classname );
0.000000,0,0.000000,my %stored;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $parent ( @{"$classname\::ISA"} ) {
0.000000,0,0.000000,my $plin = __get_linear_isa_dfs( $parent );
0.000000,0,0.000000,foreach ( @$plin ) {
0.000000,0,0.000000,next if exists $stored{$_};
0.000000,0,0.000000,push( @lin, $_ );
0.000000,0,0.000000,$stored{$_} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return \@lin;
0.000001,1,0.000001,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub validate_explain {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $value, $varname ) = @_;
0.000000,0,0.000000,$varname = '$_' unless defined $varname;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef if $self->check( $value );
0.000000,0,0.000000,return ["Not a blessed reference"] unless blessed( $value );
0.000000,0,0.000000,
0.000000,0,0.000000,my @isa = @{ __get_linear_isa_dfs( ref $value ) };
0.000000,0,0.000000,
0.000000,0,0.000000,my $display_var = $varname eq q{$_} ? '' : sprintf( ' (in %s)', $varname );
0.000000,0,0.000000,
0.000000,0,0.000000,require Type::Utils;
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf( '"%s" requires that the reference isa %s', $self, $self->class ),
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'The reference%s isa %s', $display_var, Type::Utils::english_list( @isa )
0.000000,0,0.000000,),
0.000000,0,0.000000,];
0.000000,0,0.000000,} #/ sub validate_explain
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
