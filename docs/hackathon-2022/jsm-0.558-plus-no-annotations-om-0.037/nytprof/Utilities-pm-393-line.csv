# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000030,2,0.000015,use strict;
0.000032,2,0.000016,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Utilities;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Internal utilities for JSON::Schema::Modern
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.559';
0.000000,0,0.000000,
0.000027,2,0.000013,use 5.020;
0.000058,3,0.000019,use strictures 2;
0.000040,2,0.000020,use experimental qw(signatures postderef);
0.000027,2,0.000013,use if "$]" >= 5.022, experimental => 're_strict';
0.000019,2,0.000010,no if "$]" >= 5.031009, feature => 'indirect';
0.000022,2,0.000011,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000018,2,0.000009,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000019,2,0.000010,use B;
0.000051,2,0.000025,use Carp 'croak';
0.000048,3,0.000016,use JSON::MaybeXS 1.004004 'is_bool';
0.000031,3,0.000010,use Ref::Util 0.100 qw(is_ref is_plain_arrayref is_plain_hashref);
0.000014,2,0.000007,use Scalar::Util 'blessed';
0.000014,2,0.000007,use Storable 'dclone';
0.000016,2,0.000008,use Feature::Compat::Try;
0.000027,2,0.000013,use JSON::Schema::Modern::Error;
0.000019,2,0.000010,use JSON::Schema::Modern::Annotation;
0.000035,2,0.000018,use namespace::clean;
0.000000,0,0.000000,
0.000081,2,0.000041,use Exporter 'import';
0.000000,0,0.000000,
0.000004,1,0.000004,our @EXPORT_OK = qw(
0.000000,0,0.000000,is_type
0.000000,0,0.000000,get_type
0.000000,0,0.000000,is_equal
0.000000,0,0.000000,is_elements_unique
0.000000,0,0.000000,jsonp
0.000000,0,0.000000,unjsonp
0.000000,0,0.000000,local_annotations
0.000000,0,0.000000,canonical_uri
0.000000,0,0.000000,E
0.000000,0,0.000000,A
0.000000,0,0.000000,abort
0.000000,0,0.000000,assert_keyword_exists
0.000000,0,0.000000,assert_keyword_type
0.000000,0,0.000000,assert_pattern
0.000000,0,0.000000,assert_uri_reference
0.000000,0,0.000000,assert_uri
0.000000,0,0.000000,annotate_self
0.000000,0,0.000000,sprintf_num
0.000000,0,0.000000,true
0.000000,0,0.000000,false
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000033,2,0.000016,use JSON::PP ();
0.002256,2,0.001128,use constant { true => JSON::PP::true, false => JSON::PP::false };
0.000000,0,0.000000,
0.039611,219717,0.000000,sub is_type ($type, $value) {
0.018211,73239,0.000000,if ($type eq 'null') {
0.000000,0,0.000000,return !(defined $value);
0.000000,0,0.000000,}
0.064450,73239,0.000001,if ($type eq 'boolean') {
0.000000,0,0.000000,return is_bool($value);
0.000000,0,0.000000,}
0.110668,56881,0.000002,if ($type eq 'object') {
0.000000,0,0.000000,return is_plain_hashref($value);
0.000000,0,0.000000,}
0.011831,9990,0.000001,if ($type eq 'array') {
0.000000,0,0.000000,return is_plain_arrayref($value);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001360,5227,0.000000,if ($type eq 'string' or $type eq 'number' or $type eq 'integer') {
0.000645,5227,0.000000,return 0 if not defined $value;
0.021520,5227,0.000004,my $flags = B::svref_2object(\$value)->FLAGS;
0.000000,0,0.000000,
0.009935,5227,0.000002,if ($type eq 'string') {
0.000000,0,0.000000,return !is_ref($value) && $flags & B::SVf_POK && !($flags & (B::SVf_IOK | B::SVf_NOK));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000106,196,0.000001,if ($type eq 'number') {
0.000495,109,0.000005,return ref($value) =~ /^Math::Big(?:Int|Float)$/
0.000000,0,0.000000,|| !($flags & B::SVf_POK) && ($flags & (B::SVf_IOK | B::SVf_NOK));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000027,87,0.000000,if ($type eq 'integer') {
0.000340,87,0.000004,return ref($value) =~ /^Math::Big(?:Int|Float)$/ && $value->is_int
0.000000,0,0.000000,|| !($flags & B::SVf_POK) && ($flags & (B::SVf_IOK | B::SVf_NOK)) && int($value) == $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($type =~ /^reference to (.+)$/) {
0.000000,0,0.000000,return !blessed($value) && ref($value) eq $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ref($value) eq $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.044753,320328,0.000000,sub get_type ($value) {
0.213871,160164,0.000001,return 'object' if is_plain_hashref($value);
0.043786,40911,0.000001,return 'boolean' if is_bool($value);
0.004846,36161,0.000000,return 'null' if not defined $value;
0.006546,36161,0.000000,return 'array' if is_plain_arrayref($value);
0.000000,0,0.000000,
0.003904,35065,0.000000,return ref($value) =~ /^Math::Big(?:Int|Float)$/ ? ($value->is_int ? 'integer' : 'number')
0.000000,0,0.000000,: (blessed($value) ? '' : 'reference to ').ref($value)
0.000000,0,0.000000,if is_ref($value);
0.000000,0,0.000000,
0.115638,35065,0.000003,my $flags = B::svref_2object(\$value)->FLAGS;
0.048940,35065,0.000001,return 'string' if $flags & B::SVf_POK && !($flags & (B::SVf_IOK | B::SVf_NOK));
0.000299,107,0.000003,return int($value) == $value ? 'integer' : 'number'
0.000000,0,0.000000,if !($flags & B::SVf_POK) && ($flags & (B::SVf_IOK | B::SVf_NOK));
0.000000,0,0.000000,
0.000000,0,0.000000,croak sprintf('ambiguous type for %s',
0.000000,0,0.000000,JSON::MaybeXS->new(allow_nonref => 1, canonical => 1, utf8 => 0, allow_bignum => 1, convert_blessed => 1)->encode($value));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# compares two arbitrary data payloads for equality, as per
0.000000,0,0.000000,# https://json-schema.org/draft/2020-12/json-schema-core.html#rfc.section.4.2.2
0.000000,0,0.000000,# if provided with a state hashref with a 'path' key, any differences are recorded within
0.009875,62548,0.000000,sub is_equal ($x, $y, $state = undef) {
0.005021,15637,0.000000,$state->{path} //= '';
0.000000,0,0.000000,
0.020806,15637,0.000001,my @types = map get_type($_), $x, $y;
0.000000,0,0.000000,
0.003309,15637,0.000000,if ($state->{scalarref_booleans}) {
0.000690,6978,0.000000,($x, $types[0]) = (0+!!$$x, 'boolean') if $types[0] eq 'reference to SCALAR';
0.000698,6978,0.000000,($y, $types[1]) = (0+!!$$y, 'boolean') if $types[1] eq 'reference to SCALAR';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.003451,15637,0.000000,return 0 if $types[0] ne $types[1];
0.002070,15175,0.000000,return 1 if $types[0] eq 'null';
0.023181,15175,0.000002,return $x eq $y if $types[0] eq 'string';
0.001124,173,0.000006,return $x == $y if grep $types[0] eq $_, qw(boolean number integer);
0.000000,0,0.000000,
0.000000,0,0.000000,my $path = $state->{path};
0.000000,0,0.000000,if ($types[0] eq 'object') {
0.000000,0,0.000000,return 0 if keys %$x != keys %$y;
0.000000,0,0.000000,return 0 if not is_equal([ sort keys %$x ], [ sort keys %$y ]);
0.000000,0,0.000000,foreach my $property (sort keys %$x) {
0.000000,0,0.000000,$state->{path} = jsonp($path, $property);
0.000000,0,0.000000,return 0 if not is_equal($x->{$property}, $y->{$property}, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($types[0] eq 'array') {
0.000000,0,0.000000,return 0 if @$x != @$y;
0.000000,0,0.000000,foreach my $idx (0 .. $x->$#*) {
0.000000,0,0.000000,$state->{path} = $path.'/'.$idx;
0.000000,0,0.000000,return 0 if not is_equal($x->[$idx], $y->[$idx], $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 0; # should never get here
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# checks array elements for uniqueness. short-circuits on first pair of matching elements
0.000000,0,0.000000,# if second arrayref is provided, it is populated with the indices of identical items
0.000357,1890,0.000000,sub is_elements_unique ($array, $equal_indices = undef) {
0.000952,630,0.000002,foreach my $idx0 (0 .. $array->$#*-1) {
0.001078,1097,0.000001,foreach my $idx1 ($idx0+1 .. $array->$#*) {
0.008297,6978,0.000001,if (is_equal($array->[$idx0], $array->[$idx1], { scalarref_booleans => 1 })) {
0.000000,0,0.000000,push @$equal_indices, $idx0, $idx1 if defined $equal_indices;
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.001266,630,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# shorthand for creating and appending json pointers
0.000000,0,0.000000,# the first argument is a a json pointer; remaining arguments are path segments to be encoded and
0.000000,0,0.000000,# appended
0.000000,0,0.000000,sub jsonp {
0.643225,104485,0.000006,return join('/', shift, map s/~/~0/gr =~ s!/!~1!gr, map +(is_plain_arrayref($_) ? @$_ : $_), grep defined, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# splits a json pointer apart into its path segments
0.000000,0,0.000000,sub unjsonp ($path) {
0.000000,0,0.000000,return map s!~0!~!gr =~ s!~1!/!gr, split m!/!, $path;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# get all annotations produced for the current instance data location (that are visible to this
0.000000,0,0.000000,# schema location) - remember these are hashrefs, not Annotation objects
0.001209,7484,0.000000,sub local_annotations ($state) {
0.031842,3742,0.000009,grep $_->{instance_location} eq $state->{data_path}, $state->{annotations}->@*;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# shorthand for finding the canonical uri of the present schema location
0.000000,0,0.000000,# last argument can be an arrayref, usually coming from $state->{_schema_path_suffix}
0.051265,328320,0.000000,sub canonical_uri ($state, @extra_path) {
0.096516,109440,0.000001,return $state->{initial_schema_uri} if not @extra_path and not length($state->{schema_path});
0.018491,68091,0.000000,splice(@extra_path, -1, 1, $extra_path[-1]->@*) if @extra_path and is_plain_arrayref($extra_path[-1]);
0.076741,68091,0.000001,my $uri = $state->{initial_schema_uri}->clone;
0.119028,68091,0.000002,my $fragment = ($uri->fragment//'').(@extra_path ? jsonp($state->{schema_path}, @extra_path) : $state->{schema_path});
0.017190,68091,0.000000,undef $fragment if not length($fragment);
0.061318,68091,0.000001,$uri->fragment($fragment);
0.112298,68091,0.000002,$uri;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# shorthand for creating error objects
0.000000,0,0.000000,# uses these keys from $state:
0.000000,0,0.000000,# - initial_schema_uri
0.000000,0,0.000000,# - keyword
0.000000,0,0.000000,# - data_path
0.000000,0,0.000000,# - traversed_schema_path
0.000000,0,0.000000,# - schema_path
0.000000,0,0.000000,# - _schema_path_suffix
0.000000,0,0.000000,# - errors
0.004298,16784,0.000000,sub E ($state, $error_string, @args) {
0.001026,4196,0.000000,croak 'E called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,# sometimes the keyword shouldn't be at the very end of the schema path
0.000000,0,0.000000,my $uri = canonical_uri($state, $state->{keyword}, $state->{_schema_path_suffix})
0.020755,4196,0.000005,->to_abs($state->{effective_base_uri});
0.000000,0,0.000000,
0.000000,0,0.000000,my $keyword_location = $state->{traversed_schema_path}
0.007057,4196,0.000002,.jsonp($state->{schema_path}, $state->{keyword}, delete $state->{_schema_path_suffix});
0.000000,0,0.000000,
0.013169,4196,0.000003,undef $uri if $uri eq '' and $keyword_location eq ''
0.000000,0,0.000000,or ($uri->fragment // '') eq $keyword_location and $uri->clone->fragment(undef) eq '';
0.000000,0,0.000000,
0.000000,0,0.000000,push $state->{errors}->@*, JSON::Schema::Modern::Error->new(
0.000000,0,0.000000,keyword => $state->{keyword},
0.000000,0,0.000000,instance_location => $state->{data_path},
0.000000,0,0.000000,keyword_location => $keyword_location,
0.000000,0,0.000000,defined $uri ? ( absolute_keyword_location => $uri ) : (),
0.000000,0,0.000000,error => @args ? sprintf($error_string, @args) : $error_string,
0.025880,4196,0.000006,$state->{exception} ? ( exception => $state->{exception} ) : (),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.012695,4196,0.000003,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# shorthand for creating annotations
0.000000,0,0.000000,# uses these keys from $state:
0.000000,0,0.000000,# - initial_schema_uri
0.000000,0,0.000000,# - keyword
0.000000,0,0.000000,# - data_path
0.000000,0,0.000000,# - traversed_schema_path
0.000000,0,0.000000,# - schema_path
0.000000,0,0.000000,# - _schema_path_suffix
0.000000,0,0.000000,# - annotations
0.000000,0,0.000000,# - collect_annotations
0.035023,213240,0.000000,sub A ($state, $annotation) {
0.115500,71080,0.000002,return 1 if not $state->{collect_annotations} or $state->{spec_version} eq 'draft7';
0.000000,0,0.000000,
0.000000,0,0.000000,# we store the absolute uri in unresolved form until needed,
0.000000,0,0.000000,# and perform the rest of the calculations later.
0.000000,0,0.000000,
0.000000,0,0.000000,my $uri = [ canonical_uri($state, $state->{keyword}, $state->{_schema_path_suffix}),
0.030927,13727,0.000002,$state->{effective_base_uri} ];
0.000000,0,0.000000,
0.000000,0,0.000000,my $keyword_location = $state->{traversed_schema_path}
0.019825,13727,0.000001,.jsonp($state->{schema_path}, $state->{keyword}, delete $state->{_schema_path_suffix});
0.000000,0,0.000000,
0.000000,0,0.000000,push $state->{annotations}->@*, {
0.000000,0,0.000000,keyword => $state->{keyword},
0.000000,0,0.000000,instance_location => $state->{data_path},
0.000000,0,0.000000,keyword_location => $keyword_location,
0.000000,0,0.000000,# we calculate absolute_keyword_location when instantiating the Annotation object for Result
0.000000,0,0.000000,_uri => $uri,
0.000000,0,0.000000,annotation => $annotation,
0.038474,13727,0.000003,$state->{_unknown} ? ( unknown => 1 ) : (),
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.021518,13727,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# creates an error object, but also aborts evaluation immediately
0.000000,0,0.000000,# only this error is returned, because other errors on the stack might not actually be "real"
0.000000,0,0.000000,# errors (consider if we were in the middle of evaluating a "not" or "if").
0.000000,0,0.000000,# Therefore this is only appropriate during the evaluation phase, not the traverse phase.
0.000000,0,0.000000,sub abort ($state, $error_string, @args) {
0.000000,0,0.000000,()= E({ %$state, exception => 1 }, $error_string, @args);
0.000000,0,0.000000,croak 'abort() called during traverse' if $state->{traverse};
0.000000,0,0.000000,die pop $state->{errors}->@*;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,3,0.000000,sub assert_keyword_exists ($state, $schema) {
0.000001,1,0.000001,croak 'assert_keyword_exists called in void context' if not defined wantarray;
0.000001,1,0.000001,return E($state, '%s keyword is required', $state->{keyword}) if not exists $schema->{$state->{keyword}};
0.000002,1,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001993,14156,0.000000,sub assert_keyword_type ($state, $schema, $type) {
0.000566,3539,0.000000,croak 'assert_keyword_type called in void context' if not defined wantarray;
0.002609,3539,0.000001,my $value = $schema->{$state->{keyword}};
0.000673,3539,0.000000,my $thing = 'value';
0.000000,0,0.000000,($value, $thing) = is_plain_hashref($value) ? ($value->{$state->{_schema_path_suffix}}, 'value at "'.$state->{_schema_path_suffix}.'"')
0.000000,0,0.000000,: is_plain_arrayref($value) ? ($value->[$state->{_schema_path_suffix}], 'item '.$state->{_schema_path_suffix})
0.000000,0,0.000000,: die 'unknown type'
0.000640,3539,0.000000,if exists $state->{_schema_path_suffix};
0.026097,3539,0.000007,return 1 if is_type($type, $value);
0.000000,0,0.000000,E($state, '%s %s is not a%s %s', $state->{keyword}, $thing, ($type =~ /^[aeiou]/ ? 'n' : ''), $type);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000040,225,0.000000,sub assert_pattern ($state, $pattern) {
0.000018,75,0.000000,croak 'assert_pattern called in void context' if not defined wantarray;
0.000027,75,0.000000,try {
0.000285,75,0.000004,local $SIG{__WARN__} = sub { die @_ };
0.002415,75,0.000032,qr/$pattern/;
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) { return E($state, $e); };
0.000126,75,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# this is only suitable for checking URIs within schemas themselves
0.000298,2220,0.000000,sub assert_uri_reference ($state, $schema) {
0.000197,740,0.000000,croak 'assert_uri_reference called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000413,740,0.000001,my $string = $schema->{$state->{keyword}};
0.000000,0,0.000000,return E($state, '%s value is not a valid URI reference', $state->{keyword})
0.000000,0,0.000000,# see also uri-reference format sub
0.011854,740,0.000016,if fc(Mojo::URL->new($string)->to_unsafe_string) ne fc($string)
0.000000,0,0.000000,or $string =~ /[^[:ascii:]]/
0.000000,0,0.000000,or $string =~ /#/
0.000000,0,0.000000,and $string !~ m{#$}                          # empty fragment
0.000000,0,0.000000,and $string !~ m{#[A-Za-z][A-Za-z0-9_:.-]*$}  # plain-name fragment
0.000000,0,0.000000,and $string !~ m{#/(?:[^~]|~[01])*$};         # json pointer fragment
0.000000,0,0.000000,
0.001400,740,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# this is only suitable for checking URIs within schemas themselves
0.000027,184,0.000000,sub assert_uri ($state, $schema, $override = undef) {
0.000006,46,0.000000,croak 'assert_uri called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000023,46,0.000001,my $string = $override // $schema->{$state->{keyword}};
0.000044,46,0.000001,my $uri = Mojo::URL->new($string);
0.000000,0,0.000000,
0.000216,46,0.000005,return E($state, '"%s" is not a valid URI', $string)
0.000000,0,0.000000,# see also uri format sub
0.000000,0,0.000000,if fc($uri->to_unsafe_string) ne fc($string)
0.000000,0,0.000000,or $string =~ /[^[:ascii:]]/
0.000000,0,0.000000,or not $uri->is_abs
0.000000,0,0.000000,or $string =~ /#/
0.000000,0,0.000000,and $string !~ m{#$}                          # empty fragment
0.000000,0,0.000000,and $string !~ m{#[A-Za-z][A-Za-z0-9_:.-]*$}  # plain-name fragment
0.000000,0,0.000000,and $string !~ m{#/(?:[^~]|~[01])*$};         # json pointer fragment
0.000000,0,0.000000,
0.000166,46,0.000004,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# produces an annotation whose value is the same as that of the current keyword
0.012148,95484,0.000000,sub annotate_self ($state, $schema) {
0.000000,0,0.000000,A($state, is_ref($schema->{$state->{keyword}}) ? dclone($schema->{$state->{keyword}})
0.116057,31828,0.000004,: $schema->{$state->{keyword}});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sprintf_num ($value) {
0.000000,0,0.000000,# use original value as stored in the NV, without losing precision
0.000000,0,0.000000,ref($value) =~ /^Math::Big(?:Int|Float)$/ ? $value->bstr : sprintf('%s', $value);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,1;
0.000085,1,0.000085,__END__
