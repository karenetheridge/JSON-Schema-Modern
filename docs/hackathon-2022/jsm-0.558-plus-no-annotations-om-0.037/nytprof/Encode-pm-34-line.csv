# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,#
0.000000,0,0.000000,# $Id: Encode.pm,v 3.17 2022/04/07 03:05:51 dankogai Exp $
0.000000,0,0.000000,#
0.000000,0,0.000000,package Encode;
0.000018,2,0.000009,use strict;
0.000020,2,0.000010,use warnings;
0.000053,2,0.000027,use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
0.000000,0,0.000000,our $VERSION;
0.000000,0,0.000000,BEGIN {
0.000014,1,0.000014,$VERSION = sprintf "%d.%02d", q$Revision: 3.17 $ =~ /(\d+)/g;
0.000000,1,0.000000,require XSLoader;
0.004956,1,0.004956,XSLoader::load( __PACKAGE__, $VERSION );
0.000060,1,0.000060,}
0.000000,0,0.000000,
0.000108,3,0.000036,use Exporter 5.57 'import';
0.000000,0,0.000000,
0.000171,2,0.000085,use Carp ();
0.000001,1,0.000001,our @CARP_NOT = qw(Encode::Encoder);
0.000000,0,0.000000,
0.000000,0,0.000000,# Public, encouraged API is exported by default
0.000000,0,0.000000,
0.000001,1,0.000001,our @EXPORT = qw(
0.000000,0,0.000000,decode  decode_utf8  encode  encode_utf8 str2bytes bytes2str
0.000000,0,0.000000,encodings  find_encoding find_mime_encoding clone_encoding
0.000000,0,0.000000,);
0.000001,1,0.000001,our @FB_FLAGS = qw(
0.000000,0,0.000000,DIE_ON_ERR WARN_ON_ERR RETURN_ON_ERR LEAVE_SRC
0.000000,0,0.000000,PERLQQ HTMLCREF XMLCREF STOP_AT_PARTIAL
0.000000,0,0.000000,);
0.000001,1,0.000001,our @FB_CONSTS = qw(
0.000000,0,0.000000,FB_DEFAULT FB_CROAK FB_QUIET FB_WARN
0.000000,0,0.000000,FB_PERLQQ FB_HTMLCREF FB_XMLCREF
0.000000,0,0.000000,);
0.000001,1,0.000001,our @EXPORT_OK = (
0.000000,0,0.000000,qw(
0.000000,0,0.000000,_utf8_off _utf8_on define_encoding from_to is_16bit is_8bit
0.000000,0,0.000000,is_utf8 perlio_ok resolve_alias utf8_downgrade utf8_upgrade
0.000000,0,0.000000,),
0.000000,0,0.000000,@FB_FLAGS, @FB_CONSTS,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000004,1,0.000004,our %EXPORT_TAGS = (
0.000000,0,0.000000,all          => [ @EXPORT,    @EXPORT_OK ],
0.000000,0,0.000000,default      => [ @EXPORT ],
0.000000,0,0.000000,fallbacks    => [ @FB_CONSTS ],
0.000000,0,0.000000,fallback_all => [ @FB_CONSTS, @FB_FLAGS ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Documentation moved after __END__ for speed - NI-S
0.000000,0,0.000000,
0.000000,1,0.000000,our $ON_EBCDIC = ( ord("A") == 193 );
0.000000,0,0.000000,
0.002022,2,0.001011,use Encode::Alias ();
0.001394,2,0.000697,use Encode::MIME::Name;
0.000000,0,0.000000,
0.001047,2,0.000523,use Storable;
0.000000,0,0.000000,
0.000000,0,0.000000,# Make a %Encoding package variable to allow a certain amount of cheating
0.000000,0,0.000000,our %Encoding;
0.000000,0,0.000000,our %ExtModule;
0.000539,1,0.000539,require Encode::Config;
0.000000,0,0.000000,#  See
0.000000,0,0.000000,#  https://bugzilla.redhat.com/show_bug.cgi?id=435505#c2
0.000000,0,0.000000,#  to find why sig handlers inside eval{} are disabled.
0.000000,1,0.000000,eval {
0.000002,1,0.000002,local $SIG{__DIE__};
0.000001,1,0.000001,local $SIG{__WARN__};
0.000001,1,0.000001,local @INC = @INC;
0.000001,1,0.000001,pop @INC if @INC && $INC[-1] eq '.';
0.000095,1,0.000095,require Encode::ConfigLocal;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub encodings {
0.000000,0,0.000000,my %enc;
0.000000,0,0.000000,my $arg  = $_[1] || '';
0.000000,0,0.000000,if ( $arg eq ":all" ) {
0.000000,0,0.000000,%enc = ( %Encoding, %ExtModule );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,%enc = %Encoding;
0.000000,0,0.000000,for my $mod ( map { m/::/ ? $_ : "Encode::$_" } @_ ) {
0.000000,0,0.000000,DEBUG and warn $mod;
0.000000,0,0.000000,for my $enc ( keys %ExtModule ) {
0.000000,0,0.000000,$ExtModule{$enc} eq $mod and $enc{$enc} = $mod;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return sort { lc $a cmp lc $b }
0.000000,0,0.000000,grep      { !/^(?:Internal|Unicode|Guess)$/o } keys %enc;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub perlio_ok {
0.000000,0,0.000000,my $obj = ref( $_[0] ) ? $_[0] : find_encoding( $_[0] );
0.000000,0,0.000000,$obj->can("perlio_ok") and return $obj->perlio_ok();
0.000000,0,0.000000,return 0;    # safety net
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub define_encoding {
0.000001,7,0.000000,my $obj  = shift;
0.000000,7,0.000000,my $name = shift;
0.000002,7,0.000000,$Encoding{$name} = $obj;
0.000013,7,0.000002,my $lc = lc($name);
0.000001,7,0.000000,define_alias( $lc => $obj ) unless $lc eq $name;
0.000000,7,0.000000,while (@_) {
0.000000,0,0.000000,my $alias = shift;
0.000000,0,0.000000,define_alias( $alias, $obj );
0.000000,0,0.000000,}
0.000002,7,0.000000,my $class = ref($obj);
0.000002,7,0.000000,push @Encode::CARP_NOT, $class unless grep { $_ eq $class } @Encode::CARP_NOT;
0.000003,7,0.000000,push @Encode::Encoding::CARP_NOT, $class unless grep { $_ eq $class } @Encode::Encoding::CARP_NOT;
0.000009,7,0.000001,return $obj;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getEncoding {
0.000001,3,0.000000,my ( $class, $name, $skip_external ) = @_;
0.000000,0,0.000000,
0.000003,3,0.000001,defined($name) or return;
0.000000,0,0.000000,
0.000014,3,0.000005,$name =~ s/\s+//g; # https://rt.cpan.org/Ticket/Display.html?id=65796
0.000000,0,0.000000,
0.000001,3,0.000000,ref($name) && $name->can('renew') and return $name;
0.000007,3,0.000002,exists $Encoding{$name} and return $Encoding{$name};
0.000002,2,0.000001,my $lc = lc $name;
0.000001,2,0.000000,exists $Encoding{$lc} and return $Encoding{$lc};
0.000000,0,0.000000,
0.000003,2,0.000002,my $oc = $class->find_alias($name);
0.000004,2,0.000002,defined($oc) and return $oc;
0.000000,0,0.000000,$lc ne $name and $oc = $class->find_alias($lc);
0.000000,0,0.000000,defined($oc) and return $oc;
0.000000,0,0.000000,
0.000000,0,0.000000,unless ($skip_external) {
0.000000,0,0.000000,if ( my $mod = $ExtModule{$name} || $ExtModule{$lc} ) {
0.000000,0,0.000000,$mod =~ s,::,/,g;
0.000000,0,0.000000,$mod .= '.pm';
0.000000,0,0.000000,eval { require $mod; };
0.000000,0,0.000000,exists $Encoding{$name} and return $Encoding{$name};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# HACK: These two functions must be defined in Encode and because of
0.000000,0,0.000000,# cyclic dependency between Encode and Encode::Alias, Exporter does not work
0.000000,0,0.000000,sub find_alias {
0.000008,2,0.000004,goto &Encode::Alias::find_alias;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub define_alias {
0.000000,0,0.000000,goto &Encode::Alias::define_alias;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_encoding($;$) {
0.000002,3,0.000001,my ( $name, $skip_external ) = @_;
0.000022,3,0.000007,return __PACKAGE__->getEncoding( $name, $skip_external );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_mime_encoding($;$) {
0.000000,0,0.000000,my ( $mime_name, $skip_external ) = @_;
0.000000,0,0.000000,my $name = Encode::MIME::Name::get_encode_name( $mime_name );
0.000000,0,0.000000,return find_encoding( $name, $skip_external );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub resolve_alias($) {
0.000000,0,0.000000,my $obj = find_encoding(shift);
0.000000,0,0.000000,defined $obj and return $obj->name;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone_encoding($) {
0.000000,0,0.000000,my $obj = find_encoding(shift);
0.000000,0,0.000000,ref $obj or return;
0.000000,0,0.000000,return Storable::dclone($obj);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000038,1,0.000038,onBOOT;
0.000000,0,0.000000,
0.000000,1,0.000000,if ($ON_EBCDIC) {
0.000000,0,0.000000,package Encode::UTF_EBCDIC;
0.000641,2,0.000321,use parent 'Encode::Encoding';
0.000000,0,0.000000,my $obj = bless { Name => "UTF_EBCDIC" } => "Encode::UTF_EBCDIC";
0.000000,0,0.000000,Encode::define_encoding($obj, 'Unicode');
0.000000,0,0.000000,sub decode {
0.000000,0,0.000000,my ( undef, $str, $chk ) = @_;
0.000000,0,0.000000,my $res = '';
0.000000,0,0.000000,for ( my $i = 0 ; $i < length($str) ; $i++ ) {
0.000000,0,0.000000,$res .=
0.000000,0,0.000000,chr(
0.000000,0,0.000000,utf8::unicode_to_native( ord( substr( $str, $i, 1 ) ) )
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,$_[1] = '' if $chk;
0.000000,0,0.000000,return $res;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub encode {
0.000000,0,0.000000,my ( undef, $str, $chk ) = @_;
0.000000,0,0.000000,my $res = '';
0.000000,0,0.000000,for ( my $i = 0 ; $i < length($str) ; $i++ ) {
0.000000,0,0.000000,$res .=
0.000000,0,0.000000,chr(
0.000000,0,0.000000,utf8::native_to_unicode( ord( substr( $str, $i, 1 ) ) )
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,$_[1] = '' if $chk;
0.000000,0,0.000000,return $res;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,# https://rt.cpan.org/Public/Bug/Display.html?id=103253
0.000000,0,0.000000,package Encode::XS;
0.000019,2,0.000010,use parent 'Encode::Encoding';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,1,0.000000,package Encode::utf8;
0.000058,2,0.000029,use parent 'Encode::Encoding';
0.000002,1,0.000002,my %obj = (
0.000000,0,0.000000,'utf8'         => { Name => 'utf8' },
0.000000,0,0.000000,'utf-8-strict' => { Name => 'utf-8-strict', strict_utf8 => 1 }
0.000000,0,0.000000,);
0.000002,1,0.000002,for ( keys %obj ) {
0.000001,2,0.000000,bless $obj{$_} => __PACKAGE__;
0.000002,2,0.000001,Encode::define_encoding( $obj{$_} => $_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,sub cat_decode {
0.000000,0,0.000000,# ($obj, $dst, $src, $pos, $trm, $chk)
0.000000,0,0.000000,# currently ignores $chk
0.000000,0,0.000000,my ( undef, undef, undef, $pos, $trm ) = @_;
0.000000,0,0.000000,my ( $rdst, $rsrc, $rpos ) = \@_[ 1, 2, 3 ];
0.000606,2,0.000303,use bytes;
0.000000,0,0.000000,if ( ( my $npos = index( $$rsrc, $trm, $pos ) ) >= 0 ) {
0.000000,0,0.000000,$$rdst .=
0.000000,0,0.000000,substr( $$rsrc, $pos, $npos - $pos + length($trm) );
0.000000,0,0.000000,$$rpos = $npos + length($trm);
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,$$rdst .= substr( $$rsrc, $pos );
0.000000,0,0.000000,$$rpos = length($$rsrc);
0.000000,0,0.000000,return '';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000012,2,0.000006,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
