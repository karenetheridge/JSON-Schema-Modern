# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Mojo::Util;
0.000023,2,0.000012,use Mojo::Base -strict;
0.000000,0,0.000000,
0.000016,2,0.000008,use Carp           qw(carp croak);
0.001904,2,0.000952,use Data::Dumper   ();
0.001156,2,0.000578,use Digest::MD5    qw(md5 md5_hex);
0.000477,2,0.000238,use Digest::SHA    qw(hmac_sha1_hex sha1 sha1_hex);
0.000015,2,0.000008,use Encode         qw(find_encoding);
0.000013,2,0.000006,use Exporter       qw(import);
0.001722,2,0.000861,use File::Basename qw(dirname);
0.000681,2,0.000340,use Getopt::Long   qw(GetOptionsFromArray);
0.001553,2,0.000777,use IO::Compress::Gzip;
0.000653,2,0.000326,use IO::Poll qw(POLLIN POLLPRI);
0.000482,2,0.000241,use IO::Uncompress::Gunzip;
0.000016,2,0.000008,use List::Util         qw(min);
0.000610,2,0.000305,use MIME::Base64       qw(decode_base64 encode_base64);
0.002062,2,0.001031,use Pod::Usage         qw(pod2usage);
0.000550,2,0.000275,use Socket             qw(inet_pton AF_INET6 AF_INET);
0.000041,2,0.000021,use Sub::Util          qw(set_subname);
0.000032,2,0.000016,use Symbol             qw(delete_package);
0.002390,2,0.001195,use Time::HiRes        ();
0.001215,2,0.000607,use Unicode::Normalize ();
0.000000,0,0.000000,
0.000000,0,0.000000,# Check for monotonic clock support
0.000056,3,0.000019,use constant MONOTONIC => eval { !!Time::HiRes::clock_gettime(Time::HiRes::CLOCK_MONOTONIC()) };
0.000000,0,0.000000,
0.000000,0,0.000000,# Punycode bootstring parameters
0.000000,0,0.000000,use constant {
0.000000,1,0.000000,PC_BASE         => 36,
0.000000,0,0.000000,PC_TMIN         => 1,
0.000000,0,0.000000,PC_TMAX         => 26,
0.000000,0,0.000000,PC_SKEW         => 38,
0.000000,0,0.000000,PC_DAMP         => 700,
0.000000,0,0.000000,PC_INITIAL_BIAS => 72,
0.000000,0,0.000000,PC_INITIAL_N    => 128
0.001202,1,0.001202,};
0.000000,0,0.000000,
0.000000,0,0.000000,# To generate a new HTML entity table run this command
0.000000,0,0.000000,# perl examples/entities.pl > lib/Mojo/resources/html_entities.txt
0.000000,1,0.000000,my %ENTITIES;
0.000000,0,0.000000,{
0.000000,0,0.000000,# Don't use Mojo::File here due to circular dependencies
0.000209,2,0.000104,my $path = File::Spec->catfile(dirname(__FILE__), 'resources', 'html_entities.txt');
0.000000,0,0.000000,
0.001182,1,0.001182,open my $file, '<', $path or croak "Unable to open html entities file ($path): $!";
0.000737,3,0.000246,my $lines = do { local $/; <$file> };
0.000000,0,0.000000,
0.000321,1,0.000321,for my $line (split /\n/, $lines) {
0.003291,2231,0.000001,next unless $line =~ /^(\S+)\s+U\+(\S+)(?:\s+U\+(\S+))?/;
0.002007,2231,0.000001,$ENTITIES{$1} = defined $3 ? (chr(hex $2) . chr(hex $3)) : chr(hex $2);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Characters that should be escaped in XML
0.000003,1,0.000003,my %XML = ('&' => '&amp;', '<' => '&lt;', '>' => '&gt;', '"' => '&quot;', '\'' => '&#39;');
0.000000,0,0.000000,
0.000000,0,0.000000,# "Sun, 06 Nov 1994 08:49:37 GMT" and "Sunday, 06-Nov-94 08:49:37 GMT"
0.000010,1,0.000010,my $EXPIRES_RE = qr/(\w+\W+\d+\W+\w+\W+\d+\W+\d+:\d+:\d+\W*\w+)/;
0.000000,0,0.000000,
0.000000,0,0.000000,# Header key/value pairs
0.000002,1,0.000002,my $QUOTED_VALUE_RE   = qr/\G=\s*("(?:\\\\|\\"|[^"])*")/;
0.000005,1,0.000005,my $UNQUOTED_VALUE_RE = qr/\G=\s*([^;, ]*)/;
0.000000,0,0.000000,
0.000000,0,0.000000,# HTML entities
0.000002,1,0.000002,my $ENTITY_RE = qr/&(?:\#((?:[0-9]{1,7}|x[0-9a-fA-F]{1,6}));|(\w+[;=]?))/;
0.000000,0,0.000000,
0.000000,0,0.000000,# Encoding and pattern cache
0.000001,1,0.000001,my (%ENCODING, %PATTERN);
0.000000,0,0.000000,
0.000004,1,0.000004,our @EXPORT_OK = (
0.000000,0,0.000000,qw(b64_decode b64_encode camelize class_to_file class_to_path decamelize decode deprecated dumper encode),
0.000000,0,0.000000,qw(extract_usage getopt gunzip gzip header_params hmac_sha1_sum html_attr_unescape html_unescape humanize_bytes),
0.000000,0,0.000000,qw(md5_bytes md5_sum monkey_patch network_contains punycode_decode punycode_encode quote scope_guard secure_compare),
0.000000,0,0.000000,qw(sha1_bytes sha1_sum slugify split_cookie_header split_header steady_time tablify term_escape trim unindent),
0.000000,0,0.000000,qw(unquote url_escape url_unescape xml_escape xor_encode)
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Aliases
0.000003,1,0.000003,monkey_patch(__PACKAGE__, 'b64_decode',    \&decode_base64);
0.000001,1,0.000001,monkey_patch(__PACKAGE__, 'b64_encode',    \&encode_base64);
0.000000,1,0.000000,monkey_patch(__PACKAGE__, 'hmac_sha1_sum', \&hmac_sha1_hex);
0.000002,1,0.000002,monkey_patch(__PACKAGE__, 'md5_bytes',     \&md5);
0.000001,1,0.000001,monkey_patch(__PACKAGE__, 'md5_sum',       \&md5_hex);
0.000000,1,0.000000,monkey_patch(__PACKAGE__, 'sha1_bytes',    \&sha1);
0.000001,1,0.000001,monkey_patch(__PACKAGE__, 'sha1_sum',      \&sha1_hex);
0.000000,0,0.000000,
0.000000,0,0.000000,# Use a monotonic clock if possible
0.000000,0,0.000000,monkey_patch(__PACKAGE__, 'steady_time',
0.000003,1,0.000003,MONOTONIC ? sub () { Time::HiRes::clock_gettime(Time::HiRes::CLOCK_MONOTONIC()) } : \&Time::HiRes::time);
0.000000,0,0.000000,
0.000000,0,0.000000,sub camelize {
0.000000,0,0.000000,my $str = shift;
0.000000,0,0.000000,return $str if $str =~ /^[A-Z]/;
0.000000,0,0.000000,
0.000000,0,0.000000,# CamelCase words
0.000000,0,0.000000,return join '::', map {
0.000000,0,0.000000,join('', map { ucfirst lc } split /_/)
0.000000,0,0.000000,} split /-/, $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub class_to_file {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,$class =~ s/::|'//g;
0.000000,0,0.000000,$class =~ s/([A-Z])([A-Z]*)/$1 . lc $2/ge;
0.000000,0,0.000000,return decamelize($class);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub class_to_path { join '.', join('/', split(/::|'/, shift)), 'pm' }
0.000000,0,0.000000,
0.000000,0,0.000000,sub decamelize {
0.000000,0,0.000000,my $str = shift;
0.000000,0,0.000000,return $str if $str !~ /^[A-Z]/;
0.000000,0,0.000000,
0.000000,0,0.000000,# snake_case words
0.000000,0,0.000000,return join '-', map {
0.000000,0,0.000000,join('_', map {lc} grep {length} split /([A-Z]{1}[^A-Z]*)/)
0.000000,0,0.000000,} split /::/, $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub decode {
0.061080,185786,0.000000,my ($encoding, $bytes) = @_;
0.917637,557358,0.000002,return undef unless eval { $bytes = _encoding($encoding)->decode("$bytes", 1); 1 };
0.208166,185786,0.000001,return $bytes;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub deprecated {
0.000000,0,0.000000,local $Carp::CarpLevel = 1;
0.000000,0,0.000000,$ENV{MOJO_FATAL_DEPRECATIONS} ? croak @_ : carp @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub dumper { Data::Dumper->new([@_])->Indent(1)->Sortkeys(1)->Terse(1)->Useqq(1)->Dump }
0.000000,0,0.000000,
2.857633,829417,0.000003,sub encode { _encoding($_[0])->encode("$_[1]", 0) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub extract_usage {
0.000000,0,0.000000,my $file = @_ ? "$_[0]" : (caller)[1];
0.000000,0,0.000000,
0.000000,0,0.000000,open my $handle, '>', \my $output;
0.000000,0,0.000000,pod2usage -exitval => 'noexit', -input => $file, -output => $handle;
0.000000,0,0.000000,$output =~ s/^.*\n|\n$//;
0.000000,0,0.000000,$output =~ s/\n$//;
0.000000,0,0.000000,
0.000000,0,0.000000,return unindent($output);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getopt {
0.000000,0,0.000000,my ($array, $opts) = map { ref $_[0] eq 'ARRAY' ? shift : $_ } \@ARGV, [];
0.000000,0,0.000000,
0.000000,0,0.000000,my $save   = Getopt::Long::Configure(qw(default no_auto_abbrev no_ignore_case), @$opts);
0.000000,0,0.000000,my $result = GetOptionsFromArray $array, @_;
0.000000,0,0.000000,Getopt::Long::Configure($save);
0.000000,0,0.000000,
0.000000,0,0.000000,return $result;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub gunzip {
0.000000,0,0.000000,my $compressed = shift;
0.000000,0,0.000000,IO::Uncompress::Gunzip::gunzip \$compressed, \my $uncompressed
0.000000,0,0.000000,or croak "Couldn't gunzip: $IO::Uncompress::Gunzip::GzipError";
0.000000,0,0.000000,return $uncompressed;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub gzip {
0.000000,0,0.000000,my $uncompressed = shift;
0.000000,0,0.000000,IO::Compress::Gzip::gzip \$uncompressed, \my $compressed or croak "Couldn't gzip: $IO::Compress::Gzip::GzipError";
0.000000,0,0.000000,return $compressed;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub header_params {
0.000000,0,0.000000,my $value = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $params = {};
0.000000,0,0.000000,while ($value =~ /\G[;\s]*([^=;, ]+)\s*/gc) {
0.000000,0,0.000000,my $name = $1;
0.000000,0,0.000000,
0.000000,0,0.000000,# Quoted value
0.000000,0,0.000000,if ($value =~ /$QUOTED_VALUE_RE/gco) { $params->{$name} //= unquote($1) }
0.000000,0,0.000000,
0.000000,0,0.000000,# Unquoted value
0.000000,0,0.000000,elsif ($value =~ /$UNQUOTED_VALUE_RE/gco) { $params->{$name} //= $1 }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ($params, substr($value, pos($value) // 0));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub html_attr_unescape { _html(shift, 1) }
0.000000,0,0.000000,sub html_unescape      { _html(shift, 0) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub humanize_bytes {
0.000000,0,0.000000,my $size = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $prefix = $size < 0 ? '-' : '';
0.000000,0,0.000000,
0.000000,0,0.000000,return "$prefix${size}B"               if ($size = abs $size) < 1024;
0.000000,0,0.000000,return $prefix . _round($size) . 'KiB' if ($size /= 1024) < 1024;
0.000000,0,0.000000,return $prefix . _round($size) . 'MiB' if ($size /= 1024) < 1024;
0.000000,0,0.000000,return $prefix . _round($size) . 'GiB' if ($size /= 1024) < 1024;
0.000000,0,0.000000,return $prefix . _round($size /= 1024) . 'TiB';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub monkey_patch {
0.000013,22,0.000001,my ($class, %patch) = @_;
0.000035,2,0.000018,no strict 'refs';
0.000166,2,0.000083,no warnings 'redefine';
0.000189,22,0.000009,*{"${class}::$_"} = set_subname("${class}::$_", $patch{$_}) for keys %patch;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub network_contains {
0.000000,0,0.000000,my ($cidr, $addr) = @_;
0.000000,0,0.000000,return undef unless length $cidr && length $addr;
0.000000,0,0.000000,
0.000000,0,0.000000,# Parse inputs
0.000000,0,0.000000,my ($net, $mask) = split m!/!, $cidr, 2;
0.000000,0,0.000000,my $v6 = $net =~ /:/;
0.000000,0,0.000000,return undef if $v6 xor $addr =~ /:/;
0.000000,0,0.000000,
0.000000,0,0.000000,# Convert addresses to binary
0.000000,0,0.000000,return undef unless $net  = inet_pton($v6 ? AF_INET6 : AF_INET, $net);
0.000000,0,0.000000,return undef unless $addr = inet_pton($v6 ? AF_INET6 : AF_INET, $addr);
0.000000,0,0.000000,my $length = $v6 ? 128 : 32;
0.000000,0,0.000000,
0.000000,0,0.000000,# Apply mask if given
0.000000,0,0.000000,$addr &= pack "B$length", '1' x $mask if defined $mask;
0.000000,0,0.000000,
0.000000,0,0.000000,# Compare
0.000000,0,0.000000,return 0 == unpack "B$length", ($net ^ $addr);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Direct translation of RFC 3492
0.000000,0,0.000000,sub punycode_decode {
0.000000,0,0.000000,my $input = shift;
0.000168,2,0.000084,use integer;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($n, $i, $bias, @output) = (PC_INITIAL_N, 0, PC_INITIAL_BIAS);
0.000000,0,0.000000,
0.000000,0,0.000000,# Consume all code points before the last delimiter
0.000000,0,0.000000,push @output, split(//, $1) if $input =~ s/(.*)\x2d//s;
0.000000,0,0.000000,
0.000000,0,0.000000,while (length $input) {
0.000000,0,0.000000,my ($oldi, $w) = ($i, 1);
0.000000,0,0.000000,
0.000000,0,0.000000,# Base to infinity in steps of base
0.000000,0,0.000000,for (my $k = PC_BASE; 1; $k += PC_BASE) {
0.000000,0,0.000000,my $digit = ord substr $input, 0, 1, '';
0.000000,0,0.000000,$digit = $digit < 0x40 ? $digit + (26 - 0x30) : ($digit & 0x1f) - 1;
0.000000,0,0.000000,$i += $digit * $w;
0.000000,0,0.000000,my $t = $k - $bias;
0.000000,0,0.000000,$t = $t < PC_TMIN ? PC_TMIN : $t > PC_TMAX ? PC_TMAX : $t;
0.000000,0,0.000000,last if $digit < $t;
0.000000,0,0.000000,$w *= PC_BASE - $t;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$bias = _adapt($i - $oldi, @output + 1, $oldi == 0);
0.000000,0,0.000000,$n += $i / (@output + 1);
0.000000,0,0.000000,$i = $i % (@output + 1);
0.000000,0,0.000000,splice @output, $i++, 0, chr $n;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return join '', @output;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Direct translation of RFC 3492
0.000000,0,0.000000,sub punycode_encode {
0.000000,0,0.000000,my $output = shift;
0.001537,2,0.000768,use integer;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($n, $delta, $bias) = (PC_INITIAL_N, 0, PC_INITIAL_BIAS);
0.000000,0,0.000000,
0.000000,0,0.000000,# Extract basic code points
0.000000,0,0.000000,my @input = map {ord} split //, $output;
0.000000,0,0.000000,$output =~ s/[^\x00-\x7f]+//gs;
0.000000,0,0.000000,my $h = my $basic = length $output;
0.000000,0,0.000000,$output .= "\x2d" if $basic > 0;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $m (sort grep { $_ >= PC_INITIAL_N } @input) {
0.000000,0,0.000000,next if $m < $n;
0.000000,0,0.000000,$delta += ($m - $n) * ($h + 1);
0.000000,0,0.000000,$n = $m;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $c (@input) {
0.000000,0,0.000000,
0.000000,0,0.000000,if    ($c < $n) { $delta++ }
0.000000,0,0.000000,elsif ($c == $n) {
0.000000,0,0.000000,my $q = $delta;
0.000000,0,0.000000,
0.000000,0,0.000000,# Base to infinity in steps of base
0.000000,0,0.000000,for (my $k = PC_BASE; 1; $k += PC_BASE) {
0.000000,0,0.000000,my $t = $k - $bias;
0.000000,0,0.000000,$t = $t < PC_TMIN ? PC_TMIN : $t > PC_TMAX ? PC_TMAX : $t;
0.000000,0,0.000000,last if $q < $t;
0.000000,0,0.000000,my $o = $t + (($q - $t) % (PC_BASE - $t));
0.000000,0,0.000000,$output .= chr $o + ($o < 26 ? 0x61 : 0x30 - 26);
0.000000,0,0.000000,$q = ($q - $t) / (PC_BASE - $t);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$output .= chr $q + ($q < 26 ? 0x61 : 0x30 - 26);
0.000000,0,0.000000,$bias  = _adapt($delta, $h + 1, $h == $basic);
0.000000,0,0.000000,$delta = 0;
0.000000,0,0.000000,$h++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$delta++;
0.000000,0,0.000000,$n++;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $output;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub quote {
0.000000,0,0.000000,my $str = shift;
0.000000,0,0.000000,$str =~ s/(["\\])/\\$1/g;
0.000000,0,0.000000,return qq{"$str"};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub scope_guard { Mojo::Util::_Guard->new(cb => shift) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub secure_compare {
0.000000,0,0.000000,my ($one, $two) = @_;
0.000000,0,0.000000,my $r = length $one != length $two;
0.000000,0,0.000000,$two = $one if $r;
0.000000,0,0.000000,$r |= ord(substr $one, $_) ^ ord(substr $two, $_) for 0 .. length($one) - 1;
0.000000,0,0.000000,return $r == 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub slugify {
0.000000,0,0.000000,my ($value, $allow_unicode) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($allow_unicode) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Force unicode semantics by upgrading string
0.000000,0,0.000000,utf8::upgrade($value = Unicode::Normalize::NFKC($value));
0.000000,0,0.000000,$value =~ s/[^\w\s-]+//g;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$value = Unicode::Normalize::NFKD($value);
0.000000,0,0.000000,$value =~ s/[^a-zA-Z0-9_\p{PosixSpace}-]+//g;
0.000000,0,0.000000,}
0.000000,0,0.000000,(my $new = lc trim($value)) =~ s/[-\s]+/-/g;
0.000000,0,0.000000,
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub split_cookie_header { _header(shift, 1) }
0.000000,0,0.000000,sub split_header        { _header(shift, 0) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub tablify {
0.000000,0,0.000000,my $rows = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my @spec;
0.000000,0,0.000000,for my $row (@$rows) {
0.000000,0,0.000000,for my $i (0 .. $#$row) {
0.000000,0,0.000000,($row->[$i] //= '') =~ y/\r\n//d;
0.000000,0,0.000000,my $len = length $row->[$i];
0.000000,0,0.000000,$spec[$i] = $len if $len >= ($spec[$i] // 0);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @fm = (map({"\%-${_}s"} @spec[0 .. $#spec - 1]), '%s');
0.000000,0,0.000000,return join '', map { sprintf join('  ', @fm[0 .. $#$_]) . "\n", @$_ } @$rows;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub term_escape {
0.000000,0,0.000000,my $str = shift;
0.000000,0,0.000000,$str =~ s/([\x00-\x09\x0b-\x1f\x7f\x80-\x9f])/sprintf '\\x%02x', ord $1/ge;
0.000000,0,0.000000,return $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub trim {
0.000000,0,0.000000,my $str = shift;
0.000000,0,0.000000,$str =~ s/^\s+//;
0.000000,0,0.000000,$str =~ s/\s+$//;
0.000000,0,0.000000,return $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unindent {
0.000000,0,0.000000,my $str = shift;
0.000000,0,0.000000,my $min = min map { m/^([ \t]*)/; length $1 || () } split /\n/, $str;
0.000000,0,0.000000,$str =~ s/^[ \t]{0,$min}//gm if $min;
0.000000,0,0.000000,return $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unquote {
0.000000,0,0.000000,my $str = shift;
0.000000,0,0.000000,return $str unless $str =~ s/^"(.*)"$/$1/g;
0.000000,0,0.000000,$str                    =~ s/\\\\/\\/g;
0.000000,0,0.000000,$str                    =~ s/\\"/"/g;
0.000000,0,0.000000,return $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub url_escape {
0.245600,829417,0.000000,my ($str, $pattern) = @_;
0.000000,0,0.000000,
0.181039,829417,0.000000,if ($pattern) {
0.189037,829417,0.000000,unless (exists $PATTERN{$pattern}) {
0.000039,4,0.000010,(my $quoted = $pattern) =~ s!([/\$\[])!\\$1!g;
1.998606,4,0.499651,$PATTERN{$pattern} = eval "sub { \$_[0] =~ s/([$quoted])/sprintf '%%%02X', ord \$1/ge }" or croak $@;
0.000000,0,0.000000,}
0.638644,829417,0.000001,$PATTERN{$pattern}->($str);
0.000000,0,0.000000,}
0.000000,0,0.000000,else { $str =~ s/([^A-Za-z0-9\-._~])/sprintf '%%%02X', ord $1/ge }
0.000000,0,0.000000,
0.989229,829417,0.000001,return $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub url_unescape {
0.060447,284828,0.000000,my $str = shift;
0.375483,284828,0.000001,$str =~ s/%([0-9a-fA-F]{2})/chr hex $1/ge;
0.348682,284828,0.000001,return $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub xml_escape {
0.000000,0,0.000000,return $_[0] if ref $_[0] && ref $_[0] eq 'Mojo::ByteStream';
0.000000,0,0.000000,my $str = shift // '';
0.000000,0,0.000000,$str =~ s/([&<>"'])/$XML{$1}/ge;
0.000000,0,0.000000,return $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub xor_encode {
0.000000,0,0.000000,my ($input, $key) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Encode with variable key length
0.000000,0,0.000000,my $len    = length $key;
0.000000,0,0.000000,my $buffer = my $output = '';
0.000000,0,0.000000,$output .= $buffer ^ $key while length($buffer = substr($input, 0, $len, '')) == $len;
0.000000,0,0.000000,return $output .= $buffer ^ substr($key, 0, length $buffer, '');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _adapt {
0.000000,0,0.000000,my ($delta, $numpoints, $firsttime) = @_;
0.000584,2,0.000292,use integer;
0.000000,0,0.000000,
0.000000,0,0.000000,$delta = $firsttime ? $delta / PC_DAMP : $delta / 2;
0.000000,0,0.000000,$delta += $delta / $numpoints;
0.000000,0,0.000000,my $k = 0;
0.000000,0,0.000000,while ($delta > ((PC_BASE - PC_TMIN) * PC_TMAX) / 2) {
0.000000,0,0.000000,$delta /= PC_BASE - PC_TMIN;
0.000000,0,0.000000,$k     += PC_BASE;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $k + (((PC_BASE - PC_TMIN + 1) * $delta) / ($delta + PC_SKEW));
0.000000,0,0.000000,}
0.000000,0,0.000000,
1.112096,1.0152e+06,0.000001,sub _encoding { $ENCODING{$_[0]} //= find_encoding($_[0]) // croak "Unknown encoding '$_[0]'" }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _entity {
0.000000,0,0.000000,my ($point, $name, $attr) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Code point
0.000000,0,0.000000,return chr($point !~ /^x/ ? $point : hex $point) unless defined $name;
0.000000,0,0.000000,
0.000000,0,0.000000,# Named character reference
0.000000,0,0.000000,my $rest = my $last = '';
0.000000,0,0.000000,while (length $name) {
0.000000,0,0.000000,return $ENTITIES{$name} . reverse $rest
0.000000,0,0.000000,if exists $ENTITIES{$name} && (!$attr || $name =~ /;$/ || $last !~ /[A-Za-z0-9=]/);
0.000000,0,0.000000,$rest .= $last = chop $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,return '&' . reverse $rest;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _header {
0.000000,0,0.000000,my ($str, $cookie) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my (@tree, @part);
0.000000,0,0.000000,while ($str =~ /\G[,;\s]*([^=;, ]+)\s*/gc) {
0.000000,0,0.000000,push @part, $1, undef;
0.000000,0,0.000000,my $expires = $cookie && @part > 2 && lc $1 eq 'expires';
0.000000,0,0.000000,
0.000000,0,0.000000,# Special "expires" value
0.000000,0,0.000000,if ($expires && $str =~ /\G=\s*$EXPIRES_RE/gco) { $part[-1] = $1 }
0.000000,0,0.000000,
0.000000,0,0.000000,# Quoted value
0.000000,0,0.000000,elsif ($str =~ /$QUOTED_VALUE_RE/gco) { $part[-1] = unquote $1 }
0.000000,0,0.000000,
0.000000,0,0.000000,# Unquoted value
0.000000,0,0.000000,elsif ($str =~ /$UNQUOTED_VALUE_RE/gco) { $part[-1] = $1 }
0.000000,0,0.000000,
0.000000,0,0.000000,# Separator
0.000000,0,0.000000,next unless $str =~ /\G[;\s]*,\s*/gc;
0.000000,0,0.000000,push @tree, [@part];
0.000000,0,0.000000,@part = ();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Take care of final part
0.000000,0,0.000000,return [@part ? (@tree, \@part) : @tree];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _html {
0.000000,0,0.000000,my ($str, $attr) = @_;
0.000000,0,0.000000,$str =~ s/$ENTITY_RE/_entity($1, $2, $attr)/geo;
0.000000,0,0.000000,return $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _options {
0.000000,0,0.000000,
0.000000,0,0.000000,# Hash or name (one)
0.000000,0,0.000000,return ref $_[0] eq 'HASH' ? (undef, %{shift()}) : @_ if @_ == 1;
0.000000,0,0.000000,
0.000000,0,0.000000,# Name and values (odd)
0.000000,0,0.000000,return shift, @_ if @_ % 2;
0.000000,0,0.000000,
0.000000,0,0.000000,# Name and hash or just values (even)
0.000000,0,0.000000,return ref $_[1] eq 'HASH' ? (shift, %{shift()}) : (undef, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This may break in the future, but is worth it for performance
0.000000,0,0.000000,sub _readable { !!(IO::Poll::_poll(@_[0, 1], my $m = POLLIN | POLLPRI) > 0) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _round { $_[0] < 10 ? int($_[0] * 10 + 0.5) / 10 : int($_[0] + 0.5) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _stash {
0.000000,0,0.000000,my ($name, $object) = (shift, shift);
0.000000,0,0.000000,
0.000000,0,0.000000,# Hash
0.000000,0,0.000000,return $object->{$name} //= {} unless @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Get
0.000000,0,0.000000,return $object->{$name}{$_[0]} unless @_ > 1 || ref $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,# Set
0.000000,0,0.000000,my $values = ref $_[0] ? $_[0] : {@_};
0.000000,0,0.000000,@{$object->{$name}}{keys %$values} = values %$values;
0.000000,0,0.000000,
0.000000,0,0.000000,return $object;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _teardown {
0.000000,0,0.000000,return unless my $class = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# @ISA has to be cleared first because of circular references
0.000062,2,0.000031,no strict 'refs';
0.000000,0,0.000000,@{"${class}::ISA"} = ();
0.000000,0,0.000000,delete_package $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,package Mojo::Util::_Guard;
0.000313,2,0.000157,use Mojo::Base -base;
0.000000,0,0.000000,
0.000000,0,0.000000,sub DESTROY { shift->{cb}() }
0.000000,0,0.000000,
0.000021,1,0.000021,1;
0.000000,0,0.000000,
0.000000,0,0.000000,=encoding utf8
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,Mojo::Util - Portable utility functions
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use Mojo::Util qw(b64_encode url_escape url_unescape);
0.000000,0,0.000000,
0.000000,0,0.000000,my $str = 'test=23';
0.000000,0,0.000000,my $escaped = url_escape $str;
0.000000,0,0.000000,say url_unescape $escaped;
0.000000,0,0.000000,say b64_encode $escaped, '';
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,L<Mojo::Util> provides portable utility functions for L<Mojo>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 FUNCTIONS
0.000000,0,0.000000,
0.000000,0,0.000000,L<Mojo::Util> implements the following functions, which can be imported individually.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 b64_decode
0.000000,0,0.000000,
0.000000,0,0.000000,my $bytes = b64_decode $b64;
0.000000,0,0.000000,
0.000000,0,0.000000,Base64 decode bytes with L<MIME::Base64>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 b64_encode
0.000000,0,0.000000,
0.000000,0,0.000000,my $b64 = b64_encode $bytes;
0.000000,0,0.000000,my $b64 = b64_encode $bytes, "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,Base64 encode bytes with L<MIME::Base64>, the line ending defaults to a newline.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 camelize
0.000000,0,0.000000,
0.000000,0,0.000000,my $camelcase = camelize $snakecase;
0.000000,0,0.000000,
0.000000,0,0.000000,Convert C<snake_case> string to C<CamelCase> and replace C<-> with C<::>.
0.000000,0,0.000000,
0.000000,0,0.000000,# "FooBar"
0.000000,0,0.000000,camelize 'foo_bar';
0.000000,0,0.000000,
0.000000,0,0.000000,# "FooBar::Baz"
0.000000,0,0.000000,camelize 'foo_bar-baz';
0.000000,0,0.000000,
0.000000,0,0.000000,# "FooBar::Baz"
0.000000,0,0.000000,camelize 'FooBar::Baz';
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 class_to_file
0.000000,0,0.000000,
0.000000,0,0.000000,my $file = class_to_file 'Foo::Bar';
0.000000,0,0.000000,
0.000000,0,0.000000,Convert a class name to a file.
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo_bar"
0.000000,0,0.000000,class_to_file 'Foo::Bar';
0.000000,0,0.000000,
0.000000,0,0.000000,# "foobar"
0.000000,0,0.000000,class_to_file 'FOO::Bar';
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo_bar"
0.000000,0,0.000000,class_to_file 'FooBar';
0.000000,0,0.000000,
0.000000,0,0.000000,# "foobar"
0.000000,0,0.000000,class_to_file 'FOOBar';
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 class_to_path
0.000000,0,0.000000,
0.000000,0,0.000000,my $path = class_to_path 'Foo::Bar';
0.000000,0,0.000000,
0.000000,0,0.000000,Convert class name to path, as used by C<%INC>.
0.000000,0,0.000000,
0.000000,0,0.000000,# "Foo/Bar.pm"
0.000000,0,0.000000,class_to_path 'Foo::Bar';
0.000000,0,0.000000,
0.000000,0,0.000000,# "FooBar.pm"
0.000000,0,0.000000,class_to_path 'FooBar';
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 decamelize
0.000000,0,0.000000,
0.000000,0,0.000000,my $snakecase = decamelize $camelcase;
0.000000,0,0.000000,
0.000000,0,0.000000,Convert C<CamelCase> string to C<snake_case> and replace C<::> with C<->.
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo_bar"
0.000000,0,0.000000,decamelize 'FooBar';
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo_bar-baz"
0.000000,0,0.000000,decamelize 'FooBar::Baz';
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo_bar-baz"
0.000000,0,0.000000,decamelize 'foo_bar-baz';
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 decode
0.000000,0,0.000000,
0.000000,0,0.000000,my $chars = decode 'UTF-8', $bytes;
0.000000,0,0.000000,
0.000000,0,0.000000,Decode bytes to characters with L<Encode>, or return C<undef> if decoding failed.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 deprecated
0.000000,0,0.000000,
0.000000,0,0.000000,deprecated 'foo is DEPRECATED in favor of bar';
0.000000,0,0.000000,
0.000000,0,0.000000,Warn about deprecated feature from perspective of caller. You can also set the C<MOJO_FATAL_DEPRECATIONS> environment
0.000000,0,0.000000,variable to make them die instead with L<Carp>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 dumper
0.000000,0,0.000000,
0.000000,0,0.000000,my $perl = dumper {some => 'data'};
0.000000,0,0.000000,
0.000000,0,0.000000,Dump a Perl data structure with L<Data::Dumper>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 encode
0.000000,0,0.000000,
0.000000,0,0.000000,my $bytes = encode 'UTF-8', $chars;
0.000000,0,0.000000,
0.000000,0,0.000000,Encode characters to bytes with L<Encode>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 extract_usage
0.000000,0,0.000000,
0.000000,0,0.000000,my $usage = extract_usage;
0.000000,0,0.000000,my $usage = extract_usage '/home/sri/foo.pod';
0.000000,0,0.000000,
0.000000,0,0.000000,Extract usage message from the SYNOPSIS section of a file containing POD documentation, defaults to using the file this
0.000000,0,0.000000,function was called from.
0.000000,0,0.000000,
0.000000,0,0.000000,# "Usage: APPLICATION test [OPTIONS]\n"
0.000000,0,0.000000,extract_usage;
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,Usage: APPLICATION test [OPTIONS]
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 getopt
0.000000,0,0.000000,
0.000000,0,0.000000,getopt
0.000000,0,0.000000,'H|headers=s' => \my @headers,
0.000000,0,0.000000,'t|timeout=i' => \my $timeout,
0.000000,0,0.000000,'v|verbose'   => \my $verbose;
0.000000,0,0.000000,getopt $array,
0.000000,0,0.000000,'H|headers=s' => \my @headers,
0.000000,0,0.000000,'t|timeout=i' => \my $timeout,
0.000000,0,0.000000,'v|verbose'   => \my $verbose;
0.000000,0,0.000000,getopt $array, ['pass_through'],
0.000000,0,0.000000,'H|headers=s' => \my @headers,
0.000000,0,0.000000,'t|timeout=i' => \my $timeout,
0.000000,0,0.000000,'v|verbose'   => \my $verbose;
0.000000,0,0.000000,
0.000000,0,0.000000,Extract options from an array reference with L<Getopt::Long>, but without changing its global configuration, defaults
0.000000,0,0.000000,to using C<@ARGV>. The configuration options C<no_auto_abbrev> and C<no_ignore_case> are enabled by default.
0.000000,0,0.000000,
0.000000,0,0.000000,# Extract "charset" option
0.000000,0,0.000000,getopt ['--charset', 'UTF-8'], 'charset=s' => \my $charset;
0.000000,0,0.000000,say $charset;
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 gunzip
0.000000,0,0.000000,
0.000000,0,0.000000,my $uncompressed = gunzip $compressed;
0.000000,0,0.000000,
0.000000,0,0.000000,Uncompress bytes with L<IO::Compress::Gunzip>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 gzip
0.000000,0,0.000000,
0.000000,0,0.000000,my $compressed = gzip $uncompressed;
0.000000,0,0.000000,
0.000000,0,0.000000,Compress bytes with L<IO::Compress::Gzip>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 header_params
0.000000,0,0.000000,
0.000000,0,0.000000,my ($params, $remainder) = header_params 'one=foo; two="bar", three=baz';
0.000000,0,0.000000,
0.000000,0,0.000000,Extract HTTP header field parameters until the first comma according to L<RFC 5987|http://tools.ietf.org/html/rfc5987>.
0.000000,0,0.000000,Note that this function is B<EXPERIMENTAL> and might change without warning!
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 hmac_sha1_sum
0.000000,0,0.000000,
0.000000,0,0.000000,my $checksum = hmac_sha1_sum $bytes, 'passw0rd';
0.000000,0,0.000000,
0.000000,0,0.000000,Generate HMAC-SHA1 checksum for bytes with L<Digest::SHA>.
0.000000,0,0.000000,
0.000000,0,0.000000,# "11cedfd5ec11adc0ec234466d8a0f2a83736aa68"
0.000000,0,0.000000,hmac_sha1_sum 'foo', 'passw0rd';
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 html_attr_unescape
0.000000,0,0.000000,
0.000000,0,0.000000,my $str = html_attr_unescape $escaped;
0.000000,0,0.000000,
0.000000,0,0.000000,Same as L</"html_unescape">, but handles special rules from the L<HTML Living Standard|https://html.spec.whatwg.org>
0.000000,0,0.000000,for HTML attributes.
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo=bar&ltest=baz"
0.000000,0,0.000000,html_attr_unescape 'foo=bar&ltest=baz';
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo=bar<est=baz"
0.000000,0,0.000000,html_attr_unescape 'foo=bar&lt;est=baz';
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 html_unescape
0.000000,0,0.000000,
0.000000,0,0.000000,my $str = html_unescape $escaped;
0.000000,0,0.000000,
0.000000,0,0.000000,Unescape all HTML entities in string.
0.000000,0,0.000000,
0.000000,0,0.000000,# "<div>"
0.000000,0,0.000000,html_unescape '&lt;div&gt;';
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 humanize_bytes
0.000000,0,0.000000,
0.000000,0,0.000000,my $str = humanize_bytes 1234;
0.000000,0,0.000000,
0.000000,0,0.000000,Turn number of bytes into a simplified human readable format.
0.000000,0,0.000000,
0.000000,0,0.000000,# "1B"
0.000000,0,0.000000,humanize_bytes 1;
0.000000,0,0.000000,
0.000000,0,0.000000,# "7.5GiB"
0.000000,0,0.000000,humanize_bytes 8007188480;
0.000000,0,0.000000,
0.000000,0,0.000000,# "13GiB"
0.000000,0,0.000000,humanize_bytes 13443399680;
0.000000,0,0.000000,
0.000000,0,0.000000,# "-685MiB"
0.000000,0,0.000000,humanize_bytes -717946880;
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 md5_bytes
0.000000,0,0.000000,
0.000000,0,0.000000,my $checksum = md5_bytes $bytes;
0.000000,0,0.000000,
0.000000,0,0.000000,Generate binary MD5 checksum for bytes with L<Digest::MD5>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 md5_sum
0.000000,0,0.000000,
0.000000,0,0.000000,my $checksum = md5_sum $bytes;
0.000000,0,0.000000,
0.000000,0,0.000000,Generate MD5 checksum for bytes with L<Digest::MD5>.
0.000000,0,0.000000,
0.000000,0,0.000000,# "acbd18db4cc2f85cedef654fccc4a4d8"
0.000000,0,0.000000,md5_sum 'foo';
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 monkey_patch
0.000000,0,0.000000,
0.000000,0,0.000000,monkey_patch $package, foo => sub {...};
0.000000,0,0.000000,monkey_patch $package, foo => sub {...}, bar => sub {...};
0.000000,0,0.000000,
0.000000,0,0.000000,Monkey patch functions into package.
0.000000,0,0.000000,
0.000000,0,0.000000,monkey_patch 'MyApp',
0.000000,0,0.000000,one   => sub { say 'One!' },
0.000000,0,0.000000,two   => sub { say 'Two!' },
0.000000,0,0.000000,three => sub { say 'Three!' };
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 punycode_decode
0.000000,0,0.000000,
0.000000,0,0.000000,my $str = punycode_decode $punycode;
0.000000,0,0.000000,
0.000000,0,0.000000,Punycode decode string as described in L<RFC 3492|https://tools.ietf.org/html/rfc3492>.
0.000000,0,0.000000,
0.000000,0,0.000000,# "bücher"
0.000000,0,0.000000,punycode_decode 'bcher-kva';
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 network_contains
0.000000,0,0.000000,
0.000000,0,0.000000,my $bool = network_contains $network, $address;
0.000000,0,0.000000,
0.000000,0,0.000000,Check that a given address is contained within a network in CIDR form. If the network is a single address, the
0.000000,0,0.000000,addresses must be equivalent.
0.000000,0,0.000000,
0.000000,0,0.000000,# True
0.000000,0,0.000000,network_contains('10.0.0.0/8', '10.10.10.10');
0.000000,0,0.000000,network_contains('10.10.10.10', '10.10.10.10');
0.000000,0,0.000000,network_contains('fc00::/7', 'fc::c0:ff:ee');
0.000000,0,0.000000,
0.000000,0,0.000000,# False
0.000000,0,0.000000,network_contains('10.0.0.0/29', '10.10.10.10');
0.000000,0,0.000000,network_contains('10.10.10.12', '10.10.10.10');
0.000000,0,0.000000,network_contains('fc00::/7', '::1');
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 punycode_encode
0.000000,0,0.000000,
0.000000,0,0.000000,my $punycode = punycode_encode $str;
0.000000,0,0.000000,
0.000000,0,0.000000,Punycode encode string as described in L<RFC 3492|https://tools.ietf.org/html/rfc3492>.
0.000000,0,0.000000,
0.000000,0,0.000000,# "bcher-kva"
0.000000,0,0.000000,punycode_encode 'bücher';
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 quote
0.000000,0,0.000000,
0.000000,0,0.000000,my $quoted = quote $str;
0.000000,0,0.000000,
0.000000,0,0.000000,Quote string.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 scope_guard
0.000000,0,0.000000,
0.000000,0,0.000000,my $guard = scope_guard sub {...};
0.000000,0,0.000000,
0.000000,0,0.000000,Create anonymous scope guard object that will execute the passed callback when the object is destroyed.
0.000000,0,0.000000,
0.000000,0,0.000000,# Execute closure at end of scope
0.000000,0,0.000000,{
0.000000,0,0.000000,my $guard = scope_guard sub { say "Mojo!" };
0.000000,0,0.000000,say "Hello";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 secure_compare
0.000000,0,0.000000,
0.000000,0,0.000000,my $bool = secure_compare $str1, $str2;
0.000000,0,0.000000,
0.000000,0,0.000000,Constant time comparison algorithm to prevent timing attacks. The secret string should be the second argument, to avoid
0.000000,0,0.000000,leaking information about the length of the string.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 sha1_bytes
0.000000,0,0.000000,
0.000000,0,0.000000,my $checksum = sha1_bytes $bytes;
0.000000,0,0.000000,
0.000000,0,0.000000,Generate binary SHA1 checksum for bytes with L<Digest::SHA>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 sha1_sum
0.000000,0,0.000000,
0.000000,0,0.000000,my $checksum = sha1_sum $bytes;
0.000000,0,0.000000,
0.000000,0,0.000000,Generate SHA1 checksum for bytes with L<Digest::SHA>.
0.000000,0,0.000000,
0.000000,0,0.000000,# "0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33"
0.000000,0,0.000000,sha1_sum 'foo';
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 slugify
0.000000,0,0.000000,
0.000000,0,0.000000,my $slug = slugify $string;
0.000000,0,0.000000,my $slug = slugify $string, $bool;
0.000000,0,0.000000,
0.000000,0,0.000000,Returns a URL slug generated from the input string. Non-word characters are removed, the string is trimmed and
0.000000,0,0.000000,lowercased, and whitespace characters are replaced by a dash. By default, non-ASCII characters are normalized to ASCII
0.000000,0,0.000000,word characters or removed, but if a true value is passed as the second parameter, all word characters will be allowed
0.000000,0,0.000000,in the result according to unicode semantics.
0.000000,0,0.000000,
0.000000,0,0.000000,# "joel-is-a-slug"
0.000000,0,0.000000,slugify 'Joel is a slug';
0.000000,0,0.000000,
0.000000,0,0.000000,# "this-is-my-resume"
0.000000,0,0.000000,slugify 'This is: my - résumé! ☃ ';
0.000000,0,0.000000,
0.000000,0,0.000000,# "this-is-my-résumé"
0.000000,0,0.000000,slugify 'This is: my - résumé! ☃ ', 1;
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 split_cookie_header
0.000000,0,0.000000,
0.000000,0,0.000000,my $tree = split_cookie_header 'a=b; expires=Thu, 07 Aug 2008 07:07:59 GMT';
0.000000,0,0.000000,
0.000000,0,0.000000,Same as L</"split_header">, but handles C<expires> values from L<RFC 6265|https://tools.ietf.org/html/rfc6265>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 split_header
0.000000,0,0.000000,
0.000000,0,0.000000,my $tree = split_header 'foo="bar baz"; test=123, yada';
0.000000,0,0.000000,
0.000000,0,0.000000,Split HTTP header value into key/value pairs, each comma separated part gets its own array reference, and keys without
0.000000,0,0.000000,a value get C<undef> assigned.
0.000000,0,0.000000,
0.000000,0,0.000000,# "one"
0.000000,0,0.000000,split_header('one; two="three four", five=six')->[0][0];
0.000000,0,0.000000,
0.000000,0,0.000000,# "two"
0.000000,0,0.000000,split_header('one; two="three four", five=six')->[0][2];
0.000000,0,0.000000,
0.000000,0,0.000000,# "three four"
0.000000,0,0.000000,split_header('one; two="three four", five=six')->[0][3];
0.000000,0,0.000000,
0.000000,0,0.000000,# "five"
0.000000,0,0.000000,split_header('one; two="three four", five=six')->[1][0];
0.000000,0,0.000000,
0.000000,0,0.000000,# "six"
0.000000,0,0.000000,split_header('one; two="three four", five=six')->[1][1];
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 steady_time
0.000000,0,0.000000,
0.000000,0,0.000000,my $time = steady_time;
0.000000,0,0.000000,
0.000000,0,0.000000,High resolution time elapsed from an arbitrary fixed point in the past, resilient to time jumps if a monotonic clock is
0.000000,0,0.000000,available through L<Time::HiRes>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 tablify
0.000000,0,0.000000,
0.000000,0,0.000000,my $table = tablify [['foo', 'bar'], ['baz', 'yada']];
0.000000,0,0.000000,
0.000000,0,0.000000,Row-oriented generator for text tables.
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo   bar\nyada  yada\nbaz   yada\n"
0.000000,0,0.000000,tablify [['foo', 'bar'], ['yada', 'yada'], ['baz', 'yada']];
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 term_escape
0.000000,0,0.000000,
0.000000,0,0.000000,my $escaped = term_escape $str;
0.000000,0,0.000000,
0.000000,0,0.000000,Escape all POSIX control characters except for C<\n>.
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo\\x09bar\\x0d\n"
0.000000,0,0.000000,term_escape "foo\tbar\r\n";
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 trim
0.000000,0,0.000000,
0.000000,0,0.000000,my $trimmed = trim $str;
0.000000,0,0.000000,
0.000000,0,0.000000,Trim whitespace characters from both ends of string.
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo bar"
0.000000,0,0.000000,trim '  foo bar  ';
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 unindent
0.000000,0,0.000000,
0.000000,0,0.000000,my $unindented = unindent $str;
0.000000,0,0.000000,
0.000000,0,0.000000,Unindent multi-line string.
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo\nbar\nbaz\n"
0.000000,0,0.000000,unindent "  foo\n  bar\n  baz\n";
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 unquote
0.000000,0,0.000000,
0.000000,0,0.000000,my $str = unquote $quoted;
0.000000,0,0.000000,
0.000000,0,0.000000,Unquote string.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 url_escape
0.000000,0,0.000000,
0.000000,0,0.000000,my $escaped = url_escape $str;
0.000000,0,0.000000,my $escaped = url_escape $str, '^A-Za-z0-9\-._~';
0.000000,0,0.000000,
0.000000,0,0.000000,Percent encode unsafe characters in string as described in L<RFC 3986|https://tools.ietf.org/html/rfc3986>, the pattern
0.000000,0,0.000000,used defaults to C<^A-Za-z0-9\-._~>.
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo%3Bbar"
0.000000,0,0.000000,url_escape 'foo;bar';
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 url_unescape
0.000000,0,0.000000,
0.000000,0,0.000000,my $str = url_unescape $escaped;
0.000000,0,0.000000,
0.000000,0,0.000000,Decode percent encoded characters in string as described in L<RFC 3986|https://tools.ietf.org/html/rfc3986>.
0.000000,0,0.000000,
0.000000,0,0.000000,# "foo;bar"
0.000000,0,0.000000,url_unescape 'foo%3Bbar';
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 xml_escape
0.000000,0,0.000000,
0.000000,0,0.000000,my $escaped = xml_escape $str;
0.000000,0,0.000000,
0.000000,0,0.000000,Escape unsafe characters C<&>, C<E<lt>>, C<E<gt>>, C<"> and C<'> in string, but do not escape L<Mojo::ByteStream>
0.000000,0,0.000000,objects.
0.000000,0,0.000000,
0.000000,0,0.000000,# "&lt;div&gt;"
0.000000,0,0.000000,xml_escape '<div>';
0.000000,0,0.000000,
0.000000,0,0.000000,# "<div>"
0.000000,0,0.000000,use Mojo::ByteStream qw(b);
0.000000,0,0.000000,xml_escape b('<div>');
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 xor_encode
0.000000,0,0.000000,
0.000000,0,0.000000,my $encoded = xor_encode $str, $key;
0.000000,0,0.000000,
0.000000,0,0.000000,XOR encode string with variable length key.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
