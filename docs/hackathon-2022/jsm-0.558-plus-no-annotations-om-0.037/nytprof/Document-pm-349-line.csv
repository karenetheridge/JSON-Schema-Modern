# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000020,2,0.000010,use strict;
0.000031,2,0.000016,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Document;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: One JSON Schema document
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.559';
0.000000,0,0.000000,
0.000030,2,0.000015,use 5.020;
0.000021,2,0.000010,use Moo;
0.000028,3,0.000009,use strictures 2;
0.000030,2,0.000015,use experimental qw(signatures postderef);
0.000020,2,0.000010,use if "$]" >= 5.022, experimental => 're_strict';
0.000017,2,0.000008,no if "$]" >= 5.031009, feature => 'indirect';
0.000019,2,0.000010,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000017,2,0.000008,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000018,2,0.000009,use Mojo::URL;
0.000017,2,0.000008,use Carp 'croak';
0.000029,3,0.000010,use List::Util 1.29 'pairs';
0.000025,3,0.000008,use Ref::Util 0.100 'is_plain_hashref';
0.000021,3,0.000007,use Safe::Isa 1.000008;
0.000018,2,0.000009,use MooX::TypeTiny;
0.000026,2,0.000013,use MooX::HandlesVia;
0.000034,3,0.000011,use Types::Standard 1.016003 qw(InstanceOf HashRef Str Dict ArrayRef Enum ClassName Undef Slurpy);
0.000713,2,0.000356,use namespace::clean;
0.000000,0,0.000000,
0.000001,1,0.000001,extends 'Mojo::JSON::Pointer';
0.000000,0,0.000000,
0.000003,1,0.000003,has schema => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,required => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,has canonical_uri => (
0.000000,0,0.000000,is => 'rwp',
0.000000,0,0.000000,isa => (InstanceOf['Mojo::URL'])->where(q{not defined $_->fragment}),
0.000000,0,0.000000,lazy => 1,
0.000044,8,0.000005,default => sub { Mojo::URL->new },
0.000140,25,0.000006,coerce => sub { $_[0]->$_isa('Mojo::URL') ? $_[0] : Mojo::URL->new($_[0]) },
0.000012,1,0.000012,);
0.000000,0,0.000000,
0.000000,0,0.000000,has metaschema_uri => (
0.000000,0,0.000000,is => 'rwp',
0.000000,0,0.000000,isa => InstanceOf['Mojo::URL'],
0.000118,15,0.000008,coerce => sub { $_[0]->$_isa('Mojo::URL') ? $_[0] : Mojo::URL->new($_[0]) },
0.000006,1,0.000006,);
0.000000,0,0.000000,
0.000004,1,0.000004,has evaluator => (
0.000000,0,0.000000,is => 'rwp',
0.000000,0,0.000000,isa => InstanceOf['JSON::Schema::Modern'],
0.000000,0,0.000000,weak_ref => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# "A JSON Schema resource is a schema which is canonically identified by an absolute URI."
0.000000,0,0.000000,# https://json-schema.org/draft/2020-12/json-schema-core.html#rfc.section.4.3.5
0.000000,0,0.000000,has resource_index => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => HashRef[my $resource_type = Dict[
0.000000,0,0.000000,canonical_uri => InstanceOf['Mojo::URL'],
0.000000,0,0.000000,path => Str,  # always a JSON pointer, relative to the document root
0.000000,0,0.000000,specification_version => Str, # not an Enum due to module load ordering
0.000000,0,0.000000,# the vocabularies used when evaluating instance data against schema
0.000000,0,0.000000,vocabularies => ArrayRef[ClassName->where(q{$_->DOES('JSON::Schema::Modern::Vocabulary')})],
0.000000,0,0.000000,configs => HashRef,
0.000000,0,0.000000,Slurpy[HashRef[Undef]],  # no other fields allowed
0.000000,0,0.000000,]],
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,resource_index => 'elements',
0.000000,0,0.000000,resource_pairs => 'kv',
0.000000,0,0.000000,_add_resources => 'set',
0.000000,0,0.000000,_get_resource => 'get',
0.000000,0,0.000000,_remove_resource => 'delete',
0.000000,0,0.000000,_canonical_resources => 'values',
0.000000,0,0.000000,},
0.000000,0,0.000000,init_arg => undef,
0.000000,0,0.000000,lazy => 1,
0.000032,15,0.000002,default => sub { {} },
0.000061,1,0.000061,);
0.000000,0,0.000000,
0.000000,0,0.000000,has _path_to_resource => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => HashRef[$resource_type],
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,path_to_resource => 'get',
0.000000,0,0.000000,},
0.000000,0,0.000000,init_arg => undef,
0.000000,0,0.000000,lazy => 1,
0.000061,12,0.000005,default => sub { +{ map +($_->{path} => $_), shift->_canonical_resources } },
0.000007,1,0.000007,);
0.000000,0,0.000000,
0.000000,0,0.000000,# for internal use only
0.000005,1,0.000005,has _serialized_schema => (
0.000000,0,0.000000,is => 'rw',
0.000000,0,0.000000,isa => Str,
0.000000,0,0.000000,init_arg => undef,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,has errors => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,handles_via => 'Array',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,errors => 'elements',
0.000000,0,0.000000,has_errors => 'count',
0.000000,0,0.000000,},
0.000000,0,0.000000,writer => '_set_errors',
0.000000,0,0.000000,isa => ArrayRef[InstanceOf['JSON::Schema::Modern::Error']],
0.000000,0,0.000000,lazy => 1,
0.000047,15,0.000003,default => sub { [] },
0.000009,1,0.000009,);
0.000000,0,0.000000,
0.000000,0,0.000000,around _add_resources => sub {
0.000022,22,0.000001,my $orig = shift;
0.000007,22,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000224,22,0.000010,foreach my $pair (pairs @_) {
0.000016,36,0.000000,my ($key, $value) = @$pair;
0.000000,0,0.000000,
0.000229,36,0.000006,$resource_type->($value); # check type of hash value against Dict
0.000000,0,0.000000,
0.000108,36,0.000003,if (my $existing = $self->_get_resource($key)) {
0.000000,0,0.000000,croak 'uri "'.$key.'" conflicts with an existing schema resource'
0.000000,0,0.000000,if $existing->{path} ne $value->{path}
0.000000,0,0.000000,or $existing->{canonical_uri} ne $value->{canonical_uri}
0.000000,0,0.000000,or $existing->{specification_version} ne $value->{specification_version};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# this will never happen, if we parsed $id correctly
0.000000,0,0.000000,croak sprintf('a resource canonical uri cannot contain a plain-name fragment (%s)', $value->{canonical_uri})
0.000138,36,0.000004,if ($value->{canonical_uri}->fragment // '') =~ m{^[^/]};
0.000000,0,0.000000,
0.000072,36,0.000002,$self->$orig($key, $value);
0.000000,0,0.000000,}
0.000004,1,0.000004,};
0.000000,0,0.000000,
0.000000,0,0.000000,# shims for Mojo::JSON::Pointer
0.113864,47414,0.000002,sub data { shift->schema(@_) }
0.000034,15,0.000002,sub FOREIGNBUILDARGS { () }
0.000000,0,0.000000,
0.000000,0,0.000000,# for JSON serializers
0.000000,0,0.000000,sub TO_JSON { shift->schema }
0.000000,0,0.000000,
0.000010,45,0.000000,sub BUILD ($self, $args) {
0.000057,15,0.000004,my $original_uri = $self->canonical_uri->clone;
0.000067,15,0.000004,my $state = $self->traverse($self->evaluator // JSON::Schema::Modern->new);
0.000000,0,0.000000,
0.000000,0,0.000000,# if the schema identified a canonical uri for itself, it overrides the initial value
0.000144,15,0.000010,$self->_set_canonical_uri($state->{initial_schema_uri}) if $state->{initial_schema_uri} ne $original_uri;
0.000000,0,0.000000,
0.000018,15,0.000001,if ($state->{errors}->@*) {
0.000000,0,0.000000,foreach my $error ($state->{errors}->@*) {
0.000000,0,0.000000,$error->mode('traverse') if not defined $error->mode;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_set_errors($state->{errors});
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# make sure the root schema is always indexed against *something*.
0.000000,0,0.000000,$self->_add_resources($original_uri => {
0.000000,0,0.000000,path => '',
0.000000,0,0.000000,canonical_uri => $self->canonical_uri,
0.000000,0,0.000000,specification_version => $state->{spec_version},
0.000000,0,0.000000,vocabularies => $state->{vocabularies},
0.000000,0,0.000000,configs => $state->{configs},
0.000000,0,0.000000,})
0.000215,15,0.000014,if (not "$original_uri" and $original_uri eq $self->canonical_uri)
0.000000,0,0.000000,or "$original_uri";
0.000000,0,0.000000,
0.000240,15,0.000016,$self->_add_resources($state->{identifiers}->@*);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,42,0.000000,sub traverse ($self, $evaluator) {
0.000000,0,0.000000,die 'wrong class - use JSON::Schema::Modern::Document::OpenAPI instead'
0.000042,14,0.000003,if is_plain_hashref($self->schema) and exists $self->schema->{openapi};
0.000000,0,0.000000,
0.000101,14,0.000007,my $state = $evaluator->traverse($self->schema,
0.000000,0,0.000000,{
0.000000,0,0.000000,initial_schema_uri => $self->canonical_uri->clone,
0.000000,0,0.000000,$self->metaschema_uri ? ( metaschema_uri => $self->metaschema_uri) : (),
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000006,14,0.000000,return $state if $state->{errors}->@*;
0.000000,0,0.000000,
0.000000,0,0.000000,# we don't store the metaschema_uri in $state nor in resource_index, but we can figure it out
0.000000,0,0.000000,# easily enough.
0.000000,0,0.000000,my $metaschema_uri = (is_plain_hashref($self->schema) ? $self->schema->{'$schema'} : undef)
0.000083,14,0.000006,// $self->metaschema_uri // $evaluator->METASCHEMA_URIS->{$state->{spec_version}};
0.000000,0,0.000000,
0.000058,14,0.000004,$self->_set_metaschema_uri($metaschema_uri) if $metaschema_uri ne ($self->metaschema_uri//'');
0.000000,0,0.000000,
0.000027,14,0.000002,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub validate ($self) {
0.000000,0,0.000000,my $js = $self->$_call_if_can('evaluator') // JSON::Schema::Modern->new;
0.000000,0,0.000000,
0.000000,0,0.000000,return $js->evaluate($self->schema, $self->metaschema_uri);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000031,1,0.000031,1;
0.000037,1,0.000037,__END__
