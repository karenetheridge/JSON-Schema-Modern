# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Cwd;
0.000022,2,0.000011,use strict;
0.000155,2,0.000077,use Exporter;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '3.84';
0.000001,1,0.000001,my $xs_version = $VERSION;
0.000001,1,0.000001,$VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000014,1,0.000014,our @ISA = qw/ Exporter /;
0.000001,1,0.000001,our @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
0.000001,1,0.000001,push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
0.000001,1,0.000001,our @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
0.000000,0,0.000000,
0.000000,0,0.000000,# sys_cwd may keep the builtin command
0.000000,0,0.000000,
0.000000,0,0.000000,# All the functionality of this module may provided by builtins,
0.000000,0,0.000000,# there is no sense to process the rest of the file.
0.000000,0,0.000000,# The best choice may be to have this in BEGIN, but how to return from BEGIN?
0.000000,0,0.000000,
0.000000,1,0.000000,if ($^O eq 'os2') {
0.000000,0,0.000000,local $^W = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,*cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
0.000000,0,0.000000,*getcwd             = \&cwd;
0.000000,0,0.000000,*fastgetcwd         = \&cwd;
0.000000,0,0.000000,*fastcwd            = \&cwd;
0.000000,0,0.000000,
0.000000,0,0.000000,*fast_abs_path      = \&sys_abspath if defined &sys_abspath;
0.000000,0,0.000000,*abs_path           = \&fast_abs_path;
0.000000,0,0.000000,*realpath           = \&fast_abs_path;
0.000000,0,0.000000,*fast_realpath      = \&fast_abs_path;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Need to look up the feature settings on VMS.  The preferred way is to use the
0.000000,0,0.000000,# VMS::Feature module, but that may not be available to dual life modules.
0.000000,0,0.000000,
0.000000,1,0.000000,my $use_vms_feature;
0.000000,0,0.000000,BEGIN {
0.000003,1,0.000003,if ($^O eq 'VMS') {
0.000000,0,0.000000,if (eval { local $SIG{__DIE__};
0.000000,0,0.000000,local @INC = @INC;
0.000000,0,0.000000,pop @INC if $INC[-1] eq '.';
0.000000,0,0.000000,require VMS::Feature; }) {
0.000000,0,0.000000,$use_vms_feature = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.001927,1,0.001927,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Need to look up the UNIX report mode.  This may become a dynamic mode
0.000000,0,0.000000,# in the future.
0.000000,0,0.000000,sub _vms_unix_rpt {
0.000000,0,0.000000,my $unix_rpt;
0.000000,0,0.000000,if ($use_vms_feature) {
0.000000,0,0.000000,$unix_rpt = VMS::Feature::current("filename_unix_report");
0.000000,0,0.000000,} else {
0.000000,0,0.000000,my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
0.000000,0,0.000000,$unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
0.000000,0,0.000000,}
0.000000,0,0.000000,return $unix_rpt;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Need to look up the EFS character set mode.  This may become a dynamic
0.000000,0,0.000000,# mode in the future.
0.000000,0,0.000000,sub _vms_efs {
0.000000,0,0.000000,my $efs;
0.000000,0,0.000000,if ($use_vms_feature) {
0.000000,0,0.000000,$efs = VMS::Feature::current("efs_charset");
0.000000,0,0.000000,} else {
0.000000,0,0.000000,my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
0.000000,0,0.000000,$efs = $env_efs =~ /^[ET1]/i; 
0.000000,0,0.000000,}
0.000000,0,0.000000,return $efs;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# If loading the XS stuff doesn't work, we can fall back to pure perl
0.000004,1,0.000004,if(! defined &getcwd && defined &DynaLoader::boot_DynaLoader) { # skipped on miniperl
0.000001,1,0.000001,require XSLoader;
0.004155,1,0.004155,XSLoader::load( __PACKAGE__, $xs_version);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Big nasty table of function aliases
0.000010,1,0.000010,my %METHOD_MAP =
0.000000,0,0.000000,(
0.000000,0,0.000000,VMS =>
0.000000,0,0.000000,{
0.000000,0,0.000000,cwd			=> '_vms_cwd',
0.000000,0,0.000000,getcwd		=> '_vms_cwd',
0.000000,0,0.000000,fastcwd		=> '_vms_cwd',
0.000000,0,0.000000,fastgetcwd		=> '_vms_cwd',
0.000000,0,0.000000,abs_path		=> '_vms_abs_path',
0.000000,0,0.000000,fast_abs_path	=> '_vms_abs_path',
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,MSWin32 =>
0.000000,0,0.000000,{
0.000000,0,0.000000,# We assume that &_NT_cwd is defined as an XSUB or in the core.
0.000000,0,0.000000,cwd			=> '_NT_cwd',
0.000000,0,0.000000,getcwd		=> '_NT_cwd',
0.000000,0,0.000000,fastcwd		=> '_NT_cwd',
0.000000,0,0.000000,fastgetcwd		=> '_NT_cwd',
0.000000,0,0.000000,abs_path		=> 'fast_abs_path',
0.000000,0,0.000000,realpath		=> 'fast_abs_path',
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,dos => 
0.000000,0,0.000000,{
0.000000,0,0.000000,cwd			=> '_dos_cwd',
0.000000,0,0.000000,getcwd		=> '_dos_cwd',
0.000000,0,0.000000,fastgetcwd		=> '_dos_cwd',
0.000000,0,0.000000,fastcwd		=> '_dos_cwd',
0.000000,0,0.000000,abs_path		=> 'fast_abs_path',
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,# QNX4.  QNX6 has a $os of 'nto'.
0.000000,0,0.000000,qnx =>
0.000000,0,0.000000,{
0.000000,0,0.000000,cwd			=> '_qnx_cwd',
0.000000,0,0.000000,getcwd		=> '_qnx_cwd',
0.000000,0,0.000000,fastgetcwd		=> '_qnx_cwd',
0.000000,0,0.000000,fastcwd		=> '_qnx_cwd',
0.000000,0,0.000000,abs_path		=> '_qnx_abs_path',
0.000000,0,0.000000,fast_abs_path	=> '_qnx_abs_path',
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,cygwin =>
0.000000,0,0.000000,{
0.000000,0,0.000000,getcwd		=> 'cwd',
0.000000,0,0.000000,fastgetcwd		=> 'cwd',
0.000000,0,0.000000,fastcwd		=> 'cwd',
0.000000,0,0.000000,abs_path		=> 'fast_abs_path',
0.000000,0,0.000000,realpath		=> 'fast_abs_path',
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,amigaos =>
0.000000,0,0.000000,{
0.000000,0,0.000000,getcwd              => '_backtick_pwd',
0.000000,0,0.000000,fastgetcwd          => '_backtick_pwd',
0.000000,0,0.000000,fastcwd             => '_backtick_pwd',
0.000000,0,0.000000,abs_path            => 'fast_abs_path',
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000001,1,0.000001,$METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# Find the pwd command in the expected locations.  We assume these
0.000000,0,0.000000,# are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
0.000000,0,0.000000,# so everything works under taint mode.
0.000001,1,0.000001,my $pwd_cmd;
0.000002,1,0.000002,if($^O ne 'MSWin32') {
0.000001,1,0.000001,foreach my $try ('/bin/pwd',
0.000000,0,0.000000,'/usr/bin/pwd',
0.000000,0,0.000000,'/QOpenSys/bin/pwd', # OS/400 PASE.
0.000000,0,0.000000,) {
0.000052,1,0.000052,if( -x $try ) {
0.000000,1,0.000000,$pwd_cmd = $try;
0.000001,1,0.000001,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Android has a built-in pwd. Using $pwd_cmd will DTRT if
0.000000,0,0.000000,# this perl was compiled with -Dd_useshellcmds, which is the
0.000000,0,0.000000,# default for Android, but the block below is needed for the
0.000000,0,0.000000,# miniperl running on the host when cross-compiling, and
0.000000,0,0.000000,# potentially for native builds with -Ud_useshellcmds.
0.000004,1,0.000004,if ($^O =~ /android/) {
0.000000,0,0.000000,# If targetsh is executable, then we're either a full
0.000000,0,0.000000,# perl, or a miniperl for a native build.
0.000000,0,0.000000,if ( exists($Config::Config{targetsh}) && -x $Config::Config{targetsh}) {
0.000000,0,0.000000,$pwd_cmd = "$Config::Config{targetsh} -c pwd"
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $sh = $Config::Config{sh} || (-x '/system/bin/sh' ? '/system/bin/sh' : 'sh');
0.000000,0,0.000000,$pwd_cmd = "$sh -c pwd"
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my $found_pwd_cmd = defined($pwd_cmd);
0.000000,0,0.000000,
0.000000,0,0.000000,# Lazy-load Carp
0.000000,0,0.000000,sub _carp  { require Carp; Carp::carp(@_)  }
0.000000,0,0.000000,sub _croak { require Carp; Carp::croak(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,# The 'natural and safe form' for UNIX (pwd may be setuid root)
0.000000,0,0.000000,sub _backtick_pwd {
0.000000,0,0.000000,
0.000000,0,0.000000,# Localize %ENV entries in a way that won't create new hash keys.
0.000000,0,0.000000,# Under AmigaOS we don't want to localize as it stops perl from
0.000000,0,0.000000,# finding 'sh' in the PATH.
0.000000,0,0.000000,my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV) if $^O ne "amigaos";
0.000000,0,0.000000,local @ENV{@localize} if @localize;
0.000000,0,0.000000,
0.000000,0,0.000000,my $cwd = `$pwd_cmd`;
0.000000,0,0.000000,# Belt-and-suspenders in case someone said "undef $/".
0.000000,0,0.000000,local $/ = "\n";
0.000000,0,0.000000,# `pwd` may fail e.g. if the disk is full
0.000000,0,0.000000,chomp($cwd) if defined $cwd;
0.000000,0,0.000000,$cwd;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Since some ports may predefine cwd internally (e.g., NT)
0.000000,0,0.000000,# we take care not to override an existing definition for cwd().
0.000000,0,0.000000,
0.000002,1,0.000002,unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
0.000000,0,0.000000,if( $found_pwd_cmd )
0.000000,0,0.000000,{
0.000000,0,0.000000,*cwd = \&_backtick_pwd;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# getcwd() might have an empty prototype
0.000000,0,0.000000,*cwd = sub { getcwd(); };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,if ($^O eq 'cygwin') {
0.000000,0,0.000000,# We need to make sure cwd() is called with no args, because it's
0.000000,0,0.000000,# got an arg-less prototype and will die if args are present.
0.000000,0,0.000000,local $^W = 0;
0.000000,0,0.000000,my $orig_cwd = \&cwd;
0.000000,0,0.000000,*cwd = sub { &$orig_cwd() }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# set a reasonable (and very safe) default for fastgetcwd, in case it
0.000000,0,0.000000,# isn't redefined later (20001212 rspier)
0.000001,1,0.000001,*fastgetcwd = \&cwd;
0.000000,0,0.000000,
0.000000,0,0.000000,# A non-XS version of getcwd() - also used to bootstrap the perl build
0.000000,0,0.000000,# process, when miniperl is running and no XS loading happens.
0.000000,0,0.000000,sub _perl_getcwd
0.000000,0,0.000000,{
0.000000,0,0.000000,abs_path('.');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# By John Bazik
0.000000,0,0.000000,#
0.000000,0,0.000000,# Usage: $cwd = &fastcwd;
0.000000,0,0.000000,#
0.000000,0,0.000000,# This is a faster version of getcwd.  It's also more dangerous because
0.000000,0,0.000000,# you might chdir out of a directory that you can't chdir back into.
0.000000,0,0.000000,
0.000000,0,0.000000,sub fastcwd_ {
0.000000,0,0.000000,my($odev, $oino, $cdev, $cino, $tdev, $tino);
0.000000,0,0.000000,my(@path, $path);
0.000000,0,0.000000,local(*DIR);
0.000000,0,0.000000,
0.000000,0,0.000000,my($orig_cdev, $orig_cino) = stat('.');
0.000000,0,0.000000,($cdev, $cino) = ($orig_cdev, $orig_cino);
0.000000,0,0.000000,for (;;) {
0.000000,0,0.000000,my $direntry;
0.000000,0,0.000000,($odev, $oino) = ($cdev, $cino);
0.000000,0,0.000000,CORE::chdir('..') || return undef;
0.000000,0,0.000000,($cdev, $cino) = stat('.');
0.000000,0,0.000000,last if $odev == $cdev && $oino eq $cino;
0.000000,0,0.000000,opendir(DIR, '.') || return undef;
0.000000,0,0.000000,for (;;) {
0.000000,0,0.000000,$direntry = readdir(DIR);
0.000000,0,0.000000,last unless defined $direntry;
0.000000,0,0.000000,next if $direntry eq '.';
0.000000,0,0.000000,next if $direntry eq '..';
0.000000,0,0.000000,
0.000000,0,0.000000,($tdev, $tino) = lstat($direntry);
0.000000,0,0.000000,last unless $tdev != $odev || $tino ne $oino;
0.000000,0,0.000000,}
0.000000,0,0.000000,closedir(DIR);
0.000000,0,0.000000,return undef unless defined $direntry; # should never happen
0.000000,0,0.000000,unshift(@path, $direntry);
0.000000,0,0.000000,}
0.000000,0,0.000000,$path = '/' . join('/', @path);
0.000000,0,0.000000,if ($^O eq 'apollo') { $path = "/".$path; }
0.000000,0,0.000000,# At this point $path may be tainted (if tainting) and chdir would fail.
0.000000,0,0.000000,# Untaint it then check that we landed where we started.
0.000000,0,0.000000,$path =~ /^(.*)\z/s		# untaint
0.000000,0,0.000000,&& CORE::chdir($1) or return undef;
0.000000,0,0.000000,($cdev, $cino) = stat('.');
0.000000,0,0.000000,die "Unstable directory path, current directory changed unexpectedly"
0.000000,0,0.000000,if $cdev != $orig_cdev || $cino ne $orig_cino;
0.000000,0,0.000000,$path;
0.000000,0,0.000000,}
0.000000,1,0.000000,if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# Keeps track of current working directory in PWD environment var
0.000000,0,0.000000,# Usage:
0.000000,0,0.000000,#	use Cwd 'chdir';
0.000000,0,0.000000,#	chdir $newdir;
0.000000,0,0.000000,
0.000000,1,0.000000,my $chdir_init = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,sub chdir_init {
0.000000,0,0.000000,if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
0.000000,0,0.000000,my($dd,$di) = stat('.');
0.000000,0,0.000000,my($pd,$pi) = stat($ENV{'PWD'});
0.000000,0,0.000000,if (!defined $dd or !defined $pd or $di ne $pi or $dd != $pd) {
0.000000,0,0.000000,$ENV{'PWD'} = cwd();
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $wd = cwd();
0.000000,0,0.000000,$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
0.000000,0,0.000000,$ENV{'PWD'} = $wd;
0.000000,0,0.000000,}
0.000000,0,0.000000,# Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
0.000000,0,0.000000,if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
0.000000,0,0.000000,my($pd,$pi) = stat($2);
0.000000,0,0.000000,my($dd,$di) = stat($1);
0.000000,0,0.000000,if (defined $pd and defined $dd and $di ne $pi and $dd == $pd) {
0.000000,0,0.000000,$ENV{'PWD'}="$2$3";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$chdir_init = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub chdir {
0.000000,0,0.000000,my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
0.000000,0,0.000000,if ($^O eq "cygwin") {
0.000000,0,0.000000,$newdir =~ s|\A///+|//|;
0.000000,0,0.000000,$newdir =~ s|(?<=[^/])//+|/|g;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($^O ne 'MSWin32') {
0.000000,0,0.000000,$newdir =~ s|///*|/|g;
0.000000,0,0.000000,}
0.000000,0,0.000000,chdir_init() unless $chdir_init;
0.000000,0,0.000000,my $newpwd;
0.000000,0,0.000000,if ($^O eq 'MSWin32') {
0.000000,0,0.000000,# get the full path name *before* the chdir()
0.000000,0,0.000000,$newpwd = Win32::GetFullPathName($newdir);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 0 unless CORE::chdir $newdir;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($^O eq 'VMS') {
0.000000,0,0.000000,return $ENV{'PWD'} = $ENV{'DEFAULT'}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($^O eq 'MSWin32') {
0.000000,0,0.000000,$ENV{'PWD'} = $newpwd;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
0.000000,0,0.000000,$ENV{'PWD'} = cwd();
0.000000,0,0.000000,} elsif ($newdir =~ m#^/#s) {
0.000000,0,0.000000,$ENV{'PWD'} = $newdir;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,my @curdir = split(m#/#,$ENV{'PWD'});
0.000000,0,0.000000,@curdir = ('') unless @curdir;
0.000000,0,0.000000,my $component;
0.000000,0,0.000000,foreach $component (split(m#/#, $newdir)) {
0.000000,0,0.000000,next if $component eq '.';
0.000000,0,0.000000,pop(@curdir),next if $component eq '..';
0.000000,0,0.000000,push(@curdir,$component);
0.000000,0,0.000000,}
0.000000,0,0.000000,$ENV{'PWD'} = join('/',@curdir) || '/';
0.000000,0,0.000000,}
0.000000,0,0.000000,1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _perl_abs_path
0.000000,0,0.000000,{
0.000000,0,0.000000,my $start = @_ ? shift : '.';
0.000000,0,0.000000,my($dotdots, $cwd, @pst, @cst, $dir, @tst);
0.000000,0,0.000000,
0.000000,0,0.000000,unless (@cst = stat( $start ))
0.000000,0,0.000000,{
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless (-d _) {
0.000000,0,0.000000,# Make sure we can be invoked on plain files, not just directories.
0.000000,0,0.000000,# NOTE that this routine assumes that '/' is the only directory separator.
0.000000,0,0.000000,
0.000000,0,0.000000,my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
0.000000,0,0.000000,or return cwd() . '/' . $start;
0.000000,0,0.000000,
0.000000,0,0.000000,# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
0.000000,0,0.000000,if (-l $start) {
0.000000,0,0.000000,my $link_target = readlink($start);
0.000000,0,0.000000,die "Can't resolve link $start: $!" unless defined $link_target;
0.000000,0,0.000000,
0.000000,0,0.000000,require File::Spec;
0.000000,0,0.000000,$link_target = $dir . '/' . $link_target
0.000000,0,0.000000,unless File::Spec->file_name_is_absolute($link_target);
0.000000,0,0.000000,
0.000000,0,0.000000,return abs_path($link_target);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $dir ? abs_path($dir) . "/$file" : "/$file";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$cwd = '';
0.000000,0,0.000000,$dotdots = $start;
0.000000,0,0.000000,do
0.000000,0,0.000000,{
0.000000,0,0.000000,$dotdots .= '/..';
0.000000,0,0.000000,@pst = @cst;
0.000000,0,0.000000,local *PARENT;
0.000000,0,0.000000,unless (opendir(PARENT, $dotdots))
0.000000,0,0.000000,{
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,unless (@cst = stat($dotdots))
0.000000,0,0.000000,{
0.000000,0,0.000000,my $e = $!;
0.000000,0,0.000000,closedir(PARENT);
0.000000,0,0.000000,$! = $e;
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($pst[0] == $cst[0] && $pst[1] eq $cst[1])
0.000000,0,0.000000,{
0.000000,0,0.000000,$dir = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,do
0.000000,0,0.000000,{
0.000000,0,0.000000,unless (defined ($dir = readdir(PARENT)))
0.000000,0,0.000000,{
0.000000,0,0.000000,closedir(PARENT);
0.000000,0,0.000000,require Errno;
0.000000,0,0.000000,$! = Errno::ENOENT();
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
0.000000,0,0.000000,}
0.000000,0,0.000000,while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
0.000000,0,0.000000,$tst[1] ne $pst[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
0.000000,0,0.000000,closedir(PARENT);
0.000000,0,0.000000,} while (defined $dir);
0.000000,0,0.000000,chop($cwd) unless $cwd eq '/'; # drop the trailing /
0.000000,0,0.000000,$cwd;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,1,0.000000,my $Curdir;
0.000000,0,0.000000,sub fast_abs_path {
0.000000,0,0.000000,local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
0.000000,0,0.000000,my $cwd = getcwd();
0.000000,0,0.000000,defined $cwd or return undef;
0.000000,0,0.000000,require File::Spec;
0.000000,0,0.000000,my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
0.000000,0,0.000000,
0.000000,0,0.000000,# Detaint else we'll explode in taint mode.  This is safe because
0.000000,0,0.000000,# we're not doing anything dangerous with it.
0.000000,0,0.000000,($path) = $path =~ /(.*)/s;
0.000000,0,0.000000,($cwd)  = $cwd  =~ /(.*)/s;
0.000000,0,0.000000,
0.000000,0,0.000000,unless (-e $path) {
0.000000,0,0.000000,require Errno;
0.000000,0,0.000000,$! = Errno::ENOENT();
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless (-d _) {
0.000000,0,0.000000,# Make sure we can be invoked on plain files, not just directories.
0.000000,0,0.000000,
0.000000,0,0.000000,my ($vol, $dir, $file) = File::Spec->splitpath($path);
0.000000,0,0.000000,return File::Spec->catfile($cwd, $path) unless length $dir;
0.000000,0,0.000000,
0.000000,0,0.000000,if (-l $path) {
0.000000,0,0.000000,my $link_target = readlink($path);
0.000000,0,0.000000,defined $link_target or return undef;
0.000000,0,0.000000,
0.000000,0,0.000000,$link_target = File::Spec->catpath($vol, $dir, $link_target)
0.000000,0,0.000000,unless File::Spec->file_name_is_absolute($link_target);
0.000000,0,0.000000,
0.000000,0,0.000000,return fast_abs_path($link_target);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $dir eq File::Spec->rootdir
0.000000,0,0.000000,? File::Spec->catpath($vol, $dir, $file)
0.000000,0,0.000000,: fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (!CORE::chdir($path)) {
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $realpath = getcwd();
0.000000,0,0.000000,if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
0.000000,0,0.000000,_croak("Cannot chdir back to $cwd: $!");
0.000000,0,0.000000,}
0.000000,0,0.000000,$realpath;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# added function alias to follow principle of least surprise
0.000000,0,0.000000,# based on previous aliasing.  --tchrist 27-Jan-00
0.000001,1,0.000001,*fast_realpath = \&fast_abs_path;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# --- PORTING SECTION ---
0.000000,0,0.000000,
0.000000,0,0.000000,# VMS: $ENV{'DEFAULT'} points to default directory at all times
0.000000,0,0.000000,# 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
0.000000,0,0.000000,# Note: Use of Cwd::chdir() causes the logical name PWD to be defined
0.000000,0,0.000000,#   in the process logical name table as the default device and directory
0.000000,0,0.000000,#   seen by Perl. This may not be the same as the default device
0.000000,0,0.000000,#   and directory seen by DCL after Perl exits, since the effects
0.000000,0,0.000000,#   the CRTL chdir() function persist only until Perl exits.
0.000000,0,0.000000,
0.000000,0,0.000000,sub _vms_cwd {
0.000000,0,0.000000,return $ENV{'DEFAULT'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _vms_abs_path {
0.000000,0,0.000000,return $ENV{'DEFAULT'} unless @_;
0.000000,0,0.000000,my $path = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $efs = _vms_efs;
0.000000,0,0.000000,my $unix_rpt = _vms_unix_rpt;
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined &VMS::Filespec::vmsrealpath) {
0.000000,0,0.000000,my $path_unix = 0;
0.000000,0,0.000000,my $path_vms = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,$path_unix = 1 if ($path =~ m#(?<=\^)/#);
0.000000,0,0.000000,$path_unix = 1 if ($path =~ /^\.\.?$/);
0.000000,0,0.000000,$path_vms = 1 if ($path =~ m#[\[<\]]#);
0.000000,0,0.000000,$path_vms = 1 if ($path =~ /^--?$/);
0.000000,0,0.000000,
0.000000,0,0.000000,my $unix_mode = $path_unix;
0.000000,0,0.000000,if ($efs) {
0.000000,0,0.000000,# In case of a tie, the Unix report mode decides.
0.000000,0,0.000000,if ($path_vms == $path_unix) {
0.000000,0,0.000000,$unix_mode = $unix_rpt;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$unix_mode = 0 if $path_vms;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($unix_mode) {
0.000000,0,0.000000,# Unix format
0.000000,0,0.000000,return VMS::Filespec::unixrealpath($path);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# VMS format
0.000000,0,0.000000,
0.000000,0,0.000000,my $new_path = VMS::Filespec::vmsrealpath($path);
0.000000,0,0.000000,
0.000000,0,0.000000,# Perl expects directories to be in directory format
0.000000,0,0.000000,$new_path = VMS::Filespec::pathify($new_path) if -d $path;
0.000000,0,0.000000,return $new_path;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Fallback to older algorithm if correct ones are not
0.000000,0,0.000000,# available.
0.000000,0,0.000000,
0.000000,0,0.000000,if (-l $path) {
0.000000,0,0.000000,my $link_target = readlink($path);
0.000000,0,0.000000,die "Can't resolve link $path: $!" unless defined $link_target;
0.000000,0,0.000000,
0.000000,0,0.000000,return _vms_abs_path($link_target);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# may need to turn foo.dir into [.foo]
0.000000,0,0.000000,my $pathified = VMS::Filespec::pathify($path);
0.000000,0,0.000000,$path = $pathified if defined $pathified;
0.000000,0,0.000000,
0.000000,0,0.000000,return VMS::Filespec::rmsexpand($path);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _os2_cwd {
0.000000,0,0.000000,my $pwd = `cmd /c cd`;
0.000000,0,0.000000,chomp $pwd;
0.000000,0,0.000000,$pwd =~ s:\\:/:g ;
0.000000,0,0.000000,$ENV{'PWD'} = $pwd;
0.000000,0,0.000000,return $pwd;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _win32_cwd_simple {
0.000000,0,0.000000,my $pwd = `cd`;
0.000000,0,0.000000,chomp $pwd;
0.000000,0,0.000000,$pwd =~ s:\\:/:g ;
0.000000,0,0.000000,$ENV{'PWD'} = $pwd;
0.000000,0,0.000000,return $pwd;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _win32_cwd {
0.000000,0,0.000000,my $pwd;
0.000000,0,0.000000,$pwd = Win32::GetCwd();
0.000000,0,0.000000,$pwd =~ s:\\:/:g ;
0.000000,0,0.000000,$ENV{'PWD'} = $pwd;
0.000000,0,0.000000,return $pwd;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,*_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _dos_cwd {
0.000000,0,0.000000,my $pwd;
0.000000,0,0.000000,if (!defined &Dos::GetCwd) {
0.000000,0,0.000000,chomp($pwd = `command /c cd`);
0.000000,0,0.000000,$pwd =~ s:\\:/:g ;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$pwd = Dos::GetCwd();
0.000000,0,0.000000,}
0.000000,0,0.000000,$ENV{'PWD'} = $pwd;
0.000000,0,0.000000,return $pwd;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _qnx_cwd {
0.000000,0,0.000000,local $ENV{PATH} = '';
0.000000,0,0.000000,local $ENV{CDPATH} = '';
0.000000,0,0.000000,local $ENV{ENV} = '';
0.000000,0,0.000000,my $pwd = `/usr/bin/fullpath -t`;
0.000000,0,0.000000,chomp $pwd;
0.000000,0,0.000000,$ENV{'PWD'} = $pwd;
0.000000,0,0.000000,return $pwd;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _qnx_abs_path {
0.000000,0,0.000000,local $ENV{PATH} = '';
0.000000,0,0.000000,local $ENV{CDPATH} = '';
0.000000,0,0.000000,local $ENV{ENV} = '';
0.000000,0,0.000000,my $path = @_ ? shift : '.';
0.000000,0,0.000000,local *REALPATH;
0.000000,0,0.000000,
0.000000,0,0.000000,defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
0.000000,0,0.000000,die "Can't open /usr/bin/fullpath: $!";
0.000000,0,0.000000,my $realpath = <REALPATH>;
0.000000,0,0.000000,close REALPATH;
0.000000,0,0.000000,chomp $realpath;
0.000000,0,0.000000,return $realpath;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Now that all the base-level functions are set up, alias the
0.000000,0,0.000000,# user-level functions to the right places
0.000000,0,0.000000,
0.000001,1,0.000001,if (exists $METHOD_MAP{$^O}) {
0.000000,1,0.000000,my $map = $METHOD_MAP{$^O};
0.000002,1,0.000002,foreach my $name (keys %$map) {
0.000000,0,0.000000,local $^W = 0;  # assignments trigger 'subroutine redefined' warning
0.000152,2,0.000076,no strict 'refs';
0.000000,0,0.000000,*{$name} = \&{$map->{$name}};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# built-in from 5.30
0.000001,1,0.000001,*getcwd = \&Internals::getcwd
0.000000,0,0.000000,if !defined &getcwd && defined &Internals::getcwd;
0.000000,0,0.000000,
0.000000,0,0.000000,# In case the XS version doesn't load.
0.000000,1,0.000000,*abs_path = \&_perl_abs_path unless defined &abs_path;
0.000001,1,0.000001,*getcwd = \&_perl_getcwd unless defined &getcwd;
0.000000,0,0.000000,
0.000000,0,0.000000,# added function alias for those of us more
0.000000,0,0.000000,# used to the libc function.  --tchrist 27-Jan-00
0.000000,1,0.000000,*realpath = \&abs_path;
0.000000,0,0.000000,
0.000047,1,0.000047,1;
0.000000,0,0.000000,__END__
