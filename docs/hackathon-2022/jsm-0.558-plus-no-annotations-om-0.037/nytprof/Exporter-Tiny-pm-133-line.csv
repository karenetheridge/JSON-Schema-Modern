# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Exporter::Tiny;
0.000000,0,0.000000,
0.000040,2,0.000020,use 5.006001;
0.000019,2,0.000010,use strict;
0.000120,4,0.000030,use warnings; no warnings qw(void once uninitialized numeric redefine);
0.000000,0,0.000000,
0.000001,1,0.000001,our $AUTHORITY = 'cpan:TOBYINK';
0.000000,1,0.000000,our $VERSION   = '1.006000';
0.000001,1,0.000001,our @EXPORT_OK = qw< mkopt mkopt_hash _croak _carp >;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,*_HAS_NATIVE_LEXICAL_SUB = ( $] ge '5.037002' )
0.000000,0,0.000000,? sub () { !!1 }
0.000001,1,0.000001,: sub () { !!0 };
0.000000,0,0.000000,*_HAS_MODULE_LEXICAL_SUB = ( $] ge '5.011002' and eval('require Lexical::Sub') )
0.000000,0,0.000000,? sub () { !!1 }
0.000125,1,0.000125,: sub () { !!0 };
0.000304,1,0.000304,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::croak }
0.000000,0,0.000000,sub _carp  ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::carp }
0.000000,0,0.000000,
0.000000,0,0.000000,my $_process_optlist = sub
0.000000,0,0.000000,{
0.000006,13,0.000000,my $class = shift;
0.000008,13,0.000001,my ($global_opts, $opts, $want, $not_want) = @_;
0.000000,0,0.000000,
0.000027,13,0.000002,while (@$opts)
0.000000,0,0.000000,{
0.000007,47,0.000000,my $opt = shift @{$opts};
0.000017,47,0.000000,my ($name, $value) = @$opt;
0.000000,0,0.000000,
0.000000,0,0.000000,($name =~ m{\A\!(/.+/[msixpodual]*)\z}) ?
0.000000,0,0.000000,do {
0.000000,0,0.000000,my @not = $class->_exporter_expand_regexp("$1", $value, $global_opts);
0.000000,0,0.000000,++$not_want->{$_->[0]} for @not;
0.000000,0,0.000000,} :
0.000000,0,0.000000,($name =~ m{\A\![:-](.+)\z}) ?
0.000000,0,0.000000,do {
0.000000,0,0.000000,my @not = $class->_exporter_expand_tag("$1", $value, $global_opts);
0.000000,0,0.000000,++$not_want->{$_->[0]} for @not;
0.000000,0,0.000000,} :
0.000000,0,0.000000,($name =~ m{\A\!(.+)\z}) ?
0.000297,47,0.000006,(++$not_want->{$1}) :
0.000000,0,0.000000,($name =~ m{\A[:-](.+)\z}) ?
0.000000,0,0.000000,push(@$opts, $class->_exporter_expand_tag("$1", $value, $global_opts)) :
0.000000,0,0.000000,($name =~ m{\A/.+/[msixpodual]*\z}) ?
0.000000,0,0.000000,push(@$opts, $class->_exporter_expand_regexp($name, $value, $global_opts)) :
0.000000,0,0.000000,# else ?
0.000000,0,0.000000,push(@$want, $opt);
0.000000,0,0.000000,}
0.000003,1,0.000003,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub import
0.000000,0,0.000000,{
0.000004,13,0.000000,my $class = shift;
0.000016,13,0.000001,my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
0.000000,0,0.000000,
0.000007,13,0.000001,if ( defined $global_opts->{into} and $global_opts->{into} eq '-lexical' ) {
0.000000,0,0.000000,$global_opts->{lexical} = 1;
0.000000,0,0.000000,delete $global_opts->{into};
0.000000,0,0.000000,}
0.000015,13,0.000001,if ( not defined $global_opts->{into} ) {
0.000000,0,0.000000,$global_opts->{into} = caller;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,13,0.000000,my @want;
0.000008,13,0.000001,my %not_want; $global_opts->{not} = \%not_want;
0.000326,28,0.000012,my @args = do { no strict qw(refs); @_ ? @_ : @{"$class\::EXPORT"} };
0.000027,13,0.000002,my $opts = mkopt(\@args);
0.000026,13,0.000002,$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
0.000000,0,0.000000,
0.000000,0,0.000000,$global_opts->{installer} ||= $class->_exporter_lexical_installer( $global_opts )
0.000008,13,0.000001,if $global_opts->{lexical};
0.000000,0,0.000000,
0.000030,13,0.000002,my $permitted = $class->_exporter_permitted_regexp($global_opts);
0.000030,13,0.000002,$class->_exporter_validate_opts($global_opts);
0.000000,0,0.000000,
0.000126,13,0.000010,for my $wanted (@want) {
0.000014,46,0.000000,next if $not_want{$wanted->[0]};
0.000000,0,0.000000,
0.000065,46,0.000001,my %symbols = $class->_exporter_expand_sub(@$wanted, $global_opts, $permitted);
0.000000,0,0.000000,$class->_exporter_install_sub($_, $wanted->[1], $global_opts, $symbols{$_})
0.000073,46,0.000002,for keys %symbols;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unimport
0.000000,0,0.000000,{
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
0.000000,0,0.000000,$global_opts->{is_unimport} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( defined $global_opts->{into} and $global_opts->{into} eq '-lexical' ) {
0.000000,0,0.000000,$global_opts->{lexical} = 1;
0.000000,0,0.000000,delete $global_opts->{into};
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( not defined $global_opts->{into} ) {
0.000000,0,0.000000,$global_opts->{into} = caller;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @want;
0.000000,0,0.000000,my %not_want; $global_opts->{not} = \%not_want;
0.000000,0,0.000000,my @args = do { our %TRACKED; @_ ? @_ : keys(%{$TRACKED{$class}{$global_opts->{into}}}) };
0.000000,0,0.000000,my $opts = mkopt(\@args);
0.000000,0,0.000000,$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
0.000000,0,0.000000,
0.000000,0,0.000000,my $permitted = $class->_exporter_permitted_regexp($global_opts);
0.000000,0,0.000000,$class->_exporter_validate_unimport_opts($global_opts);
0.000000,0,0.000000,
0.000000,0,0.000000,my $expando = $class->can('_exporter_expand_sub');
0.000000,0,0.000000,$expando = undef if $expando == \&_exporter_expand_sub;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $wanted (@want)
0.000000,0,0.000000,{
0.000000,0,0.000000,next if $not_want{$wanted->[0]};
0.000000,0,0.000000,
0.000000,0,0.000000,if ($wanted->[1])
0.000000,0,0.000000,{
0.000000,0,0.000000,_carp("Passing options to unimport '%s' makes no sense", $wanted->[0])
0.000000,0,0.000000,unless (ref($wanted->[1]) eq 'HASH' and not keys %{$wanted->[1]});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %symbols = defined($expando)
0.000000,0,0.000000,? $class->$expando(@$wanted, $global_opts, $permitted)
0.000000,0,0.000000,: ($wanted->[0] => sub { "dummy" });
0.000000,0,0.000000,$class->_exporter_uninstall_sub($_, $wanted->[1], $global_opts)
0.000000,0,0.000000,for keys %symbols;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Returns a coderef suitable to be used as a sub installer for lexical imports.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub _exporter_lexical_installer {
0.000000,0,0.000000,_HAS_NATIVE_LEXICAL_SUB and return sub {
0.000000,0,0.000000,my ( $sigilname, $sym ) = @{ $_[1] };
0.000219,2,0.000109,no warnings ( $] ge '5.037002' ? 'experimental::builtin' : () );
0.000000,0,0.000000,builtin::export_lexically( $sigilname, $sym );
0.000000,0,0.000000,};
0.000000,0,0.000000,_HAS_MODULE_LEXICAL_SUB and return sub {
0.000000,0,0.000000,my ( $sigilname, $sym ) = @{ $_[1] };
0.000000,0,0.000000,( $sigilname =~ /^\w/ )
0.000000,0,0.000000,? 'Lexical::Sub'->import( $sigilname, $sym )
0.000000,0,0.000000,: 'Lexical::Var'->import( $sigilname, $sym );
0.000000,0,0.000000,};
0.000000,0,0.000000,_croak( 'Lexical export requires Perl 5.37.2+ for native support, or Perl 5.11.2+ with the Lexical::Sub module' );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Called once per import/unimport, passed the "global" import options.
0.000000,0,0.000000,# Expected to validate the options and carp or croak if there are problems.
0.000000,0,0.000000,# Can also take the opportunity to do other stuff if needed.
0.000000,0,0.000000,#
0.000023,13,0.000002,sub _exporter_validate_opts          { 1 }
0.000000,0,0.000000,sub _exporter_validate_unimport_opts { 1 }
0.000000,0,0.000000,
0.000000,0,0.000000,# Called after expanding a tag or regexp to merge the tag's options with
0.000000,0,0.000000,# any sub-specific options.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub _exporter_merge_opts
0.000000,0,0.000000,{
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my ($tag_opts, $global_opts, @stuff) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$tag_opts = {} unless ref($tag_opts) eq q(HASH);
0.000000,0,0.000000,_croak('Cannot provide an -as option for tags')
0.000000,0,0.000000,if exists $tag_opts->{-as} && ref $tag_opts->{-as} ne 'CODE';
0.000000,0,0.000000,
0.000000,0,0.000000,my $optlist = mkopt(\@stuff);
0.000000,0,0.000000,for my $export (@$optlist)
0.000000,0,0.000000,{
0.000000,0,0.000000,next if defined($export->[1]) && ref($export->[1]) ne q(HASH);
0.000000,0,0.000000,
0.000000,0,0.000000,my %sub_opts = ( %{ $export->[1] or {} }, %$tag_opts );
0.000000,0,0.000000,$sub_opts{-prefix} = sprintf('%s%s', $tag_opts->{-prefix}, $export->[1]{-prefix})
0.000000,0,0.000000,if exists($export->[1]{-prefix}) && exists($tag_opts->{-prefix});
0.000000,0,0.000000,$sub_opts{-suffix} = sprintf('%s%s', $export->[1]{-suffix}, $tag_opts->{-suffix})
0.000000,0,0.000000,if exists($export->[1]{-suffix}) && exists($tag_opts->{-suffix});
0.000000,0,0.000000,$export->[1] = \%sub_opts;
0.000000,0,0.000000,}
0.000000,0,0.000000,return @$optlist;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Given a tag name, looks it up in %EXPORT_TAGS and returns the list of
0.000000,0,0.000000,# associated functions. The default implementation magically handles tags
0.000000,0,0.000000,# "all" and "default". The default implementation interprets any undefined
0.000000,0,0.000000,# tags as being global options.
0.000000,0,0.000000,# 
0.000000,0,0.000000,sub _exporter_expand_tag
0.000000,0,0.000000,{
0.000096,2,0.000048,no strict qw(refs);
0.000000,0,0.000000,
0.000000,1,0.000000,my $class = shift;
0.000001,1,0.000001,my ($name, $value, $globals) = @_;
0.000002,1,0.000002,my $tags  = \%{"$class\::EXPORT_TAGS"};
0.000000,0,0.000000,
0.000000,0,0.000000,return $class->_exporter_merge_opts($value, $globals, $tags->{$name}->($class, @_))
0.000000,1,0.000000,if ref($tags->{$name}) eq q(CODE);
0.000000,0,0.000000,
0.000000,0,0.000000,return $class->_exporter_merge_opts($value, $globals, @{$tags->{$name}})
0.000001,1,0.000001,if exists $tags->{$name};
0.000000,0,0.000000,
0.000000,1,0.000000,return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"})
0.000000,0,0.000000,if $name eq 'all';
0.000000,0,0.000000,
0.000000,1,0.000000,return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"})
0.000000,0,0.000000,if $name eq 'default';
0.000000,0,0.000000,
0.000001,1,0.000001,$globals->{$name} = $value || 1;
0.000003,1,0.000003,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Given a regexp-like string, looks it up in @EXPORT_OK and returns the
0.000000,0,0.000000,# list of matching functions.
0.000000,0,0.000000,# 
0.000000,0,0.000000,sub _exporter_expand_regexp
0.000000,0,0.000000,{
0.000071,2,0.000035,no strict qw(refs);
0.000000,0,0.000000,our %TRACKED;
0.000000,0,0.000000,
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my ($name, $value, $globals) = @_;
0.000000,0,0.000000,my $compiled = eval("qr$name");
0.000000,0,0.000000,
0.000000,0,0.000000,my @possible = $globals->{is_unimport}
0.000000,0,0.000000,? keys( %{$TRACKED{$class}{$globals->{into}}} )
0.000000,0,0.000000,: @{"$class\::EXPORT_OK"};
0.000000,0,0.000000,
0.000000,0,0.000000,$class->_exporter_merge_opts($value, $globals, grep /$compiled/, @possible);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Helper for _exporter_expand_sub. Returns a regexp matching all subs in
0.000000,0,0.000000,# the exporter package which are available for export.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub _exporter_permitted_regexp
0.000000,0,0.000000,{
0.000084,2,0.000042,no strict qw(refs);
0.000001,13,0.000000,my $class = shift;
0.000000,0,0.000000,my $re = join "|", map quotemeta, sort {
0.000000,0,0.000000,length($b) <=> length($a) or $a cmp $b
0.001035,13,0.000080,} @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"};
0.001445,13,0.000111,qr{^(?:$re)$}ms;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Given a sub name, returns a hash of subs to install (usually just one sub).
0.000000,0,0.000000,# Keys are sub names, values are coderefs.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub _exporter_expand_sub
0.000000,0,0.000000,{
0.000004,46,0.000000,my $class = shift;
0.000012,46,0.000000,my ($name, $value, $globals, $permitted) = @_;
0.000005,46,0.000000,$permitted ||= $class->_exporter_permitted_regexp($globals);
0.000000,0,0.000000,
0.000624,2,0.000312,no strict qw(refs);
0.000000,0,0.000000,
0.000006,46,0.000000,my $sigil = "&";
0.000054,46,0.000001,if ($name =~ /\A([&\$\%\@\*])(.+)\z/) {
0.000000,0,0.000000,$sigil = $1;
0.000000,0,0.000000,$name  = $2;
0.000000,0,0.000000,if ($sigil eq '*') {
0.000000,0,0.000000,_croak("Cannot export symbols with a * sigil");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000013,46,0.000000,my $sigilname = $sigil eq '&' ? $name : "$sigil$name";
0.000000,0,0.000000,
0.000190,46,0.000004,if ($sigilname =~ $permitted)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $generatorprefix = {
0.000000,0,0.000000,'&' => "_generate_",
0.000000,0,0.000000,'$' => "_generateScalar_",
0.000000,0,0.000000,'@' => "_generateArray_",
0.000000,0,0.000000,'%' => "_generateHash_",
0.000071,46,0.000002,}->{$sigil};
0.000000,0,0.000000,
0.000184,46,0.000004,my $generator = $class->can("$generatorprefix$name");
0.000004,46,0.000000,return $sigilname => $class->$generator($sigilname, $value, $globals) if $generator;
0.000000,0,0.000000,
0.000012,46,0.000000,if ($sigil eq '&') {
0.000079,46,0.000002,my $sub = $class->can($name);
0.000092,46,0.000002,return $sigilname => $sub if $sub;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# Could do this more cleverly, but this works.
0.000000,0,0.000000,my $evalled = eval "\\${sigil}${class}::${name}";
0.000000,0,0.000000,return $sigilname => $evalled if $evalled;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$class->_exporter_fail(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Called by _exporter_expand_sub if it is unable to generate a key-value
0.000000,0,0.000000,# pair for a sub.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub _exporter_fail
0.000000,0,0.000000,{
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my ($name, $value, $globals) = @_;
0.000000,0,0.000000,return if $globals->{is_unimport};
0.000000,0,0.000000,_croak("Could not find sub '%s' exported by %s", $name, $class);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Actually performs the installation of the sub into the target package. This
0.000000,0,0.000000,# also handles renaming the sub.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub _exporter_install_sub
0.000000,0,0.000000,{
0.000002,46,0.000000,my $class = shift;
0.000015,46,0.000000,my ($name, $value, $globals, $sym) = @_;
0.000017,46,0.000000,my $value_hash = ( ref($value) eq 'HASH' ) ? $value : {};
0.000000,0,0.000000,
0.000007,46,0.000000,my $into      = $globals->{into};
0.000013,46,0.000000,my $installer = $globals->{installer} || $globals->{exporter};
0.000000,0,0.000000,
0.000000,0,0.000000,$name =
0.000000,0,0.000000,ref    $globals->{as}      ? $globals->{as}->($name) :
0.000000,0,0.000000,ref    $value_hash->{-as}  ? $value_hash->{-as}->($name) :
0.000000,0,0.000000,exists $value_hash->{-as}  ? $value_hash->{-as} :
0.000020,46,0.000000,$name;
0.000000,0,0.000000,
0.000006,46,0.000000,return unless defined $name;
0.000000,0,0.000000,
0.000004,46,0.000000,my $sigil = "&";
0.000010,46,0.000000,unless (ref($name)) {
0.000052,46,0.000001,if ($name =~ /\A([&\$\%\@\*])(.+)\z/) {
0.000000,0,0.000000,$sigil = $1;
0.000000,0,0.000000,$name  = $2;
0.000000,0,0.000000,if ($sigil eq '*') {
0.000000,0,0.000000,_croak("Cannot export symbols with a * sigil");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000031,46,0.000001,my ($prefix) = grep defined, $value_hash->{-prefix}, $globals->{prefix}, q();
0.000021,46,0.000000,my ($suffix) = grep defined, $value_hash->{-suffix}, $globals->{suffix}, q();
0.000024,46,0.000001,$name = "$prefix$name$suffix";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000012,46,0.000000,my $sigilname = $sigil eq '&' ? $name : ( $sigil . $name );
0.000000,0,0.000000,
0.000000,0,0.000000,#	if ({qw/$ SCALAR @ ARRAY % HASH & CODE/}->{$sigil} ne ref($sym)) {
0.000000,0,0.000000,#		warn $sym;
0.000000,0,0.000000,#		warn $sigilname;
0.000000,0,0.000000,#		_croak("Reference type %s does not match sigil %s", ref($sym), $sigil);
0.000000,0,0.000000,#	}
0.000000,0,0.000000,
0.000006,46,0.000000,return ($$name = $sym)              if ref($name) eq q(SCALAR);
0.000005,46,0.000000,return ($into->{$sigilname} = $sym) if ref($into) eq q(HASH);
0.000000,0,0.000000,
0.000121,2,0.000061,no strict qw(refs);
0.000000,0,0.000000,our %TRACKED;
0.000000,0,0.000000,
0.000047,46,0.000001,if ( ref($sym) eq 'CODE'
0.000000,0,0.000000,and ref($into) ? exists($into->{$name}) : exists(&{"$into\::$name"})
0.000000,0,0.000000,and $sym != ( ref($into) ? $into->{$name} : \&{"$into\::$name"} ) )
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($level) = grep defined, $value_hash->{-replace}, $globals->{replace}, q(0);
0.000000,0,0.000000,my $action = {
0.000000,0,0.000000,carp     => \&_carp,
0.000000,0,0.000000,0        => \&_carp,
0.000000,0,0.000000,''       => \&_carp,
0.000000,0,0.000000,warn     => \&_carp,
0.000000,0,0.000000,nonfatal => \&_carp,
0.000000,0,0.000000,croak    => \&_croak,
0.000000,0,0.000000,fatal    => \&_croak,
0.000000,0,0.000000,die      => \&_croak,
0.000000,0,0.000000,}->{$level} || sub {};
0.000000,0,0.000000,
0.000000,0,0.000000,# Don't complain about double-installing the same sub. This isn't ideal
0.000000,0,0.000000,# because the same named sub might be generated in two different ways.
0.000000,0,0.000000,$action = sub {} if $TRACKED{$class}{$into}{$sigilname};
0.000000,0,0.000000,
0.000000,0,0.000000,$action->(
0.000000,0,0.000000,$action == \&_croak
0.000000,0,0.000000,? "Refusing to overwrite existing sub '%s' with sub '%s' exported by %s"
0.000000,0,0.000000,: "Overwriting existing sub '%s' with sub '%s' exported by %s",
0.000000,0,0.000000,ref($into) ? $name : "$into\::$name",
0.000000,0,0.000000,$_[0],
0.000000,0,0.000000,$class,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000020,46,0.000000,$TRACKED{$class}{$into}{$sigilname} = $sym;
0.000000,0,0.000000,
0.000099,2,0.000050,no warnings qw(prototype);
0.000000,0,0.000000,$installer
0.000000,0,0.000000,? $installer->($globals, [$sigilname, $sym])
0.000126,46,0.000003,: (*{"$into\::$name"} = $sym);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _exporter_uninstall_sub
0.000000,0,0.000000,{
0.000000,0,0.000000,our %TRACKED;
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my ($name, $value, $globals, $sym) = @_;
0.000000,0,0.000000,my $into = $globals->{into};
0.000000,0,0.000000,ref $into and return;
0.000000,0,0.000000,
0.000333,2,0.000166,no strict qw(refs);
0.000000,0,0.000000,
0.000000,0,0.000000,my $sigil = "&";
0.000000,0,0.000000,if ($name =~ /\A([&\$\%\@\*])(.+)\z/) {
0.000000,0,0.000000,$sigil = $1;
0.000000,0,0.000000,$name  = $2;
0.000000,0,0.000000,if ($sigil eq '*') {
0.000000,0,0.000000,_croak("Cannot export symbols with a * sigil");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my $sigilname = $sigil eq '&' ? $name : "$sigil$name";
0.000000,0,0.000000,
0.000000,0,0.000000,if ($sigil ne '&') {
0.000000,0,0.000000,_croak("Unimporting non-code symbols not supported yet");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Cowardly refuse to uninstall a sub that differs from the one
0.000000,0,0.000000,# we installed!
0.000000,0,0.000000,my $our_coderef = $TRACKED{$class}{$into}{$name};
0.000000,0,0.000000,my $cur_coderef = exists(&{"$into\::$name"}) ? \&{"$into\::$name"} : -1;
0.000000,0,0.000000,return unless $our_coderef == $cur_coderef;
0.000000,0,0.000000,
0.000000,0,0.000000,my $stash     = \%{"$into\::"};
0.000000,0,0.000000,my $old       = delete $stash->{$name};
0.000000,0,0.000000,my $full_name = join('::', $into, $name);
0.000000,0,0.000000,foreach my $type (qw(SCALAR HASH ARRAY IO)) # everything but the CODE
0.000000,0,0.000000,{
0.000000,0,0.000000,next unless defined(*{$old}{$type});
0.000000,0,0.000000,*$full_name = *{$old}{$type};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,delete $TRACKED{$class}{$into}{$name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mkopt
0.000000,0,0.000000,{
0.000005,13,0.000000,my $in = shift or return [];
0.000008,13,0.000001,my @out;
0.000000,0,0.000000,
0.000008,13,0.000001,$in = [map(($_ => ref($in->{$_}) ? $in->{$_} : ()), sort keys %$in)]
0.000000,0,0.000000,if ref($in) eq q(HASH);
0.000000,0,0.000000,
0.000028,13,0.000002,for (my $i = 0; $i < @$in; $i++)
0.000000,0,0.000000,{
0.000008,47,0.000000,my $k = $in->[$i];
0.000003,47,0.000000,my $v;
0.000000,0,0.000000,
0.000021,47,0.000000,($i == $#$in)         ? ($v = undef) :
0.000000,0,0.000000,!defined($in->[$i+1]) ? (++$i, ($v = undef)) :
0.000000,0,0.000000,!ref($in->[$i+1])     ? ($v = undef) :
0.000000,0,0.000000,($v = $in->[++$i]);
0.000000,0,0.000000,
0.000021,47,0.000000,push @out, [ $k => $v ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000036,13,0.000003,\@out;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mkopt_hash
0.000000,0,0.000000,{
0.000000,0,0.000000,my $in  = shift or return;
0.000000,0,0.000000,my %out = map +($_->[0] => $_->[1]), @{ mkopt($in) };
0.000000,0,0.000000,\%out;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
