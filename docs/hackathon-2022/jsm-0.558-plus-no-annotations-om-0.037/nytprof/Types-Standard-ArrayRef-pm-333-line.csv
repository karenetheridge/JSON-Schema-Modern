# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# INTERNAL MODULE: guts for ArrayRef type from Types::Standard.
0.000000,0,0.000000,
0.000000,0,0.000000,package Types::Standard::ArrayRef;
0.000000,0,0.000000,
0.000062,2,0.000031,use 5.008001;
0.000019,2,0.000010,use strict;
0.000025,2,0.000012,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,$Types::Standard::ArrayRef::AUTHORITY = 'cpan:TOBYINK';
0.000002,1,0.000002,$Types::Standard::ArrayRef::VERSION   = '2.000001';
0.000025,1,0.000025,}
0.000000,0,0.000000,
0.000001,1,0.000001,$Types::Standard::ArrayRef::VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000011,2,0.000005,use Type::Tiny      ();
0.000009,2,0.000005,use Types::Standard ();
0.000026,2,0.000013,use Types::TypeTiny ();
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
0.000000,0,0.000000,
0.000814,2,0.000407,no warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,sub __constraint_generator {
0.000002,4,0.000000,return Types::Standard::ArrayRef unless @_;
0.000000,0,0.000000,
0.000001,4,0.000000,my $param = shift;
0.000003,4,0.000001,Types::TypeTiny::is_TypeTiny( $param )
0.000000,0,0.000000,or _croak(
0.000000,0,0.000000,"Parameter to ArrayRef[`a] expected to be a type constraint; got $param" );
0.000000,0,0.000000,
0.000001,4,0.000000,my ( $min, $max ) = ( 0, -1 );
0.000001,4,0.000000,$min = Types::Standard::assert_Int( shift ) if @_;
0.000002,4,0.000000,$max = Types::Standard::assert_Int( shift ) if @_;
0.000000,0,0.000000,
0.000005,4,0.000001,my $param_compiled_check = $param->compiled_check;
0.000000,4,0.000000,my $xsub;
0.000006,4,0.000001,if ( Type::Tiny::_USE_XS and $min == 0 and $max == -1 ) {
0.000000,0,0.000000,my $paramname = Type::Tiny::XS::is_known( $param_compiled_check );
0.000000,0,0.000000,$xsub = Type::Tiny::XS::get_coderef_for( "ArrayRef[$paramname]" )
0.000000,0,0.000000,if $paramname;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( Type::Tiny::_USE_MOUSE
0.000000,0,0.000000,and $param->_has_xsub
0.000000,0,0.000000,and $min == 0
0.000000,0,0.000000,and $max == -1 )
0.000000,0,0.000000,{
0.000000,0,0.000000,require Mouse::Util::TypeConstraints;
0.000000,0,0.000000,my $maker = "Mouse::Util::TypeConstraints"->can( "_parameterize_ArrayRef_for" );
0.000000,0,0.000000,$xsub = $maker->( $param ) if $maker;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.000000,0,0.000000,sub {
0.000000,0,0.000000,my $array = shift;
0.000000,0,0.000000,$param->check( $_ ) || return for @$array;
0.000000,0,0.000000,return !!1;
0.000000,0,0.000000,},
0.000015,4,0.000004,$xsub,
0.000000,0,0.000000,) if $min == 0 and $max == -1;
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,my $array = shift;
0.000000,0,0.000000,return if @$array < $min;
0.000000,0,0.000000,$param->check( $_ ) || return for @$array;
0.000000,0,0.000000,return !!1;
0.000000,0,0.000000,}
0.000000,0,0.000000,if $max == -1;
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,my $array = shift;
0.000000,0,0.000000,return if @$array > $max;
0.000000,0,0.000000,$param->check( $_ ) || return for @$array;
0.000000,0,0.000000,return !!1;
0.000000,0,0.000000,}
0.000000,0,0.000000,if $min == 0;
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,my $array = shift;
0.000000,0,0.000000,return if @$array < $min;
0.000000,0,0.000000,return if @$array > $max;
0.000000,0,0.000000,$param->check( $_ ) || return for @$array;
0.000000,0,0.000000,return !!1;
0.000000,0,0.000000,};
0.000000,0,0.000000,} #/ sub __constraint_generator
0.000000,0,0.000000,
0.000000,0,0.000000,sub __inline_generator {
0.000002,4,0.000000,my $param = shift;
0.000000,4,0.000000,my ( $min, $max ) = ( 0, -1 );
0.000001,4,0.000000,$min = shift if @_;
0.000001,4,0.000000,$max = shift if @_;
0.000000,0,0.000000,
0.000004,4,0.000001,my $param_compiled_check = $param->compiled_check;
0.000000,4,0.000000,my $xsubname;
0.000000,0,0.000000,if ( Type::Tiny::_USE_XS and $min == 0 and $max == -1 ) {
0.000000,0,0.000000,my $paramname = Type::Tiny::XS::is_known( $param_compiled_check );
0.000000,0,0.000000,$xsubname = Type::Tiny::XS::get_subname_for( "ArrayRef[$paramname]" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,4,0.000001,return unless $param->can_be_inlined;
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000002,24,0.000000,my $v = $_[1];
0.000010,24,0.000000,return "$xsubname\($v\)" if $xsubname && !$Type::Tiny::AvoidCallbacks;
0.000063,24,0.000003,my $p = Types::Standard::ArrayRef->inline_check( $v );
0.000000,0,0.000000,
0.000007,24,0.000000,if ( $min != 0 ) {
0.000000,0,0.000000,$p .= sprintf( ' and @{%s} >= %d', $v, $min );
0.000000,0,0.000000,}
0.000012,24,0.000001,if ( $max > 0 ) {
0.000000,0,0.000000,$p .= sprintf( ' and @{%s} <= %d', $v, $max );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000040,24,0.000002,my $param_check = $param->inline_check( '$i' );
0.000061,24,0.000003,return $p if $param->{uniq} eq Types::Standard::Any->{uniq};
0.000000,0,0.000000,
0.000062,24,0.000003,"$p and do { "
0.000000,0,0.000000,. "my \$ok = 1; "
0.000000,0,0.000000,. "for my \$i (\@{$v}) { "
0.000000,0,0.000000,. "(\$ok = 0, last) unless $param_check " . "}; " . "\$ok " . "}";
0.000016,4,0.000004,};
0.000000,0,0.000000,} #/ sub __inline_generator
0.000000,0,0.000000,
0.000000,0,0.000000,sub __deep_explanation {
0.000000,0,0.000000,my ( $type, $value, $varname ) = @_;
0.000000,0,0.000000,my $param = $type->parameters->[0];
0.000000,0,0.000000,my ( $min, $max ) = ( 0, -1 );
0.000000,0,0.000000,$min = $type->parameters->[1] if @{ $type->parameters } > 1;
0.000000,0,0.000000,$max = $type->parameters->[2] if @{ $type->parameters } > 2;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $min != 0 and @$value < $min ) {
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf( '"%s" constrains array length at least %s', $type,    $min ),
0.000000,0,0.000000,sprintf( '@{%s} is %d',                              $varname, scalar @$value ),
0.000000,0,0.000000,];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $max > 0 and @$value > $max ) {
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf( '"%s" constrains array length at most %d', $type,    $max ),
0.000000,0,0.000000,sprintf( '@{%s} is %d',                             $varname, scalar @$value ),
0.000000,0,0.000000,];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for my $i ( 0 .. $#$value ) {
0.000000,0,0.000000,my $item = $value->[$i];
0.000000,0,0.000000,next if $param->check( $item );
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf( '"%s" constrains each value in the array with "%s"', $type, $param ),
0.000000,0,0.000000,@{ $param->validate_explain( $item, sprintf( '%s->[%d]', $varname, $i ) ) },
0.000000,0,0.000000,];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This should never happen...
0.000000,0,0.000000,return;    # uncoverable statement
0.000000,0,0.000000,} #/ sub __deep_explanation
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX: min and max need to be handled by coercion?
0.000000,0,0.000000,sub __coercion_generator {
0.000000,0,0.000000,my ( $parent, $child, $param ) = @_;
0.000000,0,0.000000,return unless $param->has_coercion;
0.000000,0,0.000000,
0.000000,0,0.000000,my $coercable_item = $param->coercion->_source_type_union;
0.000000,0,0.000000,my $C              = "Type::Coercion"->new( type_constraint => $child );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $param->coercion->can_be_inlined and $coercable_item->can_be_inlined ) {
0.000000,0,0.000000,$C->add_type_coercions(
0.000000,0,0.000000,$parent => Types::Standard::Stringable {
0.000000,0,0.000000,my @code;
0.000000,0,0.000000,push @code, 'do { my ($orig, $return_orig, @new) = ($_, 0);';
0.000000,0,0.000000,push @code, 'for (@$orig) {';
0.000000,0,0.000000,push @code,
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'++$return_orig && last unless (%s);',
0.000000,0,0.000000,$coercable_item->inline_check( '$_' )
0.000000,0,0.000000,);
0.000000,0,0.000000,push @code,
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'push @new, (%s);',
0.000000,0,0.000000,$param->coercion->inline_coercion( '$_' )
0.000000,0,0.000000,);
0.000000,0,0.000000,push @code, '}';
0.000000,0,0.000000,push @code, '$return_orig ? $orig : \\@new';
0.000000,0,0.000000,push @code, '}';
0.000000,0,0.000000,"@code";
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ if ( $param->coercion->...)
0.000000,0,0.000000,else {
0.000000,0,0.000000,$C->add_type_coercions(
0.000000,0,0.000000,$parent => sub {
0.000000,0,0.000000,my $value = @_ ? $_[0] : $_;
0.000000,0,0.000000,my @new;
0.000000,0,0.000000,for my $item ( @$value ) {
0.000000,0,0.000000,return $value unless $coercable_item->check( $item );
0.000000,0,0.000000,push @new, $param->coerce( $item );
0.000000,0,0.000000,}
0.000000,0,0.000000,return \@new;
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ else [ if ( $param->coercion->...)]
0.000000,0,0.000000,
0.000000,0,0.000000,return $C;
0.000000,0,0.000000,} #/ sub __coercion_generator
0.000000,0,0.000000,
0.000003,1,0.000003,1;
