# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000025,2,0.000013,use strict;
0.000033,2,0.000017,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Vocabulary::Content;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Implementation of the JSON Schema Content vocabulary
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.559';
0.000000,0,0.000000,
0.000026,2,0.000013,use 5.020;
0.000020,2,0.000010,use Moo;
0.000023,3,0.000008,use strictures 2;
0.000031,2,0.000015,use experimental qw(signatures postderef);
0.000021,2,0.000010,use if "$]" >= 5.022, experimental => 're_strict';
0.000020,2,0.000010,no if "$]" >= 5.031009, feature => 'indirect';
0.000018,2,0.000009,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000013,2,0.000007,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000015,2,0.000008,use Storable 'dclone';
0.000015,2,0.000008,use Feature::Compat::Try;
0.000015,2,0.000007,use JSON::Schema::Modern::Utilities qw(is_type A assert_keyword_type E abort);
0.000585,2,0.000293,use namespace::clean;
0.000000,0,0.000000,
0.000001,1,0.000001,with 'JSON::Schema::Modern::Vocabulary';
0.000000,0,0.000000,
0.000000,0,0.000000,sub vocabulary {
0.000002,1,0.000002,'https://json-schema.org/draft/2019-09/vocab/content' => 'draft2019-09',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/vocab/content' => 'draft2020-12';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,3,0.000001,sub evaluation_order { 4 }
0.000000,0,0.000000,
0.000001,6,0.000000,sub keywords ($self, $spec_version) {
0.000000,0,0.000000,return (
0.000006,2,0.000003,qw(contentEncoding contentMediaType),
0.000000,0,0.000000,$spec_version ne 'draft7' ? 'contentSchema' : (),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,4,0.000002,sub _traverse_keyword_contentEncoding ($self, $schema, $state) {
0.000031,1,0.000031,return if not assert_keyword_type($state, $schema, 'string');
0.000003,1,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_contentEncoding ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not is_type('string', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,A($state, $schema->{$state->{keyword}});
0.000000,0,0.000000,
0.000000,0,0.000000,if ($state->{validate_content_schemas}) {
0.000000,0,0.000000,my $decoder = $state->{evaluator}->get_encoding($schema->{contentEncoding});
0.000000,0,0.000000,abort($state, 'cannot find decoder for contentEncoding "%s"', $schema->{contentEncoding})
0.000000,0,0.000000,if not $decoder;
0.000000,0,0.000000,
0.000000,0,0.000000,# decode the data now, so we can report errors for the right keyword
0.000000,0,0.000000,try {
0.000000,0,0.000000,$state->{_content_ref} = $decoder->(\$data);
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,chomp $e;
0.000000,0,0.000000,return E($state, 'could not decode %s string: %s', $schema->{contentEncoding}, $e);
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000013,1,0.000013,sub _traverse_keyword_contentMediaType { shift->_traverse_keyword_contentEncoding(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_contentMediaType ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not is_type('string', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,A($state, $schema->{$state->{keyword}});
0.000000,0,0.000000,
0.000000,0,0.000000,if ($state->{validate_content_schemas}) {
0.000000,0,0.000000,my $decoder = $state->{evaluator}->get_media_type($schema->{contentMediaType});
0.000000,0,0.000000,abort($state, 'cannot find decoder for contentMediaType "%s"', $schema->{contentMediaType})
0.000000,0,0.000000,if not $decoder;
0.000000,0,0.000000,
0.000000,0,0.000000,# contentEncoding failed to decode the content
0.000000,0,0.000000,return 1 if exists $schema->{contentEncoding} and not exists $state->{_content_ref};
0.000000,0,0.000000,
0.000000,0,0.000000,# decode the data now, so we can report errors for the right keyword
0.000000,0,0.000000,try {
0.000000,0,0.000000,$state->{_content_ref} = $decoder->($state->{_content_ref} // \$data);
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,chomp $e;
0.000000,0,0.000000,delete $state->{_content_ref};
0.000000,0,0.000000,return E($state, 'could not decode %s string: %s', $schema->{contentMediaType}, $e);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,4,0.000000,sub _traverse_keyword_contentSchema ($self, $schema, $state) {
0.000000,0,0.000000,# since contentSchema should never be assumed to be evaluated in the context of the containing
0.000000,0,0.000000,# schema, it is not appropriate to gather identifiers found therein -- but we can still validate
0.000000,0,0.000000,# the subschema.
0.000010,1,0.000010,$self->traverse_subschema($schema, +{ %$state, identifiers => [] });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_contentSchema ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not exists $schema->{contentMediaType};
0.000000,0,0.000000,return 1 if not is_type('string', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,A($state, dclone($schema->{contentSchema}));
0.000000,0,0.000000,return 1 if not $state->{validate_content_schemas};
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if not exists $state->{_content_ref};  # contentMediaType failed to decode the content
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if $self->eval($state->{_content_ref}->$*, $schema->{contentSchema},
0.000000,0,0.000000,{ %$state, schema_path => $state->{schema_path}.'/contentSchema' });
0.000000,0,0.000000,return E($state, 'subschema is not valid');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,1;
0.000018,1,0.000018,__END__
