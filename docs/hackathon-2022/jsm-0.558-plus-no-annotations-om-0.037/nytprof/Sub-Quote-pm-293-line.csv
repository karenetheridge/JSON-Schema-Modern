# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Sub::Quote;
0.000000,0,0.000000,
1.693982,112,0.015125,sub _clean_eval { eval $_[0] }
0.000000,0,0.000000,
0.000023,2,0.000012,use strict;
0.000018,2,0.000009,use warnings;
0.000000,0,0.000000,
0.000516,2,0.000258,use Sub::Defer qw(defer_sub);
0.000012,2,0.000006,use Scalar::Util qw(weaken);
0.000011,2,0.000005,use Exporter qw(import);
0.000021,2,0.000011,use Carp qw(croak);
0.000011,1,0.000011,BEGIN { our @CARP_NOT = qw(Sub::Defer) }
0.000152,2,0.000076,use B ();
0.000000,0,0.000000,BEGIN {
0.000001,1,0.000001,*_HAVE_IS_UTF8 = defined &utf8::is_utf8 ? sub(){1} : sub(){0};
0.000001,1,0.000001,*_HAVE_PERLSTRING = defined &B::perlstring ? sub(){1} : sub(){0};
0.000009,1,0.000009,*_BAD_BACKSLASH_ESCAPE = _HAVE_PERLSTRING() && "$]" == 5.010_000 ? sub(){1} : sub(){0};
0.000001,1,0.000001,*_HAVE_HEX_FLOAT = !$ENV{SUB_QUOTE_NO_HEX_FLOAT} && "$]" >= 5.022 ? sub(){1} : sub(){0};
0.000000,0,0.000000,
0.000000,0,0.000000,# This may not be perfect, as we can't tell the format purely from the size
0.000000,0,0.000000,# but it should cover the common cases, and other formats are more likely to
0.000000,0,0.000000,# be less precise.
0.000000,1,0.000000,my $nvsize = 8 * length pack 'F', 0;
0.000000,1,0.000000,my $nvmantbits
0.000000,0,0.000000,= $nvsize == 16   ? 11
0.000000,0,0.000000,: $nvsize == 32   ? 24
0.000000,0,0.000000,: $nvsize == 64   ? 53
0.000000,0,0.000000,: $nvsize == 80   ? 64
0.000000,0,0.000000,: $nvsize == 128  ? 113
0.000000,0,0.000000,: $nvsize == 256  ? 237
0.000000,0,0.000000,: 237 # unknown float format
0.000000,0,0.000000,;
0.000000,1,0.000000,my $precision = int( log(2)/log(10)*$nvmantbits );
0.000000,0,0.000000,
0.000003,1,0.000003,*_NVSIZE = sub(){$nvsize};
0.000002,1,0.000002,*_NVMANTBITS = sub(){$nvmantbits};
0.000003,1,0.000003,*_FLOAT_PRECISION = sub(){$precision};
0.000111,1,0.000111,}
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '2.006006';
0.000002,1,0.000002,$VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000001,1,0.000001,our @EXPORT = qw(quote_sub unquote_sub quoted_from_sub qsub);
0.000000,1,0.000000,our @EXPORT_OK = qw(quotify capture_unroll inlinify sanitize_identifier);
0.000000,0,0.000000,
0.000000,0,0.000000,our %QUOTED;
0.000000,0,0.000000,
0.000000,1,0.000000,my %escape;
0.000000,0,0.000000,if (_BAD_BACKSLASH_ESCAPE) {
0.000000,0,0.000000,%escape = (
0.000000,0,0.000000,(map +(chr($_) => sprintf '\x%02x', $_), 0 .. 0x31, 0x7f),
0.000000,0,0.000000,"\t" => "\\t",
0.000000,0,0.000000,"\n" => "\\n",
0.000000,0,0.000000,"\r" => "\\r",
0.000000,0,0.000000,"\f" => "\\f",
0.000000,0,0.000000,"\b" => "\\b",
0.000000,0,0.000000,"\a" => "\\a",
0.000000,0,0.000000,"\e" => "\\e",
0.000000,0,0.000000,(map +($_ => "\\$_"), qw(" \ $ @)),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub quotify {
0.000188,1071,0.000000,my $value = $_[0];
0.001726,2,0.000863,no warnings 'numeric';
0.000000,0,0.000000,! defined $value     ? 'undef()'
0.000000,0,0.000000,# numeric detection
0.000000,0,0.000000,: (!(_HAVE_IS_UTF8 && utf8::is_utf8($value))
0.000000,0,0.000000,&& length( (my $dummy = '') & $value )
0.000000,0,0.000000,&& 0 + $value eq $value
0.000000,0,0.000000,) ? (
0.000000,0,0.000000,$value != $value ? (
0.000000,0,0.000000,$value eq (9**9**9*0)
0.000000,0,0.000000,? '(9**9**9*0)'    # nan
0.000000,0,0.000000,: '(-(9**9**9*0))' # -nan
0.000000,0,0.000000,)
0.000000,0,0.000000,: $value == 9**9**9  ? '(9**9**9)'     # inf
0.000000,0,0.000000,: $value == -9**9**9 ? '(-9**9**9)'    # -inf
0.000000,0,0.000000,: $value == 0 ? (
0.000000,0,0.000000,sprintf('%g', $value) eq '-0' ? '-0.0' : '0',
0.000000,0,0.000000,)
0.000000,0,0.000000,: $value !~ /[e.]/i ? (
0.000000,0,0.000000,$value > 0 ? (sprintf '%u', $value)
0.000000,0,0.000000,: (sprintf '%d', $value)
0.000000,0,0.000000,)
0.000000,0,0.000000,: do {
0.000000,0,0.000000,my $float = $value;
0.000000,0,0.000000,my $max_factor = int( log( abs($value) ) / log(2) ) - _NVMANTBITS;
0.000000,0,0.000000,my $ex_sign = $max_factor > 0 ? 1 : -1;
0.000000,0,0.000000,FACTOR: for my $ex (0 .. abs($max_factor)) {
0.000000,0,0.000000,my $num = $value / 2**($ex_sign * $ex);
0.000000,0,0.000000,for my $precision (_FLOAT_PRECISION .. _FLOAT_PRECISION+2) {
0.000000,0,0.000000,my $formatted = sprintf '%.'.$precision.'g', $num;
0.000000,0,0.000000,$float = $formatted
0.000000,0,0.000000,if $ex == 0;
0.000000,0,0.000000,if ($formatted == $num) {
0.000000,0,0.000000,if ($ex) {
0.000000,0,0.000000,$float
0.000000,0,0.000000,= $formatted
0.000000,0,0.000000,. ($ex_sign == 1 ? '*' : '/')
0.000000,0,0.000000,. (
0.000000,0,0.000000,$ex > _NVMANTBITS
0.000000,0,0.000000,? "2**$ex"
0.000000,0,0.000000,: sprintf('%u', 2**$ex)
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,last FACTOR;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if (_HAVE_HEX_FLOAT) {
0.000000,0,0.000000,$float = sprintf '%a', $value;
0.000000,0,0.000000,last FACTOR;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,"$float";
0.000000,0,0.000000,}
0.000000,0,0.000000,)
0.000000,0,0.000000,: !length($value) && length( (my $dummy2 = '') & $value ) ? '(!1)' # false
0.005526,1071,0.000005,: _BAD_BACKSLASH_ESCAPE && _HAVE_IS_UTF8 && utf8::is_utf8($value) ? do {
0.000000,0,0.000000,$value =~ s/(["\$\@\\[:cntrl:]]|[^\x00-\x7f])/
0.000000,0,0.000000,$escape{$1} || sprintf('\x{%x}', ord($1))
0.000000,0,0.000000,/ge;
0.000000,0,0.000000,qq["$value"];
0.000000,0,0.000000,}
0.000000,0,0.000000,: _HAVE_PERLSTRING ? B::perlstring($value)
0.000000,0,0.000000,: qq["\Q$value\E"];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sanitize_identifier {
0.000027,105,0.000000,my $name = shift;
0.000603,105,0.000006,$name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;
0.000174,105,0.000002,$name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub capture_unroll {
0.000042,112,0.000000,my ($from, $captures, $indent) = @_;
0.000000,0,0.000000,join(
0.000000,0,0.000000,'',
0.000000,0,0.000000,map {
0.000842,441,0.000002,/^([\@\%\$])/
0.000000,0,0.000000,or croak "capture key should start with \@, \% or \$: $_";
0.001360,658,0.000002,(' ' x $indent).qq{my ${_} = ${1}{${from}->{${\quotify $_}}};\n};
0.000000,0,0.000000,} keys %$captures
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub inlinify {
0.000000,0,0.000000,my ($code, $args, $extra, $local) = @_;
0.000000,0,0.000000,$args = '()'
0.000000,0,0.000000,if !defined $args;
0.000000,0,0.000000,my $do = 'do { '.($extra||'');
0.000000,0,0.000000,if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//) {
0.000000,0,0.000000,$do .= $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($code =~ s{
0.000000,0,0.000000,\A((?:\#\ BEGIN\ quote_sub\ PRELUDE\n.*?\#\ END\ quote_sub\ PRELUDE\n)?\s*)
0.000000,0,0.000000,(^\s*) my \s* \(([^)]+)\) \s* = \s* \@_;
0.000000,0,0.000000,}{}xms) {
0.000000,0,0.000000,my ($pre, $indent, $code_args) = ($1, $2, $3);
0.000000,0,0.000000,$do .= $pre;
0.000000,0,0.000000,if ($code_args ne $args) {
0.000000,0,0.000000,$do .= $indent . 'my ('.$code_args.') = ('.$args.'); ';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($local || $args ne '@_') {
0.000000,0,0.000000,$do .= ($local ? 'local ' : '').'@_ = ('.$args.'); ';
0.000000,0,0.000000,}
0.000000,0,0.000000,$do.$code.' }';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub quote_sub {
0.000000,0,0.000000,# HOLY DWIMMERY, BATMAN!
0.000000,0,0.000000,# $name => $code => \%captures => \%options
0.000000,0,0.000000,# $name => $code => \%captures
0.000000,0,0.000000,# $name => $code
0.000000,0,0.000000,# $code => \%captures => \%options
0.000000,0,0.000000,# $code
0.000118,133,0.000001,my $options =
0.000000,0,0.000000,(ref($_[-1]) eq 'HASH' and ref($_[-2]) eq 'HASH')
0.000000,0,0.000000,? pop
0.000000,0,0.000000,: {};
0.000055,133,0.000000,my $captures = ref($_[-1]) eq 'HASH' ? pop : undef;
0.000054,133,0.000000,undef($captures) if $captures && !keys %$captures;
0.000030,133,0.000000,my $code = pop;
0.000030,133,0.000000,my $name = $_[0];
0.000038,133,0.000000,if ($name) {
0.000018,106,0.000000,my $subname = $name;
0.000527,106,0.000005,my $package = $subname =~ s/(.*)::// ? $1 : caller;
0.000095,106,0.000001,$name = join '::', $package, $subname;
0.000022,106,0.000000,croak qq{package name "$package" too long!}
0.000000,0,0.000000,if length $package > 252;
0.000333,106,0.000003,croak qq{package name "$package" is not valid!}
0.000000,0,0.000000,unless $package =~ /^[^\d\W]\w*(?:::\w+)*$/;
0.000013,106,0.000000,croak qq{sub name "$subname" too long!}
0.000000,0,0.000000,if length $subname > 252;
0.000182,106,0.000002,croak qq{sub name "$subname" is not valid!}
0.000000,0,0.000000,unless $subname =~ /^[^\d\W]\w*$/;
0.000000,0,0.000000,}
0.000332,133,0.000002,my @caller = caller(0);
0.000100,133,0.000001,my ($attributes, $file, $line) = @{$options}{qw(attributes file line)};
0.000023,133,0.000000,if ($attributes) {
0.000000,0,0.000000,/\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_"
0.000000,0,0.000000,for @$attributes;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $quoted_info = {
0.000000,0,0.000000,name     => $name,
0.000000,0,0.000000,code     => $code,
0.000000,0,0.000000,captures => $captures,
0.000000,0,0.000000,package      => (exists $options->{package}      ? $options->{package}      : $caller[0]),
0.000000,0,0.000000,hints        => (exists $options->{hints}        ? $options->{hints}        : $caller[8]),
0.000000,0,0.000000,warning_bits => (exists $options->{warning_bits} ? $options->{warning_bits} : $caller[9]),
0.000467,133,0.000004,hintshash    => (exists $options->{hintshash}    ? $options->{hintshash}    : $caller[10]),
0.000000,0,0.000000,($attributes ? (attributes => $attributes) : ()),
0.000000,0,0.000000,($file       ? (file => $file) : ()),
0.000000,0,0.000000,($line       ? (line => $line) : ()),
0.000000,0,0.000000,};
0.000013,133,0.000000,my $unquoted;
0.000308,133,0.000002,weaken($quoted_info->{unquoted} = \$unquoted);
0.000031,133,0.000000,if ($options->{no_defer}) {
0.000017,106,0.000000,my $fake = \my $var;
0.000156,106,0.000001,local $QUOTED{$fake} = $quoted_info;
0.000124,106,0.000001,my $sub = unquote_sub($fake);
0.000175,106,0.000002,Sub::Defer::_install_coderef($name, $sub) if $name && !$options->{no_install};
0.000441,106,0.000004,return $sub;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $deferred = defer_sub(
0.000000,0,0.000000,($options->{no_install} ? undef : $name),
0.000000,0,0.000000,sub {
0.000000,0,0.000000,$unquoted if 0;
0.000019,6,0.000003,unquote_sub($quoted_info->{deferred});
0.000000,0,0.000000,},
0.000000,0,0.000000,{
0.000000,0,0.000000,($attributes ? ( attributes => $attributes ) : ()),
0.000136,27,0.000005,($name ? () : ( package => $quoted_info->{package} )),
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000051,27,0.000002,weaken($quoted_info->{deferred} = $deferred);
0.000055,27,0.000002,weaken($QUOTED{$deferred} = $quoted_info);
0.000080,27,0.000003,return $deferred;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _context {
0.000026,112,0.000000,my $info = shift;
0.000263,112,0.000002,$info->{context} ||= do {
0.000000,0,0.000000,my ($package, $hints, $warning_bits, $hintshash, $file, $line)
0.000100,112,0.000001,= @{$info}{qw(package hints warning_bits hintshash file line)};
0.000000,0,0.000000,
0.000021,112,0.000000,$line ||= 1
0.000000,0,0.000000,if $file;
0.000000,0,0.000000,
0.000059,112,0.000001,my $line_mark = '';
0.000017,112,0.000000,if ($line) {
0.000000,0,0.000000,$line_mark = "#line ".($line-1);
0.000000,0,0.000000,if ($file) {
0.000000,0,0.000000,$line_mark .= qq{ "$file"};
0.000000,0,0.000000,}
0.000000,0,0.000000,$line_mark .= "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$info->{context}
0.000000,0,0.000000,="# BEGIN quote_sub PRELUDE\n"
0.000000,0,0.000000,."package $package;\n"
0.000000,0,0.000000,."BEGIN {\n"
0.000000,0,0.000000,."  \$^H = ".quotify($hints).";\n"
0.000000,0,0.000000,."  \${^WARNING_BITS} = ".quotify($warning_bits).";\n"
0.000000,0,0.000000,."  \%^H = (\n"
0.000000,0,0.000000,. join('', map
0.000000,0,0.000000,"    ".quotify($_)." => ".quotify($hintshash->{$_}).",\n",
0.000427,112,0.000004,grep !(ref $hintshash->{$_} && $hintshash->{$_} =~ /\A(?:\w+(?:::\w+)*=)?[A-Z]+\(0x[[0-9a-fA-F]+\)\z/),
0.000000,0,0.000000,keys %$hintshash)
0.000000,0,0.000000,."  );\n"
0.000000,0,0.000000,."}\n"
0.000000,0,0.000000,.$line_mark
0.000000,0,0.000000,."# END quote_sub PRELUDE\n";
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub quoted_from_sub {
0.000006,37,0.000000,my ($sub) = @_;
0.000120,37,0.000003,my $quoted_info = $QUOTED{$sub||''} or return undef;
0.000000,0,0.000000,my ($name, $code, $captures, $unquoted, $deferred)
0.000000,0,0.000000,= @{$quoted_info}{qw(name code captures unquoted deferred)};
0.000000,0,0.000000,$code = _context($quoted_info) . $code;
0.000000,0,0.000000,$unquoted &&= $$unquoted;
0.000000,0,0.000000,if (($deferred && $deferred eq $sub)
0.000000,0,0.000000,|| ($unquoted && $unquoted eq $sub)) {
0.000000,0,0.000000,return [ $name, $code, $captures, $unquoted, $deferred ];
0.000000,0,0.000000,}
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unquote_sub {
0.000024,112,0.000000,my ($sub) = @_;
0.000061,112,0.000001,my $quoted_info = $QUOTED{$sub} or return undef;
0.000033,112,0.000000,my $unquoted = $quoted_info->{unquoted};
0.000049,112,0.000000,unless ($unquoted && $$unquoted) {
0.000000,0,0.000000,my ($name, $code, $captures, $package, $attributes)
0.000113,112,0.000001,= @{$quoted_info}{qw(name code captures package attributes)};
0.000000,0,0.000000,
0.000307,112,0.000003,($package, $name) = $name =~ /(.*)::(.*)/
0.000000,0,0.000000,if $name;
0.000000,0,0.000000,
0.000092,112,0.000001,my %captures = $captures ? %$captures : ();
0.000045,112,0.000000,$captures{'$_UNQUOTED'} = \$unquoted;
0.000029,112,0.000000,$captures{'$_QUOTED'} = \$quoted_info;
0.000000,0,0.000000,
0.000414,112,0.000004,my $make_sub
0.000000,0,0.000000,= "{\n"
0.000000,0,0.000000,. capture_unroll("\$_[1]", \%captures, 2)
0.000000,0,0.000000,. "  package ${package};\n"
0.000000,0,0.000000,. (
0.000000,0,0.000000,$name
0.000000,0,0.000000,# disable the 'variable $x will not stay shared' warning since
0.000000,0,0.000000,# we're not letting it escape from this scope anyway so there's
0.000000,0,0.000000,# nothing trying to share it
0.000000,0,0.000000,? "  no warnings 'closure';\n  sub ${name} "
0.000000,0,0.000000,: "  \$\$_UNQUOTED = sub "
0.000000,0,0.000000,)
0.000000,0,0.000000,. ($attributes ? join('', map ":$_ ", @$attributes) : '') . "{\n"
0.000000,0,0.000000,. "  (\$_QUOTED,\$_UNQUOTED) if 0;\n"
0.000000,0,0.000000,. _context($quoted_info)
0.000000,0,0.000000,. $code
0.000000,0,0.000000,. "  }".($name ? "\n  \$\$_UNQUOTED = \\&${name}" : '') . ";\n"
0.000000,0,0.000000,. "}\n"
0.000000,0,0.000000,. "1;\n";
0.000044,112,0.000000,if (my $debug = $ENV{SUB_QUOTE_DEBUG}) {
0.000000,0,0.000000,if ($debug =~ m{^([^\W\d]\w*(?:::\w+)*(?:::)?)$}) {
0.000000,0,0.000000,my $filter = $1;
0.000000,0,0.000000,my $match
0.000000,0,0.000000,= $filter =~ /::$/ ? $package.'::'
0.000000,0,0.000000,: $filter =~ /::/  ? $package.'::'.($name||'__ANON__')
0.000000,0,0.000000,: ($name||'__ANON__');
0.000000,0,0.000000,warn $make_sub
0.000000,0,0.000000,if $match eq $filter;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($debug =~ m{\A/(.*)/\z}s) {
0.000000,0,0.000000,my $filter = $1;
0.000000,0,0.000000,warn $make_sub
0.000000,0,0.000000,if $code =~ $filter;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,warn $make_sub;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,{
0.000396,114,0.000003,no strict 'refs';
0.000250,112,0.000002,local *{"${package}::${name}"} if $name;
0.000025,112,0.000000,my ($success, $e);
0.000000,0,0.000000,{
0.000076,224,0.000000,local $@;
0.000144,112,0.000001,$success = _clean_eval($make_sub, \%captures);
0.000064,112,0.000001,$e = $@;
0.000000,0,0.000000,}
0.000015,112,0.000000,unless ($success) {
0.000000,0,0.000000,my $space = length($make_sub =~ tr/\n//);
0.000000,0,0.000000,my $line = 0;
0.000000,0,0.000000,$make_sub =~ s/^/sprintf "%${space}d: ", ++$line/emg;
0.000000,0,0.000000,croak "Eval went very, very wrong:\n\n${make_sub}\n\n$e";
0.000000,0,0.000000,}
0.000482,112,0.000004,weaken($QUOTED{$$unquoted} = $quoted_info);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000265,112,0.000002,$$unquoted;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub qsub ($) {
0.000000,0,0.000000,goto &quote_sub;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub CLONE {
0.000000,0,0.000000,my @quoted = map { defined $_ ? (
0.000000,0,0.000000,$_->{unquoted} && ${$_->{unquoted}} ? (${ $_->{unquoted} } => $_) : (),
0.000000,0,0.000000,$_->{deferred} ? ($_->{deferred} => $_) : (),
0.000000,0,0.000000,) : () } values %QUOTED;
0.000000,0,0.000000,%QUOTED = @quoted;
0.000000,0,0.000000,weaken($_) for values %QUOTED;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,__END__
