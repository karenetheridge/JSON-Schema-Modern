# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Role::Tiny;
0.000018,2,0.000009,use strict;
0.000137,2,0.000068,use warnings;
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '2.002004';
0.000001,1,0.000001,$VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000000,0,0.000000,our %INFO;
0.000000,0,0.000000,our %APPLIED_TO;
0.000000,0,0.000000,our %COMPOSED;
0.000000,0,0.000000,our %COMPOSITE_INFO;
0.000000,0,0.000000,our @ON_ROLE_CREATE;
0.000000,0,0.000000,
0.000000,0,0.000000,# Module state workaround totally stolen from Zefram's Module::Runtime.
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000002,1,0.000002,*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
0.000000,0,0.000000,*_WORK_AROUND_HINT_LEAKAGE
0.000000,0,0.000000,= "$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
0.000000,1,0.000000,? sub(){1} : sub(){0};
0.000021,1,0.000021,*_CONSTANTS_DEFLATE = "$]" >= 5.012 && "$]" < 5.020 ? sub(){1} : sub(){0};
0.000021,1,0.000021,}
0.000000,0,0.000000,
0.000330,150,0.000002,sub _getglob { no strict 'refs'; \*{$_[0]} }
0.000123,28,0.000004,sub _getstash { no strict 'refs'; \%{"$_[0]::"} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub croak {
0.000000,0,0.000000,require Carp;
0.000163,2,0.000082,no warnings 'redefine';
0.000000,0,0.000000,*croak = \&Carp::croak;
0.000000,0,0.000000,goto &Carp::croak;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Role::Tiny::__GUARD__::DESTROY {
0.000000,0,0.000000,delete $INC{$_[0]->[0]} if @{$_[0]};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _load_module {
0.000001,2,0.000000,my ($module) = @_;
0.000023,2,0.000012,(my $file = "$module.pm") =~ s{::}{/}g;
0.000000,0,0.000000,return 1
0.000002,2,0.000001,if $INC{$file};
0.000000,0,0.000000,
0.000000,0,0.000000,# can't just ->can('can') because a sub-package Foo::Bar::Baz
0.000000,0,0.000000,# creates a 'Baz::' key in Foo::Bar's symbol table
0.000000,0,0.000000,return 1
0.000005,2,0.000002,if grep !/::\z/, keys %{_getstash($module)};
0.000001,2,0.000000,my $guard = _WORK_AROUND_BROKEN_MODULE_STATE
0.000000,0,0.000000,&& bless([ $file ], 'Role::Tiny::__GUARD__');
0.000000,0,0.000000,local %^H if _WORK_AROUND_HINT_LEAKAGE;
0.001353,2,0.000676,require $file;
0.000000,0,0.000000,pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;
0.000010,2,0.000005,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _require_module {
0.000008,2,0.000004,_load_module($_[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _all_subs {
0.000008,24,0.000000,my ($me, $package) = @_;
0.000064,24,0.000003,my $stash = _getstash($package);
0.000000,0,0.000000,return {
0.000000,0,0.000000,map {;
0.000635,2,0.000317,no strict 'refs';
0.000000,0,0.000000,# this is an ugly hack to populate the scalar slot of any globs, to
0.000000,0,0.000000,# prevent perl from converting constants back into scalar refs in the
0.000000,0,0.000000,# stash when they are used (perl 5.12 - 5.18). scalar slots on their own
0.000000,0,0.000000,# aren't detectable through pure perl, so this seems like an acceptable
0.000000,0,0.000000,# compromise.
0.000000,0,0.000000,${"${package}::${_}"} = ${"${package}::${_}"}
0.000000,0,0.000000,if _CONSTANTS_DEFLATE;
0.000152,292,0.000001,$_ => \&{"${package}::${_}"}
0.000000,0,0.000000,}
0.000749,24,0.000031,grep exists &{"${package}::${_}"},
0.000000,0,0.000000,grep !/::\z/,
0.000000,0,0.000000,keys %$stash
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000005,4,0.000001,my $target = caller;
0.000003,4,0.000001,my $me = shift;
0.000041,4,0.000010,strict->import;
0.000009,4,0.000002,warnings->import;
0.000010,4,0.000002,my $non_methods = $me->_non_methods($target);
0.000008,4,0.000002,$me->_install_subs($target, @_);
0.000012,4,0.000003,$me->make_role($target);
0.000001,4,0.000000,$me->_mark_new_non_methods($target, $non_methods)
0.000000,0,0.000000,if $non_methods && %$non_methods;
0.000015,4,0.000004,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _mark_new_non_methods {
0.000000,0,0.000000,my ($me, $target, $old_non_methods) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $non_methods = $INFO{$target}{non_methods};
0.000000,0,0.000000,
0.000000,0,0.000000,my $subs = $me->_all_subs($target);
0.000000,0,0.000000,for my $sub (keys %$subs) {
0.000000,0,0.000000,if ( exists $old_non_methods->{$sub} && $non_methods->{$sub} != $subs->{$sub} ) {
0.000000,0,0.000000,$non_methods->{$sub} = $subs->{$sub};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub make_role {
0.000004,4,0.000001,my ($me, $target) = @_;
0.000000,0,0.000000,
0.000003,4,0.000001,return if $me->is_role($target);
0.000014,4,0.000004,$INFO{$target}{is_role} = 1;
0.000000,0,0.000000,
0.000009,4,0.000002,my $non_methods = $me->_all_subs($target);
0.000025,4,0.000006,delete @{$non_methods}{grep /\A\(/, keys %$non_methods};
0.000002,4,0.000000,$INFO{$target}{non_methods} = $non_methods;
0.000000,0,0.000000,
0.000000,0,0.000000,# a role does itself
0.000008,4,0.000002,$APPLIED_TO{$target} = { $target => undef };
0.000012,4,0.000003,foreach my $hook (@ON_ROLE_CREATE) {
0.000009,4,0.000002,$hook->($target);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_subs {
0.000001,2,0.000000,my ($me, $target) = @_;
0.000009,2,0.000005,return if $me->is_role($target);
0.000009,2,0.000005,my %install = $me->_gen_subs($target);
0.000000,0,0.000000,*{_getglob("${target}::${_}")} = $install{$_}
0.000028,2,0.000014,for sort keys %install;
0.000006,2,0.000003,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _gen_subs {
0.000001,2,0.000000,my ($me, $target) = @_;
0.000000,0,0.000000,(
0.000000,0,0.000000,(map {;
0.000003,6,0.000000,my $type = $_;
0.000000,0,0.000000,$type => sub {
0.000000,0,0.000000,my $code = pop;
0.000000,0,0.000000,my @names = ref $_[0] eq 'ARRAY' ? @{ $_[0] } : @_;
0.000000,0,0.000000,push @{$INFO{$target}{modifiers}||=[]}, [ $type, @names, $code ];
0.000000,0,0.000000,return;
0.000012,6,0.000002,};
0.000000,0,0.000000,} qw(before after around)),
0.000000,0,0.000000,requires => sub {
0.000000,0,0.000000,push @{$INFO{$target}{requires}||=[]}, @_;
0.000000,0,0.000000,return;
0.000000,0,0.000000,},
0.000000,0,0.000000,with => sub {
0.000000,0,0.000000,$me->apply_roles_to_package($target, @_);
0.000000,0,0.000000,return;
0.000000,0,0.000000,},
0.000018,2,0.000009,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub role_application_steps {
0.000022,12,0.000002,qw(
0.000000,0,0.000000,_install_methods
0.000000,0,0.000000,_check_requires
0.000000,0,0.000000,_install_modifiers
0.000000,0,0.000000,_copy_applied_list
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _copy_applied_list {
0.000005,12,0.000000,my ($me, $to, $role) = @_;
0.000000,0,0.000000,# copy our role list into the target's
0.000046,12,0.000004,@{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}} = ();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply_roles_to_object {
0.000003,7,0.000000,my ($me, $object, @roles) = @_;
0.000003,7,0.000000,my $class = ref($object);
0.000000,0,0.000000,# on perl < 5.8.9, magic isn't copied to all ref copies. bless the parameter
0.000000,0,0.000000,# directly, so at least the variable passed to us will get any magic applied
0.000027,7,0.000004,bless($_[1], $me->create_class_with_roles($class, @roles));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,my $role_suffix = 'A000';
0.000000,0,0.000000,sub _composite_name {
0.000002,7,0.000000,my ($me, $superclass, @roles) = @_;
0.000000,0,0.000000,
0.000010,7,0.000001,my $new_name = $superclass . '__WITH__' . join '__AND__', @roles;
0.000000,0,0.000000,
0.000006,7,0.000001,if (length($new_name) > 252) {
0.000000,0,0.000000,$new_name = $COMPOSED{abbrev}{$new_name} ||= do {
0.000000,0,0.000000,my $abbrev = substr $new_name, 0, 250 - length $role_suffix;
0.000000,0,0.000000,$abbrev =~ s/(?<!:):$//;
0.000000,0,0.000000,$abbrev.'__'.$role_suffix++;
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000010,7,0.000001,return $new_name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_class_with_roles {
0.000004,7,0.000001,my ($me, $superclass, @roles) = @_;
0.000000,0,0.000000,
0.000013,7,0.000002,$me->_require_module($superclass);
0.000013,7,0.000002,$me->_check_roles(@roles);
0.000000,0,0.000000,
0.000012,7,0.000002,my $new_name = $me->_composite_name($superclass, @roles);
0.000000,0,0.000000,
0.000000,0,0.000000,return $new_name
0.000019,7,0.000003,if $COMPOSED{class}{$new_name};
0.000000,0,0.000000,
0.000004,1,0.000004,return $me->_build_class_with_roles($new_name, $superclass, @roles);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_class_with_roles {
0.000001,1,0.000001,my ($me, $new_name, $superclass, @roles) = @_;
0.000000,0,0.000000,
0.000001,1,0.000001,$COMPOSED{base}{$new_name} = $superclass;
0.000010,1,0.000010,@{*{_getglob("${new_name}::ISA")}} = ( $superclass );
0.000002,1,0.000002,$me->apply_roles_to_package($new_name, @roles);
0.000001,1,0.000001,$COMPOSED{class}{$new_name} = 1;
0.000002,1,0.000002,return $new_name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _check_roles {
0.000009,19,0.000000,my ($me, @roles) = @_;
0.000008,19,0.000000,croak "No roles supplied!" unless @roles;
0.000000,0,0.000000,
0.000001,19,0.000000,my %seen;
0.000040,19,0.000002,if (my @dupes = grep 1 == $seen{$_}++, @roles) {
0.000000,0,0.000000,croak "Duplicated roles: ".join(', ', @dupes);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000048,19,0.000003,foreach my $role (@roles) {
0.000036,19,0.000002,$me->_require_module($role);
0.000044,19,0.000002,croak "${role} is not a ${me}" unless $me->is_role($role);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,our %BACKCOMPAT_HACK;
0.000000,1,0.000000,$BACKCOMPAT_HACK{+__PACKAGE__} = 0;
0.000000,0,0.000000,sub _want_backcompat_hack {
0.000004,12,0.000000,my $me = shift;
0.000000,0,0.000000,return $BACKCOMPAT_HACK{$me}
0.000025,12,0.000002,if exists $BACKCOMPAT_HACK{$me};
0.001082,2,0.000541,no warnings 'uninitialized';
0.000007,1,0.000007,$BACKCOMPAT_HACK{$me} =
0.000000,0,0.000000,$me->can('apply_single_role_to_package') != \&apply_single_role_to_package
0.000000,0,0.000000,&& $me->can('role_application_steps') == \&role_application_steps
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,our $IN_APPLY_ROLES;
0.000000,0,0.000000,sub apply_single_role_to_package {
0.000000,0,0.000000,return
0.000000,0,0.000000,if $IN_APPLY_ROLES;
0.000000,0,0.000000,local $IN_APPLY_ROLES = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($me, $to, $role) = @_;
0.000000,0,0.000000,$me->apply_roles_to_package($to, $role);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply_role_to_package {
0.000000,0,0.000000,my ($me, $to, $role) = @_;
0.000000,0,0.000000,$me->apply_roles_to_package($to, $role);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply_roles_to_package {
0.000012,12,0.000001,my ($me, $to, @roles) = @_;
0.000005,12,0.000000,croak "Can't apply roles to object with apply_roles_to_package"
0.000000,0,0.000000,if ref $to;
0.000000,0,0.000000,
0.000024,12,0.000002,$me->_check_roles(@roles);
0.000000,0,0.000000,
0.000002,12,0.000000,my @have_conflicts;
0.000000,0,0.000000,my %role_methods;
0.000000,0,0.000000,
0.000008,12,0.000001,if (@roles > 1) {
0.000000,0,0.000000,my %conflicts = %{$me->_composite_info_for(@roles)->{conflicts}};
0.000000,0,0.000000,@have_conflicts = grep $to->can($_), keys %conflicts;
0.000000,0,0.000000,delete @conflicts{@have_conflicts};
0.000000,0,0.000000,
0.000000,0,0.000000,if (keys %conflicts) {
0.000000,0,0.000000,my $class = $COMPOSED{base}{$to} || $to;
0.000000,0,0.000000,my $fail =
0.000000,0,0.000000,join "\n",
0.000000,0,0.000000,map {
0.000000,0,0.000000,"Due to a method name conflict between roles "
0.000000,0,0.000000,.join(' and ', map "'$_'", sort values %{$conflicts{$_}})
0.000000,0,0.000000,.", the method '$_' must be implemented by '$class'"
0.000000,0,0.000000,} sort keys %conflicts;
0.000000,0,0.000000,croak $fail;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,%role_methods = map +($_ => $me->_concrete_methods_of($_)), @roles;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000026,12,0.000002,if (!$IN_APPLY_ROLES and _want_backcompat_hack($me)) {
0.000000,0,0.000000,local $IN_APPLY_ROLES = 1;
0.000000,0,0.000000,foreach my $role (@roles) {
0.000000,0,0.000000,$me->apply_single_role_to_package($to, $role);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,12,0.000000,my $role_methods;
0.000025,12,0.000002,foreach my $step ($me->role_application_steps) {
0.000031,78,0.000000,foreach my $role (@roles) {
0.000000,0,0.000000,# conflicting methods are supposed to be treated as required by the
0.000000,0,0.000000,# composed role. we don't have an actual composed role, but because
0.000000,0,0.000000,# we know the target class already provides them, we can instead
0.000000,0,0.000000,# pretend that the roles don't do for the duration of application.
0.000000,0,0.000000,$role_methods = $role_methods{$role} and (
0.000000,0,0.000000,(local @{$role_methods}{@have_conflicts}),
0.000021,78,0.000000,(delete @{$role_methods}{@have_conflicts}),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000145,78,0.000002,$me->$step($to, $role);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000049,12,0.000004,$APPLIED_TO{$to}{join('|',@roles)} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _composite_info_for {
0.000000,0,0.000000,my ($me, @roles) = @_;
0.000000,0,0.000000,$COMPOSITE_INFO{join('|', sort @roles)} ||= do {
0.000000,0,0.000000,my %methods;
0.000000,0,0.000000,foreach my $role (@roles) {
0.000000,0,0.000000,my $this_methods = $me->_concrete_methods_of($role);
0.000000,0,0.000000,$methods{$_}{$this_methods->{$_}} = $role for keys %$this_methods;
0.000000,0,0.000000,}
0.000000,0,0.000000,delete $methods{$_} for grep keys(%{$methods{$_}}) == 1, keys %methods;
0.000000,0,0.000000,+{ conflicts => \%methods }
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _check_requires {
0.000006,12,0.000000,my ($me, $to, $name, $requires) = @_;
0.000013,12,0.000001,$requires ||= $INFO{$name}{requires} || [];
0.000092,12,0.000008,if (my @requires_fail = grep !$to->can($_), @$requires) {
0.000000,0,0.000000,# role -> role, add to requires, role -> class, error out
0.000000,0,0.000000,if (my $to_info = $INFO{$to}) {
0.000000,0,0.000000,push @{$to_info->{requires}||=[]}, @requires_fail;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak "Can't apply ${name} to ${to} - missing ".join(', ', @requires_fail);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _non_methods {
0.000004,8,0.000000,my ($me, $role) = @_;
0.000017,8,0.000002,my $info = $INFO{$role} or return {};
0.000000,0,0.000000,
0.000010,4,0.000002,my %non_methods = %{ $info->{non_methods} || {} };
0.000000,0,0.000000,
0.000000,0,0.000000,# this is only for backwards compatibility with older Moo, which
0.000000,0,0.000000,# reimplements method tracking rather than calling our method
0.000004,4,0.000001,my %not_methods = reverse %{ $info->{not_methods} || {} };
0.000007,4,0.000002,return \%non_methods unless keys %not_methods;
0.000000,0,0.000000,
0.000000,0,0.000000,my $subs = $me->_all_subs($role);
0.000000,0,0.000000,for my $sub (grep !/\A\(/, keys %$subs) {
0.000000,0,0.000000,my $code = $subs->{$sub};
0.000000,0,0.000000,if (exists $not_methods{$code}) {
0.000000,0,0.000000,$non_methods{$sub} = $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return \%non_methods;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _concrete_methods_of {
0.000005,12,0.000000,my ($me, $role) = @_;
0.000008,12,0.000001,my $info = $INFO{$role};
0.000000,0,0.000000,
0.000000,0,0.000000,return $info->{methods}
0.000020,12,0.000002,if $info && $info->{methods};
0.000000,0,0.000000,
0.000006,4,0.000002,my $non_methods = $me->_non_methods($role);
0.000000,0,0.000000,
0.000005,4,0.000001,my $subs = $me->_all_subs($role);
0.000005,4,0.000001,for my $sub (keys %$subs) {
0.000024,84,0.000000,if ( exists $non_methods->{$sub} && $non_methods->{$sub} == $subs->{$sub} ) {
0.000000,0,0.000000,delete $subs->{$sub};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,4,0.000001,if ($info) {
0.000000,0,0.000000,$info->{methods} = $subs;
0.000000,0,0.000000,}
0.000011,4,0.000003,return $subs;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub methods_provided_by {
0.000000,0,0.000000,my ($me, $role) = @_;
0.000000,0,0.000000,$me->_require_module($role);
0.000000,0,0.000000,croak "${role} is not a ${me}" unless $me->is_role($role);
0.000000,0,0.000000,sort (keys %{$me->_concrete_methods_of($role)}, @{$INFO{$role}->{requires}||[]});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_methods {
0.000005,12,0.000000,my ($me, $to, $role) = @_;
0.000000,0,0.000000,
0.000022,12,0.000002,my $methods = $me->_concrete_methods_of($role);
0.000000,0,0.000000,
0.000006,12,0.000000,my %existing_methods;
0.000060,12,0.000005,@existing_methods{keys %{ $me->_all_subs($to) }} = ();
0.000000,0,0.000000,
0.000000,0,0.000000,# _concrete_methods_of caches its result on roles.  that cache needs to be
0.000000,0,0.000000,# invalidated after applying roles
0.000007,12,0.000001,delete $INFO{$to}{methods} if $INFO{$to};
0.000000,0,0.000000,
0.000040,12,0.000003,foreach my $i (keys %$methods) {
0.000000,0,0.000000,next
0.000019,131,0.000000,if exists $existing_methods{$i};
0.000000,0,0.000000,
0.000089,123,0.000001,my $glob = _getglob "${to}::${i}";
0.000039,123,0.000000,*$glob = $methods->{$i};
0.000000,0,0.000000,
0.000000,0,0.000000,# overloads using method names have the method stored in the scalar slot
0.000000,0,0.000000,# and &overload::nil in the code slot.
0.000000,0,0.000000,next
0.000000,0,0.000000,unless $i =~ /^\(/
0.000000,0,0.000000,&& ((defined &overload::nil && $methods->{$i} == \&overload::nil)
0.000160,123,0.000001,|| (defined &overload::_nil && $methods->{$i} == \&overload::_nil));
0.000000,0,0.000000,
0.000000,0,0.000000,my $overload = ${ _getglob "${role}::${i}" };
0.000000,0,0.000000,next
0.000000,0,0.000000,unless defined $overload;
0.000000,0,0.000000,
0.000000,0,0.000000,*$glob = \$overload;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000047,12,0.000004,$me->_install_does($to);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_modifiers {
0.000008,12,0.000001,my ($me, $to, $name) = @_;
0.000028,12,0.000002,return unless my $modifiers = $INFO{$name}{modifiers};
0.000000,1,0.000000,my $info = $INFO{$to};
0.000001,1,0.000001,my $existing = ($info ? $info->{modifiers} : $COMPOSED{modifiers}{$to}) ||= [];
0.000000,0,0.000000,my @modifiers = grep {
0.000000,2,0.000000,my $modifier = $_;
0.000001,2,0.000000,!grep $_ == $modifier, @$existing;
0.000001,1,0.000001,} @{$modifiers||[]};
0.000000,1,0.000000,push @$existing, @modifiers;
0.000000,0,0.000000,
0.000003,1,0.000003,if (!$info) {
0.000000,0,0.000000,foreach my $modifier (@modifiers) {
0.000003,2,0.000002,$me->_install_single_modifier($to, @$modifier);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my $vcheck_error;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_single_modifier {
0.000000,0,0.000000,my ($me, @args) = @_;
0.000000,0,0.000000,defined($vcheck_error) or $vcheck_error = do {
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,eval {
0.000000,0,0.000000,require Class::Method::Modifiers;
0.000000,0,0.000000,Class::Method::Modifiers->VERSION(1.05);
0.000000,0,0.000000,1;
0.000000,0,0.000000,} ? 0 : $@;
0.000000,0,0.000000,};
0.000000,0,0.000000,$vcheck_error and die $vcheck_error;
0.000000,0,0.000000,Class::Method::Modifiers::install_modifier(@args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,my $FALLBACK = sub { 0 };
0.000000,0,0.000000,sub _install_does {
0.000006,12,0.000000,my ($me, $to) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# only add does() method to classes
0.000013,12,0.000001,return if $me->is_role($to);
0.000000,0,0.000000,
0.000037,12,0.000003,my $does = $me->can('does_role');
0.000000,0,0.000000,# add does() only if they don't have one
0.000068,12,0.000006,*{_getglob "${to}::does"} = $does unless $to->can('does');
0.000000,0,0.000000,
0.000000,0,0.000000,return
0.000103,12,0.000009,if $to->can('DOES') and $to->can('DOES') != (UNIVERSAL->can('DOES') || 0);
0.000000,0,0.000000,
0.000026,12,0.000002,my $existing = $to->can('DOES') || $to->can('isa') || $FALLBACK;
0.000000,0,0.000000,my $new_sub = sub {
0.000205,556,0.000000,my ($proto, $role) = @_;
0.001217,556,0.000002,$proto->$does($role) or $proto->$existing($role);
0.000032,12,0.000003,};
0.000192,2,0.000096,no warnings 'redefine';
0.000047,12,0.000004,return *{_getglob "${to}::DOES"} = $new_sub;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# optimize for newer perls
0.000000,0,0.000000,require mro
0.000002,1,0.000002,if "$]" >= 5.009_005;
0.000000,0,0.000000,
0.000001,1,0.000001,if (defined &mro::get_linear_isa) {
0.000000,0,0.000000,*_linear_isa = \&mro::get_linear_isa;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $e;
0.000000,0,0.000000,{
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,# this routine is simplified and not fully compatible with mro::get_linear_isa
0.000000,0,0.000000,# but for our use the order doesn't matter, so we don't need to care
0.000000,0,0.000000,eval <<'END_CODE' or $e = $@;
0.000000,0,0.000000,sub _linear_isa($;$) {
0.000000,0,0.000000,if (defined &mro::get_linear_isa) {
0.000000,0,0.000000,no warnings 'redefine', 'prototype';
0.000000,0,0.000000,*_linear_isa = \&mro::get_linear_isa;
0.000000,0,0.000000,goto &mro::get_linear_isa;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @check = shift;
0.000000,0,0.000000,my @lin;
0.000000,0,0.000000,
0.000000,0,0.000000,my %found;
0.000000,0,0.000000,while (defined(my $check = shift @check)) {
0.000000,0,0.000000,push @lin, $check;
0.000000,0,0.000000,no strict 'refs';
0.000000,0,0.000000,unshift @check, grep !$found{$_}++, @{"$check\::ISA"};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return \@lin;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,1;
0.000000,0,0.000000,END_CODE
0.000000,0,0.000000,}
0.000000,0,0.000000,die $e if defined $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub does_role {
0.000151,603,0.000000,my ($proto, $role) = @_;
0.001471,603,0.000002,foreach my $class (@{_linear_isa(ref($proto)||$proto)}) {
0.001265,610,0.000002,return 1 if exists $APPLIED_TO{$class}{$role};
0.000000,0,0.000000,}
0.000015,7,0.000002,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_role {
0.000035,93,0.000000,my ($me, $role) = @_;
0.000000,0,0.000000,return !!($INFO{$role} && (
0.000000,0,0.000000,$INFO{$role}{is_role}
0.000000,0,0.000000,# these are for backward compatibility with older Moo that overrode some
0.000000,0,0.000000,# methods without calling the originals, thus not getting is_role set
0.000000,0,0.000000,|| $INFO{$role}{requires}
0.000000,0,0.000000,|| $INFO{$role}{not_methods}
0.000000,0,0.000000,|| $INFO{$role}{non_methods}
0.000232,93,0.000002,));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,1;
0.000000,0,0.000000,__END__
