# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000025,2,0.000013,use strict;
0.000037,2,0.000018,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Vocabulary::OpenAPI;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Implementation of the JSON Schema OpenAPI vocabulary
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.037';
0.000000,0,0.000000,
0.000026,2,0.000013,use 5.020;
0.000023,2,0.000012,use Moo;
0.000033,3,0.000011,use strictures 2;
0.000028,2,0.000014,use experimental qw(signatures postderef);
0.000022,2,0.000011,use if "$]" >= 5.022, experimental => 're_strict';
0.000018,2,0.000009,no if "$]" >= 5.031009, feature => 'indirect';
0.000018,2,0.000009,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000019,2,0.000010,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000027,3,0.000009,use JSON::Schema::Modern::Utilities 0.524 qw(assert_keyword_type annotate_self E is_type jsonp);
0.000440,2,0.000220,use namespace::clean;
0.000000,0,0.000000,
0.000002,1,0.000002,with 'JSON::Schema::Modern::Vocabulary';
0.000000,0,0.000000,
0.000000,0,0.000000,sub vocabulary {
0.000003,1,0.000003,'https://spec.openapis.org/oas/3.1/vocab/base' => 'draft2020-12',
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub keywords {
0.000003,1,0.000003,qw(discriminator example externalDocs xml);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_discriminator ($self, $schema, $state) {
0.000000,0,0.000000,return if not assert_keyword_type($state, $schema, 'object');
0.000000,0,0.000000,
0.000000,0,0.000000,# "the discriminator field MUST be a required field"
0.000000,0,0.000000,return E($state, 'missing required field propertyName')
0.000000,0,0.000000,if not exists $schema->{discriminator}{propertyName};
0.000000,0,0.000000,return E({ %$state, _schema_path_suffix => 'propertyName' }, 'discriminator propertyName is not a string')
0.000000,0,0.000000,if not is_type('string', $schema->{discriminator}{propertyName});
0.000000,0,0.000000,
0.000000,0,0.000000,my $valid = 1;
0.000000,0,0.000000,if (exists $schema->{discriminator}{mapping}) {
0.000000,0,0.000000,return if not assert_keyword_type({ %$state, _schema_path_suffix => 'mapping' }, $schema, 'object');
0.000000,0,0.000000,return E({ %$state, _schema_path_suffix => 'mapping' }, 'discriminator mapping is not an object ')
0.000000,0,0.000000,if not is_type('object', $schema->{discriminator}{mapping});
0.000000,0,0.000000,foreach my $mapping_key (sort keys $schema->{discriminator}{mapping}->%*) {
0.000000,0,0.000000,my $uri = $schema->{discriminator}{mapping}{$mapping_key};
0.000000,0,0.000000,$valid = E({ %$state, _schema_path_suffix => [ 'mapping', $mapping_key ] }, 'discriminator mapping value for "%s" is not a string', $mapping_key), next if not is_type('string', $uri);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = E($state, 'missing sibling keyword: one of oneOf, anyOf, allOf')
0.000000,0,0.000000,if not grep exists $schema->{$_}, qw(oneOf anyOf allOf);
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_discriminator ($self, $data, $schema, $state) {
0.000000,0,0.000000,# Note: the spec is unclear of the expected behaviour when the data instance is not an object
0.000000,0,0.000000,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,my $discriminator_key = $schema->{discriminator}{propertyName};
0.000000,0,0.000000,
0.000000,0,0.000000,# property with name <propertyName> MUST be present in the data payload
0.000000,0,0.000000,return E($state, 'missing required discriminator field "%s"', $discriminator_key)
0.000000,0,0.000000,if not exists $data->{$discriminator_key};
0.000000,0,0.000000,
0.000000,0,0.000000,my $discriminator_value = $data->{$discriminator_key};
0.000000,0,0.000000,
0.000000,0,0.000000,# if /components/$discriminator_value exists, that schema must validate
0.000000,0,0.000000,my $uri = Mojo::URL->new->fragment(jsonp('', qw(components schemas), $discriminator_value))
0.000000,0,0.000000,->to_abs($state->{initial_schema_uri});
0.000000,0,0.000000,if (my $component_schema_info = $state->{evaluator}->_fetch_from_uri($uri)) {
0.000000,0,0.000000,$state = { %$state, _schema_path_suffix => 'propertyName' };
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (exists $schema->{discriminator}{mapping} and exists $schema->{discriminator}{mapping}{$discriminator_value}) {
0.000000,0,0.000000,# use 'mapping' to determine which schema to use.
0.000000,0,0.000000,$uri = Mojo::URL->new($schema->{discriminator}{mapping}{$discriminator_value});
0.000000,0,0.000000,$state = { %$state, _schema_path_suffix => [ 'mapping', $discriminator_value ] };
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# If the discriminator value does not match an implicit or explicit mapping, no schema can be
0.000000,0,0.000000,# determined and validation SHOULD fail.
0.000000,0,0.000000,return E($state, 'invalid %s: "%s"', $discriminator_key, $discriminator_value);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return E($state, 'subschema for %s: %s is invalid', $discriminator_key, $discriminator_value)
0.000000,0,0.000000,if not $self->eval_subschema_at_uri($data, $schema, $state, $uri);
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_example { 1 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_example ($self, $data, $schema, $state) {
0.000000,0,0.000000,annotate_self($state, $schema);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# until we do something with these values, we do not bother checking the structure
0.000013,5,0.000003,sub _traverse_keyword_externalDocs { 1 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_externalDocs { goto \&_eval_keyword_example }
0.000000,0,0.000000,
0.000000,0,0.000000,# until we do something with these values, we do not bother checking the structure
0.000000,0,0.000000,sub _traverse_keyword_xml { 1 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_xml { goto \&_eval_keyword_example }
0.000000,0,0.000000,
0.000009,1,0.000009,1;
0.000000,0,0.000000,
0.000034,1,0.000034,__END__
