# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Method::Generate::Accessor;
0.000026,2,0.000013,use strict;
0.000018,2,0.000009,use warnings;
0.000000,0,0.000000,
0.000015,2,0.000007,use Moo::_Utils qw(_maybe_load_module _install_coderef _module_name_rx);
0.000020,2,0.000010,use Moo::Object ();
0.000021,1,0.000021,BEGIN { our @ISA = qw(Moo::Object) }
0.001147,2,0.000573,use Sub::Quote qw(quote_sub quoted_from_sub quotify sanitize_identifier);
0.000027,2,0.000013,use Scalar::Util 'blessed';
0.000067,2,0.000034,use Carp qw(croak);
0.000000,0,0.000000,BEGIN {
0.000014,1,0.000014,our @CARP_NOT = qw(
0.000000,0,0.000000,Moo::_Utils
0.000000,0,0.000000,Moo::Object
0.000000,0,0.000000,Moo::Role
0.000000,0,0.000000,);
0.000204,1,0.000204,}
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,*_CAN_WEAKEN_READONLY = (
0.000000,0,0.000000,"$]" < 5.008_003 or $ENV{MOO_TEST_PRE_583}
0.000005,1,0.000005,) ? sub(){0} : sub(){1};
0.000000,0,0.000000,our $CAN_HAZ_XS =
0.000000,0,0.000000,!$ENV{MOO_XS_DISABLE}
0.000000,0,0.000000,&&
0.000000,0,0.000000,_maybe_load_module('Class::XSAccessor')
0.000000,0,0.000000,&&
0.000010,1,0.000010,(eval { Class::XSAccessor->VERSION('1.07') })
0.000000,0,0.000000,;
0.000000,0,0.000000,our $CAN_HAZ_XS_PRED =
0.000000,0,0.000000,$CAN_HAZ_XS &&
0.000004,1,0.000004,(eval { Class::XSAccessor->VERSION('1.17') })
0.000000,0,0.000000,;
0.000046,1,0.000046,}
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,package
0.000000,0,0.000000,Method::Generate::Accessor::_Generated;
0.000002,1,0.000002,$Carp::Internal{+__PACKAGE__} = 1;
0.002445,1,0.002445,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _die_overwrite {
0.000000,0,0.000000,my ($pkg, $method, $type) = @_;
0.000000,0,0.000000,croak "You cannot overwrite a locally defined method ($method) with "
0.000000,0,0.000000,. ( $type || 'an accessor' );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub generate_method {
0.000023,49,0.000000,my ($self, $into, $name, $spec, $quote_opts) = @_;
0.000000,0,0.000000,$quote_opts = {
0.000000,0,0.000000,no_defer => 1,
0.000000,0,0.000000,package => 'Method::Generate::Accessor::_Generated',
0.000096,49,0.000002,%{ $quote_opts||{} },
0.000000,0,0.000000,};
0.000070,49,0.000001,$spec->{allow_overwrite}++ if $name =~ s/^\+//;
0.000026,49,0.000001,croak "Must have an is" unless my $is = $spec->{is};
0.000084,49,0.000002,if ($is eq 'ro') {
0.000000,0,0.000000,$spec->{reader} = $name unless exists $spec->{reader};
0.000000,0,0.000000,} elsif ($is eq 'rw') {
0.000000,0,0.000000,$spec->{accessor} = $name unless exists $spec->{accessor}
0.000000,0,0.000000,or ( $spec->{reader} and $spec->{writer} );
0.000000,0,0.000000,} elsif ($is eq 'lazy') {
0.000000,0,0.000000,$spec->{reader} = $name unless exists $spec->{reader};
0.000000,0,0.000000,$spec->{lazy} = 1;
0.000000,0,0.000000,$spec->{builder} ||= '_build_'.$name unless exists $spec->{default};
0.000000,0,0.000000,} elsif ($is eq 'rwp') {
0.000005,6,0.000001,$spec->{reader} = $name unless exists $spec->{reader};
0.000006,6,0.000001,$spec->{writer} = "_set_${name}" unless exists $spec->{writer};
0.000000,0,0.000000,} elsif ($is ne 'bare') {
0.000000,0,0.000000,croak "Unknown is ${is}";
0.000000,0,0.000000,}
0.000011,49,0.000000,if (exists $spec->{builder}) {
0.000000,0,0.000000,if(ref $spec->{builder}) {
0.000000,0,0.000000,$self->_validate_codulatable('builder', $spec->{builder},
0.000000,0,0.000000,"$into->$name", 'or a method name');
0.000000,0,0.000000,$spec->{builder_sub} = $spec->{builder};
0.000000,0,0.000000,$spec->{builder} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,$spec->{builder} = '_build_'.$name if ($spec->{builder}||0) eq 1;
0.000000,0,0.000000,croak "Invalid builder for $into->$name - not a valid method name"
0.000000,0,0.000000,if $spec->{builder} !~ _module_name_rx;
0.000000,0,0.000000,}
0.000030,49,0.000001,if (($spec->{predicate}||0) eq 1) {
0.000000,0,0.000000,$spec->{predicate} = $name =~ /^_/ ? "_has${name}" : "has_${name}";
0.000000,0,0.000000,}
0.000020,49,0.000000,if (($spec->{clearer}||0) eq 1) {
0.000000,0,0.000000,$spec->{clearer} = $name =~ /^_/ ? "_clear${name}" : "clear_${name}";
0.000000,0,0.000000,}
0.000020,49,0.000000,if (($spec->{trigger}||0) eq 1) {
0.000000,0,0.000000,$spec->{trigger} = quote_sub('shift->_trigger_'.$name.'(@_)');
0.000000,0,0.000000,}
0.000020,49,0.000000,if (($spec->{coerce}||0) eq 1) {
0.000000,0,0.000000,my $isa = $spec->{isa};
0.000000,0,0.000000,if (blessed $isa and $isa->can('coercion')) {
0.000000,0,0.000000,$spec->{coerce} = $isa->coercion;
0.000000,0,0.000000,} elsif (blessed $isa and $isa->can('coerce')) {
0.000000,0,0.000000,$spec->{coerce} = sub { $isa->coerce(@_) };
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak "Invalid coercion for $into->$name - no appropriate type constraint";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000030,49,0.000001,foreach my $setting (qw( isa coerce )) {
0.000017,98,0.000000,next if !exists $spec->{$setting};
0.000137,59,0.000002,$self->_validate_codulatable($setting, $spec->{$setting}, "$into->$name");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000046,49,0.000001,if (exists $spec->{default}) {
0.000000,0,0.000000,if (ref $spec->{default}) {
0.000000,0,0.000000,$self->_validate_codulatable('default', $spec->{default}, "$into->$name",
0.000000,0,0.000000,'or a non-ref');
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000016,49,0.000000,if (exists $spec->{moosify}) {
0.000011,12,0.000001,if (ref $spec->{moosify} ne 'ARRAY') {
0.000000,0,0.000000,$spec->{moosify} = [$spec->{moosify}];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000011,12,0.000001,foreach my $spec (@{$spec->{moosify}}) {
0.000012,12,0.000001,$self->_validate_codulatable('moosify', $spec, "$into->$name");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000011,49,0.000000,my %methods;
0.000044,49,0.000001,if (my $reader = $spec->{reader}) {
0.000000,0,0.000000,_die_overwrite($into, $reader, 'a reader')
0.000082,34,0.000002,if !$spec->{allow_overwrite} && defined &{"${into}::${reader}"};
0.000015,34,0.000000,if (our $CAN_HAZ_XS && $self->is_simple_get($name, $spec)) {
0.000000,0,0.000000,$methods{$reader} = $self->_generate_xs(
0.000000,0,0.000000,getters => $into, $reader, $name, $spec
0.000000,0,0.000000,);
0.000000,0,0.000000,} else {
0.000017,34,0.000001,$self->{captures} = {};
0.000000,0,0.000000,$methods{$reader} =
0.000000,0,0.000000,quote_sub "${into}::${reader}"
0.000000,0,0.000000,=> '    Carp::croak("'.$reader.' is a read-only accessor") if @_ > 1;'."\n"
0.000000,0,0.000000,.$self->_generate_get($name, $spec)
0.000000,0,0.000000,=> delete $self->{captures}
0.000160,34,0.000005,=> $quote_opts
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000051,49,0.000001,if (my $accessor = $spec->{accessor}) {
0.000000,0,0.000000,_die_overwrite($into, $accessor, 'an accessor')
0.000008,3,0.000003,if !$spec->{allow_overwrite} && defined &{"${into}::${accessor}"};
0.000003,3,0.000001,if (
0.000000,0,0.000000,our $CAN_HAZ_XS
0.000000,0,0.000000,&& $self->is_simple_get($name, $spec)
0.000000,0,0.000000,&& $self->is_simple_set($name, $spec)
0.000000,0,0.000000,) {
0.000000,0,0.000000,$methods{$accessor} = $self->_generate_xs(
0.000000,0,0.000000,accessors => $into, $accessor, $name, $spec
0.000000,0,0.000000,);
0.000000,0,0.000000,} else {
0.000002,3,0.000001,$self->{captures} = {};
0.000000,0,0.000000,$methods{$accessor} =
0.000000,0,0.000000,quote_sub "${into}::${accessor}"
0.000000,0,0.000000,=> $self->_generate_getset($name, $spec)
0.000000,0,0.000000,=> delete $self->{captures}
0.000013,3,0.000004,=> $quote_opts
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000020,49,0.000000,if (my $writer = $spec->{writer}) {
0.000000,0,0.000000,_die_overwrite($into, $writer, 'a writer')
0.000014,7,0.000002,if !$spec->{allow_overwrite} && defined &{"${into}::${writer}"};
0.000005,7,0.000001,if (
0.000000,0,0.000000,our $CAN_HAZ_XS
0.000000,0,0.000000,&& $self->is_simple_set($name, $spec)
0.000000,0,0.000000,) {
0.000000,0,0.000000,$methods{$writer} = $self->_generate_xs(
0.000000,0,0.000000,setters => $into, $writer, $name, $spec
0.000000,0,0.000000,);
0.000000,0,0.000000,} else {
0.000006,7,0.000001,$self->{captures} = {};
0.000000,0,0.000000,$methods{$writer} =
0.000000,0,0.000000,quote_sub "${into}::${writer}"
0.000000,0,0.000000,=> $self->_generate_set($name, $spec)
0.000000,0,0.000000,=> delete $self->{captures}
0.000028,7,0.000004,=> $quote_opts
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000026,49,0.000001,if (my $pred = $spec->{predicate}) {
0.000000,0,0.000000,_die_overwrite($into, $pred, 'a predicate')
0.000000,0,0.000000,if !$spec->{allow_overwrite} && defined &{"${into}::${pred}"};
0.000000,0,0.000000,if (our $CAN_HAZ_XS && our $CAN_HAZ_XS_PRED) {
0.000000,0,0.000000,$methods{$pred} = $self->_generate_xs(
0.000000,0,0.000000,exists_predicates => $into, $pred, $name, $spec
0.000000,0,0.000000,);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$self->{captures} = {};
0.000000,0,0.000000,$methods{$pred} =
0.000000,0,0.000000,quote_sub "${into}::${pred}"
0.000000,0,0.000000,=> $self->_generate_simple_has('$_[0]', $name, $spec)."\n"
0.000000,0,0.000000,=> delete $self->{captures}
0.000000,0,0.000000,=> $quote_opts
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000017,49,0.000000,if (my $builder = delete $spec->{builder_sub}) {
0.000000,0,0.000000,_install_coderef( "${into}::$spec->{builder}" => $builder );
0.000000,0,0.000000,}
0.000011,49,0.000000,if (my $cl = $spec->{clearer}) {
0.000000,0,0.000000,_die_overwrite($into, $cl, 'a clearer')
0.000000,0,0.000000,if !$spec->{allow_overwrite} && defined &{"${into}::${cl}"};
0.000000,0,0.000000,$self->{captures} = {};
0.000000,0,0.000000,$methods{$cl} =
0.000000,0,0.000000,quote_sub "${into}::${cl}"
0.000000,0,0.000000,=> $self->_generate_simple_clear('$_[0]', $name, $spec)."\n"
0.000000,0,0.000000,=> delete $self->{captures}
0.000000,0,0.000000,=> $quote_opts
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000024,49,0.000000,if (my $hspec = $spec->{handles}) {
0.000023,14,0.000002,my $asserter = $spec->{asserter} ||= '_assert_'.$name;
0.000008,14,0.000001,my @specs = do {
0.000040,14,0.000003,if (ref($hspec) eq 'ARRAY') {
0.000000,0,0.000000,map [ $_ => $_ ], @$hspec;
0.000000,0,0.000000,} elsif (ref($hspec) eq 'HASH') {
0.000000,0,0.000000,map [ $_ => ref($hspec->{$_}) ? @{$hspec->{$_}} : $hspec->{$_} ],
0.000000,0,0.000000,keys %$hspec;
0.000000,0,0.000000,} elsif (!ref($hspec)) {
0.000000,0,0.000000,require Moo::Role;
0.000000,0,0.000000,map [ $_ => $_ ], Moo::Role->methods_provided_by($hspec)
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak "You gave me a handles of ${hspec} and I have no idea why";
0.000000,0,0.000000,}
0.000000,0,0.000000,};
0.000016,14,0.000001,foreach my $delegation_spec (@specs) {
0.000024,41,0.000001,my ($proxy, $target, @args) = @$delegation_spec;
0.000000,0,0.000000,_die_overwrite($into, $proxy, 'a delegation')
0.000154,41,0.000004,if !$spec->{allow_overwrite} && defined &{"${into}::${proxy}"};
0.000020,41,0.000000,$self->{captures} = {};
0.000000,0,0.000000,$methods{$proxy} =
0.000000,0,0.000000,quote_sub "${into}::${proxy}"
0.000000,0,0.000000,=> $self->_generate_delegation($asserter, $target, \@args)
0.000000,0,0.000000,=> delete $self->{captures}
0.000173,41,0.000004,=> $quote_opts
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000027,49,0.000001,if (my $asserter = $spec->{asserter}) {
0.000000,0,0.000000,_die_overwrite($into, $asserter, 'an asserter')
0.000028,14,0.000002,if !$spec->{allow_overwrite} && defined &{"${into}::${asserter}"};
0.000010,14,0.000001,local $self->{captures} = {};
0.000000,0,0.000000,$methods{$asserter} =
0.000000,0,0.000000,quote_sub "${into}::${asserter}"
0.000000,0,0.000000,=> $self->_generate_asserter($name, $spec)
0.000000,0,0.000000,=> delete $self->{captures}
0.000066,14,0.000005,=> $quote_opts
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000145,49,0.000003,\%methods;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub merge_specs {
0.000002,2,0.000001,my ($self, @specs) = @_;
0.000001,2,0.000000,my $spec = shift @specs;
0.000001,2,0.000000,for my $old_spec (@specs) {
0.000004,2,0.000002,foreach my $key (keys %$old_spec) {
0.000014,12,0.000001,if ($key eq 'handles') {
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($key eq 'moosify') {
0.000000,0,0.000000,$spec->{$key} = [
0.000000,0,0.000000,map { ref $_ eq 'ARRAY' ? @$_ : $_ }
0.000000,0,0.000000,grep defined,
0.000000,0,0.000000,($old_spec->{$key}, $spec->{$key})
0.000000,0,0.000000,];
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($key eq 'builder' || $key eq 'default') {
0.000000,0,0.000000,$spec->{$key} = $old_spec->{$key}
0.000000,0,0.000000,if !(exists $spec->{builder} || exists $spec->{default});
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (!exists $spec->{$key}) {
0.000000,0,0.000000,$spec->{$key} = $old_spec->{$key};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000006,2,0.000003,$spec;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_simple_attribute {
0.000000,0,0.000000,my ($self, $name, $spec) = @_;
0.000000,0,0.000000,# clearer doesn't have to be listed because it doesn't
0.000000,0,0.000000,# affect whether defined/exists makes a difference
0.000000,0,0.000000,!grep $spec->{$_},
0.000000,0,0.000000,qw(lazy default builder coerce isa trigger predicate weak_ref);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_simple_get {
0.000017,51,0.000000,my ($self, $name, $spec) = @_;
0.000078,51,0.000002,!($spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_simple_set {
0.000005,10,0.000000,my ($self, $name, $spec) = @_;
0.000048,10,0.000005,!grep $spec->{$_}, qw(coerce isa trigger weak_ref);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_default {
0.000004,13,0.000000,my ($self, $name, $spec) = @_;
0.000028,13,0.000002,$spec->{builder} or exists $spec->{default} or (($spec->{is}||'') eq 'lazy');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_eager_default {
0.000015,55,0.000000,my ($self, $name, $spec) = @_;
0.000114,55,0.000002,(!$spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_get {
0.000019,51,0.000000,my ($self, $name, $spec) = @_;
0.000069,51,0.000001,my $simple = $self->_generate_simple_get('$_[0]', $name, $spec);
0.000135,51,0.000003,if ($self->is_simple_get($name, $spec)) {
0.000000,0,0.000000,$simple;
0.000000,0,0.000000,} else {
0.000063,17,0.000004,$self->_generate_use_default(
0.000000,0,0.000000,'$_[0]', $name, $spec,
0.000000,0,0.000000,$self->_generate_simple_has('$_[0]', $name, $spec),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub generate_simple_has {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->{captures} = {};
0.000000,0,0.000000,my $code = $self->_generate_simple_has(@_);
0.000000,0,0.000000,($code, delete $self->{captures});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_simple_has {
0.000017,31,0.000001,my ($self, $me, $name) = @_;
0.000115,31,0.000004,"exists ${me}->{${\quotify $name}}";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_simple_clear {
0.000000,0,0.000000,my ($self, $me, $name) = @_;
0.000000,0,0.000000,"    delete ${me}->{${\quotify $name}}\n"
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub generate_get_default {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->{captures} = {};
0.000000,0,0.000000,my $code = $self->_generate_get_default(@_);
0.000000,0,0.000000,($code, delete $self->{captures});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub generate_use_default {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->{captures} = {};
0.000000,0,0.000000,my $code = $self->_generate_use_default(@_);
0.000000,0,0.000000,($code, delete $self->{captures});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_use_default {
0.000009,17,0.000001,my ($self, $me, $name, $spec, $test) = @_;
0.000026,17,0.000002,my $get_value = $self->_generate_get_default($me, $name, $spec);
0.000015,17,0.000001,if ($spec->{coerce}) {
0.000000,0,0.000000,$get_value = $self->_generate_coerce(
0.000000,0,0.000000,$name, $get_value,
0.000000,0,0.000000,$spec->{coerce}
0.000000,0,0.000000,)
0.000000,0,0.000000,}
0.000000,0,0.000000,$test." ? \n"
0.000000,0,0.000000,.$self->_generate_simple_get($me, $name, $spec)."\n:"
0.000000,0,0.000000,.($spec->{isa} ?
0.000000,0,0.000000,"    do {\n      my \$value = ".$get_value.";\n"
0.000183,17,0.000011,."      ".$self->_generate_isa_check($name, '$value', $spec->{isa}).";\n"
0.000000,0,0.000000,."      ".$self->_generate_simple_set($me, $name, $spec, '$value')."\n"
0.000000,0,0.000000,."    }\n"
0.000000,0,0.000000,: '    ('.$self->_generate_simple_set($me, $name, $spec, $get_value).")\n"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_get_default {
0.000011,23,0.000000,my ($self, $me, $name, $spec) = @_;
0.000073,23,0.000003,if (exists $spec->{default}) {
0.000000,0,0.000000,ref $spec->{default}
0.000000,0,0.000000,? $self->_generate_call_code($name, 'default', $me, $spec->{default})
0.000000,0,0.000000,: quotify $spec->{default};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,"${me}->${\$spec->{builder}}"
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub generate_simple_get {
0.000000,0,0.000000,my ($self, @args) = @_;
0.000000,0,0.000000,$self->{captures} = {};
0.000000,0,0.000000,my $code = $self->_generate_simple_get(@args);
0.000000,0,0.000000,($code, delete $self->{captures});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_simple_get {
0.000030,82,0.000000,my ($self, $me, $name) = @_;
0.000086,82,0.000001,my $name_str = quotify $name;
0.000144,82,0.000002,"${me}->{${name_str}}";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_set {
0.000004,10,0.000000,my ($self, $name, $spec) = @_;
0.000005,10,0.000000,my ($me, $source) = ('$_[0]', '$_[1]');
0.000015,10,0.000001,if ($self->is_simple_set($name, $spec)) {
0.000000,0,0.000000,return $self->_generate_simple_set($me, $name, $spec, $source);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000011,10,0.000001,my ($coerce, $trigger, $isa_check) = @{$spec}{qw(coerce trigger isa)};
0.000011,10,0.000001,if ($coerce) {
0.000000,0,0.000000,$source = $self->_generate_coerce($name, $source, $coerce);
0.000000,0,0.000000,}
0.000083,10,0.000008,if ($isa_check) {
0.000000,0,0.000000,'scalar do { my $value = '.$source.";\n"
0.000000,0,0.000000,.'  ('.$self->_generate_isa_check($name, '$value', $isa_check)."),\n"
0.000000,0,0.000000,.'  ('.$self->_generate_simple_set($me, $name, $spec, '$value')."),\n"
0.000000,0,0.000000,.($trigger
0.000000,0,0.000000,? '('.$self->_generate_trigger($name, $me, '$value', $trigger)."),\n"
0.000000,0,0.000000,: '')
0.000000,0,0.000000,.'  ('.$self->_generate_simple_get($me, $name, $spec)."),\n"
0.000000,0,0.000000,."}";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($trigger) {
0.000000,0,0.000000,my $set = $self->_generate_simple_set($me, $name, $spec, $source);
0.000000,0,0.000000,"scalar (\n"
0.000000,0,0.000000,. '  ('.$self->_generate_trigger($name, $me, "($set)", $trigger)."),\n"
0.000000,0,0.000000,. '  ('.$self->_generate_simple_get($me, $name, $spec)."),\n"
0.000000,0,0.000000,. ")";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,'('.$self->_generate_simple_set($me, $name, $spec, $source).')';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub generate_coerce {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->{captures} = {};
0.000000,0,0.000000,my $code = $self->_generate_coerce(@_);
0.000000,0,0.000000,($code, delete $self->{captures});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _attr_desc {
0.000005,20,0.000000,my ($name, $init_arg) = @_;
0.000438,20,0.000022,return quotify($name) if !defined($init_arg) or $init_arg eq $name;
0.000000,0,0.000000,return quotify($name).' (constructor argument: '.quotify($init_arg).')';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_coerce {
0.000010,20,0.000001,my ($self, $name, $value, $coerce, $init_arg) = @_;
0.000140,20,0.000007,$self->_wrap_attr_exception(
0.000000,0,0.000000,$name,
0.000000,0,0.000000,"coercion",
0.000000,0,0.000000,$init_arg,
0.000000,0,0.000000,$self->_generate_call_code($name, 'coerce', "${value}", $coerce),
0.000000,0,0.000000,1,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub generate_trigger {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->{captures} = {};
0.000000,0,0.000000,my $code = $self->_generate_trigger(@_);
0.000000,0,0.000000,($code, delete $self->{captures});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_trigger {
0.000000,0,0.000000,my ($self, $name, $obj, $value, $trigger) = @_;
0.000000,0,0.000000,$self->_generate_call_code($name, 'trigger', "${obj}, ${value}", $trigger);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub generate_isa_check {
0.000000,0,0.000000,my ($self, @args) = @_;
0.000000,0,0.000000,$self->{captures} = {};
0.000000,0,0.000000,my $code = $self->_generate_isa_check(@args);
0.000000,0,0.000000,($code, delete $self->{captures});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _wrap_attr_exception {
0.000011,20,0.000001,my ($self, $name, $step, $arg, $code, $want_return) = @_;
0.000085,20,0.000004,my $prefix = quotify("${step} for "._attr_desc($name, $arg).' failed: ');
0.000115,20,0.000006,"do {\n"
0.000000,0,0.000000,.'  local $Method::Generate::Accessor::CurrentAttribute = {'."\n"
0.000000,0,0.000000,.'    init_arg => '.quotify($arg).",\n"
0.000000,0,0.000000,.'    name     => '.quotify($name).",\n"
0.000000,0,0.000000,.'    step     => '.quotify($step).",\n"
0.000000,0,0.000000,."  };\n"
0.000000,0,0.000000,.($want_return ? '  (my $_return),'."\n" : '')
0.000000,0,0.000000,.'  (my $_error), (my $_old_error = $@);'."\n"
0.000000,0,0.000000,."  (eval {\n"
0.000000,0,0.000000,.'    ($@ = $_old_error),'."\n"
0.000000,0,0.000000,.'    ('
0.000000,0,0.000000,.($want_return ? '$_return ='."\n" : '')
0.000000,0,0.000000,.$code."),\n"
0.000000,0,0.000000,."    1\n"
0.000000,0,0.000000,."  } or\n"
0.000000,0,0.000000,.'    $_error = CORE::ref $@ ? $@ : '.$prefix.'.$@);'."\n"
0.000000,0,0.000000,.'  ($@ = $_old_error),'."\n"
0.000000,0,0.000000,.'  (defined $_error and CORE::die $_error);'."\n"
0.000000,0,0.000000,.($want_return ? '  $_return;'."\n" : '')
0.000000,0,0.000000,."}\n"
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_isa_check {
0.000000,0,0.000000,my ($self, $name, $value, $check, $init_arg) = @_;
0.000000,0,0.000000,$self->_wrap_attr_exception(
0.000000,0,0.000000,$name,
0.000000,0,0.000000,"isa check",
0.000000,0,0.000000,$init_arg,
0.000000,0,0.000000,$self->_generate_call_code($name, 'isa_check', $value, $check)
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_call_code {
0.000017,37,0.000000,my ($self, $name, $type, $values, $sub) = @_;
0.000079,37,0.000002,$sub = \&{$sub} if blessed($sub);  # coderef if blessed
0.000120,37,0.000003,if (my $quoted = quoted_from_sub($sub)) {
0.000000,0,0.000000,my $local = 1;
0.000000,0,0.000000,if ($values eq '@_' || $values eq '$_[0]') {
0.000000,0,0.000000,$local = 0;
0.000000,0,0.000000,$values = '@_';
0.000000,0,0.000000,}
0.000000,0,0.000000,my $code = $quoted->[1];
0.000000,0,0.000000,if (my $captures = $quoted->[2]) {
0.000000,0,0.000000,my $cap_name = qq{\$${type}_captures_for_}.sanitize_identifier($name);
0.000000,0,0.000000,$self->{captures}->{$cap_name} = \$captures;
0.000000,0,0.000000,Sub::Quote::inlinify($code, $values,
0.000000,0,0.000000,Sub::Quote::capture_unroll($cap_name, $captures, 6), $local);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,Sub::Quote::inlinify($code, $values, undef, $local);
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000066,37,0.000002,my $cap_name = qq{\$${type}_for_}.sanitize_identifier($name);
0.000030,37,0.000001,$self->{captures}->{$cap_name} = \$sub;
0.000010,37,0.000000,"${cap_name}->(${values})";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _sanitize_name { sanitize_identifier($_[1]) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub generate_populate_set {
0.000011,49,0.000000,my $self = shift;
0.000018,49,0.000000,$self->{captures} = {};
0.000053,49,0.000001,my $code = $self->_generate_populate_set(@_);
0.000068,49,0.000001,($code, delete $self->{captures});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_populate_set {
0.000016,49,0.000000,my ($self, $me, $name, $spec, $source, $test, $init_arg) = @_;
0.000000,0,0.000000,
0.000066,49,0.000001,my $has_default = $self->has_eager_default($name, $spec);
0.000004,49,0.000000,if (!($has_default || $test)) {
0.000000,0,0.000000,return '';
0.000000,0,0.000000,}
0.000010,49,0.000000,if ($has_default) {
0.000026,6,0.000004,my $get_default = $self->_generate_get_default($me, $name, $spec);
0.000007,6,0.000001,$source =
0.000000,0,0.000000,$test
0.000000,0,0.000000,? "(\n  ${test}\n"
0.000000,0,0.000000,."   ? ${source}\n   : "
0.000000,0,0.000000,.$get_default
0.000000,0,0.000000,.")"
0.000000,0,0.000000,: $get_default;
0.000000,0,0.000000,}
0.000048,49,0.000001,if ($spec->{coerce}) {
0.000000,0,0.000000,$source = $self->_generate_coerce(
0.000000,0,0.000000,$name, $source,
0.000000,0,0.000000,$spec->{coerce}, $init_arg
0.000000,0,0.000000,)
0.000000,0,0.000000,}
0.000249,49,0.000005,if ($spec->{isa}) {
0.000000,0,0.000000,$source = 'scalar do { my $value = '.$source.";\n"
0.000000,0,0.000000,.'  ('.$self->_generate_isa_check(
0.000000,0,0.000000,$name, '$value', $spec->{isa}, $init_arg
0.000000,0,0.000000,)."),\n"
0.000000,0,0.000000,."  \$value\n"
0.000000,0,0.000000,."}\n";
0.000000,0,0.000000,}
0.000060,49,0.000001,my $set = $self->_generate_simple_set($me, $name, $spec, $source);
0.000000,0,0.000000,my $trigger = $spec->{trigger} ? $self->_generate_trigger(
0.000000,0,0.000000,$name, $me, $self->_generate_simple_get($me, $name, $spec),
0.000000,0,0.000000,$spec->{trigger}
0.000020,49,0.000000,) : undef;
0.000091,49,0.000002,if ($has_default) {
0.000000,0,0.000000,"($set)," . ($trigger && $test ? "($test and $trigger)," : '') . "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000046,43,0.000001,"($test and ($set)" . ($trigger ? ", ($trigger)" : '') . "),\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_core_set {
0.000036,76,0.000000,my ($self, $me, $name, $spec, $value) = @_;
0.000063,76,0.000001,my $name_str = quotify $name;
0.000141,76,0.000002,"${me}->{${name_str}} = ${value}";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_simple_set {
0.000050,76,0.000001,my ($self, $me, $name, $spec, $value) = @_;
0.000058,76,0.000001,my $name_str = quotify $name;
0.000076,76,0.000001,my $simple = $self->_generate_core_set($me, $name, $spec, $value);
0.000000,0,0.000000,
0.000118,76,0.000002,if ($spec->{weak_ref}) {
0.000002,4,0.000000,require Scalar::Util;
0.000007,4,0.000002,my $get = $self->_generate_simple_get($me, $name, $spec);
0.000000,0,0.000000,
0.000000,0,0.000000,# Perl < 5.8.3 can't weaken refs to readonly vars
0.000000,0,0.000000,# (e.g. string constants). This *can* be solved by:
0.000000,0,0.000000,#
0.000000,0,0.000000,# &Internals::SvREADONLY($foo, 0);
0.000000,0,0.000000,# Scalar::Util::weaken($foo);
0.000000,0,0.000000,# &Internals::SvREADONLY($foo, 1);
0.000000,0,0.000000,#
0.000000,0,0.000000,# but requires Internal functions and is just too damn crazy
0.000000,0,0.000000,# so simply throw a better exception
0.000003,4,0.000001,my $weak_simple = _CAN_WEAKEN_READONLY
0.000000,0,0.000000,? "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }"
0.000000,0,0.000000,: <<"EOC"
0.000000,0,0.000000,( eval { Scalar::Util::weaken($simple); 1 }
0.000000,0,0.000000,? do { no warnings 'void'; $get }
0.000000,0,0.000000,: do {
0.000000,0,0.000000,if( \$@ =~ /Modification of a read-only value attempted/) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak( sprintf (
0.000000,0,0.000000,'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
0.000000,0,0.000000,$name_str,
0.000000,0,0.000000,) );
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die \$@;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,)
0.000000,0,0.000000,EOC
0.000000,0,0.000000,} else {
0.000010,72,0.000000,$simple;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_getset {
0.000002,3,0.000001,my ($self, $name, $spec) = @_;
0.000016,3,0.000005,q{(@_ > 1}."\n      ? ".$self->_generate_set($name, $spec)
0.000000,0,0.000000,."\n      : ".$self->_generate_get($name, $spec)."\n    )";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_asserter {
0.000011,14,0.000001,my ($self, $name, $spec) = @_;
0.000017,14,0.000001,my $name_str = quotify($name);
0.000115,14,0.000008,"do {\n"
0.000000,0,0.000000,."  my \$val = ".$self->_generate_get($name, $spec).";\n"
0.000000,0,0.000000,."  ".$self->_generate_simple_has('$_[0]', $name, $spec)."\n"
0.000000,0,0.000000,."    or Carp::croak(q{Attempted to access '}.${name_str}.q{' but it is not set});\n"
0.000000,0,0.000000,."  \$val;\n"
0.000000,0,0.000000,."}\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,sub _generate_delegation {
0.000018,41,0.000000,my ($self, $asserter, $target, $args) = @_;
0.000015,41,0.000000,my $arg_string = do {
0.000020,41,0.000000,if (@$args) {
0.000000,0,0.000000,# I could, I reckon, linearise out non-refs here using quotify
0.000000,0,0.000000,# plus something to check for numbers but I'm unsure if it's worth it
0.000000,0,0.000000,$self->{captures}{'@curries'} = $args;
0.000000,0,0.000000,'@curries, @_';
0.000000,0,0.000000,} else {
0.000010,41,0.000000,'@_';
0.000000,0,0.000000,}
0.000000,0,0.000000,};
0.000082,41,0.000002,"shift->${asserter}->${target}(${arg_string});";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_xs {
0.000000,0,0.000000,my ($self, $type, $into, $name, $slot) = @_;
0.000000,0,0.000000,Class::XSAccessor->import(
0.000000,0,0.000000,class => $into,
0.000000,0,0.000000,$type => { $name => $slot },
0.000000,0,0.000000,replace => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,$into->can($name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000009,5,0.000002,sub default_construction_string { '{}' }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _validate_codulatable {
0.000027,88,0.000000,my ($self, $setting, $value, $into, $appended) = @_;
0.000000,0,0.000000,
0.000005,88,0.000000,my $error;
0.000000,0,0.000000,
0.000273,88,0.000003,if (blessed $value) {
0.000009,47,0.000000,local $@;
0.000151,2,0.000076,no warnings 'void';
0.000211,141,0.000001,eval { \&$value; 1 }
0.000000,0,0.000000,and return 1;
0.000000,0,0.000000,$error = "could not be converted to a coderef: $@";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (ref $value eq 'CODE') {
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$error = 'is not a coderef or code-convertible object';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,croak "Invalid $setting '"
0.000000,0,0.000000,. ($INC{'overload.pm'} ? overload::StrVal($value) : $value)
0.000000,0,0.000000,. "' for $into " . $error
0.000000,0,0.000000,. ($appended ? " $appended" : '');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,1;
