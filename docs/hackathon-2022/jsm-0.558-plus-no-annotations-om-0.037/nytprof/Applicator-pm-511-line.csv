# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000028,2,0.000014,use strict;
0.000035,2,0.000018,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Vocabulary::Applicator;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Implementation of the JSON Schema Applicator vocabulary
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.559';
0.000000,0,0.000000,
0.000027,2,0.000013,use 5.020;
0.000025,2,0.000013,use Moo;
0.000027,3,0.000009,use strictures 2;
0.000059,2,0.000029,use experimental qw(signatures postderef);
0.000022,2,0.000011,use if "$]" >= 5.022, experimental => 're_strict';
0.000020,2,0.000010,no if "$]" >= 5.031009, feature => 'indirect';
0.000017,2,0.000008,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000016,2,0.000008,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000029,3,0.000010,use List::Util 1.45 qw(any uniqstr);
0.000022,3,0.000007,use Ref::Util 0.100 'is_plain_arrayref';
0.000654,2,0.000327,use Sub::Install;
0.000021,2,0.000010,use JSON::Schema::Modern::Utilities qw(is_type jsonp E A assert_keyword_type assert_pattern true is_elements_unique);
0.000363,2,0.000182,use JSON::Schema::Modern::Vocabulary::Unevaluated;
0.004226,2,0.002113,use namespace::clean;
0.000000,0,0.000000,
0.000002,1,0.000002,with 'JSON::Schema::Modern::Vocabulary';
0.000000,0,0.000000,
0.000000,0,0.000000,sub vocabulary {
0.000003,1,0.000003,'https://json-schema.org/draft/2019-09/vocab/applicator' => 'draft2019-09',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/vocab/applicator' => 'draft2020-12';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,4,0.000001,sub evaluation_order { 1 }
0.000000,0,0.000000,
0.000000,0,0.000000,# the keyword order is arbitrary, except:
0.000000,0,0.000000,# - if must be evaluated before then, else
0.000000,0,0.000000,# - items must be evaluated before additionalItems
0.000000,0,0.000000,# - in-place applicators (allOf, anyOf, oneOf, not, if/then/else, dependentSchemas) and items,
0.000000,0,0.000000,#   additionalItems must be evaluated before unevaluatedItems (in the Unevaluated vocabulary)
0.000000,0,0.000000,# - properties and patternProperties must be evaluated before additionalProperties
0.000000,0,0.000000,# - in-place applicators and properties, patternProperties, additionalProperties must be evaluated
0.000000,0,0.000000,#   before unevaluatedProperties (in the Unevaluated vocabulary)
0.000000,0,0.000000,# - contains must be evaluated before maxContains, minContains (in the Validator vocabulary)
0.000002,6,0.000000,sub keywords ($self, $spec_version) {
0.000000,0,0.000000,return (
0.000045,2,0.000022,qw(allOf anyOf oneOf not if then else),
0.000000,0,0.000000,$spec_version eq 'draft7' ? 'dependencies' : 'dependentSchemas',
0.000000,0,0.000000,$spec_version !~ qr/^draft(7|2019-09)$/ ? 'prefixItems' : (),
0.000000,0,0.000000,'items',
0.000000,0,0.000000,$spec_version =~ qr/^draft(7|2019-09)$/ ? 'additionalItems' : (),
0.000000,0,0.000000,qw(contains properties patternProperties additionalProperties propertyNames),
0.000000,0,0.000000,$spec_version eq 'draft2019-09' ? qw(unevaluatedItems unevaluatedProperties) : (),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# in draft2019-09, the unevaluated keywords were part of the Applicator vocabulary
0.000001,1,0.000001,foreach my $phase (qw(traverse eval)) {
0.000002,2,0.000001,foreach my $type (qw(Items Properties)) {
0.000002,4,0.000000,my $method = '_'.$phase.'_keyword_unevaluated'.$type;
0.000000,0,0.000000,Sub::Install::install_sub({
0.000000,0,0.000000,as   => $method,
0.000000,0,0.000000,code => sub {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,JSON::Schema::Modern::Vocabulary::Unevaluated->$method(@_);
0.000000,0,0.000000,}
0.000020,4,0.000005,}),
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000089,22,0.000004,sub _traverse_keyword_allOf { shift->traverse_array_schemas(@_) }
0.000000,0,0.000000,
0.005620,29705,0.000000,sub _eval_keyword_allOf ($self, $data, $schema, $state) {
0.000877,5941,0.000000,my @invalid;
0.010298,5941,0.000002,foreach my $idx (0 .. $schema->{allOf}->$#*) {
0.325122,25474,0.000013,if ($self->eval($data, $schema->{allOf}[$idx], +{ %$state,
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/allOf/'.$idx })) {
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @invalid, $idx;
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.016454,5941,0.000003,return 1 if @invalid == 0;
0.000000,0,0.000000,
0.000000,0,0.000000,my $pl = @invalid > 1;
0.000000,0,0.000000,return E($state, 'subschema%s %s %s not valid', $pl?'s':'', join(', ', @invalid), $pl?'are':'is');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000130,31,0.000004,sub _traverse_keyword_anyOf { shift->traverse_array_schemas(@_) }
0.000000,0,0.000000,
0.001667,5860,0.000000,sub _eval_keyword_anyOf ($self, $data, $schema, $state) {
0.000383,1172,0.000000,my $valid = 0;
0.000259,1172,0.000000,my @errors;
0.002687,1172,0.000002,foreach my $idx (0 .. $schema->{anyOf}->$#*) {
0.000000,0,0.000000,next if not $self->eval($data, $schema->{anyOf}[$idx],
0.025628,2345,0.000011,+{ %$state, errors => \@errors, schema_path => $state->{schema_path}.'/anyOf/'.$idx });
0.000313,1173,0.000000,++$valid;
0.001021,1173,0.000001,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.005607,1172,0.000005,return 1 if $valid;
0.000000,0,0.000000,push $state->{errors}->@*, @errors;
0.000000,0,0.000000,return E($state, 'no subschemas are valid');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000080,21,0.000004,sub _traverse_keyword_oneOf { shift->traverse_array_schemas(@_) }
0.000000,0,0.000000,
0.000350,1520,0.000000,sub _eval_keyword_oneOf ($self, $data, $schema, $state) {
0.000095,304,0.000000,my (@valid, @errors);
0.000771,304,0.000003,foreach my $idx (0 .. $schema->{oneOf}->$#*) {
0.000000,0,0.000000,next if not $self->eval($data, $schema->{oneOf}[$idx],
0.006028,608,0.000010,+{ %$state, errors => \@errors, schema_path => $state->{schema_path}.'/oneOf/'.$idx });
0.000245,304,0.000001,push @valid, $idx;
0.000311,304,0.000001,last if @valid > 1 and $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001518,304,0.000005,return 1 if @valid == 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if (not @valid) {
0.000000,0,0.000000,push $state->{errors}->@*, @errors;
0.000000,0,0.000000,return E($state, 'no subschemas are valid');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return E($state, 'multiple subschemas are valid: '.join(', ', @valid));
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000077,14,0.000005,sub _traverse_keyword_not { shift->traverse_subschema(@_) }
0.000000,0,0.000000,
0.000005,20,0.000000,sub _eval_keyword_not ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not $self->eval($data, $schema->{not},
0.000000,0,0.000000,+{ %$state, schema_path => $state->{schema_path}.'/not',
0.000000,0,0.000000,short_circuit => $state->{short_circuit} || !$state->{collect_annotations},
0.000039,4,0.000010,errors => [] });
0.000000,0,0.000000,
0.000000,0,0.000000,return E($state, 'subschema is valid');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000217,63,0.000003,sub _traverse_keyword_if { shift->traverse_subschema(@_) }
0.000213,63,0.000003,sub _traverse_keyword_then { shift->traverse_subschema(@_) }
0.000052,15,0.000003,sub _traverse_keyword_else { shift->traverse_subschema(@_) }
0.000000,0,0.000000,
0.002996,15010,0.000000,sub _eval_keyword_if ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not exists $schema->{then} and not exists $schema->{else}
0.001354,3002,0.000000,and not $state->{collect_annotations};
0.000000,0,0.000000,my $keyword = $self->eval($data, $schema->{if},
0.000000,0,0.000000,+{ %$state, schema_path => $state->{schema_path}.'/if',
0.000000,0,0.000000,short_circuit => $state->{short_circuit} || !$state->{collect_annotations},
0.043044,3002,0.000014,errors => [],
0.000000,0,0.000000,})
0.000000,0,0.000000,? 'then' : 'else';
0.000000,0,0.000000,
0.003543,3002,0.000001,return 1 if not exists $schema->{$keyword};
0.000000,0,0.000000,return 1 if $self->eval($data, $schema->{$keyword},
0.023994,2207,0.000011,+{ %$state, schema_path => $state->{schema_path}.'/'.$keyword });
0.000000,0,0.000000,return E({ %$state, keyword => $keyword }, 'subschema is not valid');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000010,3,0.000003,sub _traverse_keyword_dependentSchemas { shift->traverse_object_schemas(@_) }
0.000000,0,0.000000,
0.000287,1520,0.000000,sub _eval_keyword_dependentSchemas ($self, $data, $schema, $state) {
0.000348,304,0.000001,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.000092,304,0.000000,my $valid = 1;
0.001189,304,0.000004,foreach my $property (sort keys $schema->{dependentSchemas}->%*) {
0.000099,304,0.000000,next if not exists $data->{$property};
0.000000,0,0.000000,
0.002177,289,0.000008,if ($self->eval($data, $schema->{dependentSchemas}{$property},
0.000000,0,0.000000,+{ %$state, schema_path => jsonp($state->{schema_path}, 'dependentSchemas', $property) })) {
0.000932,289,0.000003,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000077,304,0.000000,return E($state, 'not all dependencies are satisfied') if not $valid;
0.000871,304,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_dependencies ($self, $schema, $state) {
0.000000,0,0.000000,return if not assert_keyword_type($state, $schema, 'object');
0.000000,0,0.000000,
0.000000,0,0.000000,my $valid = 1;
0.000000,0,0.000000,foreach my $property (sort keys $schema->{dependencies}->%*) {
0.000000,0,0.000000,if (is_type('array', $schema->{dependencies}{$property})) {
0.000000,0,0.000000,# as in dependentRequired
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $index (0..$schema->{dependencies}{$property}->$#*) {
0.000000,0,0.000000,$valid = E({ %$state, _schema_path_suffix => [ $property, $index ] }, 'element #%d is not a string', $index)
0.000000,0,0.000000,if not is_type('string', $schema->{dependencies}{$property}[$index]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = E({ %$state, _schema_path_suffix => $property }, 'elements are not unique')
0.000000,0,0.000000,if not is_elements_unique($schema->{dependencies}{$property});
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# as in dependentSchemas
0.000000,0,0.000000,$valid = 0 if not $self->traverse_property_schema($schema, $state, $property);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_dependencies ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,my $valid = 1;
0.000000,0,0.000000,foreach my $property (sort keys $schema->{dependencies}->%*) {
0.000000,0,0.000000,next if not exists $data->{$property};
0.000000,0,0.000000,
0.000000,0,0.000000,if (is_type('array', $schema->{dependencies}{$property})) {
0.000000,0,0.000000,# as in dependentRequired
0.000000,0,0.000000,if (my @missing = grep !exists($data->{$_}), $schema->{dependencies}{$property}->@*) {
0.000000,0,0.000000,$valid = E({ %$state, _schema_path_suffix => $property },
0.000000,0,0.000000,'missing propert%s: %s', @missing > 1 ? 'ies' : 'y', join(', ', @missing));
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# as in dependentSchemas
0.000000,0,0.000000,if ($self->eval($data, $schema->{dependencies}{$property},
0.000000,0,0.000000,+{ %$state, schema_path => jsonp($state->{schema_path}, 'dependencies', $property) })) {
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return E($state, 'not all dependencies are satisfied') if not $valid;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_prefixItems { shift->traverse_array_schemas(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_prefixItems { shift->_eval_keyword__items_array_schemas(@_) }
0.000000,0,0.000000,
0.000067,384,0.000000,sub _traverse_keyword_items ($self, $schema, $state) {
0.000064,96,0.000001,if (is_plain_arrayref($schema->{items})) {
0.000000,0,0.000000,return E($state, 'array form of "items" not supported in %s', $state->{spec_version})
0.000000,0,0.000000,if $state->{spec_version} !~ /^draft(?:7|2019-09)$/;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->traverse_array_schemas($schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000541,96,0.000006,$self->traverse_subschema($schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002619,8695,0.000000,sub _eval_keyword_items ($self, $data, $schema, $state) {
0.000000,0,0.000000,return $self->_eval_keyword__items_array_schemas($data, $schema, $state)
0.001022,1739,0.000001,if is_plain_arrayref($schema->{items});
0.000000,0,0.000000,
0.007272,1739,0.000004,return $self->_eval_keyword__items_schema($data, $schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_additionalItems { shift->traverse_subschema(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_additionalItems ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not exists $state->{_last_items_index};
0.000000,0,0.000000,return $self->_eval_keyword__items_schema($data, $schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# prefixItems (draft 2020-12), array-based items (all drafts)
0.000000,0,0.000000,sub _eval_keyword__items_array_schemas ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not is_type('array', $data);
0.000000,0,0.000000,return 1 if ($state->{_last_items_index}//-1) == $data->$#*;
0.000000,0,0.000000,
0.000000,0,0.000000,my $valid = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $idx (0 .. $data->$#*) {
0.000000,0,0.000000,last if $idx > $schema->{$state->{keyword}}->$#*;
0.000000,0,0.000000,$state->{_last_items_index} = $idx;
0.000000,0,0.000000,
0.000000,0,0.000000,if (is_type('boolean', $schema->{$state->{keyword}}[$idx])) {
0.000000,0,0.000000,next if $schema->{$state->{keyword}}[$idx];
0.000000,0,0.000000,$valid = E({ %$state, data_path => $state->{data_path}.'/'.$idx,
0.000000,0,0.000000,_schema_path_suffix => $idx, collect_annotations => $state->{collect_annotations} & ~1 },
0.000000,0,0.000000,'item not permitted');
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->eval($data->[$idx], $schema->{$state->{keyword}}[$idx],
0.000000,0,0.000000,+{ %$state, data_path => $state->{data_path}.'/'.$idx,
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/'.$state->{keyword}.'/'.$idx,
0.000000,0,0.000000,collect_annotations => $state->{collect_annotations} & ~1 })) {
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,last if $state->{short_circuit} and not exists $schema->{
0.000000,0,0.000000,$state->{keyword} eq 'prefixItems' ? 'items'
0.000000,0,0.000000,: $state->{keyword} eq 'items' ? 'additionalItems' : die
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,A($state, $state->{_last_items_index} == $data->$#* ? true : $state->{_last_items_index});
0.000000,0,0.000000,return E($state, 'not all items are valid') if not $valid;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# schema-based items (all drafts), and additionalItems (up to and including draft2019-09)
0.002296,8695,0.000000,sub _eval_keyword__items_schema ($self, $data, $schema, $state) {
0.005370,1739,0.000003,return 1 if not is_type('array', $data);
0.000752,634,0.000001,return 1 if ($state->{_last_items_index}//-1) == $data->$#*;
0.000000,0,0.000000,
0.000257,634,0.000000,my $valid = 1;
0.000000,0,0.000000,
0.002076,634,0.000003,foreach my $idx (($state->{_last_items_index}//-1)+1 .. $data->$#*) {
0.002470,1597,0.000002,if (is_type('boolean', $schema->{$state->{keyword}})) {
0.000256,187,0.000001,next if $schema->{$state->{keyword}};
0.000000,0,0.000000,$valid = E({ %$state, data_path => $state->{data_path}.'/'.$idx },
0.000000,0,0.000000,'%sitem not permitted',
0.000000,0,0.000000,exists $schema->{prefixItems} || $state->{keyword} eq 'additionalItems' ? 'additional ' : '');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.014151,1410,0.000010,if ($self->eval($data->[$idx], $schema->{$state->{keyword}},
0.000000,0,0.000000,+{ %$state, data_path => $state->{data_path}.'/'.$idx,
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/'.$state->{keyword},
0.000000,0,0.000000,collect_annotations => $state->{collect_annotations} & ~1 })) {
0.005179,1410,0.000004,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000757,634,0.000001,$state->{_last_items_index} = $data->$#*;
0.000000,0,0.000000,
0.000876,634,0.000001,A($state, true);
0.000000,0,0.000000,return E($state, 'subschema is not valid against all %sitems',
0.000162,634,0.000000,$state->{keyword} eq 'additionalItems' ? 'additional ' : '') if not $valid;
0.001779,634,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000019,3,0.000006,sub _traverse_keyword_contains { shift->traverse_subschema(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_contains ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not is_type('array', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,$state->{_num_contains} = 0;
0.000000,0,0.000000,my (@errors, @valid);
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $idx (0 .. $data->$#*) {
0.000000,0,0.000000,if ($self->eval($data->[$idx], $schema->{contains},
0.000000,0,0.000000,+{ %$state, errors => \@errors,
0.000000,0,0.000000,data_path => $state->{data_path}.'/'.$idx,
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/contains',
0.000000,0,0.000000,collect_annotations => $state->{collect_annotations} & ~1 })) {
0.000000,0,0.000000,++$state->{_num_contains};
0.000000,0,0.000000,push @valid, $idx;
0.000000,0,0.000000,
0.000000,0,0.000000,last if $state->{short_circuit}
0.000000,0,0.000000,and (not exists $schema->{maxContains} or $state->{_num_contains} > $schema->{maxContains})
0.000000,0,0.000000,and ($state->{_num_contains} >= ($schema->{minContains}//1));
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# note: no items contained is only valid when minContains is explicitly 0
0.000000,0,0.000000,if (not $state->{_num_contains}
0.000000,0,0.000000,and (($schema->{minContains}//1) > 0 or $state->{spec_version} eq 'draft7')) {
0.000000,0,0.000000,push $state->{errors}->@*, @errors;
0.000000,0,0.000000,return E($state, 'subschema is not valid against any item');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $state->{spec_version} =~ /^draft(?:7|2019-09)$/ ? 1
0.000000,0,0.000000,: A($state, @valid == @$data ? true : \@valid);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001360,382,0.000004,sub _traverse_keyword_properties { shift->traverse_object_schemas(@_) }
0.000000,0,0.000000,
0.026622,160885,0.000000,sub _eval_keyword_properties ($self, $data, $schema, $state) {
0.051424,32177,0.000002,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.006938,28317,0.000000,my $valid = 1;
0.004426,28317,0.000000,my @properties;
0.163107,28317,0.000006,foreach my $property (sort keys $schema->{properties}->%*) {
0.035256,165088,0.000000,next if not exists $data->{$property};
0.004959,10976,0.000000,push @properties, $property;
0.000000,0,0.000000,
0.014916,10976,0.000001,if (is_type('boolean', $schema->{properties}{$property})) {
0.000503,142,0.000004,next if $schema->{properties}{$property};
0.000000,0,0.000000,$valid = E({ %$state, data_path => jsonp($state->{data_path}, $property),
0.000000,0,0.000000,_schema_path_suffix => $property }, 'property not permitted');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.126451,10834,0.000012,if ($self->eval($data->{$property}, $schema->{properties}{$property},
0.000000,0,0.000000,+{ %$state, data_path => jsonp($state->{data_path}, $property),
0.000000,0,0.000000,schema_path => jsonp($state->{schema_path}, 'properties', $property),
0.000000,0,0.000000,collect_annotations => $state->{collect_annotations} & ~1 })) {
0.039462,10039,0.000004,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000322,795,0.000000,$valid = 0;
0.000000,0,0.000000,}
0.000442,795,0.000001,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.036474,28317,0.000001,A($state, \@properties);
0.007920,28317,0.000000,return E($state, 'not all properties are valid') if not $valid;
0.054347,27522,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,24,0.000000,sub _traverse_keyword_patternProperties ($self, $schema, $state) {
0.000009,6,0.000002,return if not assert_keyword_type($state, $schema, 'object');
0.000000,0,0.000000,
0.000002,6,0.000000,my $valid = 1;
0.000037,6,0.000006,foreach my $property (sort keys $schema->{patternProperties}->%*) {
0.000040,6,0.000007,$valid = 0 if not assert_pattern({ %$state, _schema_path_suffix => $property }, $property);
0.000022,6,0.000004,$valid = 0 if not $self->traverse_property_schema($schema, $state, $property);
0.000000,0,0.000000,}
0.000012,6,0.000002,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.004527,16840,0.000000,sub _eval_keyword_patternProperties ($self, $data, $schema, $state) {
0.005137,3368,0.000002,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.001087,3368,0.000000,my $valid = 1;
0.000810,3368,0.000000,my @properties;
0.011356,3368,0.000003,foreach my $property_pattern (sort keys $schema->{patternProperties}->%*) {
0.076672,3368,0.000023,foreach my $property (sort grep m/$property_pattern/, keys %$data) {
0.000831,1799,0.000000,push @properties, $property;
0.002231,1799,0.000001,if (is_type('boolean', $schema->{patternProperties}{$property_pattern})) {
0.002070,1061,0.000002,next if $schema->{patternProperties}{$property_pattern};
0.000000,0,0.000000,$valid = E({ %$state, data_path => jsonp($state->{data_path}, $property),
0.000000,0,0.000000,_schema_path_suffix => $property_pattern }, 'property not permitted');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.009523,738,0.000013,if ($self->eval($data->{$property}, $schema->{patternProperties}{$property_pattern},
0.000000,0,0.000000,+{ %$state, data_path => jsonp($state->{data_path}, $property),
0.000000,0,0.000000,schema_path => jsonp($state->{schema_path}, 'patternProperties', $property_pattern),
0.000000,0,0.000000,collect_annotations => $state->{collect_annotations} & ~1 })) {
0.004429,738,0.000006,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.016589,3368,0.000005,A($state, [ uniqstr @properties ]);
0.001030,3368,0.000000,return E($state, 'not all properties are valid') if not $valid;
0.008110,3368,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000637,130,0.000005,sub _traverse_keyword_additionalProperties { shift->traverse_subschema(@_) }
0.000000,0,0.000000,
0.001156,4855,0.000000,sub _eval_keyword_additionalProperties ($self, $data, $schema, $state) {
0.001434,971,0.000001,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.000363,971,0.000000,my $valid = 1;
0.000308,971,0.000000,my @properties;
0.006158,971,0.000006,foreach my $property (sort keys %$data) {
0.001318,1816,0.000001,next if exists $schema->{properties} and exists $schema->{properties}{$property};
0.000000,0,0.000000,next if exists $schema->{patternProperties}
0.000838,1816,0.000000,and any { $property =~ /$_/ } keys $schema->{patternProperties}->%*;
0.000000,0,0.000000,
0.001119,1816,0.000001,push @properties, $property;
0.002000,1816,0.000001,if (is_type('boolean', $schema->{additionalProperties})) {
0.000000,0,0.000000,next if $schema->{additionalProperties};
0.000000,0,0.000000,$valid = E({ %$state, data_path => jsonp($state->{data_path}, $property) },
0.000000,0,0.000000,'additional property not permitted');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.020615,1816,0.000011,if ($self->eval($data->{$property}, $schema->{additionalProperties},
0.000000,0,0.000000,+{ %$state, data_path => jsonp($state->{data_path}, $property),
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/additionalProperties',
0.000000,0,0.000000,collect_annotations => $state->{collect_annotations} & ~1 })) {
0.007519,1816,0.000004,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001147,971,0.000001,A($state, \@properties);
0.000243,971,0.000000,return E($state, 'not all additional properties are valid') if not $valid;
0.003221,971,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000080,14,0.000006,sub _traverse_keyword_propertyNames { shift->traverse_subschema(@_) }
0.000000,0,0.000000,
0.000765,3135,0.000000,sub _eval_keyword_propertyNames ($self, $data, $schema, $state) {
0.000750,627,0.000001,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.000231,627,0.000000,my $valid = 1;
0.002420,627,0.000004,foreach my $property (sort keys %$data) {
0.007219,712,0.000010,if ($self->eval($property, $schema->{propertyNames},
0.000000,0,0.000000,+{ %$state, data_path => jsonp($state->{data_path}, $property),
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/propertyNames',
0.000000,0,0.000000,collect_annotations => $state->{collect_annotations} & ~1 })) {
0.001877,712,0.000003,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000166,627,0.000000,return E($state, 'not all property names are valid') if not $valid;
0.001536,627,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000017,1,0.000017,1;
0.000044,1,0.000044,__END__
