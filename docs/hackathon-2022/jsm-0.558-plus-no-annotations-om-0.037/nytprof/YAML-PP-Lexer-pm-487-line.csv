# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000042,2,0.000021,use strict;
0.000051,2,0.000026,use warnings;
0.000000,0,0.000000,package YAML::PP::Lexer;
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000025,2,0.000012,use constant TRACE => $ENV{YAML_PP_TRACE} ? 1 : 0;
0.000016,2,0.000008,use constant DEBUG => ($ENV{YAML_PP_DEBUG} || $ENV{YAML_PP_TRACE}) ? 1 : 0;
0.000000,0,0.000000,
0.000545,2,0.000273,use YAML::PP::Grammar qw/ $GRAMMAR /;
0.004352,2,0.002176,use Carp qw/ croak /;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000001,1,0.000001,my ($class, %args) = @_;
0.000000,0,0.000000,my $self = bless {
0.000000,0,0.000000,reader => $args{reader},
0.000002,1,0.000002,}, $class;
0.000001,1,0.000001,$self->init;
0.000002,1,0.000002,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub init {
0.000001,3,0.000000,my ($self) = @_;
0.000003,3,0.000001,$self->{next_tokens} = [];
0.000000,3,0.000000,$self->{next_line} = undef;
0.000001,3,0.000000,$self->{line} = 0;
0.000001,3,0.000000,$self->{offset} = 0;
0.000005,3,0.000002,$self->{flowcontext} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.044708,39124,0.000001,sub next_line { return $_[0]->{next_line} }
0.032035,26721,0.000001,sub set_next_line { $_[0]->{next_line} = $_[1] }
0.014302,13361,0.000001,sub reader { return $_[0]->{reader} }
0.000005,1,0.000005,sub set_reader { $_[0]->{reader} = $_[1] }
0.078711,76597,0.000001,sub next_tokens { return $_[0]->{next_tokens} }
0.163654,159492,0.000001,sub line { return $_[0]->{line} }
0.000000,0,0.000000,sub set_line { $_[0]->{line} = $_[1] }
0.061561,63240,0.000001,sub offset { return $_[0]->{offset} }
0.075612,63240,0.000001,sub set_offset { $_[0]->{offset} = $_[1] }
0.014697,13360,0.000001,sub inc_line { return $_[0]->{line}++ }
0.041210,37139,0.000001,sub context { return $_[0]->{context} }
0.000182,176,0.000001,sub set_context { $_[0]->{context} = $_[1] }
0.082437,75588,0.000001,sub flowcontext { return $_[0]->{flowcontext} }
0.001450,1090,0.000001,sub set_flowcontext { $_[0]->{flowcontext} = $_[1] }
0.014795,13924,0.000001,sub block { return $_[0]->{block} }
0.015813,13360,0.000001,sub set_block { $_[0]->{block} = $_[1] }
0.000000,0,0.000000,
0.000001,1,0.000001,my $RE_WS = '[\t ]';
0.000000,1,0.000000,my $RE_LB = '[\r\n]';
0.000045,1,0.000045,my $RE_DOC_END = qr/\A(\.\.\.)(?=$RE_WS|$)/m;
0.000021,1,0.000021,my $RE_DOC_START = qr/\A(---)(?=$RE_WS|$)/m;
0.000157,1,0.000157,my $RE_EOL = qr/\A($RE_WS+#.*|$RE_WS+)\z/;
0.000000,0,0.000000,#my $RE_COMMENT_EOL = qr/\A(#.*)?(?:$RE_LB|\z)/;
0.000000,0,0.000000,
0.000000,0,0.000000,#ns-word-char    ::= ns-dec-digit | ns-ascii-letter | “-”
0.000000,1,0.000000,my $RE_NS_WORD_CHAR = '[0-9A-Za-z-]';
0.000000,1,0.000000,my $RE_URI_CHAR = '(?:' . '%[0-9a-fA-F]{2}' .'|'.  q{[0-9A-Za-z#;/?:@&=+$,_.!*'\(\)\[\]-]} . ')';
0.000000,1,0.000000,my $RE_NS_TAG_CHAR = '(?:' . '%[0-9a-fA-F]{2}' .'|'.  q{[0-9A-Za-z#;/?:@&=+$_.~*'\(\)-]} . ')';
0.000000,0,0.000000,
0.000000,0,0.000000,#  [#x21-#x7E]          /* 8 bit */
0.000000,0,0.000000,# | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD] /* 16 bit */
0.000000,0,0.000000,# | [#x10000-#x10FFFF]                     /* 32 bit */
0.000000,0,0.000000,
0.000000,0,0.000000,#nb-char ::= c-printable - b-char - c-byte-order-mark
0.000000,0,0.000000,#my $RE_NB_CHAR = '[\x21-\x7E]';
0.000001,1,0.000001,my $RE_ANCHOR_CAR = '[\x21-\x2B\x2D-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
0.000000,0,0.000000,
0.000000,1,0.000000,my $RE_PLAIN_START = '[\x21\x22\x24-\x39\x3B-\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
0.000001,1,0.000001,my $RE_PLAIN_END = '[\x21-\x39\x3B-\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';
0.000000,1,0.000000,my $RE_PLAIN_FIRST = '[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
0.000000,0,0.000000,
0.000001,1,0.000001,my $RE_PLAIN_START_FLOW = '[\x21\x22\x24-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
0.000000,1,0.000000,my $RE_PLAIN_END_FLOW = '[\x21-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';
0.000001,1,0.000001,my $RE_PLAIN_FIRST_FLOW = '[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
0.000000,0,0.000000,# c-indicators
0.000000,0,0.000000,#! 21
0.000000,0,0.000000,#" 22
0.000000,0,0.000000,## 23
0.000000,0,0.000000,#% 25
0.000000,0,0.000000,#& 26
0.000000,0,0.000000,#' 27
0.000000,0,0.000000,#* 2A
0.000000,0,0.000000,#, 2C FLOW
0.000000,0,0.000000,#- 2D XX
0.000000,0,0.000000,#: 3A XX
0.000000,0,0.000000,#> 3E
0.000000,0,0.000000,#? 3F XX
0.000000,0,0.000000,#@ 40
0.000000,0,0.000000,#[ 5B FLOW
0.000000,0,0.000000,#] 5D FLOW
0.000000,0,0.000000,#` 60
0.000000,0,0.000000,#{ 7B FLOW
0.000000,0,0.000000,#| 7C
0.000000,0,0.000000,#} 7D FLOW
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000002,1,0.000002,my $RE_PLAIN_WORD = "(?::+$RE_PLAIN_END|$RE_PLAIN_START)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";
0.000000,1,0.000000,my $RE_PLAIN_FIRST_WORD = "(?:[:?-]+$RE_PLAIN_END|$RE_PLAIN_FIRST)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";
0.000000,1,0.000000,my $RE_PLAIN_WORDS = "(?:$RE_PLAIN_FIRST_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";
0.000000,1,0.000000,my $RE_PLAIN_WORDS2 = "(?:$RE_PLAIN_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";
0.000000,0,0.000000,
0.000001,1,0.000001,my $RE_PLAIN_WORD_FLOW = "(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_START_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";
0.000001,1,0.000001,my $RE_PLAIN_FIRST_WORD_FLOW = "(?:[:?-]+$RE_PLAIN_END_FLOW|$RE_PLAIN_FIRST_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";
0.000004,1,0.000004,my $RE_PLAIN_WORDS_FLOW = "(?:$RE_PLAIN_FIRST_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";
0.000000,1,0.000000,my $RE_PLAIN_WORDS_FLOW2 = "(?:$RE_PLAIN_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#c-secondary-tag-handle  ::= “!” “!”
0.000000,0,0.000000,#c-named-tag-handle  ::= “!” ns-word-char+ “!”
0.000000,0,0.000000,#ns-tag-char ::= ns-uri-char - “!” - c-flow-indicator
0.000000,0,0.000000,#ns-global-tag-prefix    ::= ns-tag-char ns-uri-char*
0.000000,0,0.000000,#c-ns-local-tag-prefix   ::= “!” ns-uri-char*
0.000001,1,0.000001,my $RE_TAG = "!(?:$RE_NS_WORD_CHAR*!$RE_NS_TAG_CHAR+|$RE_NS_TAG_CHAR+|<$RE_URI_CHAR+>|)";
0.000000,0,0.000000,
0.000000,0,0.000000,#c-ns-anchor-property    ::= “&” ns-anchor-name
0.000000,0,0.000000,#ns-char ::= nb-char - s-white
0.000000,0,0.000000,#ns-anchor-char  ::= ns-char - c-flow-indicator
0.000000,0,0.000000,#ns-anchor-name  ::= ns-anchor-char+
0.000000,0,0.000000,
0.000044,1,0.000044,my $RE_SEQSTART = qr/\A(-)(?=$RE_WS|$)/m;
0.000019,1,0.000019,my $RE_COMPLEX = qr/(\?)(?=$RE_WS|$)/m;
0.000018,1,0.000018,my $RE_COMPLEXCOLON = qr/\A(:)(?=$RE_WS|$)/m;
0.000000,1,0.000000,my $RE_ANCHOR = "&$RE_ANCHOR_CAR+";
0.000000,1,0.000000,my $RE_ALIAS = "\\*$RE_ANCHOR_CAR+";
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000303,1,0.000303,my %REGEXES = (
0.000000,0,0.000000,ANCHOR => qr{($RE_ANCHOR)},
0.000000,0,0.000000,TAG => qr{($RE_TAG)},
0.000000,0,0.000000,ALIAS => qr{($RE_ALIAS)},
0.000000,0,0.000000,SINGLEQUOTED => qr{(?:''|[^'\r\n]+)*},
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fetch_next_line {
0.003091,18360,0.000000,my ($self) = @_;
0.011162,18360,0.000001,my $next_line = $self->next_line;
0.008770,18360,0.000000,if (defined $next_line ) {
0.000000,0,0.000000,return $next_line;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.020486,13361,0.000002,my $line = $self->reader->readline;
0.002067,13361,0.000000,unless (defined $line) {
0.000001,1,0.000001,$self->set_next_line(undef);
0.000001,1,0.000001,return;
0.000000,0,0.000000,}
0.009833,13360,0.000001,$self->set_block(1);
0.007377,13360,0.000001,$self->inc_line;
0.034757,13360,0.000003,$line =~ m/\A( *)([^\r\n]*)([\r\n]|\z)/ or die "Unexpected";
0.018226,13360,0.000001,$next_line = [ $1,  $2, $3 ];
0.007829,13360,0.000001,$self->set_next_line($next_line);
0.000000,0,0.000000,# $ESCAPE_CHAR from YAML.pm
0.006226,13360,0.000000,if ($line =~ tr/\x00-\x08\x0b-\x0c\x0e-\x1f//) {
0.000000,0,0.000000,$self->exception("Control characters are not allowed");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.019629,13360,0.000001,return $next_line;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,my %TOKEN_NAMES = (
0.000000,0,0.000000,'"' => 'DOUBLEQUOTE',
0.000000,0,0.000000,"'" => 'SINGLEQUOTE',
0.000000,0,0.000000,'|' => 'LITERAL',
0.000000,0,0.000000,'>' => 'FOLDED',
0.000000,0,0.000000,'!' => 'TAG',
0.000000,0,0.000000,'*' => 'ALIAS',
0.000000,0,0.000000,'&' => 'ANCHOR',
0.000000,0,0.000000,':' => 'COLON',
0.000000,0,0.000000,'-' => 'DASH',
0.000000,0,0.000000,'?' => 'QUESTION',
0.000000,0,0.000000,'[' => 'FLOWSEQ_START',
0.000000,0,0.000000,']' => 'FLOWSEQ_END',
0.000000,0,0.000000,'{' => 'FLOWMAP_START',
0.000000,0,0.000000,'}' => 'FLOWMAP_END',
0.000000,0,0.000000,',' => 'FLOW_COMMA',
0.000000,0,0.000000,'---' => 'DOC_START',
0.000000,0,0.000000,'...' => 'DOC_END',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetch_next_tokens {
0.002626,13356,0.000000,my ($self) = @_;
0.007589,13356,0.000001,my $next = $self->next_tokens;
0.002392,13356,0.000000,return $next if @$next;
0.000000,0,0.000000,
0.010587,13356,0.000001,my $next_line = $self->_fetch_next_line;
0.001907,13356,0.000000,if (not $next_line) {
0.000000,0,0.000000,return [];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.003811,13355,0.000000,my $spaces = $next_line->[0];
0.003488,13355,0.000000,my $yaml = \$next_line->[1];
0.003272,13355,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,$self->_push_tokens([ EOL => join('', @$next_line), $self->line ]);
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,return $next;
0.000000,0,0.000000,}
0.010294,13355,0.000001,if (substr($$yaml, 0, 1) eq '#') {
0.000000,0,0.000000,$self->_push_tokens([ EOL => join('', @$next_line), $self->line ]);
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,return $next;
0.000000,0,0.000000,}
0.001932,13355,0.000000,if (not $spaces and substr($$yaml, 0, 1) eq "%") {
0.000000,0,0.000000,$self->_fetch_next_tokens_directive($yaml, $next_line->[2]);
0.000000,0,0.000000,$self->set_context(0);
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,return $next;
0.000000,0,0.000000,}
0.017387,13355,0.000001,if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//) {
0.000000,0,0.000000,$self->_push_tokens([ $TOKEN_NAMES{ $1 } => $1, $self->line ]);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->flowcontext and $$yaml =~ m/\A[ \t]+(#.*)?\z/) {
0.000000,0,0.000000,$self->_push_tokens([ EOL => join('', @$next_line), $self->line ]);
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,return $next;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.019940,13354,0.000001,$self->_push_tokens([ SPACE => $spaces, $self->line ]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.010590,13355,0.000001,my $partial = $self->_fetch_next_tokens($next_line);
0.001551,13355,0.000000,unless ($partial) {
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,}
0.019515,13355,0.000001,return $next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,my %ANCHOR_ALIAS_TAG =    ( '&' => 1, '*' => 1, '!' => 1 );
0.000001,1,0.000001,my %BLOCK_SCALAR =        ( '|' => 1, '>' => 1 );
0.000001,1,0.000001,my %COLON_DASH_QUESTION = ( ':' => 1, '-' => 1, '?' => 1 );
0.000001,1,0.000001,my %QUOTED =              ( '"' => 1, "'" => 1 );
0.000000,1,0.000000,my %FLOW =                ( '{' => 1, '[' => 1, '}' => 1, ']' => 1, ',' => 1 );
0.000000,1,0.000000,my %CONTEXT =             ( '"' => 1, "'" => 1, '>' => 1, '|' => 1 );
0.000000,0,0.000000,
0.000003,1,0.000003,my $RE_ESCAPES = qr{(?:
0.000000,0,0.000000,\\([ \\\/_0abefnrtvLNP\t"]) | \\x([0-9a-fA-F]{2})
0.000000,0,0.000000,| \\u([A-Fa-f0-9]{4}) | \\U([A-Fa-f0-9]{4,8})
0.000000,0,0.000000,)}x;
0.000008,1,0.000008,my %CONTROL = (
0.000000,0,0.000000,'\\' => '\\', '/' => '/', n => "\n", t => "\t", r => "\r", b => "\b",
0.000000,0,0.000000,'a' => "\a", 'b' => "\b", 'e' => "\e", 'f' => "\f", 'v' => "\x0b", "\t" => "\t",
0.000000,0,0.000000,'P' => "\x{2029}", L => "\x{2028}", 'N' => "\x85",
0.000000,0,0.000000,'0' => "\0", '_' => "\xa0", ' ' => ' ', q/"/ => q/"/,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fetch_next_tokens {
0.000000,0,0.000000,TRACE and warn __PACKAGE__.':'.__LINE__.": _fetch_next_tokens\n";
0.004776,27707,0.000000,my ($self, $next_line) = @_;
0.000000,0,0.000000,
0.006587,27707,0.000000,my $yaml = \$next_line->[1];
0.005037,27707,0.000000,my $eol = $next_line->[2];
0.000000,0,0.000000,
0.002681,27707,0.000000,my @tokens;
0.000000,0,0.000000,
0.003190,27707,0.000000,while (1) {
0.005432,37662,0.000000,unless (length $$yaml) {
0.000487,523,0.000001,push @tokens, ( EOL => $eol, $self->line );
0.000412,523,0.000001,$self->_push_tokens(\@tokens);
0.001033,523,0.000002,return;
0.000000,0,0.000000,}
0.013128,37139,0.000000,my $first = substr($$yaml, 0, 1);
0.004243,37139,0.000000,my $plain = 0;
0.000000,0,0.000000,
0.021249,37139,0.000001,if ($self->context) {
0.000238,88,0.000003,if ($$yaml =~ s/\A($RE_WS*)://) {
0.000000,0,0.000000,push @tokens, ( WS => $1, $self->line ) if $1;
0.000000,0,0.000000,push @tokens, ( COLON => ':', $self->line );
0.000000,0,0.000000,$self->set_context(0);
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000258,88,0.000003,if ($$yaml =~ s/\A($RE_WS*(?: #.*))\z//) {
0.000000,0,0.000000,push @tokens, ( EOL => $1 . $eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000078,88,0.000001,$self->set_context(0);
0.000000,0,0.000000,}
0.024150,37139,0.000001,if ($CONTEXT{ $first }) {
0.002375,2046,0.000001,push @tokens, ( CONTEXT => $first, $self->line );
0.001398,2046,0.000001,$self->_push_tokens(\@tokens);
0.003802,2046,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($COLON_DASH_QUESTION{ $first }) {
0.004369,13953,0.000000,my $token_name = $TOKEN_NAMES{ $first };
0.084144,13953,0.000006,if ($$yaml =~ s/\A\Q$first\E($RE_WS+|\z)//) {
0.004486,13953,0.000000,my $after = $1;
0.017095,13953,0.000001,if (not $self->flowcontext and not $self->block) {
0.000000,0,0.000000,push @tokens, ERROR => $first . $after, $self->line;
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Tabs can not be used for indentation");
0.000000,0,0.000000,}
0.004201,13953,0.000000,if ($after =~ tr/\t//) {
0.000000,0,0.000000,$self->set_block(0);
0.000000,0,0.000000,}
0.003216,13953,0.000000,my $token_name = $TOKEN_NAMES{ $first };
0.012165,13953,0.000001,push @tokens, ( $token_name => $first, $self->line );
0.003014,13953,0.000000,if (not defined $1) {
0.000000,0,0.000000,push @tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.002635,13953,0.000000,my $ws = $1;
0.029065,13953,0.000002,if ($$yaml =~ s/\A(#.*|)\z//) {
0.009711,6420,0.000002,push @tokens, ( EOL => $ws . $1 . $eol, $self->line );
0.003795,6420,0.000001,$self->_push_tokens(\@tokens);
0.018829,6420,0.000003,return;
0.000000,0,0.000000,}
0.007072,7533,0.000001,push @tokens, ( WS => $ws, $self->line );
0.006550,7533,0.000001,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->flowcontext and $$yaml =~ s/\A:(?=[,\{\}\[\]])//) {
0.000000,0,0.000000,push @tokens, ( $token_name => $first, $self->line );
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,$plain = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($ANCHOR_ALIAS_TAG{ $first }) {
0.000000,0,0.000000,my $token_name = $TOKEN_NAMES{ $first };
0.000000,0,0.000000,my $REGEX = $REGEXES{ $token_name };
0.000000,0,0.000000,if ($$yaml =~ s/\A$REGEX//) {
0.000000,0,0.000000,push @tokens, ( $token_name => $1, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, ( "Invalid $token_name" => $$yaml, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($first eq ' ' or $first eq "\t") {
0.002749,666,0.000004,if ($$yaml =~ s/\A($RE_WS+)//) {
0.000293,666,0.000000,my $ws = $1;
0.001282,666,0.000002,if ($$yaml =~ s/\A((?:#.*)?\z)//) {
0.000000,0,0.000000,push @tokens, ( EOL => $ws . $1 . $eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000658,666,0.000001,push @tokens, ( WS => $ws, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($FLOW{ $first }) {
0.002046,1756,0.000001,push @tokens, ( $TOKEN_NAMES{ $first } => $first, $self->line );
0.001368,1756,0.000001,substr($$yaml, 0, 1, '');
0.001038,1756,0.000001,my $flowcontext = $self->flowcontext;
0.001532,1756,0.000001,if ($first eq '{' or $first eq '[') {
0.000000,0,0.000000,$self->set_flowcontext(++$flowcontext);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($first eq '}' or $first eq ']') {
0.000000,0,0.000000,$self->set_flowcontext(--$flowcontext);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.002502,18718,0.000000,$plain = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.003037,21140,0.000000,if ($plain) {
0.013796,18718,0.000001,push @tokens, ( CONTEXT => '', $self->line );
0.010908,18718,0.000001,$self->_push_tokens(\@tokens);
0.031879,18718,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetch_plain {
0.005107,18718,0.000000,my ($self, $indent, $context) = @_;
0.012508,18718,0.000001,my $next_line = $self->next_line;
0.004461,18718,0.000000,my $yaml = \$next_line->[1];
0.003414,18718,0.000000,my $eol = $next_line->[2];
0.003527,18718,0.000000,my $REGEX = $RE_PLAIN_WORDS;
0.009207,18718,0.000000,if ($self->flowcontext) {
0.000000,0,0.000000,$REGEX = $RE_PLAIN_WORDS_FLOW;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002058,18718,0.000000,my @tokens;
0.262018,18718,0.000014,unless ($$yaml =~ s/\A($REGEX)//) {
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Invalid plain scalar");
0.000000,0,0.000000,}
0.009456,18718,0.000001,my $plain = $1;
0.018125,18718,0.000001,push @tokens, ( PLAIN => $plain, $self->line );
0.000000,0,0.000000,
0.073200,18718,0.000004,if ($$yaml =~ s/\A(?:($RE_WS+#.*)|($RE_WS*))\z//) {
0.002193,4998,0.000000,if (defined $1) {
0.000000,0,0.000000,push @tokens, ( EOL => $1 . $eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.006436,4998,0.000001,push @tokens, ( EOL => $2. $eol, $self->line );
0.004004,4998,0.000001,$self->set_next_line(undef);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.009037,13720,0.000001,$self->_push_tokens(\@tokens);
0.018722,13720,0.000001,my $partial = $self->_fetch_next_tokens($next_line);
0.005453,13720,0.000000,if (not $partial) {
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,}
0.032351,13720,0.000002,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001140,4998,0.000000,my $RE2 = $RE_PLAIN_WORDS2;
0.002955,4998,0.000001,if ($self->flowcontext) {
0.000000,0,0.000000,$RE2 = $RE_PLAIN_WORDS_FLOW2;
0.000000,0,0.000000,}
0.000599,4998,0.000000,my $fetch_next = 0;
0.002314,4998,0.000000,my @lines = ($plain);
0.000580,4998,0.000000,my @next;
0.000725,4998,0.000000,LOOP: while (1) {
0.006738,4998,0.000001,$next_line = $self->_fetch_next_line;
0.000869,4998,0.000000,if (not $next_line) {
0.000000,0,0.000000,last LOOP;
0.000000,0,0.000000,}
0.001388,4998,0.000000,my $spaces = $next_line->[0];
0.001346,4998,0.000000,my $yaml = \$next_line->[1];
0.001119,4998,0.000000,my $eol = $next_line->[2];
0.000000,0,0.000000,
0.001173,4998,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, ( EOL => $spaces . $eol, $self->line );
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,push @lines, '';
0.000000,0,0.000000,next LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001127,4998,0.000000,if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//) {
0.000000,0,0.000000,push @next, $TOKEN_NAMES{ $1 } => $1, $self->line;
0.000000,0,0.000000,$fetch_next = 1;
0.000000,0,0.000000,last LOOP;
0.000000,0,0.000000,}
0.002910,4998,0.000001,if ((length $spaces) < $indent) {
0.003612,4998,0.000001,last LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $ws = '';
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE_WS+)//) {
0.000000,0,0.000000,$ws = $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, ( EOL => $spaces . $ws . $eol, $self->line );
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,push @lines, '';
0.000000,0,0.000000,next LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($$yaml =~ s/\A(#.*)\z//) {
0.000000,0,0.000000,push @tokens, ( EOL => $spaces . $ws . $1 . $eol, $self->line );
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,last LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE2)//) {
0.000000,0,0.000000,push @tokens, INDENT => $spaces, $self->line;
0.000000,0,0.000000,push @tokens, WS => $ws, $self->line;
0.000000,0,0.000000,push @tokens, PLAIN => $1, $self->line;
0.000000,0,0.000000,push @lines, $1;
0.000000,0,0.000000,my $ws = '';
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE_WS+)//) {
0.000000,0,0.000000,$ws = $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, EOL => $ws . $eol, $self->line;
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,next LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($$yaml =~ s/\A(#.*)\z//) {
0.000000,0,0.000000,push @tokens, EOL => $ws . $1 . $eol, $self->line;
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,last LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, WS => $ws, $self->line if $ws;
0.000000,0,0.000000,$fetch_next = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, SPACE => $spaces, $self->line;
0.000000,0,0.000000,push @tokens, WS => $ws, $self->line;
0.000000,0,0.000000,if ($self->flowcontext) {
0.000000,0,0.000000,$fetch_next = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, ERROR => $$yaml, $self->line;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,last LOOP;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,# remove empty lines at the end
0.002642,4998,0.000001,while (@lines > 1 and $lines[-1] eq '') {
0.000000,0,0.000000,pop @lines;
0.000000,0,0.000000,}
0.004576,4998,0.000001,if (@lines > 1) {
0.000000,0,0.000000,my $value = YAML::PP::Render->render_multi_val(\@lines);
0.000000,0,0.000000,my @eol;
0.000000,0,0.000000,if ($tokens[-3] eq 'EOL') {
0.000000,0,0.000000,@eol = splice @tokens, -3;
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->push_subtokens( { name => 'PLAIN_MULTI', value => $value }, \@tokens);
0.000000,0,0.000000,$self->_push_tokens([ @eol, @next ]);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.007285,4998,0.000001,$self->_push_tokens([ @tokens, @next ]);
0.000000,0,0.000000,}
0.002709,4998,0.000001,@tokens = ();
0.000897,4998,0.000000,if ($fetch_next) {
0.000000,0,0.000000,my $partial = $self->_fetch_next_tokens($next_line);
0.000000,0,0.000000,if (not $partial) {
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.012185,4998,0.000002,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetch_block {
0.000001,1,0.000001,my ($self, $indent, $context) = @_;
0.000002,1,0.000002,my $next_line = $self->next_line;
0.000000,1,0.000000,my $yaml = \$next_line->[1];
0.000000,1,0.000000,my $eol = $next_line->[2];
0.000000,0,0.000000,
0.000000,1,0.000000,my @tokens;
0.000001,1,0.000001,my $token_name = $TOKEN_NAMES{ $context };
0.000011,1,0.000011,$$yaml =~ s/\A\Q$context\E// or die "Unexpected";
0.000001,1,0.000001,push @tokens, ( $token_name => $context, $self->line );
0.000000,1,0.000000,my $current_indent = $indent;
0.000000,1,0.000000,my $started = 0;
0.000000,1,0.000000,my $set_indent = 0;
0.000001,1,0.000001,my $chomp = '';
0.000004,1,0.000004,if ($$yaml =~ s/\A([1-9])([+-]?)//) {
0.000000,0,0.000000,push @tokens, ( BLOCK_SCALAR_INDENT => $1, $self->line );
0.000000,0,0.000000,$set_indent = $1;
0.000000,0,0.000000,$chomp = $2 if $2;
0.000000,0,0.000000,push @tokens, ( BLOCK_SCALAR_CHOMP => $2, $self->line ) if $2;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($$yaml =~ s/\A([+-])([1-9])?//) {
0.000001,1,0.000001,push @tokens, ( BLOCK_SCALAR_CHOMP => $1, $self->line );
0.000001,1,0.000001,$chomp = $1;
0.000000,1,0.000000,push @tokens, ( BLOCK_SCALAR_INDENT => $2, $self->line ) if $2;
0.000001,1,0.000001,$set_indent = $2 if $2;
0.000000,0,0.000000,}
0.000001,1,0.000001,if ($set_indent) {
0.000000,0,0.000000,$started = 1;
0.000000,0,0.000000,$indent-- if $indent > 0;
0.000000,0,0.000000,$current_indent = $indent + $set_indent;
0.000000,0,0.000000,}
0.000002,1,0.000002,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($$yaml =~ s/\A($RE_WS*(?:$RE_WS#.*|))\z//) {
0.000000,0,0.000000,push @tokens, ( EOL => $1 . $eol, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Invalid block scalar");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my @lines;
0.000001,1,0.000001,while (1) {
0.000002,6,0.000000,$self->set_next_line(undef);
0.000003,6,0.000000,$next_line = $self->_fetch_next_line;
0.000001,6,0.000000,if (not $next_line) {
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000002,6,0.000000,my $spaces = $next_line->[0];
0.000000,6,0.000000,my $content = $next_line->[1];
0.000001,6,0.000000,my $eol = $next_line->[2];
0.000001,6,0.000000,if (not $spaces and $content =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/) {
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000002,6,0.000000,if ((length $spaces) < $current_indent) {
0.000000,1,0.000000,if (length $content) {
0.000003,1,0.000003,if ($content =~ m/\A\t/) {
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Invalid block scalar");
0.000000,0,0.000000,}
0.000000,1,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @lines, '';
0.000000,0,0.000000,push @tokens, ( EOL => $spaces . $eol, $self->line );
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000001,5,0.000000,if ((length $spaces) > $current_indent) {
0.000001,1,0.000001,if ($started) {
0.000000,0,0.000000,($spaces, my $more_spaces) = unpack "a${current_indent}a*", $spaces;
0.000000,0,0.000000,$content = $more_spaces . $content;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,5,0.000000,unless (length $content) {
0.000000,0,0.000000,push @lines, '';
0.000000,0,0.000000,push @tokens, ( INDENT => $spaces, $self->line, EOL => $eol, $self->line );
0.000000,0,0.000000,unless ($started) {
0.000000,0,0.000000,$current_indent = length $spaces;
0.000000,0,0.000000,}
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,5,0.000000,unless ($started) {
0.000000,1,0.000000,$started = 1;
0.000001,1,0.000001,$current_indent = length $spaces;
0.000000,0,0.000000,}
0.000001,5,0.000000,push @lines, $content;
0.000017,5,0.000003,push @tokens, (
0.000000,0,0.000000,INDENT => $spaces, $self->line,
0.000000,0,0.000000,BLOCK_SCALAR_CONTENT => $content, $self->line,
0.000000,0,0.000000,EOL => $eol, $self->line,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000008,1,0.000008,my $value = YAML::PP::Render->render_block_scalar($context, $chomp, \@lines);
0.000001,1,0.000001,my @eol = splice @tokens, -3;
0.000001,1,0.000001,$self->push_subtokens( { name => 'BLOCK_SCALAR', value => $value }, \@tokens );
0.000002,1,0.000002,$self->_push_tokens([ @eol ]);
0.000005,1,0.000005,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetch_quoted {
0.000856,2045,0.000000,my ($self, $indent, $context) = @_;
0.001750,2045,0.000001,my $next_line = $self->next_line;
0.000845,2045,0.000000,my $yaml = \$next_line->[1];
0.000678,2045,0.000000,my $spaces = $next_line->[0];
0.000000,0,0.000000,
0.000597,2045,0.000000,my $token_name = $TOKEN_NAMES{ $context };
0.010616,2045,0.000005,$$yaml =~ s/\A\Q$context// or die "Unexpected";;
0.003057,2045,0.000001,my @tokens = ( $token_name => $context, $self->line );
0.000000,0,0.000000,
0.000484,2045,0.000000,my $start = 1;
0.000351,2045,0.000000,my @values;
0.000318,2045,0.000000,while (1) {
0.000000,0,0.000000,
0.000305,2045,0.000000,unless ($start) {
0.000000,0,0.000000,$next_line = $self->_fetch_next_line or do {
0.000000,0,0.000000,for (my $i = 0; $i < @tokens; $i+= 3) {
0.000000,0,0.000000,my $token = $tokens[ $i + 1 ];
0.000000,0,0.000000,if (ref $token) {
0.000000,0,0.000000,$tokens[ $i + 1 ] = $token->{orig};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Missing closing quote <$context> at EOF");
0.000000,0,0.000000,};
0.000000,0,0.000000,$start = 0;
0.000000,0,0.000000,$spaces = $next_line->[0];
0.000000,0,0.000000,$yaml = \$next_line->[1];
0.000000,0,0.000000,
0.000000,0,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, ( EOL => $spaces . $next_line->[2], $self->line );
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,push @values, { value => '', orig => '' };
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (not $spaces and $$yaml =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/) {
0.000000,0,0.000000,for (my $i = 0; $i < @tokens; $i+= 3) {
0.000000,0,0.000000,my $token = $tokens[ $i + 1 ];
0.000000,0,0.000000,if (ref $token) {
0.000000,0,0.000000,$tokens[ $i + 1 ] = $token->{orig};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Missing closing quote <$context> or invalid document marker");
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ((length $spaces) < $indent) {
0.000000,0,0.000000,for (my $i = 0; $i < @tokens; $i+= 3) {
0.000000,0,0.000000,my $token = $tokens[ $i + 1 ];
0.000000,0,0.000000,if (ref $token) {
0.000000,0,0.000000,$tokens[ $i + 1 ] = $token->{orig};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Wrong indendation or missing closing quote <$context>");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE_WS+)//) {
0.000000,0,0.000000,$spaces .= $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,push @tokens, ( WS => $spaces, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.003514,2045,0.000002,my $v = $self->_read_quoted_tokens($start, $context, $yaml, \@tokens);
0.000470,2045,0.000000,push @values, $v;
0.000983,2045,0.000000,if ($tokens[-3] eq $token_name) {
0.005070,2045,0.000002,if ($start) {
0.000000,0,0.000000,$self->push_subtokens(
0.000000,0,0.000000,{ name => 'QUOTED', value => $v->{value} }, \@tokens
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $value = YAML::PP::Render->render_quoted($context, \@values);
0.000000,0,0.000000,$self->push_subtokens(
0.000000,0,0.000000,{ name => 'QUOTED_MULTILINE', value => $value }, \@tokens
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.001614,2045,0.000001,$self->set_context(1) if $self->flowcontext;
0.001060,2045,0.000001,if (length $$yaml) {
0.000595,632,0.000001,my $partial = $self->_fetch_next_tokens($next_line);
0.000586,632,0.000001,if (not $partial) {
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,}
0.002698,632,0.000004,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.001014,1413,0.000001,@tokens = ();
0.001708,1413,0.000001,push @tokens, ( EOL => $next_line->[2], $self->line );
0.000985,1413,0.000001,$self->_push_tokens(\@tokens);
0.000945,1413,0.000001,$self->set_next_line(undef);
0.005276,1413,0.000004,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$tokens[-2] .= $next_line->[2];
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,$start = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _read_quoted_tokens {
0.000959,2045,0.000000,my ($self, $start, $first, $yaml, $tokens) = @_;
0.000712,2045,0.000000,my $quoted = '';
0.000610,2045,0.000000,my $decoded = '';
0.000674,2045,0.000000,my $token_name = $TOKEN_NAMES{ $first };
0.000447,2045,0.000000,my $eol = '';
0.001082,2045,0.000001,if ($first eq "'") {
0.000832,2045,0.000000,my $regex = $REGEXES{SINGLEQUOTED};
0.011991,2045,0.000006,if ($$yaml =~ s/\A($regex)//) {
0.002116,2045,0.000001,$quoted .= $1;
0.000837,2045,0.000000,$decoded .= $1;
0.003406,2045,0.000002,$decoded =~ s/''/'/g;
0.000000,0,0.000000,}
0.001246,2045,0.000001,unless (length $$yaml) {
0.000000,0,0.000000,if ($quoted =~ s/($RE_WS+)\z//) {
0.000000,0,0.000000,$eol = $1;
0.000000,0,0.000000,$decoded =~ s/($eol)\z//;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,($quoted, $decoded, $eol) = $self->_read_doublequoted($yaml);
0.000000,0,0.000000,}
0.002791,2045,0.000001,my $value = { value => $decoded, orig => $quoted };
0.000000,0,0.000000,
0.007018,2045,0.000003,if ($$yaml =~ s/\A$first//) {
0.002938,2045,0.000001,if ($start) {
0.000000,0,0.000000,push @$tokens, ( $token_name . 'D' => $value, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @$tokens, ( $token_name . 'D_LINE' => $value, $self->line );
0.000000,0,0.000000,}
0.001918,2045,0.000001,push @$tokens, ( $token_name => $first, $self->line );
0.004094,2045,0.000002,return $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (length $$yaml) {
0.000000,0,0.000000,push @$tokens, ( $token_name . 'D' => $value->{orig}, $self->line );
0.000000,0,0.000000,$self->_push_tokens($tokens);
0.000000,0,0.000000,$self->exception("Invalid quoted <$first> string");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @$tokens, ( $token_name . 'D_LINE' => $value, $self->line );
0.000000,0,0.000000,push @$tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,
0.000000,0,0.000000,return $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _read_doublequoted {
0.000000,0,0.000000,my ($self, $yaml) = @_;
0.000000,0,0.000000,my $quoted = '';
0.000000,0,0.000000,my $decoded = '';
0.000000,0,0.000000,my $eol = '';
0.000000,0,0.000000,while (1) {
0.000000,0,0.000000,my $last = 1;
0.000000,0,0.000000,if ($$yaml =~ s/\A([^"\\ \t]+)//) {
0.000000,0,0.000000,$quoted .= $1;
0.000000,0,0.000000,$decoded .= $1;
0.000000,0,0.000000,$last = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE_ESCAPES)//) {
0.000000,0,0.000000,$quoted .= $1;
0.000000,0,0.000000,my $dec = defined $2 ? $CONTROL{ $2 }
0.000000,0,0.000000,: defined $3 ? chr hex $3
0.000000,0,0.000000,: defined $4 ? chr hex $4
0.000000,0,0.000000,: chr hex $5;
0.000000,0,0.000000,$decoded .= $dec;
0.000000,0,0.000000,$last = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($$yaml =~ s/\A([ \t]+)//) {
0.000000,0,0.000000,my $spaces = $1;
0.000000,0,0.000000,if (length $$yaml) {
0.000000,0,0.000000,$quoted .= $spaces;
0.000000,0,0.000000,$decoded .= $spaces;
0.000000,0,0.000000,$last = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$eol = $spaces;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($$yaml =~ s/\A(\\)\z//) {
0.000000,0,0.000000,$quoted .= $1;
0.000000,0,0.000000,$decoded .= $1;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if $last;
0.000000,0,0.000000,}
0.000000,0,0.000000,return ($quoted, $decoded, $eol);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fetch_next_tokens_directive {
0.000000,0,0.000000,my ($self, $yaml, $eol) = @_;
0.000000,0,0.000000,my @tokens;
0.000000,0,0.000000,
0.000000,0,0.000000,my $trailing_ws = '';
0.000000,0,0.000000,my $warn = $ENV{YAML_PP_RESERVED_DIRECTIVE} || 'warn';
0.000000,0,0.000000,if ($$yaml =~ s/\A(\s*%YAML[ \t]+([0-9]+\.[0-9]+))//) {
0.000000,0,0.000000,my $dir = $1;
0.000000,0,0.000000,my $version = $2;
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE_WS+)//) {
0.000000,0,0.000000,$trailing_ws = $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (length $$yaml) {
0.000000,0,0.000000,push @tokens, ( 'Invalid directive' => $dir.$$yaml.$eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($version !~ m/^1\.[12]$/) {
0.000000,0,0.000000,if ($warn eq 'warn') {
0.000000,0,0.000000,warn "Unsupported YAML version '$dir'";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($warn eq 'fatal') {
0.000000,0,0.000000,push @tokens, ( 'Unsupported YAML version' => $dir, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,push @tokens, ( YAML_DIRECTIVE => $dir, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($$yaml =~ s/\A(\s*%TAG[ \t]+(!$RE_NS_WORD_CHAR*!|!)[ \t]+(tag:\S+|!$RE_URI_CHAR+))($RE_WS*)//) {
0.000000,0,0.000000,push @tokens, ( TAG_DIRECTIVE => $1, $self->line );
0.000000,0,0.000000,# TODO
0.000000,0,0.000000,my $tag_alias = $2;
0.000000,0,0.000000,my $tag_url = $3;
0.000000,0,0.000000,$trailing_ws = $4;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($$yaml =~ s/\A(\s*\A%(?:\w+).*)//) {
0.000000,0,0.000000,push @tokens, ( RESERVED_DIRECTIVE => $1, $self->line );
0.000000,0,0.000000,if ($warn eq 'warn') {
0.000000,0,0.000000,warn "Found reserved directive '$1'";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($warn eq 'fatal') {
0.000000,0,0.000000,die "Found reserved directive '$1'";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, ( 'Invalid directive' => $$yaml, $self->line );
0.000000,0,0.000000,push @tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($trailing_ws and $$yaml =~ s/\A(#.*)?\z//) {
0.000000,0,0.000000,push @tokens, ( EOL => "$trailing_ws$1$eol", $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($$yaml =~ s/\A([ \t]+#.*)?\z//) {
0.000000,0,0.000000,push @tokens, ( EOL => "$1$eol", $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, ( 'Invalid directive' => $trailing_ws.$$yaml, $self->line );
0.000000,0,0.000000,push @tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _push_tokens {
0.010436,61194,0.000000,my ($self, $new_tokens) = @_;
0.034782,61194,0.000001,my $next = $self->next_tokens;
0.028550,61194,0.000000,my $line = $self->line;
0.030373,61194,0.000000,my $column = $self->offset;
0.000000,0,0.000000,
0.056415,61194,0.000001,for (my $i = 0; $i < @$new_tokens; $i += 3) {
0.023537,90100,0.000000,my $value = $new_tokens->[ $i + 1 ];
0.017861,90100,0.000000,my $name = $new_tokens->[ $i ];
0.013318,90100,0.000000,my $line = $new_tokens->[ $i + 2 ];
0.085411,90100,0.000001,my $push = {
0.000000,0,0.000000,name => $name,
0.000000,0,0.000000,line => $line,
0.000000,0,0.000000,column => $column,
0.000000,0,0.000000,value => $value,
0.000000,0,0.000000,};
0.024698,90100,0.000000,$column += length $value unless $name eq 'CONTEXT';
0.012858,90100,0.000000,push @$next, $push;
0.025422,90100,0.000000,if ($name eq 'EOL') {
0.000000,0,0.000000,$column = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.034640,61194,0.000001,$self->set_offset($column);
0.081029,61194,0.000001,return $next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub push_subtokens {
0.000574,2046,0.000000,my ($self, $token, $subtokens) = @_;
0.001572,2046,0.000001,my $next = $self->next_tokens;
0.001767,2046,0.000001,my $line = $self->line;
0.001229,2046,0.000001,my $column = $self->offset;
0.000837,2046,0.000000,$token->{column} = $column;
0.000941,2046,0.000000,$token->{subtokens} = \my @sub;
0.000000,0,0.000000,
0.003321,2046,0.000002,for (my $i = 0; $i < @$subtokens; $i+=3) {
0.002955,6152,0.000000,my $name = $subtokens->[ $i ];
0.002538,6152,0.000000,my $value = $subtokens->[ $i + 1 ];
0.001320,6152,0.000000,my $line = $subtokens->[ $i + 2 ];
0.004985,6152,0.000001,my $push = {
0.000000,0,0.000000,name => $subtokens->[ $i ],
0.000000,0,0.000000,line => $line,
0.000000,0,0.000000,column => $column,
0.000000,0,0.000000,};
0.002419,6152,0.000000,if (ref $value eq 'HASH') {
0.005753,2045,0.000003,%$push = ( %$push, %$value );
0.001315,2045,0.000001,$column += length $value->{orig};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.001581,4107,0.000000,$push->{value} = $value;
0.000855,4107,0.000000,$column += length $value;
0.000000,0,0.000000,}
0.001362,6152,0.000000,if ($push->{name} eq 'EOL') {
0.000000,0,0.000000,$column = 0;
0.000000,0,0.000000,}
0.002018,6152,0.000000,push @sub, $push;
0.000000,0,0.000000,}
0.000927,2046,0.000000,$token->{line} = $sub[0]->{line};
0.000617,2046,0.000000,push @$next, $token;
0.002009,2046,0.000001,$self->set_offset($column);
0.003045,2046,0.000001,return $next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub exception {
0.000000,0,0.000000,my ($self, $msg) = @_;
0.000000,0,0.000000,my $next = $self->next_tokens;
0.000000,0,0.000000,$next = [];
0.000000,0,0.000000,my $line = @$next ? $next->[0]->{line} : $self->line;
0.000000,0,0.000000,my @caller = caller(0);
0.000000,0,0.000000,my $yaml = '';
0.000000,0,0.000000,if (my $nl = $self->next_line) {
0.000000,0,0.000000,$yaml = join '', @$nl;
0.000000,0,0.000000,$yaml = $nl->[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,my $e = YAML::PP::Exception->new(
0.000000,0,0.000000,line => $line,
0.000000,0,0.000000,column => $self->offset + 1,
0.000000,0,0.000000,msg => $msg,
0.000000,0,0.000000,next => $next,
0.000000,0,0.000000,where => $caller[1] . ' line ' . $caller[2],
0.000000,0,0.000000,yaml => $yaml,
0.000000,0,0.000000,);
0.000000,0,0.000000,croak $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000040,1,0.000040,1;
