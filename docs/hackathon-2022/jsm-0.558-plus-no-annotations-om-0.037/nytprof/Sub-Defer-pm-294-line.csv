# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Sub::Defer;
0.000023,2,0.000012,use strict;
0.000016,2,0.000008,use warnings;
0.000014,2,0.000007,use Exporter qw(import);
0.000012,2,0.000006,use Scalar::Util qw(weaken);
0.000043,2,0.000022,use Carp qw(croak);
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '2.006006';
0.000011,1,0.000011,$VERSION = eval $VERSION;
0.000000,0,0.000000,
0.000000,1,0.000000,our @EXPORT = qw(defer_sub undefer_sub undefer_all);
0.000001,1,0.000001,our @EXPORT_OK = qw(undefer_package defer_info);
0.000000,0,0.000000,
0.000426,125,0.000003,sub _getglob { no strict 'refs'; \*{$_[0]} }
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,my $no_subname;
0.000000,0,0.000000,*_subname
0.000000,0,0.000000,= defined &Sub::Util::set_subname ? \&Sub::Util::set_subname
0.000000,0,0.000000,: defined &Sub::Name::subname     ? \&Sub::Name::subname
0.000000,0,0.000000,: (eval { require Sub::Util } && defined &Sub::Util::set_subname) ? \&Sub::Util::set_subname
0.000000,0,0.000000,: (eval { require Sub::Name } && defined &Sub::Name::subname    ) ? \&Sub::Name::subname
0.000001,1,0.000001,: ($no_subname = 1, sub { $_[1] });
0.000003,1,0.000003,*_CAN_SUBNAME = $no_subname ? sub(){0} : sub(){1};
0.000048,1,0.000048,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _name_coderef {
0.000042,109,0.000000,shift if @_ > 2; # three args is (target, name, sub)
0.000642,109,0.000006,_CAN_SUBNAME ? _subname(@_) : $_[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_coderef {
0.000263,109,0.000002,my ($glob, $code) = (_getglob($_[0]), _name_coderef(@_));
0.000023,2,0.000012,no warnings 'redefine';
0.000308,109,0.000003,if (*{$glob}{CODE}) {
0.000000,0,0.000000,*{$glob} = $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,# perl will sometimes warn about mismatched prototypes coming from the
0.000000,0,0.000000,# inheritance cache, so disable them if we aren't redefining a sub
0.000000,0,0.000000,else {
0.000089,2,0.000045,no warnings 'prototype';
0.000044,109,0.000000,*{$glob} = $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# We are dealing with three subs.  The first is the generator sub.  It is
0.000000,0,0.000000,# provided by the user, so we cannot modify it.  When called, it generates the
0.000000,0,0.000000,# undeferred sub.  This is also created, so it also cannot be modified.  These
0.000000,0,0.000000,# are wrapped in a third sub.  The deferred sub is generated by us, and when
0.000000,0,0.000000,# called it uses the generator sub to create the undeferred sub.  If it is a
0.000000,0,0.000000,# named sub, it is installed in the symbol table, usually overwriting the
0.000000,0,0.000000,# deferred sub.  From then on, the deferred sub will goto the undeferred sub
0.000000,0,0.000000,# if it is called.
0.000000,0,0.000000,#
0.000000,0,0.000000,# In %DEFERRED we store array refs with information about these subs.  The key
0.000000,0,0.000000,# is the stringified subref.  We have a CLONE method to fix this up in the
0.000000,0,0.000000,# case of threading to deal with changing refaddrs.  The arrayrefs contain:
0.000000,0,0.000000,#
0.000000,0,0.000000,# 0. fully qualified sub name (or undef)
0.000000,0,0.000000,# 1. generator sub
0.000000,0,0.000000,# 2. options (attributes)
0.000000,0,0.000000,# 3. scalar ref to undeferred sub (inner reference weakened)
0.000000,0,0.000000,# 4. deferred sub (deferred only)
0.000000,0,0.000000,# 5. info arrayref for undeferred sub (deferred only, after undefer)
0.000000,0,0.000000,#
0.000000,0,0.000000,# The deferred sub contains a strong reference to its info arrayref, and the
0.000000,0,0.000000,# undeferred.
0.000000,0,0.000000,
0.000000,0,0.000000,our %DEFERRED;
0.000000,0,0.000000,
0.000000,0,0.000000,sub undefer_sub {
0.000017,38,0.000000,my ($deferred) = @_;
0.000078,38,0.000002,my $info = $DEFERRED{$deferred} or return $deferred;
0.000539,13,0.000041,my ($target, $maker, $options, $undeferred_ref, $deferred_sub) = @$info;
0.000000,0,0.000000,
0.000015,13,0.000001,if (!(
0.000000,0,0.000000,$deferred_sub && $deferred eq $deferred_sub
0.000000,0,0.000000,|| ${$undeferred_ref} && $deferred eq ${$undeferred_ref}
0.000000,0,0.000000,)) {
0.000000,0,0.000000,return $deferred;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ${$undeferred_ref}
0.000007,13,0.000001,if ${$undeferred_ref};
0.000042,13,0.000003,${$undeferred_ref} = my $made = $maker->();
0.000000,0,0.000000,
0.000000,0,0.000000,# make sure the method slot has not changed since deferral time
0.000038,13,0.000003,if (defined($target) && $deferred eq *{_getglob($target)}{CODE}||'') {
0.000332,2,0.000166,no warnings 'redefine';
0.000000,0,0.000000,
0.000000,0,0.000000,# I believe $maker already evals with the right package/name, so that
0.000000,0,0.000000,# _install_coderef calls are not necessary --ribasushi
0.000012,7,0.000002,*{_getglob($target)} = $made;
0.000000,0,0.000000,}
0.000016,13,0.000001,my $undefer_info = [ $target, $maker, $options, $undeferred_ref ];
0.000025,13,0.000002,$info->[5] = $DEFERRED{$made} = $undefer_info;
0.000039,13,0.000003,weaken ${$undefer_info->[3]};
0.000000,0,0.000000,
0.000053,13,0.000004,return $made;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub undefer_all {
0.000000,0,0.000000,undefer_sub($_) for keys %DEFERRED;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub undefer_package {
0.000004,10,0.000000,my $package = shift;
0.000000,0,0.000000,undefer_sub($_)
0.000150,10,0.000015,for grep {
0.000213,333,0.000001,my $name = $DEFERRED{$_} && $DEFERRED{$_}[0];
0.000313,333,0.000001,$name && $name =~ /^${package}::[^:]+$/
0.000000,0,0.000000,} keys %DEFERRED;
0.000017,10,0.000002,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub defer_info {
0.000000,0,0.000000,my ($deferred) = @_;
0.000000,0,0.000000,my $info = $DEFERRED{$deferred||''} or return undef;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($target, $maker, $options, $undeferred_ref, $deferred_sub) = @$info;
0.000000,0,0.000000,if (!(
0.000000,0,0.000000,$deferred_sub && $deferred eq $deferred_sub
0.000000,0,0.000000,|| ${$undeferred_ref} && $deferred eq ${$undeferred_ref}
0.000000,0,0.000000,)) {
0.000000,0,0.000000,delete $DEFERRED{$deferred};
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,[
0.000000,0,0.000000,$target, $maker, $options,
0.000000,0,0.000000,( $undeferred_ref && $$undeferred_ref ? $$undeferred_ref : ()),
0.000000,0,0.000000,];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub defer_sub {
0.000016,37,0.000000,my ($target, $maker, $options) = @_;
0.000008,37,0.000000,my $package;
0.000000,0,0.000000,my $subname;
0.000081,37,0.000002,($package, $subname) = $target =~ /^(.*)::([^:]+)$/
0.000000,0,0.000000,or croak "$target is not a fully qualified sub name!"
0.000000,0,0.000000,if $target;
0.000021,37,0.000001,$package ||= $options && $options->{package} || caller;
0.000037,37,0.000001,my @attributes = @{$options && $options->{attributes} || []};
0.000011,37,0.000000,if (@attributes) {
0.000000,0,0.000000,/\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_"
0.000000,0,0.000000,for @attributes;
0.000000,0,0.000000,}
0.000007,37,0.000000,my $deferred;
0.000000,0,0.000000,my $undeferred;
0.000039,37,0.000001,my $deferred_info = [ $target, $maker, $options, \$undeferred ];
0.000019,37,0.000001,if (@attributes || $target && !_CAN_SUBNAME) {
0.000000,0,0.000000,my $code
0.000000,0,0.000000,=  q[#line ].(__LINE__+2).q[ "].__FILE__.qq["\n]
0.000000,0,0.000000,. qq[package $package;\n]
0.000000,0,0.000000,. ($target ? "sub $subname" : '+sub') . join('', map " :$_", @attributes)
0.000000,0,0.000000,. q[ {
0.000000,0,0.000000,package Sub::Defer;
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,# uncoverable statement
0.000000,0,0.000000,$undeferred ||= undefer_sub($deferred_info->[4]);
0.000000,0,0.000000,goto &$undeferred; # uncoverable statement
0.000000,0,0.000000,$undeferred; # fake lvalue return
0.000000,0,0.000000,}]."\n"
0.000000,0,0.000000,. ($target ? "\\&$subname" : '');
0.000000,0,0.000000,my $e;
0.000000,0,0.000000,$deferred = do {
0.000170,2,0.000085,no warnings qw(redefine closure);
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,eval $code or $e = $@; # uncoverable branch true
0.000000,0,0.000000,};
0.000000,0,0.000000,die $e if defined $e; # uncoverable branch true
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# duplicated from above
0.000000,0,0.000000,$deferred = sub {
0.000566,75,0.000008,$undeferred ||= undefer_sub($deferred_info->[4]);
0.000368,75,0.000005,goto &$undeferred;
0.000057,37,0.000002,};
0.000022,37,0.000001,_install_coderef($target, $deferred)
0.000000,0,0.000000,if $target;
0.000000,0,0.000000,}
0.000145,37,0.000004,weaken($deferred_info->[4] = $deferred);
0.000099,37,0.000003,weaken($DEFERRED{$deferred} = $deferred_info);
0.000094,37,0.000003,return $deferred;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub CLONE {
0.000000,0,0.000000,%DEFERRED = map {
0.000000,0,0.000000,defined $_ ? (
0.000000,0,0.000000,$_->[4] ? ($_->[4] => $_)
0.000000,0,0.000000,: ($_->[3] && ${$_->[3]}) ? (${$_->[3]} => $_)
0.000000,0,0.000000,: ()
0.000000,0,0.000000,) : ()
0.000000,0,0.000000,} values %DEFERRED;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,1;
0.000000,0,0.000000,__END__
