# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Type::Tiny::Enum;
0.000000,0,0.000000,
0.000038,2,0.000019,use 5.008001;
0.000021,2,0.000011,use strict;
0.000025,2,0.000012,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000001,1,0.000001,$Type::Tiny::Enum::AUTHORITY = 'cpan:TOBYINK';
0.000002,1,0.000002,$Type::Tiny::Enum::VERSION   = '2.000001';
0.000042,1,0.000042,}
0.000000,0,0.000000,
0.000001,1,0.000001,$Type::Tiny::Enum::VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
0.000000,0,0.000000,
0.000023,3,0.000008,use Exporter::Tiny 1.004001 ();
0.000146,2,0.000073,use Type::Tiny ();
0.000008,1,0.000008,our @ISA = qw( Type::Tiny Exporter::Tiny );
0.000000,0,0.000000,
0.000000,0,0.000000,__PACKAGE__->_install_overloads(
0.000000,0,0.000000,q[@{}] => sub { shift->values },
0.000005,1,0.000005,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub _exporter_fail {
0.000000,0,0.000000,my ( $class, $type_name, $values, $globals ) = @_;
0.000000,0,0.000000,my $caller = $globals->{into};
0.000000,0,0.000000,my $type = $class->new(
0.000000,0,0.000000,name      => $type_name,
0.000000,0,0.000000,values    => [ @$values ],
0.000000,0,0.000000,coercion  => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,$INC{'Type/Registry.pm'}
0.000000,0,0.000000,? 'Type::Registry'->for_class( $caller )->add_type( $type, $type_name )
0.000000,0,0.000000,: ( $Type::Registry::DELAYED{$caller}{$type_name} = $type )
0.000000,0,0.000000,unless( ref($caller) or $caller eq '-lexical' or $globals->{'lexical'} );
0.000000,0,0.000000,return map +( $_->{name} => $_->{code} ), @{ $type->exportables };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000002,4,0.000000,my $proto = shift;
0.000000,0,0.000000,
0.000005,4,0.000001,my %opts = ( @_ == 1 ) ? %{ $_[0] } : @_;
0.000000,0,0.000000,_croak
0.000000,0,0.000000,"Enum type constraints cannot have a parent constraint passed to the constructor"
0.000003,4,0.000001,if exists $opts{parent};
0.000000,0,0.000000,_croak
0.000000,0,0.000000,"Enum type constraints cannot have a constraint coderef passed to the constructor"
0.000000,4,0.000000,if exists $opts{constraint};
0.000000,0,0.000000,_croak
0.000000,0,0.000000,"Enum type constraints cannot have a inlining coderef passed to the constructor"
0.000002,4,0.000000,if exists $opts{inlined};
0.000000,4,0.000000,_croak "Need to supply list of values" unless exists $opts{values};
0.000000,0,0.000000,
0.001737,2,0.000869,no warnings 'uninitialized';
0.000000,0,0.000000,$opts{values} = [
0.000000,0,0.000000,map "$_",
0.000014,4,0.000004,@{ ref $opts{values} eq 'ARRAY' ? $opts{values} : [ $opts{values} ] }
0.000000,0,0.000000,];
0.000000,0,0.000000,
0.000001,4,0.000000,my %tmp;
0.000017,4,0.000004,undef $tmp{$_} for @{ $opts{values} };
0.000027,4,0.000007,$opts{unique_values} = [ sort keys %tmp ];
0.000000,0,0.000000,
0.000006,4,0.000001,my $xs_encoding = _xs_encoding( $opts{unique_values} );
0.000001,4,0.000000,if ( defined $xs_encoding ) {
0.000000,0,0.000000,my $xsub = Type::Tiny::XS::get_coderef_for( $xs_encoding );
0.000000,0,0.000000,$opts{compiled_type_constraint} = $xsub if $xsub;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000025,4,0.000006,if ( defined $opts{coercion} and !ref $opts{coercion} and 1 eq $opts{coercion} )
0.000000,0,0.000000,{
0.000000,0,0.000000,delete $opts{coercion};
0.000000,0,0.000000,$opts{_build_coercion} = sub {
0.000000,0,0.000000,require Types::Standard;
0.000000,0,0.000000,my $c = shift;
0.000000,0,0.000000,my $t = $c->type_constraint;
0.000000,0,0.000000,$c->add_type_coercions(
0.000000,0,0.000000,Types::Standard::Str(),
0.000000,0,0.000000,sub { $t->closest_match( @_ ? $_[0] : $_ ) }
0.000000,0,0.000000,);
0.000000,0,0.000000,};
0.000000,0,0.000000,} #/ if ( defined $opts{coercion...})
0.000000,0,0.000000,
0.000019,4,0.000005,return $proto->SUPER::new( %opts );
0.000000,0,0.000000,} #/ sub new
0.000000,0,0.000000,
0.000000,0,0.000000,sub new_union {
0.000000,0,0.000000,my $proto  = shift;
0.000000,0,0.000000,my %opts   = ( @_ == 1 ) ? %{ $_[0] } : @_;
0.000000,0,0.000000,my @types  = @{ delete $opts{type_constraints} };
0.000000,0,0.000000,my @values = map @$_, @types;
0.000000,0,0.000000,$proto->new( %opts, values => \@values );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub new_intersection {
0.000000,0,0.000000,my $proto  = shift;
0.000000,0,0.000000,my %opts   = ( @_ == 1 ) ? %{ $_[0] } : @_;
0.000000,0,0.000000,my @types  = @{ delete $opts{type_constraints} };
0.000000,0,0.000000,my %values; ++$values{$_} for map @$_, @types;
0.000000,0,0.000000,my @values = sort grep $values{$_}==@types, keys %values;
0.000000,0,0.000000,$proto->new( %opts, values => \@values );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub values        { $_[0]{values} }
0.000086,41,0.000002,sub unique_values { $_[0]{unique_values} }
0.000000,0,0.000000,sub constraint    { $_[0]{constraint} ||= $_[0]->_build_constraint }
0.000000,0,0.000000,
0.000008,4,0.000002,sub _is_null_constraint { 0 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_display_name {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,sprintf( "Enum[%s]", join q[,], @{ $self->unique_values } );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_word_safe {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return not grep /\W/, @{ $self->unique_values };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub exportables {
0.000000,0,0.000000,my ( $self, $base_name ) = @_;
0.000000,0,0.000000,if ( not $self->is_anon ) {
0.000000,0,0.000000,$base_name ||= $self->name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $exportables = $self->SUPER::exportables( $base_name );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->is_word_safe ) {
0.000000,0,0.000000,require Eval::TypeTiny;
0.000000,0,0.000000,require B;
0.000000,0,0.000000,for my $value ( @{ $self->unique_values } ) {
0.000000,0,0.000000,push @$exportables, {
0.000000,0,0.000000,name => uc( sprintf '%s_%s', $base_name, $value ),
0.000000,0,0.000000,tags => [ 'constants' ],
0.000000,0,0.000000,code => Eval::TypeTiny::eval_closure(
0.000000,0,0.000000,source      => sprintf( 'sub () { %s }', B::perlstring($value) ),
0.000000,0,0.000000,environment => {},
0.000000,0,0.000000,),
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $exportables;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,1,0.000000,my $new_xs;
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# Note the fallback code for older Type::Tiny::XS cannot be tested as
0.000000,0,0.000000,# part of the coverage tests because they use the latest Type::Tiny::XS.
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,0,0.000000,sub _xs_encoding {
0.000010,41,0.000000,my $unique_values = shift;
0.000000,0,0.000000,
0.000067,41,0.000002,return undef unless Type::Tiny::_USE_XS;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef if @$unique_values > 50;    # RT 121957
0.000000,0,0.000000,
0.000000,0,0.000000,$new_xs = eval { Type::Tiny::XS->VERSION( "0.020" ); 1 } ? 1 : 0
0.000000,0,0.000000,unless defined $new_xs;
0.000000,0,0.000000,if ( $new_xs ) {
0.000000,0,0.000000,require B;
0.000000,0,0.000000,return sprintf(
0.000000,0,0.000000,"Enum[%s]",
0.000000,0,0.000000,join( ",", map B::perlstring( $_ ), @$unique_values )
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {                                   # uncoverable statement
0.000000,0,0.000000,return undef if grep /\W/, @$unique_values;                    # uncoverable statement
0.000000,0,0.000000,return sprintf( "Enum[%s]", join( ",", @$unique_values ) );    # uncoverable statement
0.000000,0,0.000000,}    # uncoverable statement
0.000000,0,0.000000,} #/ sub _xs_encoding
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,2,0.000000,my %cached;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_constraint {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $regexp = $self->_regexp;
0.000000,0,0.000000,return $cached{$regexp} if $cached{$regexp};
0.000000,0,0.000000,my $coderef = ( $cached{$regexp} = sub { defined and m{\A(?:$regexp)\z} } );
0.000000,0,0.000000,Scalar::Util::weaken( $cached{$regexp} );
0.000000,0,0.000000,return $coderef;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,2,0.000000,my %cached;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_compiled_check {
0.000001,4,0.000000,my $self   = shift;
0.000005,4,0.000001,my $regexp = $self->_regexp;
0.000003,4,0.000001,return $cached{$regexp} if $cached{$regexp};
0.000012,4,0.000003,my $coderef = ( $cached{$regexp} = $self->SUPER::_build_compiled_check( @_ ) );
0.000010,4,0.000002,Scalar::Util::weaken( $cached{$regexp} );
0.000007,4,0.000002,return $coderef;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,sub _regexp {
0.000012,41,0.000000,my $self = shift;
0.000084,41,0.000002,$self->{_regexp} ||= 'Type::Tiny::Enum::_Trie'->handle( $self->unique_values );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub as_regexp {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $flags = @_ ? $_[0] : '';
0.000000,0,0.000000,unless ( defined $flags and $flags =~ /^[i]*$/ ) {
0.000000,0,0.000000,_croak(
0.000000,0,0.000000,"Unknown regexp flags: '$flags'; only 'i' currently accepted; stopped" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $regexp = $self->_regexp;
0.000000,0,0.000000,$flags ? qr/\A(?:$regexp)\z/i : qr/\A(?:$regexp)\z/;
0.000000,0,0.000000,} #/ sub as_regexp
0.000000,0,0.000000,
0.000000,0,0.000000,sub can_be_inlined {
0.000041,21,0.000002,!!1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub inline_check {
0.000007,37,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000008,37,0.000000,my $xsub;
0.000114,37,0.000003,if ( my $xs_encoding = _xs_encoding( $self->unique_values ) ) {
0.000000,0,0.000000,$xsub = Type::Tiny::XS::get_subname_for( $xs_encoding );
0.000000,0,0.000000,return "$xsub\($_[0]\)" if $xsub && !$Type::Tiny::AvoidCallbacks;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000047,37,0.000001,my $regexp = $self->_regexp;
0.000041,37,0.000001,my $code =
0.000000,0,0.000000,$_[0] eq '$_'
0.000000,0,0.000000,? "(defined and !ref and m{\\A(?:$regexp)\\z})"
0.000000,0,0.000000,: "(defined($_[0]) and !ref($_[0]) and $_[0] =~ m{\\A(?:$regexp)\\z})";
0.000000,0,0.000000,
0.000011,37,0.000000,return "do { $Type::Tiny::SafePackage $code }"
0.000000,0,0.000000,if $Type::Tiny::AvoidCallbacks;
0.000059,37,0.000002,return $code;
0.000000,0,0.000000,} #/ sub inline_check
0.000000,0,0.000000,
0.000000,0,0.000000,sub _instantiate_moose_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %opts = @_;
0.000000,0,0.000000,delete $opts{parent};
0.000000,0,0.000000,delete $opts{constraint};
0.000000,0,0.000000,delete $opts{inlined};
0.000000,0,0.000000,require Moose::Meta::TypeConstraint::Enum;
0.000000,0,0.000000,return "Moose::Meta::TypeConstraint::Enum"
0.000000,0,0.000000,->new( %opts, values => $self->values );
0.000000,0,0.000000,} #/ sub _instantiate_moose_type
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_parent {
0.000028,22,0.000001,!!1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parent {
0.000018,44,0.000000,require Types::Standard;
0.000072,44,0.000002,Types::Standard::Str();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub validate_explain {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $value, $varname ) = @_;
0.000000,0,0.000000,$varname = '$_' unless defined $varname;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef if $self->check( $value );
0.000000,0,0.000000,
0.000000,0,0.000000,require Type::Utils;
0.000000,0,0.000000,!defined( $value )
0.000000,0,0.000000,? [
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'"%s" requires that the value is defined',
0.000000,0,0.000000,$self,
0.000000,0,0.000000,),
0.000000,0,0.000000,]
0.000000,0,0.000000,: @$self < 13 ? [
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'"%s" requires that the value is equal to %s',
0.000000,0,0.000000,$self,
0.000000,0,0.000000,Type::Utils::english_list( \"or", map B::perlstring( $_ ), @$self ),
0.000000,0,0.000000,),
0.000000,0,0.000000,]
0.000000,0,0.000000,: [
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'"%s" requires that the value is one of an enumerated list of strings',
0.000000,0,0.000000,$self,
0.000000,0,0.000000,),
0.000000,0,0.000000,];
0.000000,0,0.000000,} #/ sub validate_explain
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_sorter {
0.000000,0,0.000000,!!1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _enum_order_hash {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %hash;
0.000000,0,0.000000,my $i = 0;
0.000000,0,0.000000,for my $value ( @{ $self->values } ) {
0.000000,0,0.000000,next if exists $hash{$value};
0.000000,0,0.000000,$hash{$value} = $i++;
0.000000,0,0.000000,}
0.000000,0,0.000000,return %hash;
0.000000,0,0.000000,} #/ sub _enum_order_hash
0.000000,0,0.000000,
0.000000,0,0.000000,sub sorter {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %hash = $self->_enum_order_hash;
0.000000,0,0.000000,return [
0.000000,0,0.000000,sub { $_[0] <=> $_[1] },
0.000000,0,0.000000,sub { exists( $hash{ $_[0] } ) ? $hash{ $_[0] } : 2_100_000_000 },
0.000000,0,0.000000,];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my $canon;
0.000000,0,0.000000,
0.000000,0,0.000000,sub closest_match {
0.000000,0,0.000000,require Types::Standard;
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $self, $given ) = ( shift, @_ );
0.000000,0,0.000000,
0.000000,0,0.000000,return unless Types::Standard::is_Str $given;
0.000000,0,0.000000,
0.000000,0,0.000000,return $given if $self->check( $given );
0.000000,0,0.000000,
0.000000,0,0.000000,$canon ||= eval(
0.000000,0,0.000000,$] lt '5.016'
0.000000,0,0.000000,? q< sub { ( my $var = lc($_[0]) ) =~ s/(^\s+)|(\s+$)//g; $var } >
0.000000,0,0.000000,: q< sub { CORE::fc($_[0]) =~ s/(^\s+)|(\s+$)//gr; } >
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{_lookups} ||= do {
0.000000,0,0.000000,my %lookups;
0.000000,0,0.000000,for ( @{ $self->values } ) {
0.000000,0,0.000000,my $key = $canon->( $_ );
0.000000,0,0.000000,next if exists $lookups{$key};
0.000000,0,0.000000,$lookups{$key} = $_;
0.000000,0,0.000000,}
0.000000,0,0.000000,\%lookups;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,my $cgiven = $canon->( $given );
0.000000,0,0.000000,return $self->{_lookups}{$cgiven}
0.000000,0,0.000000,if $self->{_lookups}{$cgiven};
0.000000,0,0.000000,
0.000000,0,0.000000,my $best;
0.000000,0,0.000000,VALUE: for my $possible ( @{ $self->values } ) {
0.000000,0,0.000000,my $stem = substr( $possible, 0, length $cgiven );
0.000000,0,0.000000,if ( $cgiven eq $canon->( $stem ) ) {
0.000000,0,0.000000,if ( defined( $best ) and length( $best ) >= length( $possible ) ) {
0.000000,0,0.000000,next VALUE;
0.000000,0,0.000000,}
0.000000,0,0.000000,$best = $possible;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $best if defined $best;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->values->[$given]
0.000000,0,0.000000,if Types::Standard::is_Int $given;
0.000000,0,0.000000,
0.000000,0,0.000000,return $given;
0.000000,0,0.000000,} #/ sub closest_match
0.000000,0,0.000000,
0.000000,0,0.000000,push @Type::Tiny::CMP, sub {
0.000000,0,0.000000,my $A = shift->find_constraining_type;
0.000000,0,0.000000,my $B = shift->find_constraining_type;
0.000000,0,0.000000,return Type::Tiny::CMP_UNKNOWN
0.000000,0,0.000000,unless $A->isa( __PACKAGE__ ) && $B->isa( __PACKAGE__ );
0.000000,0,0.000000,
0.000000,0,0.000000,my %seen;
0.000000,0,0.000000,for my $word ( @{ $A->unique_values } ) {
0.000000,0,0.000000,$seen{$word} += 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,for my $word ( @{ $B->unique_values } ) {
0.000000,0,0.000000,$seen{$word} += 2;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $values = join( '', CORE::values %seen );
0.000000,0,0.000000,if ( $values =~ /^3*$/ ) {
0.000000,0,0.000000,return Type::Tiny::CMP_EQUIVALENT;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $values !~ /2/ ) {
0.000000,0,0.000000,return Type::Tiny::CMP_SUPERTYPE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $values !~ /1/ ) {
0.000000,0,0.000000,return Type::Tiny::CMP_SUBTYPE;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return Type::Tiny::CMP_UNKNOWN;
0.000002,1,0.000002,};
0.000000,0,0.000000,
0.000000,0,0.000000,package    # stolen from Regexp::Trie
0.000000,0,0.000000,Type::Tiny::Enum::_Trie;
0.000009,4,0.000002,sub new { bless {} => shift }
0.000000,0,0.000000,
0.000000,0,0.000000,sub add {
0.000003,19,0.000000,my $self = shift;
0.000002,19,0.000000,my $str  = shift;
0.000001,19,0.000000,my $ref  = $self;
0.000036,19,0.000002,for my $char ( split //, $str ) {
0.000041,137,0.000000,$ref->{$char} ||= {};
0.000030,137,0.000000,$ref = $ref->{$char};
0.000000,0,0.000000,}
0.000005,19,0.000000,$ref->{''} = 1;    # { '' => 1 } as terminator
0.000018,19,0.000001,$self;
0.000000,0,0.000000,} #/ sub add
0.000000,0,0.000000,
0.000000,0,0.000000,sub _regexp {
0.000012,126,0.000000,my $self = shift;
0.000035,126,0.000000,return if $self->{''} and scalar keys %$self == 1;    # terminator
0.000009,107,0.000000,my ( @alt, @cc );
0.000008,107,0.000000,my $q = 0;
0.000141,107,0.000001,for my $char ( sort keys %$self ) {
0.000019,122,0.000000,my $qchar = quotemeta $char;
0.000171,122,0.000001,if ( ref $self->{$char} ) {
0.000000,0,0.000000,if ( defined( my $recurse = _regexp( $self->{$char} ) ) ) {
0.000000,0,0.000000,push @alt, $qchar . $recurse;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000008,19,0.000000,push @cc, $qchar;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$q = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ for my $char ( sort keys...)
0.000011,107,0.000000,my $cconly = !@alt;
0.000014,107,0.000000,@cc and push @alt, @cc == 1 ? $cc[0] : '[' . join( '', @cc ) . ']';
0.000037,107,0.000000,my $result = @alt == 1 ? $alt[0] : '(?:' . join( '|', @alt ) . ')';
0.000010,107,0.000000,$q and $result = $cconly ? "$result?" : "(?:$result)?";
0.000145,107,0.000001,return $result;
0.000000,0,0.000000,} #/ sub _regexp
0.000000,0,0.000000,
0.000000,0,0.000000,sub handle {
0.000001,4,0.000000,my $class = shift;
0.000001,4,0.000000,my ( $vals ) = @_;
0.000001,4,0.000000,return '(?!)' unless @$vals;
0.000008,4,0.000002,my $self = $class->new;
0.000013,4,0.000003,$self->add( $_ ) for @$vals;
0.000031,4,0.000008,$self->_regexp;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
