# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package IO::Uncompress::Base ;
0.000000,0,0.000000,
0.000023,2,0.000012,use strict ;
0.000012,2,0.000006,use warnings;
0.000042,2,0.000021,use bytes;
0.000000,0,0.000000,
0.000000,0,0.000000,our (@ISA, $VERSION, @EXPORT_OK, %EXPORT_TAGS);
0.000014,1,0.000014,@ISA    = qw(IO::File Exporter);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,1,0.000000,$VERSION = '2.106';
0.000000,0,0.000000,
0.000019,2,0.000010,use constant G_EOF => 0 ;
0.000015,2,0.000008,use constant G_ERR => -1 ;
0.000000,0,0.000000,
0.000027,3,0.000009,use IO::Compress::Base::Common 2.106 ;
0.000000,0,0.000000,
0.000022,2,0.000011,use IO::File ;
0.000018,2,0.000009,use Symbol;
0.000017,2,0.000008,use Scalar::Util ();
0.000022,2,0.000011,use List::Util ();
0.000167,2,0.000083,use Carp ;
0.000000,0,0.000000,
0.000001,1,0.000001,%EXPORT_TAGS = ( );
0.000001,1,0.000001,push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;
0.000000,0,0.000000,
0.000000,0,0.000000,sub smartRead
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = $_[0];
0.000000,0,0.000000,my $out = $_[1];
0.000000,0,0.000000,my $size = $_[2];
0.000000,0,0.000000,$$out = "" ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $offset = 0 ;
0.000000,0,0.000000,my $status = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined *$self->{InputLength}) {
0.000000,0,0.000000,return 0
0.000000,0,0.000000,if *$self->{InputLengthRemaining} <= 0 ;
0.000000,0,0.000000,$size = List::Util::min($size, *$self->{InputLengthRemaining});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( length *$self->{Prime} ) {
0.000000,0,0.000000,$$out = substr(*$self->{Prime}, 0, $size) ;
0.000000,0,0.000000,substr(*$self->{Prime}, 0, $size) =  '' ;
0.000000,0,0.000000,if (length $$out == $size) {
0.000000,0,0.000000,*$self->{InputLengthRemaining} -= length $$out
0.000000,0,0.000000,if defined *$self->{InputLength};
0.000000,0,0.000000,
0.000000,0,0.000000,return length $$out ;
0.000000,0,0.000000,}
0.000000,0,0.000000,$offset = length $$out ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $get_size = $size - $offset ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined *$self->{FH}) {
0.000000,0,0.000000,if ($offset) {
0.000000,0,0.000000,# Not using this
0.000000,0,0.000000,#
0.000000,0,0.000000,#  *$self->{FH}->read($$out, $get_size, $offset);
0.000000,0,0.000000,#
0.000000,0,0.000000,# because the filehandle may not support the offset parameter
0.000000,0,0.000000,# An example is Net::FTP
0.000000,0,0.000000,my $tmp = '';
0.000000,0,0.000000,$status = *$self->{FH}->read($tmp, $get_size) ;
0.000000,0,0.000000,substr($$out, $offset) = $tmp
0.000000,0,0.000000,if defined $status && $status > 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{ $status = *$self->{FH}->read($$out, $get_size) }
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (defined *$self->{InputEvent}) {
0.000000,0,0.000000,my $got = 1 ;
0.000000,0,0.000000,while (length $$out < $size) {
0.000000,0,0.000000,last
0.000000,0,0.000000,if ($got = *$self->{InputEvent}->($$out, $get_size)) <= 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (length $$out > $size ) {
0.000000,0,0.000000,*$self->{Prime} = substr($$out, $size, length($$out));
0.000000,0,0.000000,substr($$out, $size, length($$out)) =  '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{EventEof} = 1 if $got <= 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.001057,2,0.000528,no warnings 'uninitialized';
0.000000,0,0.000000,my $buf = *$self->{Buffer} ;
0.000000,0,0.000000,$$buf = '' unless defined $$buf ;
0.000000,0,0.000000,substr($$out, $offset) = substr($$buf, *$self->{BufferOffset}, $get_size);
0.000000,0,0.000000,if (*$self->{ConsumeInput})
0.000000,0,0.000000,{ substr($$buf, 0, $get_size) = '' }
0.000000,0,0.000000,else
0.000000,0,0.000000,{ *$self->{BufferOffset} += length($$out) - $offset }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{InputLengthRemaining} -= length($$out) #- $offset
0.000000,0,0.000000,if defined *$self->{InputLength};
0.000000,0,0.000000,
0.000000,0,0.000000,if (! defined $status) {
0.000000,0,0.000000,$self->saveStatus($!) ;
0.000000,0,0.000000,return STATUS_ERROR;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->saveStatus(length $$out < 0 ? STATUS_ERROR : STATUS_OK) ;
0.000000,0,0.000000,
0.000000,0,0.000000,return length $$out;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub pushBack
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return if ! defined $_[0] || length $_[0] == 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined *$self->{FH} || defined *$self->{InputEvent} ) {
0.000000,0,0.000000,*$self->{Prime} = $_[0] . *$self->{Prime} ;
0.000000,0,0.000000,*$self->{InputLengthRemaining} += length($_[0]);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $len = length $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,if($len > *$self->{BufferOffset}) {
0.000000,0,0.000000,*$self->{Prime} = substr($_[0], 0, $len - *$self->{BufferOffset}) . *$self->{Prime} ;
0.000000,0,0.000000,*$self->{InputLengthRemaining} = *$self->{InputLength};
0.000000,0,0.000000,*$self->{BufferOffset} = 0
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,*$self->{InputLengthRemaining} += length($_[0]);
0.000000,0,0.000000,*$self->{BufferOffset} -= length($_[0]) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub smartSeek
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,my $offset = shift ;
0.000000,0,0.000000,my $truncate = shift;
0.000000,0,0.000000,my $position = shift || SEEK_SET;
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO -- need to take prime into account
0.000000,0,0.000000,*$self->{Prime} = '';
0.000000,0,0.000000,if (defined *$self->{FH})
0.000000,0,0.000000,{ *$self->{FH}->seek($offset, $position) }
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($position == SEEK_END) {
0.000000,0,0.000000,*$self->{BufferOffset} = length(${ *$self->{Buffer} }) + $offset ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($position == SEEK_CUR) {
0.000000,0,0.000000,*$self->{BufferOffset} += $offset ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,*$self->{BufferOffset} = $offset ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,substr(${ *$self->{Buffer} }, *$self->{BufferOffset}) = ''
0.000000,0,0.000000,if $truncate;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub smartTell
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined *$self->{FH})
0.000000,0,0.000000,{ return *$self->{FH}->tell() }
0.000000,0,0.000000,else
0.000000,0,0.000000,{ return *$self->{BufferOffset} }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub smartWrite
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,my $out_data = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined *$self->{FH}) {
0.000000,0,0.000000,# flush needed for 5.8.0
0.000000,0,0.000000,defined *$self->{FH}->write($out_data, length $out_data) &&
0.000000,0,0.000000,defined *$self->{FH}->flush() ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $buf = *$self->{Buffer} ;
0.000000,0,0.000000,substr($$buf, *$self->{BufferOffset}, length $out_data) = $out_data ;
0.000000,0,0.000000,*$self->{BufferOffset} += length($out_data) ;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub smartReadExact
0.000000,0,0.000000,{
0.000000,0,0.000000,return $_[0]->smartRead($_[1], $_[2]) == $_[2];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub smartEof
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($self) = $_[0];
0.000000,0,0.000000,local $.;
0.000000,0,0.000000,
0.000000,0,0.000000,return 0 if length *$self->{Prime} || *$self->{PushMode};
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined *$self->{FH})
0.000000,0,0.000000,{
0.000000,0,0.000000,# Could use
0.000000,0,0.000000,#
0.000000,0,0.000000,#  *$self->{FH}->eof()
0.000000,0,0.000000,#
0.000000,0,0.000000,# here, but this can cause trouble if
0.000000,0,0.000000,# the filehandle is itself a tied handle, but it uses sysread.
0.000000,0,0.000000,# Then we get into mixing buffered & non-buffered IO,
0.000000,0,0.000000,# which will cause trouble
0.000000,0,0.000000,
0.000000,0,0.000000,my $info = $self->getErrInfo();
0.000000,0,0.000000,
0.000000,0,0.000000,my $buffer = '';
0.000000,0,0.000000,my $status = $self->smartRead(\$buffer, 1);
0.000000,0,0.000000,$self->pushBack($buffer) if length $buffer;
0.000000,0,0.000000,$self->setErrInfo($info);
0.000000,0,0.000000,
0.000000,0,0.000000,return $status == 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (defined *$self->{InputEvent})
0.000000,0,0.000000,{ *$self->{EventEof} }
0.000000,0,0.000000,else
0.000000,0,0.000000,{ *$self->{BufferOffset} >= length(${ *$self->{Buffer} }) }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clearError
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{ErrorNo}  =  0 ;
0.000000,0,0.000000,${ *$self->{Error} } = '' ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getErrInfo
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return [ *$self->{ErrorNo}, ${ *$self->{Error} } ] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub setErrInfo
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,my $ref    = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{ErrorNo}  =  $ref->[0] ;
0.000000,0,0.000000,${ *$self->{Error} } = $ref->[1] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub saveStatus
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,my $errno = shift() + 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{ErrorNo}  = $errno;
0.000000,0,0.000000,${ *$self->{Error} } = '' ;
0.000000,0,0.000000,
0.000000,0,0.000000,return *$self->{ErrorNo} ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub saveErrorString
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,my $retval = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,${ *$self->{Error} } = shift ;
0.000000,0,0.000000,*$self->{ErrorNo} = @_ ? shift() + 0 : STATUS_ERROR ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $retval;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub croakError
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,$self->saveErrorString(0, $_[0]);
0.000000,0,0.000000,croak $_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub closeError
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $retval = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $errno = *$self->{ErrorNo};
0.000000,0,0.000000,my $error = ${ *$self->{Error} };
0.000000,0,0.000000,
0.000000,0,0.000000,$self->close();
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{ErrorNo} = $errno ;
0.000000,0,0.000000,${ *$self->{Error} } = $error ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $retval;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub error
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,return ${ *$self->{Error} } ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub errorNo
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,return *$self->{ErrorNo};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub HeaderError
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($self) = shift;
0.000000,0,0.000000,return $self->saveErrorString(undef, "Header Error: $_[0]", STATUS_ERROR);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub TrailerError
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($self) = shift;
0.000000,0,0.000000,return $self->saveErrorString(G_ERR, "Trailer Error: $_[0]", STATUS_ERROR);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub TruncatedHeader
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($self) = shift;
0.000000,0,0.000000,return $self->HeaderError("Truncated in $_[0] Section");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub TruncatedTrailer
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($self) = shift;
0.000000,0,0.000000,return $self->TrailerError("Truncated in $_[0] Section");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub postCheckParams
0.000000,0,0.000000,{
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub checkParams
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $class = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $got = shift || IO::Compress::Base::Parameters::new();
0.000000,0,0.000000,
0.000000,0,0.000000,my $Valid = {
0.000000,0,0.000000,'blocksize'     => [IO::Compress::Base::Common::Parse_unsigned, 16 * 1024],
0.000000,0,0.000000,'autoclose'     => [IO::Compress::Base::Common::Parse_boolean,  0],
0.000000,0,0.000000,'strict'        => [IO::Compress::Base::Common::Parse_boolean,  0],
0.000000,0,0.000000,'append'        => [IO::Compress::Base::Common::Parse_boolean,  0],
0.000000,0,0.000000,'prime'         => [IO::Compress::Base::Common::Parse_any,      undef],
0.000000,0,0.000000,'multistream'   => [IO::Compress::Base::Common::Parse_boolean,  0],
0.000000,0,0.000000,'transparent'   => [IO::Compress::Base::Common::Parse_any,      1],
0.000000,0,0.000000,'scan'          => [IO::Compress::Base::Common::Parse_boolean,  0],
0.000000,0,0.000000,'inputlength'   => [IO::Compress::Base::Common::Parse_unsigned, undef],
0.000000,0,0.000000,'binmodeout'    => [IO::Compress::Base::Common::Parse_boolean,  0],
0.000000,0,0.000000,#'decode'        => [IO::Compress::Base::Common::Parse_any,      undef],
0.000000,0,0.000000,
0.000000,0,0.000000,#'consumeinput'  => [IO::Compress::Base::Common::Parse_boolean,  0],
0.000000,0,0.000000,
0.000000,0,0.000000,$self->getExtraParams(),
0.000000,0,0.000000,
0.000000,0,0.000000,#'Todo - Revert to ordinary file on end Z_STREAM_END'=> 0,
0.000000,0,0.000000,# ContinueAfterEof
0.000000,0,0.000000,} ;
0.000000,0,0.000000,
0.000000,0,0.000000,$Valid->{trailingdata} = [IO::Compress::Base::Common::Parse_writable_scalar, undef]
0.000000,0,0.000000,if  *$self->{OneShot} ;
0.000000,0,0.000000,
0.000000,0,0.000000,$got->parse($Valid, @_ )
0.000000,0,0.000000,or $self->croakError("${class}: " . $got->getError()) ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->postCheckParams($got)
0.000000,0,0.000000,or $self->croakError("${class}: " . $self->error()) ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $got;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _create
0.000000,0,0.000000,{
0.000000,0,0.000000,my $obj = shift;
0.000000,0,0.000000,my $got = shift;
0.000000,0,0.000000,my $append_mode = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $class = ref $obj;
0.000000,0,0.000000,$obj->croakError("$class: Missing Input parameter")
0.000000,0,0.000000,if ! @_ && ! $got ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $inValue = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,*$obj->{OneShot} = 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (! $got)
0.000000,0,0.000000,{
0.000000,0,0.000000,$got = $obj->checkParams($class, undef, @_)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $inType  = whatIsInput($inValue, 1);
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->ckInputParam($class, $inValue, 1)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,*$obj->{InNew} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->ckParams($got)
0.000000,0,0.000000,or $obj->croakError("${class}: " . *$obj->{Error});
0.000000,0,0.000000,
0.000000,0,0.000000,if ($inType eq 'buffer' || $inType eq 'code') {
0.000000,0,0.000000,*$obj->{Buffer} = $inValue ;
0.000000,0,0.000000,*$obj->{InputEvent} = $inValue
0.000000,0,0.000000,if $inType eq 'code' ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($inType eq 'handle') {
0.000000,0,0.000000,*$obj->{FH} = $inValue ;
0.000000,0,0.000000,*$obj->{Handle} = 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,# Need to rewind for Scan
0.000000,0,0.000000,*$obj->{FH}->seek(0, SEEK_SET)
0.000000,0,0.000000,if $got->getValue('scan');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.003015,2,0.001507,no warnings ;
0.000000,0,0.000000,my $mode = '<';
0.000000,0,0.000000,$mode = '+<' if $got->getValue('scan');
0.000000,0,0.000000,*$obj->{StdIO} = ($inValue eq '-');
0.000000,0,0.000000,*$obj->{FH} = IO::File->new( "$mode $inValue" )
0.000000,0,0.000000,or return $obj->saveErrorString(undef, "cannot open file '$inValue': $!", $!) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,*$obj->{LineNo} = $. = 0;
0.000000,0,0.000000,setBinModeInput(*$obj->{FH}) ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $buff = "" ;
0.000000,0,0.000000,*$obj->{Buffer} = \$buff ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#    if ($got->getValue('decode')) {
0.000000,0,0.000000,#        my $want_encoding = $got->getValue('decode');
0.000000,0,0.000000,#        *$obj->{Encoding} = IO::Compress::Base::Common::getEncoding($obj, $class, $want_encoding);
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#    else {
0.000000,0,0.000000,#        *$obj->{Encoding} = undef;
0.000000,0,0.000000,#    }
0.000000,0,0.000000,
0.000000,0,0.000000,*$obj->{InputLength}       = $got->parsed('inputlength')
0.000000,0,0.000000,? $got->getValue('inputlength')
0.000000,0,0.000000,: undef ;
0.000000,0,0.000000,*$obj->{InputLengthRemaining} = $got->getValue('inputlength');
0.000000,0,0.000000,*$obj->{BufferOffset}      = 0 ;
0.000000,0,0.000000,*$obj->{AutoClose}         = $got->getValue('autoclose');
0.000000,0,0.000000,*$obj->{Strict}            = $got->getValue('strict');
0.000000,0,0.000000,*$obj->{BlockSize}         = $got->getValue('blocksize');
0.000000,0,0.000000,*$obj->{Append}            = $got->getValue('append');
0.000000,0,0.000000,*$obj->{AppendOutput}      = $append_mode || $got->getValue('append');
0.000000,0,0.000000,*$obj->{ConsumeInput}      = $got->getValue('consumeinput');
0.000000,0,0.000000,*$obj->{Transparent}       = $got->getValue('transparent');
0.000000,0,0.000000,*$obj->{MultiStream}       = $got->getValue('multistream');
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO - move these two into RawDeflate
0.000000,0,0.000000,*$obj->{Scan}              = $got->getValue('scan');
0.000000,0,0.000000,*$obj->{ParseExtra}        = $got->getValue('parseextra')
0.000000,0,0.000000,|| $got->getValue('strict')  ;
0.000000,0,0.000000,*$obj->{Type}              = '';
0.000000,0,0.000000,*$obj->{Prime}             = $got->getValue('prime') || '' ;
0.000000,0,0.000000,*$obj->{Pending}           = '';
0.000000,0,0.000000,*$obj->{Plain}             = 0;
0.000000,0,0.000000,*$obj->{PlainBytesRead}    = 0;
0.000000,0,0.000000,*$obj->{InflatedBytesRead} = 0;
0.000000,0,0.000000,*$obj->{UnCompSize}        = U64->new;
0.000000,0,0.000000,*$obj->{CompSize}          = U64->new;
0.000000,0,0.000000,*$obj->{TotalInflatedBytesRead} = 0;
0.000000,0,0.000000,*$obj->{NewStream}         = 0 ;
0.000000,0,0.000000,*$obj->{EventEof}          = 0 ;
0.000000,0,0.000000,*$obj->{ClassName}         = $class ;
0.000000,0,0.000000,*$obj->{Params}            = $got ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (*$obj->{ConsumeInput}) {
0.000000,0,0.000000,*$obj->{InNew} = 0;
0.000000,0,0.000000,*$obj->{Closed} = 0;
0.000000,0,0.000000,return $obj
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $status = $obj->mkUncomp($got);
0.000000,0,0.000000,
0.000000,0,0.000000,return undef
0.000000,0,0.000000,unless defined $status;
0.000000,0,0.000000,
0.000000,0,0.000000,*$obj->{InNew} = 0;
0.000000,0,0.000000,*$obj->{Closed} = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,return $obj
0.000000,0,0.000000,if *$obj->{Pause} ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($status) {
0.000000,0,0.000000,# Need to try uncompressing to catch the case
0.000000,0,0.000000,# where the compressed file uncompresses to an
0.000000,0,0.000000,# empty string - so eof is set immediately.
0.000000,0,0.000000,
0.000000,0,0.000000,my $out_buffer = '';
0.000000,0,0.000000,
0.000000,0,0.000000,$status = $obj->read(\$out_buffer);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($status < 0) {
0.000000,0,0.000000,*$obj->{ReadStatus} = [ $status, $obj->error(), $obj->errorNo() ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->ungetc($out_buffer)
0.000000,0,0.000000,if length $out_buffer;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return undef
0.000000,0,0.000000,unless *$obj->{Transparent};
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->clearError();
0.000000,0,0.000000,*$obj->{Type} = 'plain';
0.000000,0,0.000000,*$obj->{Plain} = 1;
0.000000,0,0.000000,$obj->pushBack(*$obj->{HeaderPending})  ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @{ *$obj->{InfoList} }, *$obj->{Info} ;
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->saveStatus(STATUS_OK) ;
0.000000,0,0.000000,*$obj->{InNew} = 0;
0.000000,0,0.000000,*$obj->{Closed} = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,return $obj;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ckInputParam
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $from = shift ;
0.000000,0,0.000000,my $inType = whatIsInput($_[0], $_[1]);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->croakError("$from: input parameter not a filename, filehandle, array ref or scalar ref")
0.000000,0,0.000000,if ! $inType ;
0.000000,0,0.000000,
0.000000,0,0.000000,#    if ($inType  eq 'filename' )
0.000000,0,0.000000,#    {
0.000000,0,0.000000,#        return $self->saveErrorString(1, "$from: input filename is undef or null string", STATUS_ERROR)
0.000000,0,0.000000,#            if ! defined $_[0] || $_[0] eq ''  ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#        if ($_[0] ne '-' && ! -e $_[0] )
0.000000,0,0.000000,#        {
0.000000,0,0.000000,#            return $self->saveErrorString(1,
0.000000,0,0.000000,#                            "input file '$_[0]' does not exist", STATUS_ERROR);
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#    }
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inf
0.000000,0,0.000000,{
0.000000,0,0.000000,my $obj = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $class = (caller)[0] ;
0.000000,0,0.000000,my $name = (caller(1))[3] ;
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->croakError("$name: expected at least 1 parameters\n")
0.000000,0,0.000000,unless @_ >= 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $input = shift ;
0.000000,0,0.000000,my $haveOut = @_ ;
0.000000,0,0.000000,my $output = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,my $x = IO::Compress::Base::Validator->new($class, *$obj->{Error}, $name, $input, $output)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,push @_, $output if $haveOut && $x->{Hash};
0.000000,0,0.000000,
0.000000,0,0.000000,*$obj->{OneShot} = 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $got = $obj->checkParams($name, undef, @_)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($got->parsed('trailingdata'))
0.000000,0,0.000000,{
0.000000,0,0.000000,#        my $value = $got->valueRef('TrailingData');
0.000000,0,0.000000,#        warn "TD $value ";
0.000000,0,0.000000,#        #$value = $$value;
0.000000,0,0.000000,##                warn "TD $value $$value ";
0.000000,0,0.000000,#
0.000000,0,0.000000,#        return retErr($obj, "Parameter 'TrailingData' not writable")
0.000000,0,0.000000,#            if readonly $$value ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#        if (ref $$value)
0.000000,0,0.000000,#        {
0.000000,0,0.000000,#            return retErr($obj,"Parameter 'TrailingData' not a scalar reference")
0.000000,0,0.000000,#                if ref $$value ne 'SCALAR' ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#            *$obj->{TrailingData} = $$value ;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#        else
0.000000,0,0.000000,#        {
0.000000,0,0.000000,#            return retErr($obj,"Parameter 'TrailingData' not a scalar")
0.000000,0,0.000000,#                if ref $value ne 'SCALAR' ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#            *$obj->{TrailingData} = $value ;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,
0.000000,0,0.000000,*$obj->{TrailingData} = $got->getValue('trailingdata');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,*$obj->{MultiStream} = $got->getValue('multistream');
0.000000,0,0.000000,$got->setValue('multistream', 0);
0.000000,0,0.000000,
0.000000,0,0.000000,$x->{Got} = $got ;
0.000000,0,0.000000,
0.000000,0,0.000000,#    if ($x->{Hash})
0.000000,0,0.000000,#    {
0.000000,0,0.000000,#        while (my($k, $v) = each %$input)
0.000000,0,0.000000,#        {
0.000000,0,0.000000,#            $v = \$input->{$k}
0.000000,0,0.000000,#                unless defined $v ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#            $obj->_singleTarget($x, $k, $v, @_)
0.000000,0,0.000000,#                or return undef ;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#
0.000000,0,0.000000,#        return keys %$input ;
0.000000,0,0.000000,#    }
0.000000,0,0.000000,
0.000000,0,0.000000,if ($x->{GlobMap})
0.000000,0,0.000000,{
0.000000,0,0.000000,$x->{oneInput} = 1 ;
0.000000,0,0.000000,foreach my $pair (@{ $x->{Pairs} })
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($from, $to) = @$pair ;
0.000000,0,0.000000,$obj->_singleTarget($x, $from, $to, @_)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return scalar @{ $x->{Pairs} } ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (! $x->{oneOutput} )
0.000000,0,0.000000,{
0.000000,0,0.000000,my $inFile = ($x->{inType} eq 'filenames'
0.000000,0,0.000000,|| $x->{inType} eq 'filename');
0.000000,0,0.000000,
0.000000,0,0.000000,$x->{inType} = $inFile ? 'filename' : 'buffer';
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $in ($x->{oneInput} ? $input : @$input)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $out ;
0.000000,0,0.000000,$x->{oneInput} = 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->_singleTarget($x, $in, $output, @_)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# finally the 1 to 1 and n to 1
0.000000,0,0.000000,return $obj->_singleTarget($x, $input, $output, @_);
0.000000,0,0.000000,
0.000000,0,0.000000,croak "should not be here" ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub retErr
0.000000,0,0.000000,{
0.000000,0,0.000000,my $x = shift ;
0.000000,0,0.000000,my $string = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,${ $x->{Error} } = $string ;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _singleTarget
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self      = shift ;
0.000000,0,0.000000,my $x         = shift ;
0.000000,0,0.000000,my $input     = shift;
0.000000,0,0.000000,my $output    = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $buff = '';
0.000000,0,0.000000,$x->{buff} = \$buff ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $fh ;
0.000000,0,0.000000,if ($x->{outType} eq 'filename') {
0.000000,0,0.000000,my $mode = '>' ;
0.000000,0,0.000000,$mode = '>>'
0.000000,0,0.000000,if $x->{Got}->getValue('append') ;
0.000000,0,0.000000,$x->{fh} = IO::File->new( "$mode $output" )
0.000000,0,0.000000,or return retErr($x, "cannot open file '$output': $!") ;
0.000000,0,0.000000,binmode $x->{fh} ;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,elsif ($x->{outType} eq 'handle') {
0.000000,0,0.000000,$x->{fh} = $output;
0.000000,0,0.000000,binmode $x->{fh} ;
0.000000,0,0.000000,if ($x->{Got}->getValue('append')) {
0.000000,0,0.000000,seek($x->{fh}, 0, SEEK_END)
0.000000,0,0.000000,or return retErr($x, "Cannot seek to end of output filehandle: $!") ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,elsif ($x->{outType} eq 'buffer' )
0.000000,0,0.000000,{
0.000000,0,0.000000,$$output = ''
0.000000,0,0.000000,unless $x->{Got}->getValue('append');
0.000000,0,0.000000,$x->{buff} = $output ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($x->{oneInput})
0.000000,0,0.000000,{
0.000000,0,0.000000,defined $self->_rd2($x, $input, $output)
0.000000,0,0.000000,or return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,for my $element ( ($x->{inType} eq 'hash') ? keys %$input : @$input)
0.000000,0,0.000000,{
0.000000,0,0.000000,defined $self->_rd2($x, $element, $output)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ($x->{outType} eq 'filename' && $output ne '-') ||
0.000000,0,0.000000,($x->{outType} eq 'handle' && $x->{Got}->getValue('autoclose'))) {
0.000000,0,0.000000,$x->{fh}->close()
0.000000,0,0.000000,or return retErr($x, $!);
0.000000,0,0.000000,delete $x->{fh};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _rd2
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self      = shift ;
0.000000,0,0.000000,my $x         = shift ;
0.000000,0,0.000000,my $input     = shift;
0.000000,0,0.000000,my $output    = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $z = IO::Compress::Base::Common::createSelfTiedObject($x->{Class}, *$self->{Error});
0.000000,0,0.000000,
0.000000,0,0.000000,$z->_create($x->{Got}, 1, $input, @_)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $status ;
0.000000,0,0.000000,my $fh = $x->{fh};
0.000000,0,0.000000,
0.000000,0,0.000000,while (1) {
0.000000,0,0.000000,
0.000000,0,0.000000,while (($status = $z->read($x->{buff})) > 0) {
0.000000,0,0.000000,if ($fh) {
0.000000,0,0.000000,local $\;
0.000000,0,0.000000,print $fh ${ $x->{buff} }
0.000000,0,0.000000,or return $z->saveErrorString(undef, "Error writing to output file: $!", $!);
0.000000,0,0.000000,${ $x->{buff} } = '' ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (! $x->{oneOutput} ) {
0.000000,0,0.000000,my $ot = $x->{outType} ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($ot eq 'array')
0.000000,0,0.000000,{ push @$output, $x->{buff} }
0.000000,0,0.000000,elsif ($ot eq 'hash')
0.000000,0,0.000000,{ $output->{$input} = $x->{buff} }
0.000000,0,0.000000,
0.000000,0,0.000000,my $buff = '';
0.000000,0,0.000000,$x->{buff} = \$buff;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,last if $status < 0 || $z->smartEof();
0.000000,0,0.000000,
0.000000,0,0.000000,last
0.000000,0,0.000000,unless *$self->{MultiStream};
0.000000,0,0.000000,
0.000000,0,0.000000,$status = $z->nextStream();
0.000000,0,0.000000,
0.000000,0,0.000000,last
0.000000,0,0.000000,unless $status == 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $z->closeError(undef)
0.000000,0,0.000000,if $status < 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,${ *$self->{TrailingData} } = $z->trailingData()
0.000000,0,0.000000,if defined *$self->{TrailingData} ;
0.000000,0,0.000000,
0.000000,0,0.000000,$z->close()
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub TIEHANDLE
0.000000,0,0.000000,{
0.000000,0,0.000000,return $_[0] if ref($_[0]);
0.000000,0,0.000000,die "OOPS\n" ;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub UNTIE
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub getHeaderInfo
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,wantarray ? @{ *$self->{InfoList} } : *$self->{Info};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub readBlock
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $buff = shift ;
0.000000,0,0.000000,my $size = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined *$self->{CompressedInputLength}) {
0.000000,0,0.000000,if (*$self->{CompressedInputLengthRemaining} == 0) {
0.000000,0,0.000000,delete *$self->{CompressedInputLength};
0.000000,0,0.000000,*$self->{CompressedInputLengthDone} = 1;
0.000000,0,0.000000,return STATUS_OK ;
0.000000,0,0.000000,}
0.000000,0,0.000000,$size = List::Util::min($size, *$self->{CompressedInputLengthRemaining} );
0.000000,0,0.000000,*$self->{CompressedInputLengthRemaining} -= $size ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $status = $self->smartRead($buff, $size) ;
0.000000,0,0.000000,return $self->saveErrorString(STATUS_ERROR, "Error Reading Data: $!", $!)
0.000000,0,0.000000,if $status == STATUS_ERROR  ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($status == 0 ) {
0.000000,0,0.000000,*$self->{Closed} = 1 ;
0.000000,0,0.000000,*$self->{EndStream} = 1 ;
0.000000,0,0.000000,return $self->saveErrorString(STATUS_ERROR, "unexpected end of file", STATUS_ERROR);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return STATUS_OK;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub postBlockChk
0.000000,0,0.000000,{
0.000000,0,0.000000,return STATUS_OK;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _raw_read
0.000000,0,0.000000,{
0.000000,0,0.000000,# return codes
0.000000,0,0.000000,# >0 - ok, number of bytes read
0.000000,0,0.000000,# =0 - ok, eof
0.000000,0,0.000000,# <0 - not ok
0.000000,0,0.000000,
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return G_EOF if *$self->{Closed} ;
0.000000,0,0.000000,return G_EOF if *$self->{EndStream} ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $buffer = shift ;
0.000000,0,0.000000,my $scan_mode = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (*$self->{Plain}) {
0.000000,0,0.000000,my $tmp_buff ;
0.000000,0,0.000000,my $len = $self->smartRead(\$tmp_buff, *$self->{BlockSize}) ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->saveErrorString(G_ERR, "Error reading data: $!", $!)
0.000000,0,0.000000,if $len == STATUS_ERROR ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($len == 0 ) {
0.000000,0,0.000000,*$self->{EndStream} = 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,*$self->{PlainBytesRead} += $len ;
0.000000,0,0.000000,$$buffer .= $tmp_buff;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $len ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (*$self->{NewStream}) {
0.000000,0,0.000000,
0.000000,0,0.000000,$self->gotoNextStream() > 0
0.000000,0,0.000000,or return G_ERR;
0.000000,0,0.000000,
0.000000,0,0.000000,# For the headers that actually uncompressed data, put the
0.000000,0,0.000000,# uncompressed data into the output buffer.
0.000000,0,0.000000,$$buffer .=  *$self->{Pending} ;
0.000000,0,0.000000,my $len = length  *$self->{Pending} ;
0.000000,0,0.000000,*$self->{Pending} = '';
0.000000,0,0.000000,return $len;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $temp_buf = '';
0.000000,0,0.000000,my $outSize = 0;
0.000000,0,0.000000,my $status = $self->readBlock(\$temp_buf, *$self->{BlockSize}, $outSize) ;
0.000000,0,0.000000,
0.000000,0,0.000000,return G_ERR
0.000000,0,0.000000,if $status == STATUS_ERROR  ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $buf_len = 0;
0.000000,0,0.000000,if ($status == STATUS_OK) {
0.000000,0,0.000000,my $beforeC_len = length $temp_buf;
0.000000,0,0.000000,my $before_len = defined $$buffer ? length $$buffer : 0 ;
0.000000,0,0.000000,$status = *$self->{Uncomp}->uncompr(\$temp_buf, $buffer,
0.000000,0,0.000000,defined *$self->{CompressedInputLengthDone} ||
0.000000,0,0.000000,$self->smartEof(), $outSize);
0.000000,0,0.000000,
0.000000,0,0.000000,# Remember the input buffer if it wasn't consumed completely
0.000000,0,0.000000,$self->pushBack($temp_buf) if *$self->{Uncomp}{ConsumesInput};
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->saveErrorString(G_ERR, *$self->{Uncomp}{Error}, *$self->{Uncomp}{ErrorNo})
0.000000,0,0.000000,if $self->saveStatus($status) == STATUS_ERROR;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->postBlockChk($buffer, $before_len) == STATUS_OK
0.000000,0,0.000000,or return G_ERR;
0.000000,0,0.000000,
0.000000,0,0.000000,$buf_len = defined $$buffer ? length($$buffer) - $before_len : 0;
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{CompSize}->add($beforeC_len - length $temp_buf) ;
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{InflatedBytesRead} += $buf_len ;
0.000000,0,0.000000,*$self->{TotalInflatedBytesRead} += $buf_len ;
0.000000,0,0.000000,*$self->{UnCompSize}->add($buf_len) ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->filterUncompressed($buffer, $before_len);
0.000000,0,0.000000,
0.000000,0,0.000000,#        if (*$self->{Encoding}) {
0.000000,0,0.000000,#            use Encode ;
0.000000,0,0.000000,#            *$self->{PendingDecode} .= substr($$buffer, $before_len) ;
0.000000,0,0.000000,#            my $got = *$self->{Encoding}->decode(*$self->{PendingDecode}, Encode::FB_QUIET) ;
0.000000,0,0.000000,#            substr($$buffer, $before_len) = $got;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($status == STATUS_ENDSTREAM) {
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{EndStream} = 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $trailer;
0.000000,0,0.000000,my $trailer_size = *$self->{Info}{TrailerLength} ;
0.000000,0,0.000000,my $got = 0;
0.000000,0,0.000000,if (*$self->{Info}{TrailerLength})
0.000000,0,0.000000,{
0.000000,0,0.000000,$got = $self->smartRead(\$trailer, $trailer_size) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($got == $trailer_size) {
0.000000,0,0.000000,$self->chkTrailer($trailer) == STATUS_OK
0.000000,0,0.000000,or return G_ERR;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $self->TrailerError("trailer truncated. Expected " .
0.000000,0,0.000000,"$trailer_size bytes, got $got")
0.000000,0,0.000000,if *$self->{Strict};
0.000000,0,0.000000,$self->pushBack($trailer)  ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO - if want file pointer, do it here
0.000000,0,0.000000,
0.000000,0,0.000000,if (! $self->smartEof()) {
0.000000,0,0.000000,*$self->{NewStream} = 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (*$self->{MultiStream}) {
0.000000,0,0.000000,*$self->{EndStream} = 0 ;
0.000000,0,0.000000,return $buf_len ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# return the number of uncompressed bytes read
0.000000,0,0.000000,return $buf_len ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub reset
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return *$self->{Uncomp}->reset();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub filterUncompressed
0.000000,0,0.000000,{
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#sub isEndStream
0.000000,0,0.000000,#{
0.000000,0,0.000000,#    my $self = shift ;
0.000000,0,0.000000,#    return *$self->{NewStream} ||
0.000000,0,0.000000,#           *$self->{EndStream} ;
0.000000,0,0.000000,#}
0.000000,0,0.000000,
0.000000,0,0.000000,sub nextStream
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,# An uncompressed file cannot have a next stream, so
0.000000,0,0.000000,# return immediately.
0.000000,0,0.000000,return 0
0.000000,0,0.000000,if *$self->{Plain} ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $status = $self->gotoNextStream();
0.000000,0,0.000000,$status == 1
0.000000,0,0.000000,or return $status ;
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{Pending} = ''
0.000000,0,0.000000,if $self !~ /IO::Uncompress::RawInflate/ && ! *$self->{MultiStream};
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{TotalInflatedBytesRead} = 0 ;
0.000000,0,0.000000,*$self->{LineNo} = $. = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub gotoNextStream
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (! *$self->{NewStream}) {
0.000000,0,0.000000,my $status = 1;
0.000000,0,0.000000,my $buffer ;
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO - make this more efficient if know the offset for the end of
0.000000,0,0.000000,# the stream and seekable
0.000000,0,0.000000,$status = $self->read($buffer)
0.000000,0,0.000000,while $status > 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $status
0.000000,0,0.000000,if $status < 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{NewStream} = 0 ;
0.000000,0,0.000000,*$self->{EndStream} = 0 ;
0.000000,0,0.000000,*$self->{CompressedInputLengthDone} = undef ;
0.000000,0,0.000000,*$self->{CompressedInputLength} = undef ;
0.000000,0,0.000000,$self->reset();
0.000000,0,0.000000,*$self->{UnCompSize}->reset();
0.000000,0,0.000000,*$self->{CompSize}->reset();
0.000000,0,0.000000,
0.000000,0,0.000000,my $magic = $self->ckMagic();
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ! defined $magic) {
0.000000,0,0.000000,if (! *$self->{Transparent} || $self->eof())
0.000000,0,0.000000,{
0.000000,0,0.000000,*$self->{EndStream} = 1 ;
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Not EOF, so Transparent mode kicks in now for trailing data
0.000000,0,0.000000,# Reset member name in case anyone calls getHeaderInfo()->{Name}
0.000000,0,0.000000,*$self->{Info} = { Name => undef, Type  => 'plain' };
0.000000,0,0.000000,
0.000000,0,0.000000,$self->clearError();
0.000000,0,0.000000,*$self->{Type} = 'plain';
0.000000,0,0.000000,*$self->{Plain} = 1;
0.000000,0,0.000000,$self->pushBack(*$self->{HeaderPending})  ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,*$self->{Info} = $self->readHeader($magic);
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ! defined *$self->{Info} ) {
0.000000,0,0.000000,*$self->{EndStream} = 1 ;
0.000000,0,0.000000,return -1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @{ *$self->{InfoList} }, *$self->{Info} ;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub streamCount
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,return 1 if ! defined *$self->{InfoList};
0.000000,0,0.000000,return scalar @{ *$self->{InfoList} }  ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub read
0.000000,0,0.000000,{
0.000000,0,0.000000,# return codes
0.000000,0,0.000000,# >0 - ok, number of bytes read
0.000000,0,0.000000,# =0 - ok, eof
0.000000,0,0.000000,# <0 - not ok
0.000000,0,0.000000,
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined *$self->{ReadStatus} ) {
0.000000,0,0.000000,my $status = *$self->{ReadStatus}[0];
0.000000,0,0.000000,$self->saveErrorString( @{ *$self->{ReadStatus} } );
0.000000,0,0.000000,delete  *$self->{ReadStatus} ;
0.000000,0,0.000000,return $status ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return G_EOF if *$self->{Closed} ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $buffer ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref $_[0] ) {
0.000000,0,0.000000,$self->croakError(*$self->{ClassName} . "::read: buffer parameter is read-only")
0.000000,0,0.000000,if Scalar::Util::readonly(${ $_[0] });
0.000000,0,0.000000,
0.000000,0,0.000000,$self->croakError(*$self->{ClassName} . "::read: not a scalar reference $_[0]" )
0.000000,0,0.000000,unless ref $_[0] eq 'SCALAR' ;
0.000000,0,0.000000,$buffer = $_[0] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->croakError(*$self->{ClassName} . "::read: buffer parameter is read-only")
0.000000,0,0.000000,if Scalar::Util::readonly($_[0]);
0.000000,0,0.000000,
0.000000,0,0.000000,$buffer = \$_[0] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $length = $_[1] ;
0.000000,0,0.000000,my $offset = $_[2] || 0;
0.000000,0,0.000000,
0.000000,0,0.000000,if (! *$self->{AppendOutput}) {
0.000000,0,0.000000,if (! $offset) {
0.000000,0,0.000000,
0.000000,0,0.000000,$$buffer = '' ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($offset > length($$buffer)) {
0.000000,0,0.000000,$$buffer .= "\x00" x ($offset - length($$buffer));
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,substr($$buffer, $offset) = '';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (! defined $$buffer) {
0.000000,0,0.000000,$$buffer = '' ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return G_EOF if !length *$self->{Pending} && *$self->{EndStream} ;
0.000000,0,0.000000,
0.000000,0,0.000000,# the core read will return 0 if asked for 0 bytes
0.000000,0,0.000000,return 0 if defined $length && $length == 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,$length = $length || 0;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->croakError(*$self->{ClassName} . "::read: length parameter is negative")
0.000000,0,0.000000,if $length < 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,# Short-circuit if this is a simple read, with no length
0.000000,0,0.000000,# or offset specified.
0.000000,0,0.000000,unless ( $length || $offset) {
0.000000,0,0.000000,if (length *$self->{Pending}) {
0.000000,0,0.000000,$$buffer .= *$self->{Pending} ;
0.000000,0,0.000000,my $len = length *$self->{Pending};
0.000000,0,0.000000,*$self->{Pending} = '' ;
0.000000,0,0.000000,return $len ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $len = 0;
0.000000,0,0.000000,$len = $self->_raw_read($buffer)
0.000000,0,0.000000,while ! *$self->{EndStream} && $len == 0 ;
0.000000,0,0.000000,return $len ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Need to jump through more hoops - either length or offset
0.000000,0,0.000000,# or both are specified.
0.000000,0,0.000000,my $out_buffer = *$self->{Pending} ;
0.000000,0,0.000000,*$self->{Pending} = '';
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,while (! *$self->{EndStream} && length($out_buffer) < $length)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $buf_len = $self->_raw_read(\$out_buffer);
0.000000,0,0.000000,return $buf_len
0.000000,0,0.000000,if $buf_len < 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$length = length $out_buffer
0.000000,0,0.000000,if length($out_buffer) < $length ;
0.000000,0,0.000000,
0.000000,0,0.000000,return 0
0.000000,0,0.000000,if $length == 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,$$buffer = ''
0.000000,0,0.000000,if ! defined $$buffer;
0.000000,0,0.000000,
0.000000,0,0.000000,$offset = length $$buffer
0.000000,0,0.000000,if *$self->{AppendOutput} ;
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{Pending} = $out_buffer;
0.000000,0,0.000000,$out_buffer = \*$self->{Pending} ;
0.000000,0,0.000000,
0.000000,0,0.000000,substr($$buffer, $offset) = substr($$out_buffer, 0, $length) ;
0.000000,0,0.000000,substr($$out_buffer, 0, $length) =  '' ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $length ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _getline
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $status = 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,# Slurp Mode
0.000000,0,0.000000,if ( ! defined $/ ) {
0.000000,0,0.000000,my $data ;
0.000000,0,0.000000,1 while ($status = $self->read($data)) > 0 ;
0.000000,0,0.000000,return ($status, \$data);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Record Mode
0.000000,0,0.000000,if ( ref $/ eq 'SCALAR' && ${$/} =~ /^\d+$/ && ${$/} > 0) {
0.000000,0,0.000000,my $reclen = ${$/} ;
0.000000,0,0.000000,my $data ;
0.000000,0,0.000000,$status = $self->read($data, $reclen) ;
0.000000,0,0.000000,return ($status, \$data);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Paragraph Mode
0.000000,0,0.000000,if ( ! length $/ ) {
0.000000,0,0.000000,my $paragraph ;
0.000000,0,0.000000,while (($status = $self->read($paragraph)) > 0 ) {
0.000000,0,0.000000,if ($paragraph =~ s/^(.*?\n\n+)//s) {
0.000000,0,0.000000,*$self->{Pending}  = $paragraph ;
0.000000,0,0.000000,my $par = $1 ;
0.000000,0,0.000000,return (1, \$par);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return ($status, \$paragraph);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# $/ isn't empty, or a reference, so it's Line Mode.
0.000000,0,0.000000,{
0.000000,0,0.000000,my $line ;
0.000000,0,0.000000,my $p = \*$self->{Pending}  ;
0.000000,0,0.000000,while (($status = $self->read($line)) > 0 ) {
0.000000,0,0.000000,my $offset = index($line, $/);
0.000000,0,0.000000,if ($offset >= 0) {
0.000000,0,0.000000,my $l = substr($line, 0, $offset + length $/ );
0.000000,0,0.000000,substr($line, 0, $offset + length $/) = '';
0.000000,0,0.000000,$$p = $line;
0.000000,0,0.000000,return (1, \$l);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ($status, \$line);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getline
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined *$self->{ReadStatus} ) {
0.000000,0,0.000000,$self->saveErrorString( @{ *$self->{ReadStatus} } );
0.000000,0,0.000000,delete  *$self->{ReadStatus} ;
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return undef
0.000000,0,0.000000,if *$self->{Closed} || (!length *$self->{Pending} && *$self->{EndStream}) ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $current_append = *$self->{AppendOutput} ;
0.000000,0,0.000000,*$self->{AppendOutput} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($status, $lineref) = $self->_getline();
0.000000,0,0.000000,*$self->{AppendOutput} = $current_append;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef
0.000000,0,0.000000,if $status < 0 || length $$lineref == 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,$. = ++ *$self->{LineNo} ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $$lineref ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getlines
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->croakError(*$self->{ClassName} .
0.000000,0,0.000000,"::getlines: called in scalar context\n") unless wantarray;
0.000000,0,0.000000,my($line, @lines);
0.000000,0,0.000000,push(@lines, $line)
0.000000,0,0.000000,while defined($line = $self->getline);
0.000000,0,0.000000,return @lines;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub READLINE
0.000000,0,0.000000,{
0.000000,0,0.000000,goto &getlines if wantarray;
0.000000,0,0.000000,goto &getline;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getc
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $buf;
0.000000,0,0.000000,return $buf if $self->read($buf, 1);
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ungetc
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,*$self->{Pending} = ""  unless defined *$self->{Pending} ;
0.000000,0,0.000000,*$self->{Pending} = $_[0] . *$self->{Pending} ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub trailingData
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined *$self->{FH} || defined *$self->{InputEvent} ) {
0.000000,0,0.000000,return *$self->{Prime} ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $buf = *$self->{Buffer} ;
0.000000,0,0.000000,my $offset = *$self->{BufferOffset} ;
0.000000,0,0.000000,return substr($$buf, $offset) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub eof
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return (*$self->{Closed} ||
0.000000,0,0.000000,(!length *$self->{Pending}
0.000000,0,0.000000,&& ( $self->smartEof() || *$self->{EndStream}))) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub tell
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $in ;
0.000000,0,0.000000,if (*$self->{Plain}) {
0.000000,0,0.000000,$in = *$self->{PlainBytesRead} ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$in = *$self->{TotalInflatedBytesRead} ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $pending = length *$self->{Pending} ;
0.000000,0,0.000000,
0.000000,0,0.000000,return 0 if $pending > $in ;
0.000000,0,0.000000,return $in - $pending ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub close
0.000000,0,0.000000,{
0.000000,0,0.000000,# todo - what to do if close is called before the end of the gzip file
0.000000,0,0.000000,#        do we remember any trailing data?
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if *$self->{Closed} ;
0.000000,0,0.000000,
0.000000,0,0.000000,untie *$self
0.000000,0,0.000000,if $] >= 5.008 ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $status = 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined *$self->{FH}) {
0.000000,0,0.000000,if ((! *$self->{Handle} || *$self->{AutoClose}) && ! *$self->{StdIO}) {
0.000000,0,0.000000,local $.;
0.000000,0,0.000000,$! = 0 ;
0.000000,0,0.000000,$status = *$self->{FH}->close();
0.000000,0,0.000000,return $self->saveErrorString(0, $!, $!)
0.000000,0,0.000000,if !*$self->{InNew} && $self->saveStatus($!) != 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,delete *$self->{FH} ;
0.000000,0,0.000000,$! = 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,*$self->{Closed} = 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub DESTROY
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,local ($., $@, $!, $^E, $?);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->close() ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub seek
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self     = shift ;
0.000000,0,0.000000,my $position = shift;
0.000000,0,0.000000,my $whence   = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $here = $self->tell() ;
0.000000,0,0.000000,my $target = 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,if ($whence == SEEK_SET) {
0.000000,0,0.000000,$target = $position ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($whence == SEEK_CUR) {
0.000000,0,0.000000,$target = $here + $position ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($whence == SEEK_END) {
0.000000,0,0.000000,$target = $position ;
0.000000,0,0.000000,$self->croakError(*$self->{ClassName} . "::seek: SEEK_END not allowed") ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->croakError(*$self->{ClassName} ."::seek: unknown value, $whence, for whence parameter");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# short circuit if seeking to current offset
0.000000,0,0.000000,if ($target == $here) {
0.000000,0,0.000000,# On ordinary filehandles, seeking to the current
0.000000,0,0.000000,# position also clears the EOF condition, so we
0.000000,0,0.000000,# emulate this behavior locally while simultaneously
0.000000,0,0.000000,# cascading it to the underlying filehandle
0.000000,0,0.000000,if (*$self->{Plain}) {
0.000000,0,0.000000,*$self->{EndStream} = 0;
0.000000,0,0.000000,seek(*$self->{FH},0,1) if *$self->{FH};
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Outlaw any attempt to seek backwards
0.000000,0,0.000000,$self->croakError( *$self->{ClassName} ."::seek: cannot seek backwards")
0.000000,0,0.000000,if $target < $here ;
0.000000,0,0.000000,
0.000000,0,0.000000,# Walk the file to the new offset
0.000000,0,0.000000,my $offset = $target - $here ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $got;
0.000000,0,0.000000,while (($got = $self->read(my $buffer, List::Util::min($offset, *$self->{BlockSize})) ) > 0)
0.000000,0,0.000000,{
0.000000,0,0.000000,$offset -= $got;
0.000000,0,0.000000,last if $offset == 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$here = $self->tell() ;
0.000000,0,0.000000,return $offset == 0 ? 1 : 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fileno
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,return defined *$self->{FH}
0.000000,0,0.000000,? fileno *$self->{FH}
0.000000,0,0.000000,: undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub binmode
0.000000,0,0.000000,{
0.000000,0,0.000000,1;
0.000000,0,0.000000,#    my $self     = shift ;
0.000000,0,0.000000,#    return defined *$self->{FH}
0.000000,0,0.000000,#            ? binmode *$self->{FH}
0.000000,0,0.000000,#            : 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub opened
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self     = shift ;
0.000000,0,0.000000,return ! *$self->{Closed} ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub autoflush
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self     = shift ;
0.000000,0,0.000000,return defined *$self->{FH}
0.000000,0,0.000000,? *$self->{FH}->autoflush(@_)
0.000000,0,0.000000,: undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub input_line_number
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $last = *$self->{LineNo};
0.000000,0,0.000000,$. = *$self->{LineNo} = $_[1] if @_ ;
0.000000,0,0.000000,return $last;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _notAvailable
0.000000,0,0.000000,{
0.000001,6,0.000000,my $name = shift ;
0.000014,6,0.000002,return sub { croak "$name Not Available: File opened only for intput" ; } ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000151,3,0.000050,no warnings 'once';
0.000000,0,0.000000,
0.000002,1,0.000002,*BINMODE  = \&binmode;
0.000000,1,0.000000,*SEEK     = \&seek;
0.000000,1,0.000000,*READ     = \&read;
0.000000,1,0.000000,*sysread  = \&read;
0.000000,1,0.000000,*TELL     = \&tell;
0.000000,1,0.000000,*EOF      = \&eof;
0.000000,0,0.000000,
0.000000,1,0.000000,*FILENO   = \&fileno;
0.000000,1,0.000000,*CLOSE    = \&close;
0.000000,0,0.000000,
0.000002,1,0.000002,*print    = _notAvailable('print');
0.000001,1,0.000001,*PRINT    = _notAvailable('print');
0.000000,1,0.000000,*printf   = _notAvailable('printf');
0.000000,1,0.000000,*PRINTF   = _notAvailable('printf');
0.000001,1,0.000001,*write    = _notAvailable('write');
0.000000,1,0.000000,*WRITE    = _notAvailable('write');
0.000000,0,0.000000,
0.000000,0,0.000000,#*sysread  = \&read;
0.000000,0,0.000000,#*syswrite = \&_notAvailable;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,package IO::Uncompress::Base ;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000009,1,0.000009,1 ;
0.000000,0,0.000000,__END__
