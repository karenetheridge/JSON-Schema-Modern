# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Digest::SHA;
0.000000,0,0.000000,
0.000007,1,0.000007,require 5.003000;
0.000000,0,0.000000,
0.000027,2,0.000013,use strict;
0.000022,2,0.000011,use warnings;
0.000612,2,0.000306,use vars qw($VERSION @ISA @EXPORT_OK $errmsg);
0.000017,2,0.000008,use Fcntl qw(O_RDONLY O_RDWR);
0.000832,2,0.000416,use integer;
0.000000,0,0.000000,
0.000001,1,0.000001,$VERSION = '6.02';
0.000000,0,0.000000,
0.000000,1,0.000000,require Exporter;
0.000007,1,0.000007,@ISA = qw(Exporter);
0.000002,1,0.000002,@EXPORT_OK = qw(
0.000000,0,0.000000,$errmsg
0.000000,0,0.000000,hmac_sha1	hmac_sha1_base64	hmac_sha1_hex
0.000000,0,0.000000,hmac_sha224	hmac_sha224_base64	hmac_sha224_hex
0.000000,0,0.000000,hmac_sha256	hmac_sha256_base64	hmac_sha256_hex
0.000000,0,0.000000,hmac_sha384	hmac_sha384_base64	hmac_sha384_hex
0.000000,0,0.000000,hmac_sha512	hmac_sha512_base64	hmac_sha512_hex
0.000000,0,0.000000,hmac_sha512224	hmac_sha512224_base64	hmac_sha512224_hex
0.000000,0,0.000000,hmac_sha512256	hmac_sha512256_base64	hmac_sha512256_hex
0.000000,0,0.000000,sha1		sha1_base64		sha1_hex
0.000000,0,0.000000,sha224		sha224_base64		sha224_hex
0.000000,0,0.000000,sha256		sha256_base64		sha256_hex
0.000000,0,0.000000,sha384		sha384_base64		sha384_hex
0.000000,0,0.000000,sha512		sha512_base64		sha512_hex
0.000000,0,0.000000,sha512224	sha512224_base64	sha512224_hex
0.000000,0,0.000000,sha512256	sha512256_base64	sha512256_hex);
0.000000,0,0.000000,
0.000000,0,0.000000,# Inherit from Digest::base if possible
0.000000,0,0.000000,
0.000001,1,0.000001,eval {
0.000000,1,0.000000,require Digest::base;
0.000004,1,0.000004,push(@ISA, 'Digest::base');
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,# The following routines aren't time-critical, so they can be left in Perl
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my($class, $alg) = @_;
0.000000,0,0.000000,$alg =~ s/\D+//g if defined $alg;
0.000000,0,0.000000,if (ref($class)) {	# instance method
0.000000,0,0.000000,if (!defined($alg) || ($alg == $class->algorithm)) {
0.000000,0,0.000000,sharewind($class);
0.000000,0,0.000000,return($class);
0.000000,0,0.000000,}
0.000000,0,0.000000,return shainit($class, $alg) ? $class : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,$alg = 1 unless defined $alg;
0.000000,0,0.000000,return $class->newSHA($alg);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000525,1,0.000525,BEGIN { *reset = \&new }
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_bits {
0.000000,0,0.000000,my($self, $data, $nbits) = @_;
0.000000,0,0.000000,unless (defined $nbits) {
0.000000,0,0.000000,$nbits = length($data);
0.000000,0,0.000000,$data = pack("B*", $data);
0.000000,0,0.000000,}
0.000000,0,0.000000,$nbits = length($data) * 8 if $nbits > length($data) * 8;
0.000000,0,0.000000,shawrite($data, $nbits, $self);
0.000000,0,0.000000,return($self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _bail {
0.000000,0,0.000000,my $msg = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,$errmsg = $!;
0.000000,0,0.000000,$msg .= ": $!";
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak($msg);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,1,0.000000,my $_can_T_filehandle;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _istext {
0.000000,0,0.000000,local *FH = shift;
0.000000,0,0.000000,my $file = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,if (! defined $_can_T_filehandle) {
0.000000,0,0.000000,local $^W = 0;
0.000000,0,0.000000,my $istext = eval { -T FH };
0.000000,0,0.000000,$_can_T_filehandle = $@ ? 0 : 1;
0.000000,0,0.000000,return $_can_T_filehandle ? $istext : -T $file;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $_can_T_filehandle ? -T FH : -T $file;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,sub _addfile {
0.000000,0,0.000000,my ($self, $handle) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $n;
0.000000,0,0.000000,my $buf = "";
0.000000,0,0.000000,
0.000000,0,0.000000,while (($n = read($handle, $buf, 4096))) {
0.000000,0,0.000000,$self->add($buf);
0.000000,0,0.000000,}
0.000000,0,0.000000,_bail("Read failed") unless defined $n;
0.000000,0,0.000000,
0.000000,0,0.000000,$self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub addfile {
0.000000,0,0.000000,my ($self, $file, $mode) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return(_addfile($self, $file)) unless ref(\$file) eq 'SCALAR';
0.000000,0,0.000000,
0.000000,0,0.000000,$mode = defined($mode) ? $mode : "";
0.000000,0,0.000000,my ($binary, $UNIVERSAL, $BITS) =
0.000000,0,0.000000,map { $_ eq $mode } ("b", "U", "0");
0.000000,0,0.000000,
0.000000,0,0.000000,## Always interpret "-" to mean STDIN; otherwise use
0.000000,0,0.000000,##	sysopen to handle full range of POSIX file names.
0.000000,0,0.000000,## If $file is a directory, force an EISDIR error
0.000000,0,0.000000,##	by attempting to open with mode O_RDWR
0.000000,0,0.000000,
0.000000,0,0.000000,local *FH;
0.000000,0,0.000000,$file eq '-' and open(FH, '< -')
0.000000,0,0.000000,or sysopen(FH, $file, -d $file ? O_RDWR : O_RDONLY)
0.000000,0,0.000000,or _bail('Open failed');
0.000000,0,0.000000,
0.000000,0,0.000000,if ($BITS) {
0.000000,0,0.000000,my ($n, $buf) = (0, "");
0.000000,0,0.000000,while (($n = read(FH, $buf, 4096))) {
0.000000,0,0.000000,$buf =~ tr/01//cd;
0.000000,0,0.000000,$self->add_bits($buf);
0.000000,0,0.000000,}
0.000000,0,0.000000,_bail("Read failed") unless defined $n;
0.000000,0,0.000000,close(FH);
0.000000,0,0.000000,return($self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,binmode(FH) if $binary || $UNIVERSAL;
0.000000,0,0.000000,if ($UNIVERSAL && _istext(*FH, $file)) {
0.000000,0,0.000000,$self->_addfileuniv(*FH);
0.000000,0,0.000000,}
0.000000,0,0.000000,else { $self->_addfilebin(*FH) }
0.000000,0,0.000000,close(FH);
0.000000,0,0.000000,
0.000000,0,0.000000,$self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getstate {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $alg = $self->algorithm or return;
0.000000,0,0.000000,my $state = $self->_getstate or return;
0.000000,0,0.000000,my $nD = $alg <= 256 ?  8 :  16;
0.000000,0,0.000000,my $nH = $alg <= 256 ? 32 :  64;
0.000000,0,0.000000,my $nB = $alg <= 256 ? 64 : 128;
0.000000,0,0.000000,my($H, $block, $blockcnt, $lenhh, $lenhl, $lenlh, $lenll) =
0.000000,0,0.000000,$state =~ /^(.{$nH})(.{$nB})(.{4})(.{4})(.{4})(.{4})(.{4})$/s;
0.000000,0,0.000000,for ($alg, $H, $block, $blockcnt, $lenhh, $lenhl, $lenlh, $lenll) {
0.000000,0,0.000000,return unless defined $_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @s = ();
0.000000,0,0.000000,push(@s, "alg:" . $alg);
0.000000,0,0.000000,push(@s, "H:" . join(":", unpack("H*", $H) =~ /.{$nD}/g));
0.000000,0,0.000000,push(@s, "block:" . join(":", unpack("H*", $block) =~ /.{2}/g));
0.000000,0,0.000000,push(@s, "blockcnt:" . unpack("N", $blockcnt));
0.000000,0,0.000000,push(@s, "lenhh:" . unpack("N", $lenhh));
0.000000,0,0.000000,push(@s, "lenhl:" . unpack("N", $lenhl));
0.000000,0,0.000000,push(@s, "lenlh:" . unpack("N", $lenlh));
0.000000,0,0.000000,push(@s, "lenll:" . unpack("N", $lenll));
0.000000,0,0.000000,join("\n", @s) . "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub putstate {
0.000000,0,0.000000,my($class, $state) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my %s = ();
0.000000,0,0.000000,for (split(/\n/, $state)) {
0.000000,0,0.000000,s/^\s+//;
0.000000,0,0.000000,s/\s+$//;
0.000000,0,0.000000,next if (/^(#|$)/);
0.000000,0,0.000000,my @f = split(/[:\s]+/);
0.000000,0,0.000000,my $tag = shift(@f);
0.000000,0,0.000000,$s{$tag} = join('', @f);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# H and block may contain arbitrary values, but check everything else
0.000000,0,0.000000,grep { $_ == $s{'alg'} } (1,224,256,384,512,512224,512256) or return;
0.000000,0,0.000000,length($s{'H'}) == ($s{'alg'} <= 256 ? 64 : 128) or return;
0.000000,0,0.000000,length($s{'block'}) == ($s{'alg'} <= 256 ? 128 : 256) or return;
0.000000,0,0.000000,{
0.000237,2,0.000118,no integer;
0.000000,0,0.000000,for (qw(blockcnt lenhh lenhl lenlh lenll)) {
0.000000,0,0.000000,0 <= $s{$_} or return;
0.000000,0,0.000000,$s{$_} <= 4294967295 or return;
0.000000,0,0.000000,}
0.000000,0,0.000000,$s{'blockcnt'} < ($s{'alg'} <= 256 ? 512 : 1024) or return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $packed_state = (
0.000000,0,0.000000,pack("H*", $s{'H'}) .
0.000000,0,0.000000,pack("H*", $s{'block'}) .
0.000000,0,0.000000,pack("N",  $s{'blockcnt'}) .
0.000000,0,0.000000,pack("N",  $s{'lenhh'}) .
0.000000,0,0.000000,pack("N",  $s{'lenhl'}) .
0.000000,0,0.000000,pack("N",  $s{'lenlh'}) .
0.000000,0,0.000000,pack("N",  $s{'lenll'})
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,return $class->new($s{'alg'})->_putstate($packed_state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub dump {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $file = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $state = $self->getstate or return;
0.000000,0,0.000000,$file = "-" if (!defined($file) || $file eq "");
0.000000,0,0.000000,
0.000000,0,0.000000,local *FH;
0.000000,0,0.000000,open(FH, "> $file") or return;
0.000000,0,0.000000,print FH $state;
0.000000,0,0.000000,close(FH);
0.000000,0,0.000000,
0.000000,0,0.000000,return($self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub load {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $file = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,$file = "-" if (!defined($file) || $file eq "");
0.000000,0,0.000000,
0.000000,0,0.000000,local *FH;
0.000000,0,0.000000,open(FH, "< $file") or return;
0.000000,0,0.000000,my $str = join('', <FH>);
0.000000,0,0.000000,close(FH);
0.000000,0,0.000000,
0.000000,0,0.000000,$class->putstate($str);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,eval {
0.000000,1,0.000000,require XSLoader;
0.003561,1,0.003561,XSLoader::load('Digest::SHA', $VERSION);
0.000001,1,0.000001,1;
0.000001,1,0.000001,} or do {
0.000000,0,0.000000,require DynaLoader;
0.000000,0,0.000000,push @ISA, 'DynaLoader';
0.000000,0,0.000000,Digest::SHA->bootstrap($VERSION);
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000011,1,0.000011,1;
0.000000,0,0.000000,__END__
