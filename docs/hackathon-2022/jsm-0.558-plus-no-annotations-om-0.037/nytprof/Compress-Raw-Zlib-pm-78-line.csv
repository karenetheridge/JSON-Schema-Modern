# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package Compress::Raw::Zlib;
0.000000,0,0.000000,
0.000007,1,0.000007,require 5.006 ;
0.000001,1,0.000001,require Exporter;
0.000032,2,0.000016,use Carp ;
0.000000,0,0.000000,
0.000017,2,0.000008,use strict ;
0.000014,2,0.000007,use warnings ;
0.000160,2,0.000080,use bytes ;
0.000000,0,0.000000,our ($VERSION, $XS_VERSION, @ISA, @EXPORT, %EXPORT_TAGS, @EXPORT_OK, $AUTOLOAD, %DEFLATE_CONSTANTS, @DEFLATE_CONSTANTS);
0.000000,0,0.000000,
0.000000,1,0.000000,$VERSION = '2.105';
0.000000,1,0.000000,$XS_VERSION = $VERSION;
0.000016,1,0.000016,$VERSION = eval $VERSION;
0.000000,0,0.000000,
0.000006,1,0.000006,@ISA = qw(Exporter);
0.000003,1,0.000003,%EXPORT_TAGS = ( flush     => [qw{
0.000000,0,0.000000,Z_NO_FLUSH
0.000000,0,0.000000,Z_PARTIAL_FLUSH
0.000000,0,0.000000,Z_SYNC_FLUSH
0.000000,0,0.000000,Z_FULL_FLUSH
0.000000,0,0.000000,Z_FINISH
0.000000,0,0.000000,Z_BLOCK
0.000000,0,0.000000,}],
0.000000,0,0.000000,level     => [qw{
0.000000,0,0.000000,Z_NO_COMPRESSION
0.000000,0,0.000000,Z_BEST_SPEED
0.000000,0,0.000000,Z_BEST_COMPRESSION
0.000000,0,0.000000,Z_DEFAULT_COMPRESSION
0.000000,0,0.000000,}],
0.000000,0,0.000000,strategy  => [qw{
0.000000,0,0.000000,Z_FILTERED
0.000000,0,0.000000,Z_HUFFMAN_ONLY
0.000000,0,0.000000,Z_RLE
0.000000,0,0.000000,Z_FIXED
0.000000,0,0.000000,Z_DEFAULT_STRATEGY
0.000000,0,0.000000,}],
0.000000,0,0.000000,status   => [qw{
0.000000,0,0.000000,Z_OK
0.000000,0,0.000000,Z_STREAM_END
0.000000,0,0.000000,Z_NEED_DICT
0.000000,0,0.000000,Z_ERRNO
0.000000,0,0.000000,Z_STREAM_ERROR
0.000000,0,0.000000,Z_DATA_ERROR
0.000000,0,0.000000,Z_MEM_ERROR
0.000000,0,0.000000,Z_BUF_ERROR
0.000000,0,0.000000,Z_VERSION_ERROR
0.000000,0,0.000000,}],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000001,1,0.000001,%DEFLATE_CONSTANTS = %EXPORT_TAGS;
0.000000,0,0.000000,
0.000000,0,0.000000,# Items to export into callers namespace by default. Note: do not export
0.000000,0,0.000000,# names by default without a very good reason. Use EXPORT_OK instead.
0.000000,0,0.000000,# Do not simply export all your public functions/methods/constants.
0.000003,1,0.000003,@DEFLATE_CONSTANTS =
0.000000,0,0.000000,@EXPORT = qw(
0.000000,0,0.000000,ZLIB_VERSION
0.000000,0,0.000000,ZLIB_VERNUM
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,OS_CODE
0.000000,0,0.000000,
0.000000,0,0.000000,MAX_MEM_LEVEL
0.000000,0,0.000000,MAX_WBITS
0.000000,0,0.000000,
0.000000,0,0.000000,Z_ASCII
0.000000,0,0.000000,Z_BEST_COMPRESSION
0.000000,0,0.000000,Z_BEST_SPEED
0.000000,0,0.000000,Z_BINARY
0.000000,0,0.000000,Z_BLOCK
0.000000,0,0.000000,Z_BUF_ERROR
0.000000,0,0.000000,Z_DATA_ERROR
0.000000,0,0.000000,Z_DEFAULT_COMPRESSION
0.000000,0,0.000000,Z_DEFAULT_STRATEGY
0.000000,0,0.000000,Z_DEFLATED
0.000000,0,0.000000,Z_ERRNO
0.000000,0,0.000000,Z_FILTERED
0.000000,0,0.000000,Z_FIXED
0.000000,0,0.000000,Z_FINISH
0.000000,0,0.000000,Z_FULL_FLUSH
0.000000,0,0.000000,Z_HUFFMAN_ONLY
0.000000,0,0.000000,Z_MEM_ERROR
0.000000,0,0.000000,Z_NEED_DICT
0.000000,0,0.000000,Z_NO_COMPRESSION
0.000000,0,0.000000,Z_NO_FLUSH
0.000000,0,0.000000,Z_NULL
0.000000,0,0.000000,Z_OK
0.000000,0,0.000000,Z_PARTIAL_FLUSH
0.000000,0,0.000000,Z_RLE
0.000000,0,0.000000,Z_STREAM_END
0.000000,0,0.000000,Z_STREAM_ERROR
0.000000,0,0.000000,Z_SYNC_FLUSH
0.000000,0,0.000000,Z_TREES
0.000000,0,0.000000,Z_UNKNOWN
0.000000,0,0.000000,Z_VERSION_ERROR
0.000000,0,0.000000,
0.000000,0,0.000000,WANT_GZIP
0.000000,0,0.000000,WANT_GZIP_OR_ZLIB
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000004,1,0.000004,push @EXPORT, qw(crc32 adler32 DEF_WBITS);
0.000000,0,0.000000,
0.000016,2,0.000008,use constant WANT_GZIP           => 16;
0.000066,2,0.000033,use constant WANT_GZIP_OR_ZLIB   => 32;
0.000000,0,0.000000,
0.000000,0,0.000000,sub AUTOLOAD {
0.000000,5,0.000000,my($constname);
0.000023,5,0.000005,($constname = $AUTOLOAD) =~ s/.*:://;
0.000009,5,0.000002,my ($error, $val) = constant($constname);
0.000001,5,0.000000,Carp::croak $error if $error;
0.000055,2,0.000028,no strict 'refs';
0.000020,13,0.000002,*{$AUTOLOAD} = sub { $val };
0.000011,5,0.000002,goto &{$AUTOLOAD};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000014,2,0.000007,use constant FLAG_APPEND             => 1 ;
0.000014,2,0.000007,use constant FLAG_CRC                => 2 ;
0.000011,2,0.000005,use constant FLAG_ADLER              => 4 ;
0.000011,2,0.000005,use constant FLAG_CONSUME_INPUT      => 8 ;
0.000038,2,0.000019,use constant FLAG_LIMIT_OUTPUT       => 16 ;
0.000000,0,0.000000,
0.000000,0,0.000000,eval {
0.000001,1,0.000001,require XSLoader;
0.004912,1,0.004912,XSLoader::load('Compress::Raw::Zlib', $XS_VERSION);
0.000001,1,0.000001,1;
0.000000,0,0.000000,}
0.000000,1,0.000000,or do {
0.000000,0,0.000000,require DynaLoader;
0.000000,0,0.000000,local @ISA = qw(DynaLoader);
0.000000,0,0.000000,bootstrap Compress::Raw::Zlib $XS_VERSION ;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000011,2,0.000005,use constant Parse_any      => 0x01;
0.000010,2,0.000005,use constant Parse_unsigned => 0x02;
0.000010,2,0.000005,use constant Parse_signed   => 0x04;
0.000012,2,0.000006,use constant Parse_boolean  => 0x08;
0.000000,0,0.000000,#use constant Parse_string   => 0x10;
0.000000,0,0.000000,#use constant Parse_custom   => 0x12;
0.000000,0,0.000000,
0.000000,0,0.000000,#use constant Parse_store_ref => 0x100 ;
0.000000,0,0.000000,
0.000011,2,0.000005,use constant OFF_PARSED     => 0 ;
0.000011,2,0.000005,use constant OFF_TYPE       => 1 ;
0.000011,2,0.000005,use constant OFF_DEFAULT    => 2 ;
0.000010,2,0.000005,use constant OFF_FIXED      => 3 ;
0.000014,2,0.000007,use constant OFF_FIRST_ONLY => 4 ;
0.001635,2,0.000817,use constant OFF_STICKY     => 5 ;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub ParseParameters
0.000000,0,0.000000,{
0.000000,0,0.000000,my $level = shift || 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $sub = (caller($level + 1))[3] ;
0.000000,0,0.000000,#local $Carp::CarpLevel = 1 ;
0.000000,0,0.000000,my $p = new Compress::Raw::Zlib::Parameters() ;
0.000000,0,0.000000,$p->parse(@_)
0.000000,0,0.000000,or croak "$sub: $p->{Error}" ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $p;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::Parameters::new
0.000000,0,0.000000,{
0.000000,0,0.000000,my $class = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $obj = { Error => '',
0.000000,0,0.000000,Got   => {},
0.000000,0,0.000000,} ;
0.000000,0,0.000000,
0.000000,0,0.000000,#return bless $obj, ref($class) || $class || __PACKAGE__ ;
0.000000,0,0.000000,return bless $obj, 'Compress::Raw::Zlib::Parameters' ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::Parameters::setError
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $error = shift ;
0.000000,0,0.000000,my $retval = @_ ? shift : undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{Error} = $error ;
0.000000,0,0.000000,return $retval;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#sub getError
0.000000,0,0.000000,#{
0.000000,0,0.000000,#    my $self = shift ;
0.000000,0,0.000000,#    return $self->{Error} ;
0.000000,0,0.000000,#}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::Parameters::parse
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $default = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $got = $self->{Got} ;
0.000000,0,0.000000,my $firstTime = keys %{ $got } == 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,my (@Bad) ;
0.000000,0,0.000000,my @entered = () ;
0.000000,0,0.000000,
0.000000,0,0.000000,# Allow the options to be passed as a hash reference or
0.000000,0,0.000000,# as the complete hash.
0.000000,0,0.000000,if (@_ == 0) {
0.000000,0,0.000000,@entered = () ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (@_ == 1) {
0.000000,0,0.000000,my $href = $_[0] ;
0.000000,0,0.000000,return $self->setError("Expected even number of parameters, got 1")
0.000000,0,0.000000,if ! defined $href or ! ref $href or ref $href ne "HASH" ;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $key (keys %$href) {
0.000000,0,0.000000,push @entered, $key ;
0.000000,0,0.000000,push @entered, \$href->{$key} ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $count = @_;
0.000000,0,0.000000,return $self->setError("Expected even number of parameters, got $count")
0.000000,0,0.000000,if $count % 2 != 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $i (0.. $count / 2 - 1) {
0.000000,0,0.000000,push @entered, $_[2* $i] ;
0.000000,0,0.000000,push @entered, \$_[2* $i+1] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,while (my ($key, $v) = each %$default)
0.000000,0,0.000000,{
0.000000,0,0.000000,croak "need 4 params [@$v]"
0.000000,0,0.000000,if @$v != 4 ;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($first_only, $sticky, $type, $value) = @$v ;
0.000000,0,0.000000,my $x ;
0.000000,0,0.000000,$self->_checkType($key, \$value, $type, 0, \$x)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,$key = lc $key;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($firstTime || ! $sticky) {
0.000000,0,0.000000,$got->{$key} = [0, $type, $value, $x, $first_only, $sticky] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$got->{$key}[OFF_PARSED] = 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for my $i (0.. @entered / 2 - 1) {
0.000000,0,0.000000,my $key = $entered[2* $i] ;
0.000000,0,0.000000,my $value = $entered[2* $i+1] ;
0.000000,0,0.000000,
0.000000,0,0.000000,#print "Key [$key] Value [$value]" ;
0.000000,0,0.000000,#print defined $$value ? "[$$value]\n" : "[undef]\n";
0.000000,0,0.000000,
0.000000,0,0.000000,$key =~ s/^-// ;
0.000000,0,0.000000,my $canonkey = lc $key;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($got->{$canonkey} && ($firstTime ||
0.000000,0,0.000000,! $got->{$canonkey}[OFF_FIRST_ONLY]  ))
0.000000,0,0.000000,{
0.000000,0,0.000000,my $type = $got->{$canonkey}[OFF_TYPE] ;
0.000000,0,0.000000,my $s ;
0.000000,0,0.000000,$self->_checkType($key, $value, $type, 1, \$s)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,#$value = $$value unless $type & Parse_store_ref ;
0.000000,0,0.000000,$value = $$value ;
0.000000,0,0.000000,$got->{$canonkey} = [1, $type, $value, $s] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{ push (@Bad, $key) }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (@Bad) {
0.000000,0,0.000000,my ($bad) = join(", ", @Bad) ;
0.000000,0,0.000000,return $self->setError("unknown key value(s) @Bad") ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::Parameters::_checkType
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $key   = shift ;
0.000000,0,0.000000,my $value = shift ;
0.000000,0,0.000000,my $type  = shift ;
0.000000,0,0.000000,my $validate  = shift ;
0.000000,0,0.000000,my $output  = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,#local $Carp::CarpLevel = $level ;
0.000000,0,0.000000,#print "PARSE $type $key $value $validate $sub\n" ;
0.000000,0,0.000000,#    if ( $type & Parse_store_ref)
0.000000,0,0.000000,#    {
0.000000,0,0.000000,#        #$value = $$value
0.000000,0,0.000000,#        #    if ref ${ $value } ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#        $$output = $value ;
0.000000,0,0.000000,#        return 1;
0.000000,0,0.000000,#    }
0.000000,0,0.000000,
0.000000,0,0.000000,$value = $$value ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($type & Parse_any)
0.000000,0,0.000000,{
0.000000,0,0.000000,$$output = $value ;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type & Parse_unsigned)
0.000000,0,0.000000,{
0.000000,0,0.000000,return $self->setError("Parameter '$key' must be an unsigned int, got 'undef'")
0.000000,0,0.000000,if $validate && ! defined $value ;
0.000000,0,0.000000,return $self->setError("Parameter '$key' must be an unsigned int, got '$value'")
0.000000,0,0.000000,if $validate && $value !~ /^\d+$/;
0.000000,0,0.000000,
0.000000,0,0.000000,$$output = defined $value ? $value : 0 ;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type & Parse_signed)
0.000000,0,0.000000,{
0.000000,0,0.000000,return $self->setError("Parameter '$key' must be a signed int, got 'undef'")
0.000000,0,0.000000,if $validate && ! defined $value ;
0.000000,0,0.000000,return $self->setError("Parameter '$key' must be a signed int, got '$value'")
0.000000,0,0.000000,if $validate && $value !~ /^-?\d+$/;
0.000000,0,0.000000,
0.000000,0,0.000000,$$output = defined $value ? $value : 0 ;
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type & Parse_boolean)
0.000000,0,0.000000,{
0.000000,0,0.000000,return $self->setError("Parameter '$key' must be an int, got '$value'")
0.000000,0,0.000000,if $validate && defined $value && $value !~ /^\d*$/;
0.000000,0,0.000000,$$output =  defined $value ? $value != 0 : 0 ;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,#    elsif ($type & Parse_string)
0.000000,0,0.000000,#    {
0.000000,0,0.000000,#        $$output = defined $value ? $value : "" ;
0.000000,0,0.000000,#        return 1;
0.000000,0,0.000000,#    }
0.000000,0,0.000000,
0.000000,0,0.000000,$$output = $value ;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::Parameters::parsed
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $name = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{Got}{lc $name}[OFF_PARSED] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::Parameters::value
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $name = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (@_)
0.000000,0,0.000000,{
0.000000,0,0.000000,$self->{Got}{lc $name}[OFF_PARSED]  = 1;
0.000000,0,0.000000,$self->{Got}{lc $name}[OFF_DEFAULT] = $_[0] ;
0.000000,0,0.000000,$self->{Got}{lc $name}[OFF_FIXED]   = $_[0] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{Got}{lc $name}[OFF_FIXED] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000016,1,0.000016,our $OPTIONS_deflate =
0.000000,0,0.000000,{
0.000000,0,0.000000,'AppendOutput'  => [1, 1, Parse_boolean,  0],
0.000000,0,0.000000,'CRC32'         => [1, 1, Parse_boolean,  0],
0.000000,0,0.000000,'ADLER32'       => [1, 1, Parse_boolean,  0],
0.000000,0,0.000000,'Bufsize'       => [1, 1, Parse_unsigned, 4096],
0.000000,0,0.000000,
0.000000,0,0.000000,'Level'         => [1, 1, Parse_signed,   Z_DEFAULT_COMPRESSION()],
0.000000,0,0.000000,'Method'        => [1, 1, Parse_unsigned, Z_DEFLATED()],
0.000000,0,0.000000,'WindowBits'    => [1, 1, Parse_signed,   MAX_WBITS()],
0.000000,0,0.000000,'MemLevel'      => [1, 1, Parse_unsigned, MAX_MEM_LEVEL()],
0.000000,0,0.000000,'Strategy'      => [1, 1, Parse_unsigned, Z_DEFAULT_STRATEGY()],
0.000000,0,0.000000,'Dictionary'    => [1, 1, Parse_any,      ""],
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::Deflate::new
0.000000,0,0.000000,{
0.000000,0,0.000000,my $pkg = shift ;
0.000000,0,0.000000,my ($got) = ParseParameters(0, $OPTIONS_deflate, @_);
0.000000,0,0.000000,
0.000000,0,0.000000,croak "Compress::Raw::Zlib::Deflate::new: Bufsize must be >= 1, you specified " .
0.000000,0,0.000000,$got->value('Bufsize')
0.000000,0,0.000000,unless $got->value('Bufsize') >= 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $flags = 0 ;
0.000000,0,0.000000,$flags |= FLAG_APPEND if $got->value('AppendOutput') ;
0.000000,0,0.000000,$flags |= FLAG_CRC    if $got->value('CRC32') ;
0.000000,0,0.000000,$flags |= FLAG_ADLER  if $got->value('ADLER32') ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $windowBits =  $got->value('WindowBits');
0.000000,0,0.000000,$windowBits += MAX_WBITS()
0.000000,0,0.000000,if ($windowBits & MAX_WBITS()) == 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,_deflateInit($flags,
0.000000,0,0.000000,$got->value('Level'),
0.000000,0,0.000000,$got->value('Method'),
0.000000,0,0.000000,$windowBits,
0.000000,0,0.000000,$got->value('MemLevel'),
0.000000,0,0.000000,$got->value('Strategy'),
0.000000,0,0.000000,$got->value('Bufsize'),
0.000000,0,0.000000,$got->value('Dictionary')) ;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::deflateStream::STORABLE_freeze
0.000000,0,0.000000,{
0.000000,0,0.000000,my $type = ref shift;
0.000000,0,0.000000,croak "Cannot freeze $type object\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::deflateStream::STORABLE_thaw
0.000000,0,0.000000,{
0.000000,0,0.000000,my $type = ref shift;
0.000000,0,0.000000,croak "Cannot thaw $type object\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000008,1,0.000008,our $OPTIONS_inflate =
0.000000,0,0.000000,{
0.000000,0,0.000000,'AppendOutput'  => [1, 1, Parse_boolean,  0],
0.000000,0,0.000000,'LimitOutput'   => [1, 1, Parse_boolean,  0],
0.000000,0,0.000000,'CRC32'         => [1, 1, Parse_boolean,  0],
0.000000,0,0.000000,'ADLER32'       => [1, 1, Parse_boolean,  0],
0.000000,0,0.000000,'ConsumeInput'  => [1, 1, Parse_boolean,  1],
0.000000,0,0.000000,'Bufsize'       => [1, 1, Parse_unsigned, 4096],
0.000000,0,0.000000,
0.000000,0,0.000000,'WindowBits'    => [1, 1, Parse_signed,   MAX_WBITS()],
0.000000,0,0.000000,'Dictionary'    => [1, 1, Parse_any,      ""],
0.000000,0,0.000000,} ;
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::Inflate::new
0.000000,0,0.000000,{
0.000000,0,0.000000,my $pkg = shift ;
0.000000,0,0.000000,my ($got) = ParseParameters(0, $OPTIONS_inflate, @_);
0.000000,0,0.000000,
0.000000,0,0.000000,croak "Compress::Raw::Zlib::Inflate::new: Bufsize must be >= 1, you specified " .
0.000000,0,0.000000,$got->value('Bufsize')
0.000000,0,0.000000,unless $got->value('Bufsize') >= 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $flags = 0 ;
0.000000,0,0.000000,$flags |= FLAG_APPEND if $got->value('AppendOutput') ;
0.000000,0,0.000000,$flags |= FLAG_CRC    if $got->value('CRC32') ;
0.000000,0,0.000000,$flags |= FLAG_ADLER  if $got->value('ADLER32') ;
0.000000,0,0.000000,$flags |= FLAG_CONSUME_INPUT if $got->value('ConsumeInput') ;
0.000000,0,0.000000,$flags |= FLAG_LIMIT_OUTPUT if $got->value('LimitOutput') ;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,my $windowBits =  $got->value('WindowBits');
0.000000,0,0.000000,$windowBits += MAX_WBITS()
0.000000,0,0.000000,if ($windowBits & MAX_WBITS()) == 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,_inflateInit($flags, $windowBits, $got->value('Bufsize'),
0.000000,0,0.000000,$got->value('Dictionary')) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::inflateStream::STORABLE_freeze
0.000000,0,0.000000,{
0.000000,0,0.000000,my $type = ref shift;
0.000000,0,0.000000,croak "Cannot freeze $type object\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::inflateStream::STORABLE_thaw
0.000000,0,0.000000,{
0.000000,0,0.000000,my $type = ref shift;
0.000000,0,0.000000,croak "Cannot thaw $type object\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::InflateScan::new
0.000000,0,0.000000,{
0.000000,0,0.000000,my $pkg = shift ;
0.000000,0,0.000000,my ($got) = ParseParameters(0,
0.000000,0,0.000000,{
0.000000,0,0.000000,'CRC32'         => [1, 1, Parse_boolean,  0],
0.000000,0,0.000000,'ADLER32'       => [1, 1, Parse_boolean,  0],
0.000000,0,0.000000,'Bufsize'       => [1, 1, Parse_unsigned, 4096],
0.000000,0,0.000000,
0.000000,0,0.000000,'WindowBits'    => [1, 1, Parse_signed,   -MAX_WBITS()],
0.000000,0,0.000000,'Dictionary'    => [1, 1, Parse_any,      ""],
0.000000,0,0.000000,}, @_) ;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,croak "Compress::Raw::Zlib::InflateScan::new: Bufsize must be >= 1, you specified " .
0.000000,0,0.000000,$got->value('Bufsize')
0.000000,0,0.000000,unless $got->value('Bufsize') >= 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $flags = 0 ;
0.000000,0,0.000000,#$flags |= FLAG_APPEND if $got->value('AppendOutput') ;
0.000000,0,0.000000,$flags |= FLAG_CRC    if $got->value('CRC32') ;
0.000000,0,0.000000,$flags |= FLAG_ADLER  if $got->value('ADLER32') ;
0.000000,0,0.000000,#$flags |= FLAG_CONSUME_INPUT if $got->value('ConsumeInput') ;
0.000000,0,0.000000,
0.000000,0,0.000000,_inflateScanInit($flags, $got->value('WindowBits'), $got->value('Bufsize'),
0.000000,0,0.000000,'') ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::inflateScanStream::createDeflateStream
0.000000,0,0.000000,{
0.000000,0,0.000000,my $pkg = shift ;
0.000000,0,0.000000,my ($got) = ParseParameters(0,
0.000000,0,0.000000,{
0.000000,0,0.000000,'AppendOutput'  => [1, 1, Parse_boolean,  0],
0.000000,0,0.000000,'CRC32'         => [1, 1, Parse_boolean,  0],
0.000000,0,0.000000,'ADLER32'       => [1, 1, Parse_boolean,  0],
0.000000,0,0.000000,'Bufsize'       => [1, 1, Parse_unsigned, 4096],
0.000000,0,0.000000,
0.000000,0,0.000000,'Level'         => [1, 1, Parse_signed,   Z_DEFAULT_COMPRESSION()],
0.000000,0,0.000000,'Method'        => [1, 1, Parse_unsigned, Z_DEFLATED()],
0.000000,0,0.000000,'WindowBits'    => [1, 1, Parse_signed,   - MAX_WBITS()],
0.000000,0,0.000000,'MemLevel'      => [1, 1, Parse_unsigned, MAX_MEM_LEVEL()],
0.000000,0,0.000000,'Strategy'      => [1, 1, Parse_unsigned, Z_DEFAULT_STRATEGY()],
0.000000,0,0.000000,}, @_) ;
0.000000,0,0.000000,
0.000000,0,0.000000,croak "Compress::Raw::Zlib::InflateScan::createDeflateStream: Bufsize must be >= 1, you specified " .
0.000000,0,0.000000,$got->value('Bufsize')
0.000000,0,0.000000,unless $got->value('Bufsize') >= 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $flags = 0 ;
0.000000,0,0.000000,$flags |= FLAG_APPEND if $got->value('AppendOutput') ;
0.000000,0,0.000000,$flags |= FLAG_CRC    if $got->value('CRC32') ;
0.000000,0,0.000000,$flags |= FLAG_ADLER  if $got->value('ADLER32') ;
0.000000,0,0.000000,
0.000000,0,0.000000,$pkg->_createDeflateStream($flags,
0.000000,0,0.000000,$got->value('Level'),
0.000000,0,0.000000,$got->value('Method'),
0.000000,0,0.000000,$got->value('WindowBits'),
0.000000,0,0.000000,$got->value('MemLevel'),
0.000000,0,0.000000,$got->value('Strategy'),
0.000000,0,0.000000,$got->value('Bufsize'),
0.000000,0,0.000000,) ;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::inflateScanStream::inflate
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $buffer = $_[1];
0.000000,0,0.000000,my $eof = $_[2];
0.000000,0,0.000000,
0.000000,0,0.000000,my $status = $self->scan(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($status == Z_OK() && $_[2]) {
0.000000,0,0.000000,my $byte = ' ';
0.000000,0,0.000000,
0.000000,0,0.000000,$status = $self->scan(\$byte, $_[1]) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $status ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Compress::Raw::Zlib::deflateStream::deflateParams
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my ($got) = ParseParameters(0, {
0.000000,0,0.000000,'Level'      => [1, 1, Parse_signed,   undef],
0.000000,0,0.000000,'Strategy'   => [1, 1, Parse_unsigned, undef],
0.000000,0,0.000000,'Bufsize'    => [1, 1, Parse_unsigned, undef],
0.000000,0,0.000000,},
0.000000,0,0.000000,@_) ;
0.000000,0,0.000000,
0.000000,0,0.000000,croak "Compress::Raw::Zlib::deflateParams needs Level and/or Strategy"
0.000000,0,0.000000,unless $got->parsed('Level') + $got->parsed('Strategy') +
0.000000,0,0.000000,$got->parsed('Bufsize');
0.000000,0,0.000000,
0.000000,0,0.000000,croak "Compress::Raw::Zlib::Inflate::deflateParams: Bufsize must be >= 1, you specified " .
0.000000,0,0.000000,$got->value('Bufsize')
0.000000,0,0.000000,if $got->parsed('Bufsize') && $got->value('Bufsize') <= 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $flags = 0;
0.000000,0,0.000000,$flags |= 1 if $got->parsed('Level') ;
0.000000,0,0.000000,$flags |= 2 if $got->parsed('Strategy') ;
0.000000,0,0.000000,$flags |= 4 if $got->parsed('Bufsize') ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_deflateParams($flags, $got->value('Level'),
0.000000,0,0.000000,$got->value('Strategy'), $got->value('Bufsize'));
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000021,1,0.000021,1;
0.000000,0,0.000000,__END__
