# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Module::Implementation;
0.000000,0,0.000000,# git description: v0.08-2-gd599347
0.000001,1,0.000001,$Module::Implementation::VERSION = '0.09';
0.000000,0,0.000000,
0.000025,2,0.000012,use strict;
0.000016,2,0.000008,use warnings;
0.000000,0,0.000000,
0.000030,3,0.000010,use Module::Runtime 0.012 qw( require_module );
0.001338,2,0.000669,use Try::Tiny;
0.000000,0,0.000000,
0.000000,0,0.000000,# This is needed for the benefit of Test::CleanNamespaces, which in turn loads
0.000000,0,0.000000,# Package::Stash, which in turn loads this module and expects a minimum
0.000000,0,0.000000,# version.
0.000001,1,0.000001,unless ( exists $Module::Implementation::{VERSION}
0.000000,0,0.000000,&& ${ $Module::Implementation::{VERSION} } ) {
0.000000,0,0.000000,
0.000000,0,0.000000,$Module::Implementation::{VERSION} = \42;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,my %Implementation;
0.000000,0,0.000000,
0.000000,0,0.000000,sub build_loader_sub {
0.000002,2,0.000001,my $caller = caller();
0.000000,0,0.000000,
0.000007,2,0.000003,return _build_loader( $caller, @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_loader {
0.000001,2,0.000000,my $package = shift;
0.000002,2,0.000001,my %args    = @_;
0.000000,0,0.000000,
0.000002,2,0.000001,my @implementations = @{ $args{implementations} };
0.000003,2,0.000002,my @symbols = @{ $args{symbols} || [] };
0.000000,0,0.000000,
0.000000,2,0.000000,my $implementation;
0.000002,2,0.000001,my $env_var = uc $package;
0.000010,2,0.000005,$env_var =~ s/::/_/g;
0.000002,2,0.000001,$env_var .= '_IMPLEMENTATION';
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,my ( $implementation, $loaded ) = _load_implementation(
0.000000,0,0.000000,$package,
0.000007,2,0.000003,$ENV{$env_var},
0.000000,0,0.000000,\@implementations,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000003,2,0.000002,$Implementation{$package} = $implementation;
0.000000,0,0.000000,
0.000003,2,0.000002,_copy_symbols( $loaded, $package, \@symbols );
0.000000,0,0.000000,
0.000005,2,0.000002,return $loaded;
0.000008,2,0.000004,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub implementation_for {
0.000001,1,0.000001,my $package = shift;
0.000000,0,0.000000,
0.000002,1,0.000002,return $Implementation{$package};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _load_implementation {
0.000001,2,0.000000,my $package         = shift;
0.000002,2,0.000001,my $env_value       = shift;
0.000000,2,0.000000,my $implementations = shift;
0.000000,0,0.000000,
0.000000,2,0.000000,if ($env_value) {
0.000000,0,0.000000,die "$env_value is not a valid implementation for $package"
0.000000,0,0.000000,unless grep { $_ eq $env_value } @{$implementations};
0.000000,0,0.000000,
0.000000,0,0.000000,my $requested = "${package}::$env_value";
0.000000,0,0.000000,
0.000000,0,0.000000,# Values from the %ENV hash are tainted. We know it's safe to untaint
0.000000,0,0.000000,# this value because the value was one of our known implementations.
0.000000,0,0.000000,($requested) = $requested =~ /^(.+)$/;
0.000000,0,0.000000,
0.000000,0,0.000000,try {
0.000000,0,0.000000,require_module($requested);
0.000000,0,0.000000,}
0.000000,0,0.000000,catch {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Could not load $requested: $_");
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,return ( $env_value, $requested );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,2,0.000000,my $err;
0.000001,2,0.000000,for my $possible ( @{$implementations} ) {
0.000002,2,0.000001,my $try = "${package}::$possible";
0.000000,0,0.000000,
0.000000,2,0.000000,my $ok;
0.000000,0,0.000000,try {
0.000005,2,0.000002,require_module($try);
0.000005,2,0.000002,$ok = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,catch {
0.000000,0,0.000000,$err .= $_ if defined $_;
0.000021,2,0.000010,};
0.000000,0,0.000000,
0.000008,2,0.000004,return ( $possible, $try ) if $ok;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,if ( defined $err && length $err ) {
0.000000,0,0.000000,Carp::croak(
0.000000,0,0.000000,"Could not find a suitable $package implementation: $err");
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Carp::croak(
0.000000,0,0.000000,'Module::Runtime failed to load a module but did not throw a real error. This should never happen. Something is very broken'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _copy_symbols {
0.000002,2,0.000001,my $from_package = shift;
0.000000,2,0.000000,my $to_package   = shift;
0.000001,2,0.000000,my $symbols      = shift;
0.000000,0,0.000000,
0.000006,2,0.000003,for my $sym ( @{$symbols} ) {
0.000017,12,0.000001,my $type = $sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';
0.000000,0,0.000000,
0.000001,12,0.000000,my $from = "${from_package}::$sym";
0.000002,12,0.000000,my $to   = "${to_package}::$sym";
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000033,14,0.000002,no strict 'refs';
0.000145,2,0.000073,no warnings 'once';
0.000000,0,0.000000,
0.000000,0,0.000000,# Copied from Exporter
0.000000,0,0.000000,*{$to}
0.000000,0,0.000000,= $type eq '&' ? \&{$from}
0.000000,0,0.000000,: $type eq '$' ? \${$from}
0.000000,0,0.000000,: $type eq '@' ? \@{$from}
0.000000,0,0.000000,: $type eq '%' ? \%{$from}
0.000020,12,0.000002,: $type eq '*' ? *{$from}
0.000000,0,0.000000,: die
0.000000,0,0.000000,"Can't copy symbol from $from_package to $to_package: $type$sym";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Loads one of several alternate underlying implementations for a module
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
