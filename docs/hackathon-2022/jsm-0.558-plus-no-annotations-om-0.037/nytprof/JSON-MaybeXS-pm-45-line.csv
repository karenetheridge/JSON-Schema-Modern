# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package JSON::MaybeXS;
0.000000,0,0.000000,
0.000029,2,0.000015,use strict;
0.000022,2,0.000011,use warnings FATAL => 'all';
0.000623,2,0.000311,use base qw(Exporter);
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '1.004004';
0.000001,1,0.000001,$VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _choose_json_module {
0.000001,1,0.000001,return 'Cpanel::JSON::XS' if $INC{'Cpanel/JSON/XS.pm'};
0.000000,1,0.000000,return 'JSON::XS'         if $INC{'JSON/XS.pm'} && eval { JSON::XS->VERSION(3.0); 1 };
0.000000,0,0.000000,
0.000000,1,0.000000,my @err;
0.000000,0,0.000000,
0.002281,3,0.000760,return 'Cpanel::JSON::XS' if eval { require Cpanel::JSON::XS; 1; };
0.000000,0,0.000000,push @err, "Error loading Cpanel::JSON::XS: $@";
0.000000,0,0.000000,
0.000000,0,0.000000,return 'JSON::XS' if eval { require JSON::XS; JSON::XS->VERSION(3.0); 1; };
0.000000,0,0.000000,push @err, "Error loading JSON::XS: $@";
0.000000,0,0.000000,
0.000000,0,0.000000,return 'JSON::PP' if eval { require JSON::PP; 1 };
0.000000,0,0.000000,push @err, "Error loading JSON::PP: $@";
0.000000,0,0.000000,
0.000000,0,0.000000,die join( "\n", "Couldn't load a JSON module:", @err );
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,our $JSON_Class = _choose_json_module();
0.000004,1,0.000004,$JSON_Class->import(qw(encode_json decode_json));
0.000035,2,0.000017,no strict 'refs';
0.000000,0,0.000000,*$_ = $JSON_Class->can($_)
0.000013,1,0.000013,for qw(true false);
0.000136,1,0.000136,}
0.000000,0,0.000000,
0.000001,1,0.000001,our @EXPORT = qw(encode_json decode_json JSON);
0.000000,1,0.000000,my @EXPORT_ALL = qw(is_bool);
0.000000,1,0.000000,our @EXPORT_OK = qw(is_bool to_json from_json);
0.000002,1,0.000002,our %EXPORT_TAGS = ( all => [ @EXPORT, @EXPORT_ALL ],
0.000000,0,0.000000,legacy => [ @EXPORT, @EXPORT_OK ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub JSON () { our $JSON_Class }
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,1,0.000000,shift;
0.000003,1,0.000003,my %args = @_ == 1 ? %{$_[0]} : @_;
0.000017,1,0.000017,my $new = (our $JSON_Class)->new;
0.000019,1,0.000019,$new->$_($args{$_}) for keys %args;
0.000003,1,0.000003,return $new;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000054,2,0.000027,use Scalar::Util ();
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_bool {
0.008481,57269,0.000000,die 'is_bool is not a method' if $_[1];
0.000000,0,0.000000,
0.192806,57269,0.000003,Scalar::Util::blessed($_[0])
0.000000,0,0.000000,and ($_[0]->isa('JSON::PP::Boolean')
0.000000,0,0.000000,or $_[0]->isa('Cpanel::JSON::XS::Boolean')
0.000000,0,0.000000,or $_[0]->isa('JSON::XS::Boolean'));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# (mostly) CopyPasta from JSON.pm version 2.90
0.000548,2,0.000274,use Carp ();
0.000000,0,0.000000,
0.000000,0,0.000000,sub from_json ($@) {
0.000000,0,0.000000,if ( ref($_[0]) =~ /^JSON/ or $_[0] =~ /^JSON/ ) {
0.000000,0,0.000000,Carp::croak "from_json should not be called as a method.";
0.000000,0,0.000000,}
0.000000,0,0.000000,my $json = JSON()->new;
0.000000,0,0.000000,
0.000000,0,0.000000,if (@_ == 2 and ref $_[1] eq 'HASH') {
0.000000,0,0.000000,my $opt  = $_[1];
0.000000,0,0.000000,for my $method (keys %$opt) {
0.000000,0,0.000000,$json->$method( $opt->{$method} );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $json->decode( $_[0] );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub to_json ($@) {
0.000000,0,0.000000,if (
0.000000,0,0.000000,ref($_[0]) =~ /^JSON/
0.000000,0,0.000000,or (@_ > 2 and $_[0] =~ /^JSON/)
0.000000,0,0.000000,) {
0.000000,0,0.000000,Carp::croak "to_json should not be called as a method.";
0.000000,0,0.000000,}
0.000000,0,0.000000,my $json = JSON()->new;
0.000000,0,0.000000,
0.000000,0,0.000000,if (@_ == 2 and ref $_[1] eq 'HASH') {
0.000000,0,0.000000,my $opt  = $_[1];
0.000000,0,0.000000,for my $method (keys %$opt) {
0.000000,0,0.000000,$json->$method( $opt->{$method} );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$json->encode($_[0]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,JSON::MaybeXS - Use L<Cpanel::JSON::XS> with a fallback to L<JSON::XS> and L<JSON::PP>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use JSON::MaybeXS;
0.000000,0,0.000000,
0.000000,0,0.000000,my $data_structure = decode_json($json_input);
0.000000,0,0.000000,
0.000000,0,0.000000,my $json_output = encode_json($data_structure);
0.000000,0,0.000000,
0.000000,0,0.000000,my $json = JSON()->new;
0.000000,0,0.000000,
0.000000,0,0.000000,my $json_with_args = JSON::MaybeXS->new(utf8 => 1); # or { utf8 => 1 }
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,This module first checks to see if either L<Cpanel::JSON::XS> or
0.000000,0,0.000000,L<JSON::XS> (at at least version 3.0)
0.000000,0,0.000000,is already loaded, in which case it uses that module. Otherwise
0.000000,0,0.000000,it tries to load L<Cpanel::JSON::XS>, then L<JSON::XS>, then L<JSON::PP>
0.000000,0,0.000000,in order, and either uses the first module it finds or throws an error.
0.000000,0,0.000000,
0.000000,0,0.000000,It then exports the C<encode_json> and C<decode_json> functions from the
0.000000,0,0.000000,loaded module, along with a C<JSON> constant that returns the class name
0.000000,0,0.000000,for calling C<new> on.
0.000000,0,0.000000,
0.000000,0,0.000000,If you're writing fresh code rather than replacing L<JSON.pm|JSON> usage, you might
0.000000,0,0.000000,want to pass options as constructor args rather than calling mutators, so
0.000000,0,0.000000,we provide our own C<new> method that supports that.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 EXPORTS
0.000000,0,0.000000,
0.000000,0,0.000000,C<encode_json>, C<decode_json> and C<JSON> are exported by default; C<is_bool>
0.000000,0,0.000000,is exported on request.
0.000000,0,0.000000,
0.000000,0,0.000000,To import only some symbols, specify them on the C<use> line:
0.000000,0,0.000000,
0.000000,0,0.000000,use JSON::MaybeXS qw(encode_json decode_json is_bool); # functions only
0.000000,0,0.000000,
0.000000,0,0.000000,use JSON::MaybeXS qw(JSON); # JSON constant only
0.000000,0,0.000000,
0.000000,0,0.000000,To import all available sensible symbols (C<encode_json>, C<decode_json>, and
0.000000,0,0.000000,C<is_bool>), use C<:all>:
0.000000,0,0.000000,
0.000000,0,0.000000,use JSON::MaybeXS ':all';
0.000000,0,0.000000,
0.000000,0,0.000000,To import all symbols including those needed by legacy apps that use L<JSON::PP>:
0.000000,0,0.000000,
0.000000,0,0.000000,use JSON::MaybeXS ':legacy';
0.000000,0,0.000000,
0.000000,0,0.000000,This imports the C<to_json> and C<from_json> symbols as well as everything in
0.000000,0,0.000000,C<:all>.  NOTE: This is to support legacy code that makes extensive
0.000000,0,0.000000,use of C<to_json> and C<from_json> which you are not yet in a position to
0.000000,0,0.000000,refactor.  DO NOT use this import tag in new code, in order to avoid
0.000000,0,0.000000,the crawling horrors of getting UTF-8 support subtly wrong.  See the
0.000000,0,0.000000,documentation for L<JSON> for further details.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 encode_json
0.000000,0,0.000000,
0.000000,0,0.000000,This is the C<encode_json> function provided by the selected implementation
0.000000,0,0.000000,module, and takes a perl data structure which is serialised to JSON text.
0.000000,0,0.000000,
0.000000,0,0.000000,my $json_text = encode_json($data_structure);
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 decode_json
0.000000,0,0.000000,
0.000000,0,0.000000,This is the C<decode_json> function provided by the selected implementation
0.000000,0,0.000000,module, and takes a string of JSON text to deserialise to a perl data structure.
0.000000,0,0.000000,
0.000000,0,0.000000,my $data_structure = decode_json($json_text);
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 to_json, from_json
0.000000,0,0.000000,
0.000000,0,0.000000,See L<JSON> for details.  These are included to support legacy code
0.000000,0,0.000000,B<only>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 JSON
0.000000,0,0.000000,
0.000000,0,0.000000,The C<JSON> constant returns the selected implementation module's name for
0.000000,0,0.000000,use as a class name - so:
0.000000,0,0.000000,
0.000000,0,0.000000,my $json_obj = JSON()->new; # returns a Cpanel::JSON::XS or JSON::PP object
0.000000,0,0.000000,
0.000000,0,0.000000,and that object can then be used normally:
0.000000,0,0.000000,
0.000000,0,0.000000,my $data_structure = $json_obj->decode($json_text); # etc.
0.000000,0,0.000000,
0.000000,0,0.000000,The use of parentheses here is optional, and only used as a hint to the reader
0.000000,0,0.000000,that this use of C<JSON> is a I<subroutine> call, I<not> a class name.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 is_bool
0.000000,0,0.000000,
0.000000,0,0.000000,$is_boolean = is_bool($scalar)
0.000000,0,0.000000,
0.000000,0,0.000000,Returns true if the passed scalar represents either C<true> or
0.000000,0,0.000000,C<false>, two constants that act like C<1> and C<0>, respectively
0.000000,0,0.000000,and are used to represent JSON C<true> and C<false> values in Perl.
0.000000,0,0.000000,
0.000000,0,0.000000,Since this is a bare sub in the various backend classes, it cannot be called as
0.000000,0,0.000000,a class method like the other interfaces; it must be called as a function, with
0.000000,0,0.000000,no invocant.  It supports the representation used in all JSON backends.
0.000000,0,0.000000,
0.000000,0,0.000000,Available since version 1.002004.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 CONSTRUCTOR
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 new
0.000000,0,0.000000,
0.000000,0,0.000000,With L<JSON::PP>, L<JSON::XS> and L<Cpanel::JSON::XS> you are required to call
0.000000,0,0.000000,mutators to set options, such as:
0.000000,0,0.000000,
0.000000,0,0.000000,my $json = $class->new->utf8(1)->pretty(1);
0.000000,0,0.000000,
0.000000,0,0.000000,Since this is a trifle irritating and noticeably un-perlish, we also offer:
0.000000,0,0.000000,
0.000000,0,0.000000,my $json = JSON::MaybeXS->new(utf8 => 1, pretty => 1);
0.000000,0,0.000000,
0.000000,0,0.000000,which works equivalently to the above (and in the usual tradition will accept
0.000000,0,0.000000,a hashref instead of a hash, should you so desire).
0.000000,0,0.000000,
0.000000,0,0.000000,The resulting object is blessed into the underlying backend, which offers (at
0.000000,0,0.000000,least) the methods C<encode> and C<decode>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 BOOLEANS
0.000000,0,0.000000,
0.000000,0,0.000000,To include JSON-aware booleans (C<true>, C<false>) in your data, just do:
0.000000,0,0.000000,
0.000000,0,0.000000,use JSON::MaybeXS;
0.000000,0,0.000000,my $true = JSON()->true;
0.000000,0,0.000000,my $false = JSON()->false;
0.000000,0,0.000000,
0.000000,0,0.000000,The booleans are also available as subs or methods on JSON::MaybeXS.
0.000000,0,0.000000,
0.000000,0,0.000000,use JSON::MaybeXS ();
0.000000,0,0.000000,my $true = JSON::MaybeXS::true;
0.000000,0,0.000000,my $true = JSON::MaybeXS->true;
0.000000,0,0.000000,my $false = JSON::MaybeXS::false;
0.000000,0,0.000000,my $false = JSON::MaybeXS->false;
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 CONVERTING FROM JSON::Any
0.000000,0,0.000000,
0.000000,0,0.000000,L<JSON::Any> used to be the favoured compatibility layer above the various
0.000000,0,0.000000,JSON backends, but over time has grown a lot of extra code to deal with legacy
0.000000,0,0.000000,backends (e.g. L<JSON::Syck>) that are no longer needed.  This is a rough guide of translating such code:
0.000000,0,0.000000,
0.000000,0,0.000000,Change code from:
0.000000,0,0.000000,
0.000000,0,0.000000,use JSON::Any;
0.000000,0,0.000000,my $json = JSON::Any->new->objToJson($data);    # or to_json($data), or Dump($data)
0.000000,0,0.000000,
0.000000,0,0.000000,to:
0.000000,0,0.000000,
0.000000,0,0.000000,use JSON::MaybeXS;
0.000000,0,0.000000,my $json = encode_json($data);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,Change code from:
0.000000,0,0.000000,
0.000000,0,0.000000,use JSON::Any;
0.000000,0,0.000000,my $data = JSON::Any->new->jsonToObj($json);    # or from_json($json), or Load($json)
0.000000,0,0.000000,
0.000000,0,0.000000,to:
0.000000,0,0.000000,
0.000000,0,0.000000,use JSON::MaybeXS;
0.000000,0,0.000000,my $json = decode_json($data);
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 CAVEATS
0.000000,0,0.000000,
0.000000,0,0.000000,The C<new()> method in this module is technically a factory, not a
0.000000,0,0.000000,constructor, because the objects it returns will I<NOT> be blessed into the
0.000000,0,0.000000,C<JSON::MaybeXS> class.
0.000000,0,0.000000,
0.000000,0,0.000000,If you are using an object returned by this module as a Moo(se) attribute,
0.000000,0,0.000000,this type constraint code:
0.000000,0,0.000000,
0.000000,0,0.000000,is 'json' => ( isa => 'JSON::MaybeXS' );
0.000000,0,0.000000,
0.000000,0,0.000000,will I<NOT> do what you expect. Instead, either rely on the C<JSON> class
0.000000,0,0.000000,constant described above, as so:
0.000000,0,0.000000,
0.000000,0,0.000000,is 'json' => ( isa => JSON::MaybeXS::JSON() );
0.000000,0,0.000000,
0.000000,0,0.000000,Alternatively, you can use duck typing:
0.000000,0,0.000000,
0.000000,0,0.000000,use Moose::Util::TypeConstraints 'duck_type';
0.000000,0,0.000000,is 'json' => ( isa => Object , duck_type([qw/ encode decode /]));
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 INSTALLATION
0.000000,0,0.000000,
0.000000,0,0.000000,At installation time, F<Makefile.PL> will attempt to determine if you have a
0.000000,0,0.000000,working compiler available, and therefore whether you are able to run XS code.
0.000000,0,0.000000,If so, L<Cpanel::JSON::XS> will be added to the prerequisite list, unless
0.000000,0,0.000000,L<JSON::XS> is already installed at a high enough version. L<JSON::XS> may
0.000000,0,0.000000,also be upgraded to fix any incompatibility issues.
0.000000,0,0.000000,
0.000000,0,0.000000,Because running XS code is not mandatory and L<JSON::PP> (which is in perl
0.000000,0,0.000000,core) is used as a fallback backend, this module is safe to be used in a suite
0.000000,0,0.000000,of code that is fatpacked or installed into a restricted-resource environment.
0.000000,0,0.000000,
0.000000,0,0.000000,You can also prevent any XS dependencies from being installed by setting
0.000000,0,0.000000,C<PUREPERL_ONLY=1> in F<Makefile.PL> options (or in the C<PERL_MM_OPT>
0.000000,0,0.000000,environment variable), or using the C<--pp> or C<--pureperl> flags with the
0.000000,0,0.000000,L<cpanminus client|cpanm>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHOR
0.000000,0,0.000000,
0.000000,0,0.000000,mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 CONTRIBUTORS
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Clinton Gormley <drtech@cpan.org>
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Karen Etheridge <ether@cpan.org>
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Kieren Diment <diment@gmail.com>
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright (c) 2013 the C<JSON::MaybeXS> L</AUTHOR> and L</CONTRIBUTORS>
0.000000,0,0.000000,as listed above.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 LICENSE
0.000000,0,0.000000,
0.000000,0,0.000000,This library is free software and may be distributed under the same terms
0.000000,0,0.000000,as perl itself.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
