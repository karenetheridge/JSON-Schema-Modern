# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Type::Tiny::Union;
0.000000,0,0.000000,
0.000039,2,0.000019,use 5.008001;
0.000015,2,0.000008,use strict;
0.000022,2,0.000011,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,$Type::Tiny::Union::AUTHORITY = 'cpan:TOBYINK';
0.000003,1,0.000003,$Type::Tiny::Union::VERSION   = '2.000001';
0.000021,1,0.000021,}
0.000000,0,0.000000,
0.000001,1,0.000001,$Type::Tiny::Union::VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000015,2,0.000008,use Scalar::Util qw< blessed >;
0.000029,2,0.000015,use Types::TypeTiny ();
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
0.000000,0,0.000000,
0.001268,2,0.000634,use Type::Tiny ();
0.000005,1,0.000005,our @ISA = 'Type::Tiny';
0.000000,0,0.000000,
0.000000,0,0.000000,__PACKAGE__->_install_overloads(
0.000017,8,0.000002,q[@{}] => sub { $_[0]{type_constraints} ||= [] } );
0.000000,0,0.000000,
0.000000,0,0.000000,sub new_by_overload {
0.000000,1,0.000000,my $proto = shift;
0.000001,1,0.000001,my %opts  = ( @_ == 1 ) ? %{ $_[0] } : @_;
0.000000,0,0.000000,
0.000001,1,0.000001,my @types = @{ $opts{type_constraints} };
0.000007,1,0.000007,if ( my @makers = map scalar( blessed($_) && $_->can( 'new_union' ) ), @types ) {
0.000000,1,0.000000,my $first_maker = shift @makers;
0.000001,1,0.000001,if ( ref $first_maker ) {
0.000000,0,0.000000,my $all_same = not grep +( !defined $_ or $_ ne $first_maker ), @makers;
0.000000,0,0.000000,if ( $all_same ) {
0.000000,0,0.000000,return ref( $types[0] )->$first_maker( %opts );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,return $proto->new( \%opts );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,1,0.000000,my $proto = shift;
0.000000,0,0.000000,
0.000002,1,0.000002,my %opts = ( @_ == 1 ) ? %{ $_[0] } : @_;
0.000000,0,0.000000,_croak
0.000000,0,0.000000,"Union type constraints cannot have a parent constraint passed to the constructor"
0.000000,1,0.000000,if exists $opts{parent};
0.000000,0,0.000000,_croak
0.000000,0,0.000000,"Union type constraints cannot have a constraint coderef passed to the constructor"
0.000001,1,0.000001,if exists $opts{constraint};
0.000000,0,0.000000,_croak
0.000000,0,0.000000,"Union type constraints cannot have a inlining coderef passed to the constructor"
0.000000,1,0.000000,if exists $opts{inlined};
0.000000,0,0.000000,_croak "Need to supply list of type constraints"
0.000000,1,0.000000,unless exists $opts{type_constraints};
0.000000,0,0.000000,
0.000000,0,0.000000,$opts{type_constraints} = [
0.000003,2,0.000002,map { $_->isa( __PACKAGE__ ) ? @$_ : $_ }
0.000000,0,0.000000,map Types::TypeTiny::to_TypeTiny( $_ ),
0.000000,0,0.000000,@{
0.000004,1,0.000004,ref $opts{type_constraints} eq "ARRAY"
0.000000,0,0.000000,? $opts{type_constraints}
0.000000,0,0.000000,: [ $opts{type_constraints} ]
0.000000,0,0.000000,}
0.000000,0,0.000000,];
0.000000,0,0.000000,
0.000000,0,0.000000,if ( Type::Tiny::_USE_XS ) {
0.000000,0,0.000000,my @constraints = @{ $opts{type_constraints} };
0.000000,0,0.000000,my @known       = map {
0.000000,0,0.000000,my $known = Type::Tiny::XS::is_known( $_->compiled_check );
0.000000,0,0.000000,defined( $known ) ? $known : ();
0.000000,0,0.000000,} @constraints;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( @known == @constraints ) {
0.000000,0,0.000000,my $xsub = Type::Tiny::XS::get_coderef_for(
0.000000,0,0.000000,sprintf "AnyOf[%s]",
0.000000,0,0.000000,join( ',', @known )
0.000000,0,0.000000,);
0.000000,0,0.000000,$opts{compiled_type_constraint} = $xsub if $xsub;
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( Type::Tiny::_USE_XS)
0.000000,0,0.000000,
0.000002,1,0.000002,my $self = $proto->SUPER::new( %opts );
0.000004,1,0.000004,$self->coercion if grep $_->has_coercion, @$self;
0.000002,1,0.000002,return $self;
0.000000,0,0.000000,} #/ sub new
0.000000,0,0.000000,
0.000000,0,0.000000,sub type_constraints { $_[0]{type_constraints} }
0.000000,0,0.000000,sub constraint       { $_[0]{constraint} ||= $_[0]->_build_constraint }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _is_null_constraint { 0 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_display_name {
0.000000,1,0.000000,my $self = shift;
0.000006,1,0.000006,join q[|], @$self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_coercion {
0.000000,0,0.000000,require Type::Coercion::Union;
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return "Type::Coercion::Union"->new( type_constraint => $self );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_constraint {
0.000000,0,0.000000,my @checks = map $_->compiled_check, @{ +shift };
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,my $val = $_;
0.000000,0,0.000000,$_->( $val ) && return !!1 for @checks;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub can_be_inlined {
0.000001,3,0.000000,my $self = shift;
0.000012,3,0.000004,not grep !$_->can_be_inlined, @$self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub inline_check {
0.000000,2,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( Type::Tiny::_USE_XS and !exists $self->{xs_sub} ) {
0.000000,0,0.000000,$self->{xs_sub} = undef;
0.000000,0,0.000000,
0.000000,0,0.000000,my @constraints = @{ $self->type_constraints };
0.000000,0,0.000000,my @known       = map {
0.000000,0,0.000000,my $known = Type::Tiny::XS::is_known( $_->compiled_check );
0.000000,0,0.000000,defined( $known ) ? $known : ();
0.000000,0,0.000000,} @constraints;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( @known == @constraints ) {
0.000000,0,0.000000,$self->{xs_sub} = Type::Tiny::XS::get_subname_for(
0.000000,0,0.000000,sprintf "AnyOf[%s]",
0.000000,0,0.000000,join( ',', @known )
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( Type::Tiny::_USE_XS...)
0.000000,0,0.000000,
0.000008,2,0.000004,my $code = sprintf '(%s)', join " or ", map $_->inline_check( $_[0] ), @$self;
0.000000,0,0.000000,
0.000000,2,0.000000,return "do { $Type::Tiny::SafePackage $code }"
0.000000,0,0.000000,if $Type::Tiny::AvoidCallbacks;
0.000000,0,0.000000,return "$self->{xs_sub}\($_[0]\)"
0.000001,2,0.000000,if $self->{xs_sub};
0.000004,2,0.000002,return $code;
0.000000,0,0.000000,} #/ sub inline_check
0.000000,0,0.000000,
0.000000,0,0.000000,sub _instantiate_moose_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %opts = @_;
0.000000,0,0.000000,delete $opts{parent};
0.000000,0,0.000000,delete $opts{constraint};
0.000000,0,0.000000,delete $opts{inlined};
0.000000,0,0.000000,
0.000000,0,0.000000,my @tc = map $_->moose_type, @{ $self->type_constraints };
0.000000,0,0.000000,
0.000000,0,0.000000,require Moose::Meta::TypeConstraint::Union;
0.000000,0,0.000000,return "Moose::Meta::TypeConstraint::Union"
0.000000,0,0.000000,->new( %opts, type_constraints => \@tc );
0.000000,0,0.000000,} #/ sub _instantiate_moose_type
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_parent {
0.000000,0,0.000000,defined( shift->parent );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parent {
0.000000,0,0.000000,$_[0]{parent} ||= $_[0]->_build_parent;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_parent {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $first, @rest ) = @$self;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $parent ( $first, $first->parents ) {
0.000000,0,0.000000,return $parent unless grep !$_->is_a_type_of( $parent ), @rest;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,} #/ sub _build_parent
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_type_for {
0.000000,0,0.000000,my @types = @{ +shift };
0.000000,0,0.000000,for my $type ( @types ) {
0.000000,0,0.000000,return $type if $type->check( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub validate_explain {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $value, $varname ) = @_;
0.000000,0,0.000000,$varname = '$_' unless defined $varname;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef if $self->check( $value );
0.000000,0,0.000000,
0.000000,0,0.000000,require Type::Utils;
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'"%s" requires that the value pass %s',
0.000000,0,0.000000,$self,
0.000000,0,0.000000,Type::Utils::english_list( \"or", map qq["$_"], @$self ),
0.000000,0,0.000000,),
0.000000,0,0.000000,map {
0.000000,0,0.000000,$_->get_message( $value ),
0.000000,0,0.000000,map( "    $_", @{ $_->validate_explain( $value ) || [] } ),
0.000000,0,0.000000,} @$self
0.000000,0,0.000000,];
0.000000,0,0.000000,} #/ sub validate_explain
0.000000,0,0.000000,
0.000000,0,0.000000,my $_delegate = sub {
0.000000,0,0.000000,my ( $self, $method ) = ( shift, shift );
0.000000,0,0.000000,my @types = @{ $self->type_constraints };
0.000000,0,0.000000,
0.000000,0,0.000000,my @unsupported = grep !$_->can( $method ), @types;
0.000000,0,0.000000,_croak( 'Could not apply method %s to all types within the union', $method )
0.000000,0,0.000000,if @unsupported;
0.000000,0,0.000000,
0.000000,0,0.000000,ref( $self )->new( type_constraints => [ map $_->$method( @_ ), @types ] );
0.000001,1,0.000001,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub stringifies_to {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->$_delegate( stringifies_to => @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub numifies_to {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->$_delegate( numifies_to => @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub with_attribute_values {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->$_delegate( with_attribute_values => @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @Type::Tiny::CMP, sub {
0.000000,0,0.000000,my $A = shift->find_constraining_type;
0.000000,0,0.000000,my $B = shift->find_constraining_type;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $A->isa( __PACKAGE__ ) and $B->isa( __PACKAGE__ ) ) {
0.000000,0,0.000000,my @A_constraints = @{ $A->type_constraints };
0.000000,0,0.000000,my @B_constraints = @{ $B->type_constraints };
0.000000,0,0.000000,
0.000000,0,0.000000,# If everything in @A_constraints is equal to something in @B_constraints and vice versa, then $A equiv to $B
0.000000,0,0.000000,EQUALITY: {
0.000000,0,0.000000,my $everything_in_a_is_equal = 1;
0.000000,0,0.000000,OUTER: for my $A_child ( @A_constraints ) {
0.000000,0,0.000000,INNER: for my $B_child ( @B_constraints ) {
0.000000,0,0.000000,if ( $A_child->equals( $B_child ) ) {
0.000000,0,0.000000,next OUTER;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$everything_in_a_is_equal = 0;
0.000000,0,0.000000,last OUTER;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $everything_in_b_is_equal = 1;
0.000000,0,0.000000,OUTER: for my $B_child ( @B_constraints ) {
0.000000,0,0.000000,INNER: for my $A_child ( @A_constraints ) {
0.000000,0,0.000000,if ( $B_child->equals( $A_child ) ) {
0.000000,0,0.000000,next OUTER;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$everything_in_b_is_equal = 0;
0.000000,0,0.000000,last OUTER;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return Type::Tiny::CMP_EQUIVALENT
0.000000,0,0.000000,if $everything_in_a_is_equal && $everything_in_b_is_equal;
0.000000,0,0.000000,} #/ EQUALITY:
0.000000,0,0.000000,
0.000000,0,0.000000,# If everything in @A_constraints is a subtype of something in @B_constraints, then $A is subtype of $B
0.000000,0,0.000000,SUBTYPE: {
0.000000,0,0.000000,OUTER: for my $A_child ( @A_constraints ) {
0.000000,0,0.000000,my $a_child_is_subtype_of_something = 0;
0.000000,0,0.000000,INNER: for my $B_child ( @B_constraints ) {
0.000000,0,0.000000,if ( $A_child->is_a_type_of( $B_child ) ) {
0.000000,0,0.000000,++$a_child_is_subtype_of_something;
0.000000,0,0.000000,last INNER;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( not $a_child_is_subtype_of_something ) {
0.000000,0,0.000000,last SUBTYPE;
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ OUTER: for my $A_child ( @A_constraints)
0.000000,0,0.000000,return Type::Tiny::CMP_SUBTYPE;
0.000000,0,0.000000,} #/ SUBTYPE:
0.000000,0,0.000000,
0.000000,0,0.000000,# If everything in @B_constraints is a subtype of something in @A_constraints, then $A is supertype of $B
0.000000,0,0.000000,SUPERTYPE: {
0.000000,0,0.000000,OUTER: for my $B_child ( @B_constraints ) {
0.000000,0,0.000000,my $b_child_is_subtype_of_something = 0;
0.000000,0,0.000000,INNER: for my $A_child ( @A_constraints ) {
0.000000,0,0.000000,if ( $B_child->is_a_type_of( $A_child ) ) {
0.000000,0,0.000000,++$b_child_is_subtype_of_something;
0.000000,0,0.000000,last INNER;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( not $b_child_is_subtype_of_something ) {
0.000000,0,0.000000,last SUPERTYPE;
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ OUTER: for my $B_child ( @B_constraints)
0.000000,0,0.000000,return Type::Tiny::CMP_SUPERTYPE;
0.000000,0,0.000000,} #/ SUPERTYPE:
0.000000,0,0.000000,} #/ if ( $A->isa( __PACKAGE__...))
0.000000,0,0.000000,
0.000000,0,0.000000,# I think it might be possible to merge this into the first bit by treating $B as union[$B].
0.000000,0,0.000000,# Test cases first though.
0.000000,0,0.000000,if ( $A->isa( __PACKAGE__ ) ) {
0.000000,0,0.000000,my @A_constraints = @{ $A->type_constraints };
0.000000,0,0.000000,if ( @A_constraints == 1 ) {
0.000000,0,0.000000,my $result = Type::Tiny::cmp( $A_constraints[0], $B );
0.000000,0,0.000000,return $result unless $result eq Type::Tiny::CMP_UNKNOWN;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $subtype = 1;
0.000000,0,0.000000,for my $child ( @A_constraints ) {
0.000000,0,0.000000,if ( $B->is_a_type_of( $child ) ) {
0.000000,0,0.000000,return Type::Tiny::CMP_SUPERTYPE;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( $subtype and not $B->is_supertype_of( $child ) ) {
0.000000,0,0.000000,$subtype = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( $subtype ) {
0.000000,0,0.000000,return Type::Tiny::CMP_SUBTYPE;
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( $A->isa( __PACKAGE__...))
0.000000,0,0.000000,
0.000000,0,0.000000,# I think it might be possible to merge this into the first bit by treating $A as union[$A].
0.000000,0,0.000000,# Test cases first though.
0.000000,0,0.000000,if ( $B->isa( __PACKAGE__ ) ) {
0.000000,0,0.000000,my @B_constraints = @{ $B->type_constraints };
0.000000,0,0.000000,if ( @B_constraints == 1 ) {
0.000000,0,0.000000,my $result = Type::Tiny::cmp( $A, $B_constraints[0] );
0.000000,0,0.000000,return $result unless $result eq Type::Tiny::CMP_UNKNOWN;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $supertype = 1;
0.000000,0,0.000000,for my $child ( @B_constraints ) {
0.000000,0,0.000000,if ( $A->is_a_type_of( $child ) ) {
0.000000,0,0.000000,return Type::Tiny::CMP_SUBTYPE;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( $supertype and not $A->is_supertype_of( $child ) ) {
0.000000,0,0.000000,$supertype = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( $supertype ) {
0.000000,0,0.000000,return Type::Tiny::CMP_SUPERTYPE;
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( $B->isa( __PACKAGE__...))
0.000000,0,0.000000,
0.000000,0,0.000000,return Type::Tiny::CMP_UNKNOWN;
0.000002,1,0.000002,};
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
