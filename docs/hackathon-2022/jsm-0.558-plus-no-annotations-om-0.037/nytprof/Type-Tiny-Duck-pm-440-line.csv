# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Type::Tiny::Duck;
0.000000,0,0.000000,
0.000042,2,0.000021,use 5.008001;
0.000021,2,0.000011,use strict;
0.000034,2,0.000017,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,$Type::Tiny::Duck::AUTHORITY = 'cpan:TOBYINK';
0.000003,1,0.000003,$Type::Tiny::Duck::VERSION   = '2.000001';
0.000029,1,0.000029,}
0.000000,0,0.000000,
0.000001,1,0.000001,$Type::Tiny::Duck::VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000052,2,0.000026,use Scalar::Util qw< blessed >;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000025,3,0.000008,use Exporter::Tiny 1.004001 ();
0.000707,2,0.000354,use Type::Tiny::ConstrainedObject ();
0.000013,1,0.000013,our @ISA = qw( Type::Tiny::ConstrainedObject Exporter::Tiny );
0.000000,0,0.000000,
0.000000,0,0.000000,sub _short_name { 'Duck' }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _exporter_fail {
0.000000,0,0.000000,my ( $class, $type_name, $methods, $globals ) = @_;
0.000000,0,0.000000,my $caller = $globals->{into};
0.000000,0,0.000000,my $type = $class->new(
0.000000,0,0.000000,name      => $type_name,
0.000000,0,0.000000,methods   => [ @$methods ],
0.000000,0,0.000000,);
0.000000,0,0.000000,$INC{'Type/Registry.pm'}
0.000000,0,0.000000,? 'Type::Registry'->for_class( $caller )->add_type( $type, $type_name )
0.000000,0,0.000000,: ( $Type::Registry::DELAYED{$caller}{$type_name} = $type )
0.000000,0,0.000000,unless( ref($caller) or $caller eq '-lexical' or $globals->{'lexical'} );
0.000000,0,0.000000,return map +( $_->{name} => $_->{code} ), @{ $type->exportables };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000001,1,0.000001,my $proto = shift;
0.000000,0,0.000000,
0.000001,1,0.000001,my %opts = ( @_ == 1 ) ? %{ $_[0] } : @_;
0.000000,1,0.000000,_croak "Need to supply list of methods" unless exists $opts{methods};
0.000000,0,0.000000,
0.000000,1,0.000000,$opts{methods} = [ $opts{methods} ] unless ref $opts{methods};
0.000000,0,0.000000,
0.000003,1,0.000003,if ( Type::Tiny::_USE_XS ) {
0.000000,0,0.000000,my $methods = join ",", sort( @{ $opts{methods} } );
0.000000,0,0.000000,my $xsub    = Type::Tiny::XS::get_coderef_for( "HasMethods[$methods]" );
0.000000,0,0.000000,$opts{compiled_type_constraint} = $xsub if $xsub;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( Type::Tiny::_USE_MOUSE ) {
0.000000,0,0.000000,require Mouse::Util::TypeConstraints;
0.000000,0,0.000000,my $maker = "Mouse::Util::TypeConstraints"->can( "generate_can_predicate_for" );
0.000000,0,0.000000,$opts{compiled_type_constraint} = $maker->( $opts{methods} ) if $maker;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,return $proto->SUPER::new( %opts );
0.000000,0,0.000000,} #/ sub new
0.000000,0,0.000000,
0.000002,1,0.000002,sub methods { $_[0]{methods} }
0.000009,4,0.000002,sub inlined { $_[0]{inlined} ||= $_[0]->_build_inlined }
0.000000,0,0.000000,
0.000009,9,0.000001,sub has_inlined { !!1 }
0.000000,0,0.000000,
0.000016,14,0.000001,sub _is_null_constraint { 0 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_constraint {
0.000000,0,0.000000,my $self    = shift;
0.000000,0,0.000000,my @methods = @{ $self->methods };
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,blessed( $_[0] )
0.000000,0,0.000000,and not grep( !$_[0]->can( $_ ), @methods );
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_inlined {
0.000000,1,0.000000,my $self    = shift;
0.000001,1,0.000001,my @methods = @{ $self->methods };
0.000000,0,0.000000,
0.000000,1,0.000000,my $xsub;
0.000000,0,0.000000,if ( Type::Tiny::_USE_XS ) {
0.000000,0,0.000000,my $methods = join ",", sort( @{ $self->methods } );
0.000000,0,0.000000,$xsub = Type::Tiny::XS::get_subname_for( "HasMethods[$methods]" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub {
0.000001,4,0.000000,my $var = $_[1];
0.000002,4,0.000000,local $" = q{ };
0.000000,0,0.000000,
0.000000,0,0.000000,# If $var is $_ or $_->{foo} or $foo{$_} or somesuch, then we
0.000000,0,0.000000,# can't use it within the grep expression, so we need to save
0.000000,0,0.000000,# it into a temporary variable ($tmp).
0.000017,4,0.000004,my $code =
0.000000,0,0.000000,( $var =~ /\$_/ )
0.000000,0,0.000000,? qq{ Scalar::Util::blessed($var) and not do { my \$tmp = $var; grep(!\$tmp->can(\$_), qw/@methods/) } }
0.000000,0,0.000000,: qq{ Scalar::Util::blessed($var) and not grep(!$var->can(\$_), qw/@methods/) };
0.000000,0,0.000000,
0.000003,4,0.000001,return qq{do { $Type::Tiny::SafePackage use Scalar::Util (); $code }}
0.000000,0,0.000000,if $Type::Tiny::AvoidCallbacks;
0.000000,4,0.000000,return "$xsub\($var\)"
0.000000,0,0.000000,if $xsub;
0.000005,4,0.000001,$code;
0.000003,1,0.000003,};
0.000000,0,0.000000,} #/ sub _build_inlined
0.000000,0,0.000000,
0.000000,0,0.000000,sub _instantiate_moose_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %opts = @_;
0.000000,0,0.000000,delete $opts{parent};
0.000000,0,0.000000,delete $opts{constraint};
0.000000,0,0.000000,delete $opts{inlined};
0.000000,0,0.000000,
0.000000,0,0.000000,require Moose::Meta::TypeConstraint::DuckType;
0.000000,0,0.000000,return "Moose::Meta::TypeConstraint::DuckType"
0.000000,0,0.000000,->new( %opts, methods => $self->methods );
0.000000,0,0.000000,} #/ sub _instantiate_moose_type
0.000000,0,0.000000,
0.000000,0,0.000000,sub validate_explain {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $value, $varname ) = @_;
0.000000,0,0.000000,$varname = '$_' unless defined $varname;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef if $self->check( $value );
0.000000,0,0.000000,return ["Not a blessed reference"] unless blessed( $value );
0.000000,0,0.000000,
0.000000,0,0.000000,require Type::Utils;
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'"%s" requires that the reference can %s',
0.000000,0,0.000000,$self,
0.000000,0,0.000000,Type::Utils::english_list( map qq["$_"], @{ $self->methods } ),
0.000000,0,0.000000,),
0.000000,0,0.000000,map sprintf( 'The reference cannot "%s"', $_ ),
0.000000,0,0.000000,grep !$value->can( $_ ),
0.000000,0,0.000000,@{ $self->methods }
0.000000,0,0.000000,];
0.000000,0,0.000000,} #/ sub validate_explain
0.000000,0,0.000000,
0.000000,0,0.000000,push @Type::Tiny::CMP, sub {
0.000000,0,0.000000,my $A = shift->find_constraining_type;
0.000000,0,0.000000,my $B = shift->find_constraining_type;
0.000000,0,0.000000,return Type::Tiny::CMP_UNKNOWN
0.000000,0,0.000000,unless $A->isa( __PACKAGE__ ) && $B->isa( __PACKAGE__ );
0.000000,0,0.000000,
0.000000,0,0.000000,my %seen;
0.000000,0,0.000000,for my $word ( @{ $A->methods } ) {
0.000000,0,0.000000,$seen{$word} += 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,for my $word ( @{ $B->methods } ) {
0.000000,0,0.000000,$seen{$word} += 2;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $values = join( '', CORE::values %seen );
0.000000,0,0.000000,if ( $values =~ /^3*$/ ) {
0.000000,0,0.000000,return Type::Tiny::CMP_EQUIVALENT;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $values !~ /2/ ) {
0.000000,0,0.000000,return Type::Tiny::CMP_SUBTYPE;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $values !~ /1/ ) {
0.000000,0,0.000000,return Type::Tiny::CMP_SUPERTYPE;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return Type::Tiny::CMP_UNKNOWN;
0.000002,1,0.000002,};
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
