# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000033,2,0.000017,use strict;
0.000339,2,0.000170,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Vocabulary::Unevaluated;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Implementation of the JSON Schema Unevaluated vocabulary
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.559';
0.000000,0,0.000000,
0.000062,2,0.000031,use 5.020;
0.000035,2,0.000017,use Moo;
0.000040,3,0.000013,use strictures 2;
0.000038,2,0.000019,use experimental qw(signatures postderef);
0.000024,2,0.000012,use if "$]" >= 5.022, experimental => 're_strict';
0.000019,2,0.000010,no if "$]" >= 5.031009, feature => 'indirect';
0.000052,2,0.000026,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000026,2,0.000013,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000039,3,0.000013,use List::Util 1.45 qw(any max);
0.000013,2,0.000007,use JSON::Schema::Modern::Utilities qw(is_type jsonp local_annotations E A abort true);
0.000710,2,0.000355,use namespace::clean;
0.000000,0,0.000000,
0.000003,1,0.000003,with 'JSON::Schema::Modern::Vocabulary';
0.000000,0,0.000000,
0.000000,0,0.000000,sub vocabulary {
0.000002,1,0.000002,'https://json-schema.org/draft/2020-12/vocab/unevaluated' => 'draft2020-12';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,2,0.000003,sub evaluation_order { 7 }
0.000000,0,0.000000,
0.000000,0,0.000000,# This vocabulary should be evaluated after the Applicator vocabulary.
0.000002,6,0.000000,sub keywords ($self, $spec_version) {
0.000009,2,0.000005,die 'Unevaluated not implemented in '.$spec_version if $spec_version =~ /^draft[467]$/;
0.000004,2,0.000002,qw(unevaluatedItems unevaluatedProperties);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_unevaluatedItems ($self, $schema, $state) {
0.000000,0,0.000000,$self->traverse_subschema($schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_unevaluatedItems ($self, $data, $schema, $state) {
0.000000,0,0.000000,abort($state, 'EXCEPTION: "unevaluatedItems" keyword present, but annotation collection is disabled')
0.000000,0,0.000000,if not $state->{collect_annotations};
0.000000,0,0.000000,
0.000000,0,0.000000,abort($state, 'EXCEPTION: "unevaluatedItems" keyword present, but short_circuit is enabled: results unreliable')
0.000000,0,0.000000,if $state->{short_circuit};
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if not is_type('array', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,my @annotations = local_annotations($state);
0.000000,0,0.000000,
0.000000,0,0.000000,# a relevant keyword already produced a 'true' annotation at this location
0.000000,0,0.000000,my @boolean_annotation_keywords =
0.000000,0,0.000000,$state->{spec_version} eq 'draft2019-09' ? qw(items additionalItems unevaluatedItems)
0.000000,0,0.000000,: qw(prefixItems items contains unevaluatedItems);
0.000000,0,0.000000,my %bools; @bools{@boolean_annotation_keywords} = (1)x@boolean_annotation_keywords;
0.000000,0,0.000000,return 1
0.000000,0,0.000000,if any { $bools{$_->{keyword}} && is_type('boolean', $_->{annotation}) && $_->{annotation} }
0.000000,0,0.000000,@annotations;
0.000000,0,0.000000,
0.000000,0,0.000000,# otherwise, evaluate at every instance item greater than the max of all 'prefixItems'/numeric
0.000000,0,0.000000,# 'items' annotations that isn't in a 'contains' annotation
0.000000,0,0.000000,my $max_index_annotation_keyword = $state->{spec_version} eq 'draft2019-09' ? 'items' : 'prefixItems';
0.000000,0,0.000000,my $last_index = max(-1, grep is_type('integer', $_),
0.000000,0,0.000000,map +($_->{keyword} eq $max_index_annotation_keyword ? $_->{annotation} : ()), @annotations);
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if $last_index == $data->$#*;
0.000000,0,0.000000,
0.000000,0,0.000000,my @contains_annotation_indexes = $state->{spec_version} eq 'draft2019-09' ? ()
0.000000,0,0.000000,: map +($_->{keyword} eq 'contains' ? $_->{annotation}->@* : ()), @annotations;
0.000000,0,0.000000,
0.000000,0,0.000000,my $valid = 1;
0.000000,0,0.000000,foreach my $idx ($last_index+1 .. $data->$#*) {
0.000000,0,0.000000,next if any { $idx == $_ } @contains_annotation_indexes;
0.000000,0,0.000000,if (is_type('boolean', $schema->{unevaluatedItems})) {
0.000000,0,0.000000,next if $schema->{unevaluatedItems};
0.000000,0,0.000000,$valid = E({ %$state, data_path => $state->{data_path}.'/'.$idx },
0.000000,0,0.000000,'additional item not permitted')
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($self->eval($data->[$idx], $schema->{unevaluatedItems},
0.000000,0,0.000000,+{ %$state, data_path => $state->{data_path}.'/'.$idx,
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/unevaluatedItems',
0.000000,0,0.000000,collect_annotations => $state->{collect_annotations} & ~1 })) {
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,A($state, true);
0.000000,0,0.000000,return E($state, 'subschema is not valid against all additional items') if not $valid;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000105,616,0.000000,sub _traverse_keyword_unevaluatedProperties ($self, $schema, $state) {
0.000743,154,0.000005,$self->traverse_subschema($schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.003366,18710,0.000000,sub _eval_keyword_unevaluatedProperties ($self, $data, $schema, $state) {
0.000000,0,0.000000,abort($state, 'EXCEPTION: "unevaluatedProperties" keyword present, but annotation collection is disabled')
0.001690,3742,0.000000,if not $state->{collect_annotations};
0.000000,0,0.000000,
0.000000,0,0.000000,abort($state, 'EXCEPTION: "unevaluatedProperties" keyword present, but short_circuit is enabled: results unreliable')
0.001464,3742,0.000000,if $state->{short_circuit};
0.000000,0,0.000000,
0.004193,3742,0.000001,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,my @evaluated_properties = map {
0.010809,12729,0.000001,my $keyword = $_->{keyword};
0.000000,0,0.000000,(grep $keyword eq $_, qw(properties additionalProperties patternProperties unevaluatedProperties))
0.009065,8987,0.000001,? $_->{annotation}->@* : ();
0.000000,0,0.000000,} local_annotations($state);
0.000000,0,0.000000,
0.000691,3742,0.000000,my $valid = 1;
0.000671,3742,0.000000,my @properties;
0.026778,3742,0.000007,foreach my $property (sort keys %$data) {
0.037485,54182,0.000001,next if any { $_ eq $property } @evaluated_properties;
0.000000,0,0.000000,push @properties, $property;
0.000000,0,0.000000,
0.000000,0,0.000000,if (is_type('boolean', $schema->{unevaluatedProperties})) {
0.000000,0,0.000000,next if $schema->{unevaluatedProperties};
0.000000,0,0.000000,$valid = E({ %$state, data_path => jsonp($state->{data_path}, $property) },
0.000000,0,0.000000,'additional property not permitted');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($self->eval($data->{$property}, $schema->{unevaluatedProperties},
0.000000,0,0.000000,+{ %$state, data_path => jsonp($state->{data_path}, $property),
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/unevaluatedProperties',
0.000000,0,0.000000,collect_annotations => $state->{collect_annotations} & ~1 })) {
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.003377,3742,0.000001,A($state, \@properties);
0.000834,3742,0.000000,return E($state, 'not all additional properties are valid') if not $valid;
0.043496,3742,0.000012,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000010,1,0.000010,1;
0.000030,1,0.000030,__END__
