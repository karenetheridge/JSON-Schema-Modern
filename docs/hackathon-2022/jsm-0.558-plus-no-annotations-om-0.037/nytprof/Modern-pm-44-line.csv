# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000017,2,0.000008,use strict;
0.000041,2,0.000021,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Validate data against a schema
0.000000,0,0.000000,# KEYWORDS: JSON Schema validator data validation structure specification
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.559';
0.000000,0,0.000000,
0.000022,2,0.000011,use 5.020;  # for fc, unicode_strings features
0.000021,2,0.000010,use Moo;
0.000025,3,0.000008,use strictures 2;
0.000027,2,0.000013,use experimental qw(signatures postderef);
0.000022,2,0.000011,use if "$]" >= 5.022, experimental => 're_strict';
0.000016,2,0.000008,no if "$]" >= 5.031009, feature => 'indirect';
0.000014,2,0.000007,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000015,2,0.000007,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.001218,2,0.000609,use JSON::MaybeXS;
0.000023,2,0.000012,use Carp qw(croak carp);
0.000029,3,0.000010,use List::Util 1.55 qw(pairs first uniqint pairmap uniq any);
0.000024,3,0.000008,use Ref::Util 0.100 qw(is_ref is_plain_hashref);
0.000012,2,0.000006,use Scalar::Util 'refaddr';
0.001652,2,0.000826,use Mojo::URL;
0.000019,2,0.000010,use Safe::Isa;
0.001016,2,0.000508,use Path::Tiny;
0.000020,2,0.000010,use Storable 'dclone';
0.001533,2,0.000766,use File::ShareDir 'dist_dir';
0.001822,2,0.000911,use Module::Runtime qw(use_module require_module);
0.001134,3,0.000378,use MooX::TypeTiny 0.002002;
0.001140,2,0.000570,use MooX::HandlesVia;
0.001331,3,0.000444,use Types::Standard 1.016003 qw(Bool Int Str HasMethods Enum InstanceOf HashRef Dict CodeRef Optional Slurpy ArrayRef Undef ClassName Tuple Map);
0.000020,2,0.000010,use Feature::Compat::Try;
0.000546,2,0.000273,use JSON::Schema::Modern::Error;
0.000634,2,0.000317,use JSON::Schema::Modern::Result;
0.000367,2,0.000184,use JSON::Schema::Modern::Document;
0.000583,2,0.000292,use JSON::Schema::Modern::Utilities qw(get_type canonical_uri E abort annotate_self);
0.000083,2,0.000041,use namespace::clean;
0.000000,0,0.000000,
0.000003,1,0.000003,our @CARP_NOT = qw(
0.000000,0,0.000000,JSON::Schema::Modern::Document
0.000000,0,0.000000,JSON::Schema::Modern::Vocabulary
0.000000,0,0.000000,JSON::Schema::Modern::Vocabulary::Applicator
0.000000,0,0.000000,OpenAPI::Modern
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000034,2,0.000017,use constant SPECIFICATION_VERSION_DEFAULT => 'draft2020-12';
0.003839,2,0.001919,use constant SPECIFICATION_VERSIONS_SUPPORTED => [qw(draft7 draft2019-09 draft2020-12)];
0.000000,0,0.000000,
0.000000,0,0.000000,has specification_version => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Enum(SPECIFICATION_VERSIONS_SUPPORTED),
0.000000,0,0.000000,coerce => sub {
0.000000,0,0.000000,return $_[0] if any { $_[0] eq $_ } SPECIFICATION_VERSIONS_SUPPORTED->@*;
0.000000,0,0.000000,my $real = 'draft'.($_[0]//'');
0.000000,0,0.000000,(any { $real eq $_ } SPECIFICATION_VERSIONS_SUPPORTED->@*) ? $real : $_[0];
0.000000,0,0.000000,},
0.000007,1,0.000007,);
0.000000,0,0.000000,
0.000016,1,0.000016,has output_format => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Enum(JSON::Schema::Modern::Result->OUTPUT_FORMATS),
0.000000,0,0.000000,default => 'basic',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,has short_circuit => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Bool,
0.000000,0,0.000000,lazy => 1,
0.000054,1,0.000054,default => sub { $_[0]->output_format eq 'flag' && !$_[0]->collect_annotations },
0.000004,1,0.000004,);
0.000000,0,0.000000,
0.000002,1,0.000002,has max_traversal_depth => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Int,
0.000000,0,0.000000,default => 50,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000002,1,0.000002,has validate_formats => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Bool,
0.000000,0,0.000000,default => 0, # as specified by https://json-schema.org/draft/<version>/schema#/$vocabulary
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,has validate_content_schemas => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Bool,
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,# defaults to false in latest versions, as specified by
0.000000,0,0.000000,# https://json-schema.org/draft/2020-12/json-schema-validation.html#rfc.section.8.2
0.000004,1,0.000004,default => sub { ($_[0]->specification_version//'') eq 'draft7' },
0.000004,1,0.000004,);
0.000000,0,0.000000,
0.000000,1,0.000000,has collect_annotations => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Bool,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000003,1,0.000003,has scalarref_booleans => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Bool,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000001,1,0.000001,has strict => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Bool,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,has _format_validations => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => my $format_type = Dict[
0.000000,0,0.000000,(map +($_ => Optional[CodeRef]), qw(date-time date time duration email idn-email hostname idn-hostname ipv4 ipv6 uri uri-reference iri iri-reference uuid uri-template json-pointer relative-json-pointer regex)),
0.000000,0,0.000000,Slurpy[HashRef[Dict[type => Enum[qw(null object array boolean string number integer)], sub => CodeRef]]],
0.000000,0,0.000000,],
0.000000,0,0.000000,init_arg => 'format_validations',
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,_get_format_validation => 'get',
0.000000,0,0.000000,add_format_validation => 'set',
0.000000,0,0.000000,},
0.000000,0,0.000000,lazy => 1,
0.000002,1,0.000002,default => sub { {} },
0.000043,1,0.000043,);
0.000000,0,0.000000,
0.000050,5,0.000010,before add_format_validation => sub ($self, @kvs) { $format_type->({ @$_ }) foreach pairs @kvs };
0.000000,0,0.000000,
0.000001,4,0.000000,around BUILDARGS => sub ($orig, $class, @args) {
0.000002,1,0.000002,my $args = $class->$orig(@args);
0.000000,0,0.000000,croak 'output_format: strict_basic can only be used with specification_version: draft2019-09'
0.000000,0,0.000000,if ($args->{output_format}//'') eq 'strict_basic'
0.000001,1,0.000001,and ($args->{specification_version}//'') ne 'draft2019-09';
0.000000,0,0.000000,
0.000002,1,0.000002,return $args;
0.000004,1,0.000004,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_schema {
0.000007,9,0.000001,croak 'insufficient arguments' if @_ < 2;
0.000013,9,0.000001,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: resolve $uri against $self->base_uri
0.000053,9,0.000006,my $uri = !is_ref($_[0]) ? Mojo::URL->new(shift)
0.000000,0,0.000000,: $_[0]->$_isa('Mojo::URL') ? shift : Mojo::URL->new;
0.000000,0,0.000000,
0.000007,9,0.000001,croak 'cannot add a schema with a uri with a fragment' if defined $uri->fragment;
0.000000,0,0.000000,
0.000009,9,0.000001,if (not @_) {
0.000000,0,0.000000,my $schema_info = $self->_fetch_from_uri($uri);
0.000000,0,0.000000,return if not $schema_info or not defined wantarray;
0.000000,0,0.000000,return $schema_info->{document};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# document BUILD will trigger $self->traverse($schema)
0.000107,9,0.000012,my $document = $_[0]->$_isa('JSON::Schema::Modern::Document') ? shift
0.000000,0,0.000000,: JSON::Schema::Modern::Document->new(
0.000000,0,0.000000,schema => shift,
0.000000,0,0.000000,$uri ? (canonical_uri => $uri) : (),
0.000000,0,0.000000,evaluator => $self,  # used mainly for traversal during document construction
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000048,9,0.000005,if ($document->has_errors) {
0.000000,0,0.000000,my $result = JSON::Schema::Modern::Result->new(
0.000000,0,0.000000,output_format => $self->output_format,
0.000000,0,0.000000,valid => 0,
0.000000,0,0.000000,errors => [ $document->errors ],
0.000000,0,0.000000,exception => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,die $result;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000333,9,0.000037,if (not grep refaddr($_->{document}) == refaddr($document), $self->_canonical_resources) {
0.008414,7,0.001202,my $schema_content = $document->_serialized_schema
0.000000,0,0.000000,// $document->_serialized_schema($self->_json_decoder->encode($document->schema));
0.000000,0,0.000000,
0.000178,7,0.000025,if (my $existing_doc = first {
0.000183,29,0.000006,my $existing_content = $_->_serialized_schema
0.000000,0,0.000000,// $_->_serialized_schema($self->_json_decoder->encode($_->schema));
0.000020,29,0.000001,$existing_content eq $schema_content
0.000000,0,0.000000,} uniqint map $_->{document}, $self->_canonical_resources) {
0.000000,0,0.000000,# we already have this schema content in another document object.
0.000000,0,0.000000,$document = $existing_doc;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000692,7,0.000099,$self->_add_resources(map +($_->[0] => +{ $_->[1]->%*, document => $document }),
0.000000,0,0.000000,$document->resource_pairs);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000061,9,0.000007,if ("$uri") {
0.000029,8,0.000004,my $resource = $document->_get_resource($document->canonical_uri);
0.000000,0,0.000000,$self->_add_resources($uri => {
0.000000,0,0.000000,path => '',
0.000000,0,0.000000,canonical_uri => $document->canonical_uri,
0.000000,0,0.000000,specification_version => $resource->{specification_version},
0.000000,0,0.000000,vocabularies => $resource->{vocabularies},  # reference, not copy
0.000000,0,0.000000,document => $document,
0.000000,0,0.000000,configs => $resource->{configs},
0.000050,8,0.000006,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000052,9,0.000006,return $document;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub evaluate_json_string ($self, $json_data, $schema, $config_override = {}) {
0.000000,0,0.000000,croak 'evaluate_json_string called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,my $data;
0.000000,0,0.000000,try {
0.000000,0,0.000000,$data = $self->_json_decoder->decode($json_data)
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,return JSON::Schema::Modern::Result->new(
0.000000,0,0.000000,output_format => $self->output_format,
0.000000,0,0.000000,valid => 0,
0.000000,0,0.000000,exception => 1,
0.000000,0,0.000000,errors => [
0.000000,0,0.000000,JSON::Schema::Modern::Error->new(
0.000000,0,0.000000,keyword => undef,
0.000000,0,0.000000,instance_location => '',
0.000000,0,0.000000,keyword_location => '',
0.000000,0,0.000000,error => $e,
0.000000,0,0.000000,)
0.000000,0,0.000000,],
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->evaluate($data, $schema, $config_override);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# this is called whenever we need to walk a document for something.
0.000000,0,0.000000,# for now it is just called when a ::Document object is created, to verify the integrity of the
0.000000,0,0.000000,# schema structure, to identify the metaschema (via the $schema keyword), and to extract all
0.000000,0,0.000000,# embedded resources via $id and $anchor keywords within.
0.000000,0,0.000000,# Returns the internal $state object accumulated during the traversal.
0.000673,2964,0.000000,sub traverse ($self, $schema_reference, $config_override = {}) {
0.000000,0,0.000000,# Note: the starting position is not guaranteed to be at the root of the $document.
0.001201,741,0.000002,my $initial_uri = Mojo::URL->new($config_override->{initial_schema_uri} // '');
0.000598,741,0.000001,my $initial_path = $config_override->{traversed_schema_path} // '';
0.002224,741,0.000003,my $spec_version = $self->specification_version//SPECIFICATION_VERSION_DEFAULT;
0.000000,0,0.000000,
0.000000,0,0.000000,my $state = {
0.000000,0,0.000000,depth => 0,
0.000000,0,0.000000,data_path => '',                        # this never changes since we don't have an instance yet
0.000000,0,0.000000,initial_schema_uri => $initial_uri,     # the canonical URI as of the start of this method, or last $id
0.000000,0,0.000000,traversed_schema_path => $initial_path, # the accumulated traversal path as of the start, or last $id
0.000000,0,0.000000,schema_path => '',                      # the rest of the path, since the start of this method, or last $id
0.000000,0,0.000000,effective_base_uri => Mojo::URL->new(''),
0.000000,0,0.000000,errors => [],
0.000000,0,0.000000,identifiers => [],
0.000000,0,0.000000,configs => {},
0.000000,0,0.000000,callbacks => $config_override->{callbacks} // {},
0.005078,741,0.000007,evaluator => $self,
0.000000,0,0.000000,traverse => 1,
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000375,741,0.000001,try {
0.000000,0,0.000000,my $for_canonical_uri = Mojo::URL->new(
0.000000,0,0.000000,(is_plain_hashref($schema_reference) && exists $schema_reference->{'$id'}
0.000000,0,0.000000,? Mojo::URL->new($schema_reference->{'$id'}) : undef)
0.001467,741,0.000002,// $state->{initial_schema_uri});
0.000729,741,0.000001,$for_canonical_uri->fragment(undef) if not length $for_canonical_uri->fragment;
0.000000,0,0.000000,
0.000000,0,0.000000,# a subsequent "$schema" keyword can still change these values
0.000000,0,0.000000,$state->@{qw(spec_version vocabularies)} = $self->_get_metaschema_info(
0.004609,741,0.000006,$config_override->{metaschema_uri} // $self->METASCHEMA_URIS->{$spec_version},
0.000000,0,0.000000,$for_canonical_uri,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,if ($e->$_isa('JSON::Schema::Modern::Result')) {
0.000000,0,0.000000,push $state->{errors}->@*, $e->errors;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($e->$_isa('JSON::Schema::Modern::Error')) {
0.000000,0,0.000000,push $state->{errors}->@*, $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,()= E({ %$state, exception => 1 }, 'EXCEPTION: '.$e);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000307,741,0.000000,try {
0.001754,741,0.000002,$self->_traverse_subschema($schema_reference, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,if ($e->$_isa('JSON::Schema::Modern::Error')) {
0.000000,0,0.000000,# note: we should never be here, since traversal subs are no longer be fatal
0.000000,0,0.000000,push $state->{errors}->@*, $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,E({ %$state, exception => 1 }, 'EXCEPTION: '.$e);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000391,741,0.000001,delete $state->{traverse};
0.002465,741,0.000003,return $state;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# the actual runtime evaluation of the schema against input data.
0.000000,5,0.000000,sub evaluate ($self, $data, $schema_reference, $config_override = {}) {
0.000001,1,0.000001,croak 'evaluate called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000001,1,0.000001,my $initial_path = $config_override->{traversed_schema_path} // '';
0.000001,1,0.000001,my $effective_base_uri = Mojo::URL->new($config_override->{effective_base_uri}//'');
0.000000,0,0.000000,
0.000000,0,0.000000,my $state = {
0.000004,1,0.000004,data_path => $config_override->{data_path} // '',
0.000000,0,0.000000,traversed_schema_path => $initial_path, # the accumulated path as of the start of evaluation, or last $id or $ref
0.000000,0,0.000000,initial_schema_uri => Mojo::URL->new,   # the canonical URI as of the start of evaluation, or last $id or $ref
0.000000,0,0.000000,schema_path => '',                  # the rest of the path, since the start of evaluation, or last $id or $ref
0.000000,0,0.000000,effective_base_uri => $effective_base_uri, # resolve locations against this for errors and annotations
0.000000,0,0.000000,errors => [],
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,exists $config_override->{$_} and die $_.' not supported as a config override'
0.000001,1,0.000001,foreach qw(output_format specification_version);
0.000000,0,0.000000,
0.000000,1,0.000000,my $valid;
0.000000,1,0.000000,try {
0.000000,1,0.000000,my $schema_info;
0.000000,0,0.000000,
0.000003,1,0.000003,if (not is_ref($schema_reference) or $schema_reference->$_isa('Mojo::URL')) {
0.000001,1,0.000001,$schema_info = $self->_fetch_from_uri($schema_reference);
0.000001,1,0.000001,$state->{initial_schema_uri} = Mojo::URL->new($config_override->{initial_schema_uri} // '');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# traverse is called via add_schema -> ::Document->new -> ::Document->BUILD
0.000000,0,0.000000,my $document = $self->add_schema('', $schema_reference);
0.000000,0,0.000000,my $base_resource = $document->_get_resource($document->canonical_uri)
0.000000,0,0.000000,|| croak "couldn't get resource: document parse error";
0.000000,0,0.000000,
0.000000,0,0.000000,$schema_info = {
0.000000,0,0.000000,schema => $document->schema,
0.000000,0,0.000000,document => $document,
0.000000,0,0.000000,document_path => '',
0.000000,0,0.000000,$base_resource->%{qw(canonical_uri specification_version vocabularies configs)},
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,abort($state, 'EXCEPTION: unable to find resource %s', $schema_reference)
0.000000,0,0.000000,if not $schema_info;
0.000000,0,0.000000,
0.000000,0,0.000000,$state = +{
0.000000,0,0.000000,%$state,
0.000000,0,0.000000,depth => 0,
0.000000,0,0.000000,initial_schema_uri => $schema_info->{canonical_uri}, # the canonical URI as of the start of evaluation, or last $id or $ref
0.000000,0,0.000000,document => $schema_info->{document},   # the ::Document object containing this schema
0.000000,0,0.000000,document_path => $schema_info->{document_path}, # the path within the document of this schema, as of the start of evaluation, or last $id or $ref
0.000000,0,0.000000,dynamic_scope => [ $schema_info->{canonical_uri} ],
0.000000,0,0.000000,annotations => [],
0.000000,0,0.000000,seen => {},
0.000000,0,0.000000,spec_version => $schema_info->{specification_version},
0.000000,0,0.000000,vocabularies => $schema_info->{vocabularies},
0.000000,0,0.000000,callbacks => $config_override->{callbacks} // {},
0.000000,0,0.000000,evaluator => $self,
0.000000,0,0.000000,$schema_info->{configs}->%*,
0.000000,0,0.000000,(map {
0.000027,7,0.000004,my $val = $config_override->{$_} // $self->$_;
0.000002,6,0.000000,defined $val ? ( $_ => $val ) : ()
0.000000,0,0.000000,} qw(validate_formats validate_content_schemas short_circuit collect_annotations scalarref_booleans strict)),
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000001,1,0.000001,if ($state->{validate_formats}) {
0.000000,0,0.000000,$state->{vocabularies} = [
0.000000,0,0.000000,map s/^JSON::Schema::Modern::Vocabulary::Format\KAnnotation$/Assertion/r, $state->{vocabularies}->@*
0.000011,1,0.000011,];
0.000000,1,0.000000,require JSON::Schema::Modern::Vocabulary::FormatAssertion;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# we're going to set collect_annotations during evaluation when we see an unevaluated* keyword,
0.000000,0,0.000000,# but after we pass to a new data scope we'll clear it again.. unless we've got the config set
0.000000,0,0.000000,# globally for the entire evaluation, so we store that value in a high bit.
0.000001,1,0.000001,$state->{collect_annotations} = ($state->{collect_annotations}//0) << 8;
0.000000,0,0.000000,
0.000014,1,0.000014,$valid = $self->_eval_subschema($data, $schema_info->{schema}, $state);
0.000018,1,0.000018,warn 'result is false but there are no errors' if not $valid and not $state->{errors}->@*;
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,if ($e->$_isa('JSON::Schema::Modern::Result')) {
0.000000,0,0.000000,return $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($e->$_isa('JSON::Schema::Modern::Error')) {
0.000000,0,0.000000,push $state->{errors}->@*, $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$valid = E({ %$state, exception => 1 }, 'EXCEPTION: '.$e);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000012,1,0.000012,die 'evaluate validity inconstent with error count' if $valid xor !$state->{errors}->@*;
0.000000,0,0.000000,
0.000000,0,0.000000,return JSON::Schema::Modern::Result->new(
0.000000,0,0.000000,output_format => $self->output_format,
0.000000,0,0.000000,valid => $valid,
0.000000,0,0.000000,$valid
0.000000,0,0.000000,# strip annotations from result if user didn't explicitly ask for them
0.000000,0,0.000000,? ($config_override->{collect_annotations} // $self->collect_annotations
0.000000,0,0.000000,? (annotations => $state->{annotations}) : ())
0.149166,1,0.149166,: (errors => $state->{errors}),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub validate_schema ($self, $schema, $config_override = {}) {
0.000000,0,0.000000,croak 'validate_schema called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,my $metaschema_uri = is_plain_hashref($schema) && $schema->{'$schema'} ? $schema->{'$schema'}
0.000000,0,0.000000,: $self->METASCHEMA_URIS->{$self->specification_version // $self->SPECIFICATION_VERSION_DEFAULT};
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->evaluate($schema, $metaschema_uri, $config_override);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get ($self, $uri) {
0.000000,0,0.000000,my $schema_info = $self->_fetch_from_uri($uri);
0.000000,0,0.000000,return if not $schema_info;
0.000000,0,0.000000,my $subschema = is_ref($schema_info->{schema}) ? dclone($schema_info->{schema}) : $schema_info->{schema};
0.000000,0,0.000000,return wantarray ? ($subschema, $schema_info->{canonical_uri}) : $subschema;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# defined lower down:
0.000000,0,0.000000,# sub add_vocabulary { ... }
0.000000,0,0.000000,# sub add_encoding { ... }
0.000000,0,0.000000,# sub add_media_type { ... }
0.000000,0,0.000000,
0.000000,0,0.000000,######## NO PUBLIC INTERFACES FOLLOW THIS POINT ########
0.000000,0,0.000000,
0.000000,0,0.000000,# current spec version => { keyword => undef, or arrayref of alternatives }
0.000009,1,0.000009,my %removed_keywords = (
0.000000,0,0.000000,'draft7' => {
0.000000,0,0.000000,id => [ '$id' ],
0.000000,0,0.000000,},
0.000000,0,0.000000,'draft2019-09' => {
0.000000,0,0.000000,id => [ '$id' ],
0.000000,0,0.000000,definitions => [ '$defs' ],
0.000000,0,0.000000,dependencies => [ qw(dependentSchemas dependentRequired) ],
0.000000,0,0.000000,},
0.000000,0,0.000000,'draft2020-12' => {
0.000000,0,0.000000,id => [ '$id' ],
0.000000,0,0.000000,definitions => [ '$defs' ],
0.000000,0,0.000000,dependencies => [ qw(dependentSchemas dependentRequired) ],
0.000000,0,0.000000,'$recursiveAnchor' => [ '$dynamicAnchor' ],
0.000000,0,0.000000,'$recursiveRef' => [ '$dynamicRef' ],
0.000000,0,0.000000,additionalItems => [ 'items' ],
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# {
0.000000,0,0.000000,#   $spec_version => {
0.000000,0,0.000000,#     $vocabulary_class => {
0.000000,0,0.000000,#       traverse => [ [ $keyword => $subref ], [ ... ] ],
0.000000,0,0.000000,#       evaluate => [ [ $keyword => $subref ], [ ... ] ],
0.000000,0,0.000000,#     }
0.000000,0,0.000000,#   }
0.000000,0,0.000000,# }
0.000000,0,0.000000,# If we could serialize coderefs, this could be an object attribute;
0.000000,0,0.000000,# otherwise, we might as well persist this for the lifetime of the process.
0.000000,1,0.000000,our $vocabulary_cache = {};
0.000000,0,0.000000,
0.001657,11332,0.000000,sub _traverse_subschema ($self, $schema, $state) {
0.000951,2833,0.000000,delete $state->{keyword};
0.000000,0,0.000000,
0.000000,0,0.000000,return E($state, 'EXCEPTION: maximum traversal depth exceeded')
0.003333,2833,0.000001,if $state->{depth}++ > $self->max_traversal_depth;
0.000000,0,0.000000,
0.003266,2833,0.000001,my $schema_type = get_type($schema);
0.001233,2833,0.000000,return 1 if $schema_type eq 'boolean';
0.000000,0,0.000000,
0.000623,2463,0.000000,return E($state, 'invalid schema type: %s', $schema_type) if $schema_type ne 'object';
0.000000,0,0.000000,
0.001009,2463,0.000000,return 1 if not keys %$schema;
0.000000,0,0.000000,
0.000406,2460,0.000000,my $valid = 1;
0.007696,2460,0.000003,my %unknown_keywords = map +($_ => undef), keys %$schema;
0.000000,0,0.000000,# we must check the array length on every iteration because some keywords can change it!
0.009213,2460,0.000004,for (my $idx = 0; $idx <= $state->{vocabularies}->$#*; ++$idx) {
0.005205,19210,0.000000,my $vocabulary = $state->{vocabularies}[$idx];
0.000000,0,0.000000,
0.000000,0,0.000000,# [ [ $keyword => $subref ], [ ... ] ]
0.000000,0,0.000000,my $keyword_list = $vocabulary_cache->{$state->{spec_version}}{$vocabulary}{traverse} //= [
0.000000,0,0.000000,map [ $_ => $vocabulary->can('_traverse_keyword_'.($_ =~ s/^\$//r)) ],
0.000000,0,0.000000,$vocabulary->keywords($state->{spec_version})
0.009897,19210,0.000001,];
0.000000,0,0.000000,
0.021862,19210,0.000001,foreach my $keyword_tuple ($keyword_list->@*) {
0.028757,148180,0.000000,my ($keyword, $sub) = $keyword_tuple->@*;
0.022371,148180,0.000000,next if not exists $schema->{$keyword};
0.000000,0,0.000000,
0.000000,0,0.000000,# keywords adjacent to $ref are not evaluated before draft2019-09
0.001522,4325,0.000000,next if $keyword ne '$ref' and exists $schema->{'$ref'} and $state->{spec_version} eq 'draft7';
0.000000,0,0.000000,
0.001143,4325,0.000000,delete $unknown_keywords{$keyword};
0.001190,4325,0.000000,$state->{keyword} = $keyword;
0.000000,0,0.000000,
0.006030,4325,0.000001,if (not $sub->($vocabulary, $schema, $state)) {
0.000000,0,0.000000,die 'traverse returned false but we have no errors' if not $state->{errors}->@*;
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002840,4325,0.000001,if (my $callback = $state->{callbacks}{$keyword}) {
0.000000,0,0.000000,$callback->($schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000788,2460,0.000000,delete $state->{keyword};
0.000000,0,0.000000,
0.003500,2460,0.000001,if ($self->strict and keys %unknown_keywords) {
0.000000,0,0.000000,()= E($state, 'unknown keyword%s found: %s', keys %unknown_keywords > 1 ? 's' : '',
0.000000,0,0.000000,join(', ', sort keys %unknown_keywords));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# check for previously-supported but now removed keywords
0.010930,2460,0.000004,foreach my $keyword (sort keys $removed_keywords{$state->{spec_version}}->%*) {
0.001676,14760,0.000000,next if not exists $schema->{$keyword};
0.000000,0,0.000000,my $message ='no-longer-supported "'.$keyword.'" keyword present (at location "'
0.000000,0,0.000000,.canonical_uri($state).'")';
0.000000,0,0.000000,if (my $alternates = $removed_keywords{$state->{spec_version}}->{$keyword}) {
0.000000,0,0.000000,my @list = map '"'.$_.'"', @$alternates;
0.000000,0,0.000000,@list = ((map $_.',', @list[0..$#list-1]), $list[-1]) if @list > 2;
0.000000,0,0.000000,splice(@list, -1, 0, 'or') if @list > 1;
0.000000,0,0.000000,$message .= ': this should be rewritten as '.join(' ', @list);
0.000000,0,0.000000,}
0.000000,0,0.000000,carp $message;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.004690,2460,0.000002,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.059554,453885,0.000000,sub _eval_subschema ($self, $data, $schema, $state) {
0.020549,90777,0.000000,croak '_eval_subschema called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,# callers created a new $state for us, so we do not propagate upwards changes to depth, traversed
0.000000,0,0.000000,# paths; but annotations, errors are arrayrefs so their contents will be shared
0.078092,90777,0.000001,$state->{dynamic_scope} = [ ($state->{dynamic_scope}//[])->@* ];
2.050594,90777,0.000023,delete $state->@{'keyword', grep /^_/, keys %$state};
0.000000,0,0.000000,
0.000000,0,0.000000,abort($state, 'EXCEPTION: maximum evaluation depth exceeded')
0.137082,90777,0.000002,if $state->{depth}++ > $self->max_traversal_depth;
0.000000,0,0.000000,
0.097730,90777,0.000001,my $schema_type = get_type($schema);
0.024655,90777,0.000000,return $schema || E($state, 'subschema is false') if $schema_type eq 'boolean';
0.000000,0,0.000000,
0.000000,0,0.000000,# this should never happen, due to checks in traverse
0.022668,90777,0.000000,abort($state, 'invalid schema type: %s', $schema_type) if $schema_type ne 'object';
0.000000,0,0.000000,
0.027894,90777,0.000000,return 1 if not keys %$schema;
0.000000,0,0.000000,
0.000000,0,0.000000,# find all schema locations in effect at this data path + canonical_uri combination
0.000000,0,0.000000,# if any of them are absolute prefix of this schema location, we are in a loop.
0.077943,90777,0.000001,my $canonical_uri = canonical_uri($state);
0.039587,90777,0.000000,my $schema_location = $state->{traversed_schema_path}.$state->{schema_path};
0.000000,0,0.000000,abort($state, 'EXCEPTION: infinite loop detected (same location evaluated twice)')
0.000000,0,0.000000,if grep substr($schema_location, 0, length) eq $_,
0.343309,90777,0.000004,keys $state->{seen}{$state->{data_path}}{$canonical_uri}->%*;
0.265688,90777,0.000003,$state->{seen}{$state->{data_path}}{$canonical_uri}{$schema_location}++;
0.000000,0,0.000000,
0.022731,90777,0.000000,my $valid = 1;
0.262695,90777,0.000003,my %unknown_keywords = map +($_ => undef), keys %$schema;
0.031737,90777,0.000000,my $orig_annotations = $state->{annotations};
0.028036,90777,0.000000,$state->{annotations} = [];
0.014519,90777,0.000000,my @new_annotations;
0.000000,0,0.000000,
0.000000,0,0.000000,# in order to collect annotations from applicator keywords only when needed, we twiddle the low
0.000000,0,0.000000,# bit if we see a local unevaluated* keyword, and clear it again as we move on to a new data path.
0.062822,90777,0.000001,$state->{collect_annotations} |= 0+(exists $schema->{unevaluatedItems} || exists $schema->{unevaluatedProperties});
0.000000,0,0.000000,
0.000000,0,0.000000,ALL_KEYWORDS:
0.062841,90777,0.000001,foreach my $vocabulary ($state->{vocabularies}->@*) {
0.000000,0,0.000000,# [ [ $keyword => $subref|undef ], [ ... ] ]
0.000000,0,0.000000,my $keyword_list = $vocabulary_cache->{$state->{spec_version}}{$vocabulary}{evaluate} //= [
0.000000,0,0.000000,map [ $_ => $vocabulary->can('_eval_keyword_'.($_ =~ s/^\$//r)) ],
0.000000,0,0.000000,$vocabulary->keywords($state->{spec_version})
0.350474,631747,0.000001,];
0.000000,0,0.000000,
0.804834,631747,0.000001,foreach my $keyword_tuple ($keyword_list->@*) {
1.023768,5.16137e+06,0.000000,my ($keyword, $sub) = $keyword_tuple->@*;
0.794901,5.16137e+06,0.000000,next if not exists $schema->{$keyword};
0.000000,0,0.000000,
0.000000,0,0.000000,# keywords adjacent to $ref are not evaluated before draft2019-09
0.076435,304999,0.000000,next if $keyword ne '$ref' and exists $schema->{'$ref'} and $state->{spec_version} eq 'draft7';
0.000000,0,0.000000,
0.076555,304999,0.000000,delete $unknown_keywords{$keyword};
0.073511,304999,0.000000,$state->{keyword} = $keyword;
0.000000,0,0.000000,
0.069563,304999,0.000000,if ($sub) {
0.050952,200548,0.000000,my $error_count = $state->{errors}->@*;
0.000000,0,0.000000,
0.300929,200548,0.000002,if (not $sub->($vocabulary, $data, $schema, $state)) {
0.000000,0,0.000000,warn 'result is false but there are no errors (keyword: '.$keyword.')'
0.002354,4262,0.000001,if $error_count == $state->{errors}->@*;
0.001074,4262,0.000000,$valid = 0;
0.000000,0,0.000000,
0.002280,4262,0.000001,last ALL_KEYWORDS if $state->{short_circuit};
0.002085,3339,0.000001,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.169046,300737,0.000001,if (my $callback = $state->{callbacks}{$keyword}) {
0.000000,0,0.000000,$callback->($data, $schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.230580,300737,0.000001,push @new_annotations, $state->{annotations}->@[$#new_annotations+1 .. $state->{annotations}->$#*];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.043674,90777,0.000000,delete $state->{keyword};
0.000000,0,0.000000,
0.022370,90777,0.000000,if ($state->{strict} and keys %unknown_keywords) {
0.000000,0,0.000000,abort($state, 'unknown keyword%s found: %s', keys %unknown_keywords > 1 ? 's' : '',
0.000000,0,0.000000,join(', ', sort keys %unknown_keywords));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.037113,90777,0.000000,$state->{annotations} = $orig_annotations;
0.000000,0,0.000000,
0.034943,90777,0.000000,if ($valid) {
0.038476,86515,0.000000,push $state->{annotations}->@*, @new_annotations;
0.137075,86515,0.000002,if ($state->{collect_annotations} and $state->{spec_version} !~ qr/^draft(7|2019-09)$/) {
0.000000,0,0.000000,annotate_self(+{ %$state, keyword => $_, _unknown => 1 }, $schema)
0.000000,0,0.000000,foreach sort keys %unknown_keywords;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.385084,90777,0.000004,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,has _resource_index => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => HashRef[my $resource_type = Dict[
0.000000,0,0.000000,canonical_uri => InstanceOf['Mojo::URL'],
0.000000,0,0.000000,path => Str,
0.000000,0,0.000000,specification_version => my $spec_version_type = Enum(SPECIFICATION_VERSIONS_SUPPORTED),
0.000000,0,0.000000,document => InstanceOf['JSON::Schema::Modern::Document'],
0.000000,0,0.000000,# the vocabularies used when evaluating instance data against schema
0.000000,0,0.000000,vocabularies => ArrayRef[my $vocabulary_class_type = ClassName->where(q{$_->DOES('JSON::Schema::Modern::Vocabulary')})],
0.000000,0,0.000000,configs => HashRef,
0.000000,0,0.000000,Slurpy[HashRef[Undef]],  # no other fields allowed
0.000000,0,0.000000,]],
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,_add_resources => 'set',
0.000000,0,0.000000,_get_resource => 'get',
0.000000,0,0.000000,_remove_resource => 'delete',
0.000000,0,0.000000,_resource_index => 'elements',
0.000000,0,0.000000,_resource_keys => 'keys',
0.000000,0,0.000000,_add_resources_unsafe => 'set',
0.000000,0,0.000000,_canonical_resources => 'values',
0.000000,0,0.000000,_resource_exists => 'exists',
0.000000,0,0.000000,},
0.000000,0,0.000000,lazy => 1,
0.000003,1,0.000003,default => sub { {} },
0.000041,1,0.000041,);
0.000000,0,0.000000,
0.000000,0,0.000000,around _add_resources => sub {
0.000017,15,0.000001,my ($orig, $self) = (shift, shift);
0.000000,0,0.000000,
0.000006,15,0.000000,my @resources;
0.000176,15,0.000012,foreach my $pair (sort { $a->[0] cmp $b->[0] } pairs @_) {
0.000011,24,0.000000,my ($key, $value) = @$pair;
0.000000,0,0.000000,
0.000140,24,0.000006,$resource_type->($value); # check type of hash value against Dict
0.000000,0,0.000000,
0.000111,24,0.000005,if (my $existing = $self->_get_resource($key)) {
0.000000,0,0.000000,# we allow overwriting canonical_uri = '' to allow for ad hoc evaluation of schemas that
0.000000,0,0.000000,# lack all identifiers altogether, but preserve other resources from the original document
0.000019,6,0.000003,if ($key ne '') {
0.000000,0,0.000000,next if $existing->{path} eq $value->{path}
0.000000,0,0.000000,and $existing->{canonical_uri} eq $value->{canonical_uri}
0.000000,0,0.000000,and $existing->{specification_version} eq $value->{specification_version}
0.000185,6,0.000031,and refaddr($existing->{document}) == refaddr($value->{document});
0.000000,0,0.000000,croak 'uri "'.$key.'" conflicts with an existing schema resource';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->CACHED_METASCHEMAS->{$key}) {
0.000000,0,0.000000,croak 'uri "'.$key.'" conflicts with an existing meta-schema resource';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000048,18,0.000003,my $fragment = $value->{canonical_uri}->fragment;
0.000000,0,0.000000,croak sprintf('canonical_uri cannot contain an empty fragment (%s)', $value->{canonical_uri})
0.000006,18,0.000000,if defined $fragment and $fragment eq '';
0.000000,0,0.000000,
0.000000,0,0.000000,croak sprintf('canonical_uri cannot contain a plain-name fragment (%s)', $value->{canonical_uri})
0.000034,18,0.000002,if ($fragment // '') =~ m{^[^/]};
0.000000,0,0.000000,
0.000035,18,0.000002,$self->$orig($key, $value);
0.000000,0,0.000000,}
0.000007,1,0.000007,};
0.000000,0,0.000000,
0.000000,0,0.000000,# $vocabulary uri (not its $id!) => [ spec_version, class ]
0.000000,0,0.000000,has _vocabulary_classes => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => HashRef[
0.000000,0,0.000000,Tuple[
0.000000,0,0.000000,$spec_version_type,
0.000000,0,0.000000,$vocabulary_class_type,
0.000000,0,0.000000,]
0.000000,0,0.000000,],
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,_get_vocabulary_class => 'get',
0.000000,0,0.000000,_set_vocabulary_class => 'set',
0.000000,0,0.000000,_get_vocabulary_values => 'values',
0.000000,0,0.000000,},
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,default => sub {
0.000000,0,0.000000,+{
0.000098,31,0.000003,map { my $class = $_; pairmap { $a => [ $b, $class ] } $class->vocabulary }
0.000000,0,0.000000,map use_module('JSON::Schema::Modern::Vocabulary::'.$_),
0.000000,0,0.000000,qw(Core Applicator Validation FormatAssertion FormatAnnotation Content MetaData Unevaluated)
0.000000,0,0.000000,}
0.000000,0,0.000000,},
0.000015,1,0.000015,);
0.000000,0,0.000000,
0.000000,3,0.000000,sub add_vocabulary ($self, $classname) {
0.000005,1,0.000005,return if grep $_->[1] eq $classname, $self->_get_vocabulary_values;
0.000000,0,0.000000,
0.000014,1,0.000014,$vocabulary_class_type->(use_module($classname));
0.000000,0,0.000000,
0.000000,0,0.000000,# uri => version, uri => version
0.000035,1,0.000035,foreach my $pair (pairs $classname->vocabulary) {
0.000004,1,0.000004,my ($uri_string, $spec_version) = @$pair;
0.000014,1,0.000014,Str->where(q{my $uri = Mojo::URL->new($_); $uri->is_abs && !defined $uri->fragment})->($uri_string);
0.000052,1,0.000052,$spec_version_type->($spec_version);
0.000004,1,0.000004,$self->_set_vocabulary_class($uri_string => [ $spec_version, $classname ])
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# $schema uri => [ spec_version, [ vocab classes ] ].
0.000000,0,0.000000,has _metaschema_vocabulary_classes => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => HashRef[
0.000000,0,0.000000,Tuple[
0.000000,0,0.000000,$spec_version_type,
0.000000,0,0.000000,ArrayRef[$vocabulary_class_type],
0.000000,0,0.000000,]
0.000000,0,0.000000,],
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,_get_metaschema_vocabulary_classes => 'get',
0.000000,0,0.000000,_set_metaschema_vocabulary_classes => 'set',
0.000000,0,0.000000,__all_metaschema_vocabulary_classes => 'values',
0.000000,0,0.000000,},
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,default => sub {
0.000008,1,0.000008,my @modules = map use_module('JSON::Schema::Modern::Vocabulary::'.$_),
0.000000,0,0.000000,qw(Core Applicator Validation FormatAnnotation Content MetaData Unevaluated);
0.000000,0,0.000000,+{
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/schema' => [ 'draft2020-12', [ @modules ] ],
0.000008,3,0.000003,do { pop @modules; () },
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/schema' => [ 'draft2019-09', \@modules ],
0.000000,0,0.000000,'http://json-schema.org/draft-07/schema#' => [ 'draft7', \@modules ],
0.000000,0,0.000000,},
0.000000,0,0.000000,},
0.000020,1,0.000020,);
0.000000,0,0.000000,
0.000000,0,0.000000,# retrieves metaschema info either from cache or by parsing the schema for vocabularies
0.000000,0,0.000000,# throws a JSON::Schema::Modern::Result on error
0.000698,2964,0.000000,sub _get_metaschema_info ($self, $metaschema_uri, $for_canonical_uri) {
0.000000,0,0.000000,# check the cache
0.001791,741,0.000002,my $metaschema_info = $self->_get_metaschema_vocabulary_classes($metaschema_uri);
0.001775,741,0.000002,return @$metaschema_info if $metaschema_info;
0.000000,0,0.000000,
0.000000,0,0.000000,# otherwise, fetch the metaschema and parse its $vocabulary keyword.
0.000000,0,0.000000,# we do this by traversing a baby schema with just the $schema keyword.
0.000004,1,0.000004,my $state = $self->traverse({ '$schema' => $metaschema_uri.'' });
0.000000,0,0.000000,die JSON::Schema::Modern::Result->new(
0.000000,0,0.000000,output_format => $self->output_format,
0.000000,0,0.000000,valid => JSON::PP::false,
0.000000,0,0.000000,errors => [
0.000000,0,0.000000,map {
0.000000,0,0.000000,my $e = $_;
0.000000,0,0.000000,# absolute location is undef iff the location = '/$schema'
0.000000,0,0.000000,my $absolute_location = $e->absolute_keyword_location // $for_canonical_uri;
0.000000,0,0.000000,JSON::Schema::Modern::Error->new(
0.000000,0,0.000000,keyword => $e->keyword eq '$schema' ? '' : $e->keyword,
0.000000,0,0.000000,instance_location => $e->instance_location,
0.000000,0,0.000000,keyword_location => ($for_canonical_uri->fragment//'').($e->keyword_location =~ s{^/\$schema\b}{}r),
0.000000,0,0.000000,length $absolute_location ? ( absolute_keyword_location => $absolute_location ) : (),
0.000000,0,0.000000,error => $e->error,
0.000000,0,0.000000,)
0.000000,0,0.000000,}
0.000000,0,0.000000,$state->{errors}->@* ],
0.000000,0,0.000000,exception => 1,
0.000001,1,0.000001,) if $state->{errors}->@*;
0.000005,1,0.000005,return ($state->{spec_version}, $state->{vocabularies});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# used for determining a default '$schema' keyword where there is none
0.000001,1,0.000001,use constant METASCHEMA_URIS => {
0.000000,0,0.000000,'draft2020-12' => 'https://json-schema.org/draft/2020-12/schema',
0.000000,0,0.000000,'draft2019-09' => 'https://json-schema.org/draft/2019-09/schema',
0.000000,0,0.000000,'draft7' => 'http://json-schema.org/draft-07/schema#',
0.000095,1,0.000095,};
0.000000,0,0.000000,
0.000000,1,0.000000,use constant CACHED_METASCHEMAS => {
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/applicator'     => 'draft2020-12/meta/applicator.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/content'        => 'draft2020-12/meta/content.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/core'           => 'draft2020-12/meta/core.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/format-annotation' => 'draft2020-12/meta/format-annotation.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/format-assertion'  => 'draft2020-12/meta/format-assertion.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/meta-data'      => 'draft2020-12/meta/meta-data.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/unevaluated'    => 'draft2020-12/meta/unevaluated.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/meta/validation'     => 'draft2020-12/meta/validation.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/output/schema'       => 'draft2020-12/output/schema.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/schema'              => 'draft2020-12/schema.json',
0.000000,0,0.000000,
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/meta/applicator'     => 'draft2019-09/meta/applicator.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/meta/content'        => 'draft2019-09/meta/content.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/meta/core'           => 'draft2019-09/meta/core.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/meta/format'         => 'draft2019-09/meta/format.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/meta/meta-data'      => 'draft2019-09/meta/meta-data.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/meta/validation'     => 'draft2019-09/meta/validation.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/output/schema'       => 'draft2019-09/output/schema.json',
0.000000,0,0.000000,'https://json-schema.org/draft/2019-09/schema'              => 'draft2019-09/schema.json',
0.000000,0,0.000000,
0.000000,0,0.000000,# trailing # is omitted because we always cache documents by its canonical (fragmentless) URI
0.000000,0,0.000000,'http://json-schema.org/draft-07/schema' => 'draft7/schema.json',
0.000980,1,0.000980,};
0.000000,0,0.000000,
0.000000,0,0.000000,# returns the same as _get_resource
0.019382,116349,0.000000,sub _get_or_load_resource ($self, $uri) {
0.070948,38783,0.000002,my $resource = $self->_get_resource($uri);
0.058059,38783,0.000001,return $resource if $resource;
0.000000,0,0.000000,
0.000074,8,0.000009,if (my $local_filename = $self->CACHED_METASCHEMAS->{$uri}) {
0.000044,8,0.000005,my $file = path(dist_dir('JSON-Schema-Modern'), $local_filename);
0.000316,8,0.000039,my $schema = $self->_json_decoder->decode($file->slurp_raw);
0.000049,8,0.000006,my $document = JSON::Schema::Modern::Document->new(schema => $schema, evaluator => $self);
0.000000,0,0.000000,
0.000000,0,0.000000,# this should be caught by the try/catch in evaluate()
0.000017,8,0.000002,die JSON::Schema::Modern::Result->new(
0.000000,0,0.000000,output_format => $self->output_format,
0.000000,0,0.000000,valid => 0,
0.000000,0,0.000000,errors => [ $document->errors ],
0.000000,0,0.000000,exception => 1,
0.000000,0,0.000000,) if $document->has_errors;
0.000000,0,0.000000,
0.000000,0,0.000000,# we have already performed the appropriate collision checks, so we bypass them here
0.000073,8,0.000009,$self->_add_resources_unsafe(
0.000000,0,0.000000,map +($_->[0] => +{ $_->[1]->%*, document => $document }),
0.000000,0,0.000000,$document->resource_pairs
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000053,8,0.000007,return $self->_get_resource($uri);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO:
0.000000,0,0.000000,# - load from network or disk
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,# returns information necessary to use a schema found at a particular URI:
0.000000,0,0.000000,# - a schema (which may not be at a document root)
0.000000,0,0.000000,# - the canonical uri for that schema,
0.000000,0,0.000000,# - the JSON::Schema::Modern::Document object that holds that schema
0.000000,0,0.000000,# - the path relative to the document root for this schema
0.000000,0,0.000000,# - the specification version that applies to this schema
0.000000,0,0.000000,# - the vocabularies to use when considering schema keywords
0.000000,0,0.000000,# - the config overrides to set when considering schema keywords
0.000000,0,0.000000,# creates a Document and adds it to the resource index, if not already present.
0.023866,139353,0.000000,sub _fetch_from_uri ($self, $uri) {
0.015576,46451,0.000000,$uri = Mojo::URL->new($uri) if not is_ref($uri);
0.039485,46451,0.000001,my $fragment = $uri->fragment;
0.000000,0,0.000000,
0.058908,46451,0.000001,if (not length($fragment) or $fragment =~ m{^/}) {
0.056899,38783,0.000001,my $base = $uri->clone->fragment(undef);
0.057084,38783,0.000001,if (my $resource = $self->_get_or_load_resource($base)) {
0.104154,38783,0.000003,my $subschema = $resource->{document}->get(my $document_path = $resource->{path}.($fragment//''));
0.010952,38783,0.000000,return if not defined $subschema;
0.014149,38783,0.000000,my $document = $resource->{document};
0.000000,0,0.000000,my $closest_resource = first { !length($_->[1]{path})       # document root
0.176165,38783,0.000005,|| length($document_path)
0.000000,0,0.000000,&& $document_path =~ m{^\Q$_->[1]{path}\E(?:/|\z)} }  # path is above present location
0.000000,0,0.000000,sort { length($b->[1]{path}) <=> length($a->[1]{path}) }  # sort by length, descending
0.516619,38783,0.000013,grep { not length Mojo::URL->new($_->[0])->fragment }     # omit anchors
0.000000,0,0.000000,$document->resource_pairs;
0.000000,0,0.000000,
0.000000,0,0.000000,my $canonical_uri = $closest_resource->[1]{canonical_uri}->clone
0.118950,38783,0.000003,->fragment(substr($document_path, length($closest_resource->[1]{path})));
0.051004,38783,0.000001,$canonical_uri->fragment(undef) if not length($canonical_uri->fragment);
0.000000,0,0.000000,return {
0.000000,0,0.000000,schema => $subschema,
0.000000,0,0.000000,canonical_uri => $canonical_uri,
0.000000,0,0.000000,document => $document,
0.000000,0,0.000000,document_path => $document_path,
0.328589,38783,0.000008,$resource->%{qw(specification_version vocabularies configs)}, # reference, not copy
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {  # we are following a URI with a plain-name fragment
0.011072,7668,0.000001,if (my $resource = $self->_get_resource($uri)) {
0.013726,7668,0.000002,my $subschema = $resource->{document}->get($resource->{path});
0.001278,7668,0.000000,return if not defined $subschema;
0.000000,0,0.000000,return {
0.000000,0,0.000000,schema => $subschema,
0.000000,0,0.000000,canonical_uri => $resource->{canonical_uri}->clone, # this is *not* the anchor-containing URI
0.000000,0,0.000000,document => $resource->{document},
0.000000,0,0.000000,document_path => $resource->{path},
0.044068,7668,0.000006,$resource->%{qw(specification_version vocabularies configs)}, # reference, not copy
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# used for internal encoding as well (when caching serialized schemas)
0.000000,0,0.000000,has _json_decoder => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => HasMethods[qw(encode decode)],
0.000000,0,0.000000,lazy => 1,
0.000006,1,0.000006,default => sub { JSON::MaybeXS->new(allow_nonref => 1, canonical => 1, utf8 => 1, allow_bignum => 1, convert_blessed => 1) },
0.000012,1,0.000012,);
0.000000,0,0.000000,
0.000000,0,0.000000,# since media types are case-insensitive, all type names must be foldcased on insertion.
0.000000,0,0.000000,has _media_type => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => my $media_type_type = Map[Str->where(q{$_ eq CORE::fc($_)}), CodeRef],
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,get_media_type => 'get',
0.000000,0,0.000000,add_media_type => 'set',
0.000000,0,0.000000,_media_types => 'keys',
0.000000,0,0.000000,},
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,default => sub ($self) {
0.000000,0,0.000000,my $_json_media_type = sub ($content_ref) {
0.000000,0,0.000000,# utf-8 decoding is always done, as per the JSON spec.
0.000000,0,0.000000,# other charsets are not supported: see RFC8259 §11
0.000000,0,0.000000,\ JSON::MaybeXS->new(allow_nonref => 1, utf8 => 1)->decode($content_ref->$*);
0.000000,0,0.000000,};
0.000000,0,0.000000,+{
0.000000,0,0.000000,(map +($_ => $_json_media_type),
0.000000,0,0.000000,qw(application/json application/schema+json application/schema-instance+json)),
0.000000,0,0.000000,map +($_ => sub ($content_ref) { $content_ref }),
0.000000,0,0.000000,qw(text/* application/octet-stream),
0.000000,0,0.000000,};
0.000000,0,0.000000,},
0.000017,1,0.000017,);
0.000000,0,0.000000,
0.000000,0,0.000000,# get_media_type('TExT/bloop') will fall through to matching an entry for 'text/*' or '*/*'
0.000000,0,0.000000,around get_media_type => sub ($orig, $self, $type) {
0.000000,0,0.000000,my $mt = $self->$orig(fc $type);
0.000000,0,0.000000,return $mt if $mt;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->$orig((first { m{([^/]+)/\*$} && fc($type) =~ m{^\Q$1\E/[^/]+$} } $self->_media_types)
0.000000,0,0.000000,// '*/*');
0.000003,1,0.000003,};
0.000000,0,0.000000,
0.000002,1,0.000002,before add_media_type => sub ($self, $type, $sub) { $media_type_type->({ $type => $sub }) };
0.000000,0,0.000000,
0.000000,0,0.000000,has _encoding => (
0.000000,0,0.000000,is => 'bare',
0.000000,0,0.000000,isa => HashRef[CodeRef],
0.000000,0,0.000000,handles_via => 'Hash',
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,get_encoding => 'get',
0.000000,0,0.000000,add_encoding => 'set',
0.000000,0,0.000000,},
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,default => sub ($self) {
0.000000,0,0.000000,+{
0.000000,0,0.000000,identity => sub ($content_ref) { $content_ref },
0.000000,0,0.000000,base64 => sub ($content_ref) {
0.000000,0,0.000000,die "invalid characters\n"
0.000000,0,0.000000,if $content_ref->$* =~ m{[^A-Za-z0-9+/=]} or $content_ref->$* =~ m{=(?=[^=])};
0.000000,0,0.000000,require MIME::Base64; \ MIME::Base64::decode($content_ref->$*);
0.000000,0,0.000000,},
0.000000,0,0.000000,};
0.000000,0,0.000000,},
0.000009,1,0.000009,);
0.000000,0,0.000000,
0.000000,0,0.000000,# callback hook for Sereal::Encode
0.000000,0,0.000000,sub FREEZE ($self, $serializer) {
0.000000,0,0.000000,my $data = +{ %$self };
0.000000,0,0.000000,# Cpanel::JSON::XS doesn't serialize: https://github.com/Sereal/Sereal/issues/266
0.000000,0,0.000000,# coderefs can't serialize cleanly and must be re-added by the user.
0.000000,0,0.000000,delete $data->@{qw(_json_decoder _format_validations _media_type _encoding)};
0.000000,0,0.000000,return $data;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# callback hook for Sereal::Decode
0.000000,0,0.000000,sub THAW ($class, $serializer, $data) {
0.000000,0,0.000000,my $self = bless($data, $class);
0.000000,0,0.000000,
0.000000,0,0.000000,# load all vocabulary classes
0.000000,0,0.000000,require_module($_) foreach uniq map $_->{vocabularies}->@*, $self->_canonical_resources;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000105,1,0.000105,1;
0.000115,1,0.000115,__END__
