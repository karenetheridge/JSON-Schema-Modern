# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000054,2,0.000027,use strict;
0.000051,2,0.000025,use warnings;
0.000000,0,0.000000,package YAML::PP::Schema::JSON;
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000058,2,0.000029,use base 'Exporter';
0.000001,1,0.000001,our @EXPORT_OK = qw/
0.000000,0,0.000000,represent_int represent_float represent_literal represent_bool
0.000000,0,0.000000,represent_undef
0.000000,0,0.000000,/;
0.000000,0,0.000000,
0.000024,2,0.000012,use B;
0.000100,2,0.000050,use Carp qw/ croak /;
0.000000,0,0.000000,
0.001081,2,0.000540,use YAML::PP::Common qw/ YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE /;
0.000000,0,0.000000,
0.000011,1,0.000011,my $RE_INT = qr{^(-?(?:0|[1-9][0-9]*))$};
0.000002,1,0.000002,my $RE_FLOAT = qr{^(-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)$};
0.000000,0,0.000000,
0.000484,147,0.000003,sub _to_int { 0 + $_[2]->[0] }
0.000000,0,0.000000,
0.000000,0,0.000000,# DaTa++ && shmem++
0.000000,0,0.000000,sub _to_float { unpack F => pack F => $_[2]->[0] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub register {
0.000000,0,0.000000,my ($self, %args) = @_;
0.000000,0,0.000000,my $schema = $args{schema};
0.000000,0,0.000000,my $options = $args{options};
0.000000,0,0.000000,my $empty_null = 0;
0.000000,0,0.000000,for my $opt (@$options) {
0.000000,0,0.000000,if ($opt eq 'empty=str') {
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($opt eq 'empty=null') {
0.000000,0,0.000000,$empty_null = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,croak "Invalid option for JSON Schema: '$opt'";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:null',
0.000000,0,0.000000,match => [ equals => null => undef ],
0.000000,0,0.000000,);
0.000000,0,0.000000,if ($empty_null) {
0.000000,0,0.000000,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:null',
0.000000,0,0.000000,match => [ equals => '' => undef ],
0.000000,0,0.000000,implicit => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:str',
0.000000,0,0.000000,match => [ equals => '' => '' ],
0.000000,0,0.000000,implicit => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:bool',
0.000000,0,0.000000,match => [ equals => true => $schema->true ],
0.000000,0,0.000000,);
0.000000,0,0.000000,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:bool',
0.000000,0,0.000000,match => [ equals => false => $schema->false ],
0.000000,0,0.000000,);
0.000000,0,0.000000,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:int',
0.000000,0,0.000000,match => [ regex => $RE_INT => \&_to_int ],
0.000000,0,0.000000,);
0.000000,0,0.000000,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:float',
0.000000,0,0.000000,match => [ regex => $RE_FLOAT => \&_to_float ],
0.000000,0,0.000000,);
0.000000,0,0.000000,$schema->add_resolver(
0.000000,0,0.000000,tag => 'tag:yaml.org,2002:str',
0.000000,0,0.000000,match => [ all => sub { $_[1]->{value} } ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$schema->add_representer(
0.000000,0,0.000000,undefined => \&represent_undef,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $int_flags = B::SVp_IOK;
0.000000,0,0.000000,my $float_flags = B::SVp_NOK;
0.000000,0,0.000000,$schema->add_representer(
0.000000,0,0.000000,flags => $int_flags,
0.000000,0,0.000000,code => \&represent_int,
0.000000,0,0.000000,);
0.000000,0,0.000000,my %special = ( (0+'nan').'' => '.nan', (0+'inf').'' => '.inf', (0-'inf').'' => '-.inf' );
0.000000,0,0.000000,$schema->add_representer(
0.000000,0,0.000000,flags => $float_flags,
0.000000,0,0.000000,code => \&represent_float,
0.000000,0,0.000000,);
0.000000,0,0.000000,$schema->add_representer(
0.000000,0,0.000000,equals => $_,
0.000000,0,0.000000,code => \&represent_literal,
0.000000,0,0.000000,) for ("", qw/ true false null /);
0.000000,0,0.000000,$schema->add_representer(
0.000000,0,0.000000,regex => qr{$RE_INT|$RE_FLOAT},
0.000000,0,0.000000,code => \&represent_literal,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($schema->bool_class) {
0.000000,0,0.000000,for my $class (@{ $schema->bool_class }) {
0.000000,0,0.000000,$schema->add_representer(
0.000000,0,0.000000,class_equals => $class,
0.000000,0,0.000000,code => \&represent_bool,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub represent_undef {
0.000000,0,0.000000,my ($rep, $node) = @_;
0.000000,0,0.000000,$node->{style} = YAML_PLAIN_SCALAR_STYLE;
0.000000,0,0.000000,$node->{data} = 'null';
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub represent_literal {
0.000000,0,0.000000,my ($rep, $node) = @_;
0.000000,0,0.000000,$node->{style} ||= YAML_SINGLE_QUOTED_SCALAR_STYLE;
0.000000,0,0.000000,$node->{data} = "$node->{value}";
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub represent_int {
0.000000,0,0.000000,my ($rep, $node) = @_;
0.000000,0,0.000000,if (int($node->{value}) ne $node->{value}) {
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,$node->{style} = YAML_PLAIN_SCALAR_STYLE;
0.000000,0,0.000000,$node->{data} = "$node->{value}";
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000016,1,0.000016,my %special = (
0.000000,0,0.000000,(0+'nan').'' => '.nan',
0.000000,0,0.000000,(0+'inf').'' => '.inf',
0.000000,0,0.000000,(0-'inf').'' => '-.inf'
0.000000,0,0.000000,);
0.000000,0,0.000000,sub represent_float {
0.000000,0,0.000000,my ($rep, $node) = @_;
0.000000,0,0.000000,if (exists $special{ $node->{value} }) {
0.000000,0,0.000000,$node->{style} = YAML_PLAIN_SCALAR_STYLE;
0.000000,0,0.000000,$node->{data} = $special{ $node->{value} };
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (0.0 + $node->{value} ne $node->{value}) {
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (int($node->{value}) eq $node->{value} and not $node->{value} =~ m/\./) {
0.000000,0,0.000000,$node->{value} .= '.0';
0.000000,0,0.000000,}
0.000000,0,0.000000,$node->{style} = YAML_PLAIN_SCALAR_STYLE;
0.000000,0,0.000000,$node->{data} = "$node->{value}";
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub represent_bool {
0.000000,0,0.000000,my ($rep, $node) = @_;
0.000000,0,0.000000,my $string = $node->{value} ? 'true' : 'false';
0.000000,0,0.000000,$node->{style} = YAML_PLAIN_SCALAR_STYLE;
0.000000,0,0.000000,@{ $node->{items} } = $string;
0.000000,0,0.000000,$node->{data} = $string;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
