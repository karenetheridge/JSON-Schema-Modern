# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package IO::Uncompress::RawInflate ;
0.000000,0,0.000000,# for RFC1951
0.000000,0,0.000000,
0.000036,2,0.000018,use strict ;
0.000053,2,0.000027,use warnings;
0.000027,2,0.000014,use bytes;
0.000000,0,0.000000,
0.000052,3,0.000017,use Compress::Raw::Zlib  2.103 ;
0.000040,3,0.000013,use IO::Compress::Base::Common  2.106 qw(:Status );
0.000000,0,0.000000,
0.000865,3,0.000288,use IO::Uncompress::Base  2.106 ;
0.001769,3,0.000590,use IO::Uncompress::Adapter::Inflate  2.106 ;
0.000000,0,0.000000,
0.000001,1,0.000001,require Exporter ;
0.000000,0,0.000000,our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, %DEFLATE_CONSTANTS, $RawInflateError);
0.000000,0,0.000000,
0.000000,1,0.000000,$VERSION = '2.106';
0.000001,1,0.000001,$RawInflateError = '';
0.000000,0,0.000000,
0.000027,1,0.000027,@ISA    = qw(IO::Uncompress::Base Exporter);
0.000002,1,0.000002,@EXPORT_OK = qw( $RawInflateError rawinflate ) ;
0.000001,1,0.000001,%DEFLATE_CONSTANTS = ();
0.000002,1,0.000002,%EXPORT_TAGS = %IO::Uncompress::Base::EXPORT_TAGS ;
0.000002,1,0.000002,push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;
0.000004,1,0.000004,Exporter::export_ok_tags('all');
0.000000,0,0.000000,
0.000000,0,0.000000,#{
0.000000,0,0.000000,#    # Execute at runtime
0.000000,0,0.000000,#    my %bad;
0.000000,0,0.000000,#    for my $module (qw(Compress::Raw::Zlib IO::Compress::Base::Common IO::Uncompress::Base IO::Uncompress::Adapter::Inflate))
0.000000,0,0.000000,#    {
0.000000,0,0.000000,#        my $ver = ${ $module . "::VERSION"} ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#        $bad{$module} = $ver
0.000000,0,0.000000,#            if $ver ne $VERSION;
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#
0.000000,0,0.000000,#    if (keys %bad)
0.000000,0,0.000000,#    {
0.000000,0,0.000000,#        my $string = join "\n", map { "$_ $bad{$_}" } keys %bad;
0.000000,0,0.000000,#        die caller(0)[0] . "needs version $VERSION mismatch\n$string\n";
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#}
0.000000,0,0.000000,
0.000000,0,0.000000,sub new
0.000000,0,0.000000,{
0.000000,0,0.000000,my $class = shift ;
0.000000,0,0.000000,my $obj = IO::Compress::Base::Common::createSelfTiedObject($class, \$RawInflateError);
0.000000,0,0.000000,$obj->_create(undef, 0, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub rawinflate
0.000000,0,0.000000,{
0.000000,0,0.000000,my $obj = IO::Compress::Base::Common::createSelfTiedObject(undef, \$RawInflateError);
0.000000,0,0.000000,return $obj->_inf(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getExtraParams
0.000000,0,0.000000,{
0.000000,0,0.000000,return ();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ckParams
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $got = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mkUncomp
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $got = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($obj, $errstr, $errno) = IO::Uncompress::Adapter::Inflate::mkUncompObject(
0.000000,0,0.000000,$got->getValue('crc32'),
0.000000,0,0.000000,$got->getValue('adler32'),
0.000000,0,0.000000,$got->getValue('scan'),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->saveErrorString(undef, $errstr, $errno)
0.000000,0,0.000000,if ! defined $obj;
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{Uncomp} = $obj;
0.000000,0,0.000000,
0.000000,0,0.000000,my $magic = $self->ckMagic()
0.000000,0,0.000000,or return 0;
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{Info} = $self->readHeader($magic)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub ckMagic
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->_isRaw() ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub readHeader
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $magic = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return {
0.000000,0,0.000000,'Type'          => 'rfc1951',
0.000000,0,0.000000,'FingerprintLength'  => 0,
0.000000,0,0.000000,'HeaderLength'  => 0,
0.000000,0,0.000000,'TrailerLength' => 0,
0.000000,0,0.000000,'Header'        => ''
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub chkTrailer
0.000000,0,0.000000,{
0.000000,0,0.000000,return STATUS_OK ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _isRaw
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $got = $self->_isRawx(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($got) {
0.000000,0,0.000000,*$self->{Pending} = *$self->{HeaderPending} ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->pushBack(*$self->{HeaderPending});
0.000000,0,0.000000,*$self->{Uncomp}->reset();
0.000000,0,0.000000,}
0.000000,0,0.000000,*$self->{HeaderPending} = '';
0.000000,0,0.000000,
0.000000,0,0.000000,return $got ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _isRawx
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,my $magic = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,$magic = '' unless defined $magic ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $buffer = '';
0.000000,0,0.000000,
0.000000,0,0.000000,$self->smartRead(\$buffer, *$self->{BlockSize}) >= 0
0.000000,0,0.000000,or return $self->saveErrorString(undef, "No data to read");
0.000000,0,0.000000,
0.000000,0,0.000000,my $temp_buf = $magic . $buffer ;
0.000000,0,0.000000,*$self->{HeaderPending} = $temp_buf ;
0.000000,0,0.000000,$buffer = '';
0.000000,0,0.000000,my $status = *$self->{Uncomp}->uncompr(\$temp_buf, \$buffer, $self->smartEof()) ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->saveErrorString(undef, *$self->{Uncomp}{Error}, STATUS_ERROR)
0.000000,0,0.000000,if $status == STATUS_ERROR;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->pushBack($temp_buf)  ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->saveErrorString(undef, "unexpected end of file", STATUS_ERROR)
0.000000,0,0.000000,if $self->smartEof() && $status != STATUS_ENDSTREAM;
0.000000,0,0.000000,
0.000000,0,0.000000,#my $buf_len = *$self->{Uncomp}->uncompressedBytes();
0.000000,0,0.000000,my $buf_len = length $buffer;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($status == STATUS_ENDSTREAM) {
0.000000,0,0.000000,if (*$self->{MultiStream}
0.000000,0,0.000000,&& (length $temp_buf || ! $self->smartEof())){
0.000000,0,0.000000,*$self->{NewStream} = 1 ;
0.000000,0,0.000000,*$self->{EndStream} = 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,*$self->{EndStream} = 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,*$self->{HeaderPending} = $buffer ;
0.000000,0,0.000000,*$self->{InflatedBytesRead} = $buf_len ;
0.000000,0,0.000000,*$self->{TotalInflatedBytesRead} += $buf_len ;
0.000000,0,0.000000,*$self->{Type} = 'rfc1951';
0.000000,0,0.000000,
0.000000,0,0.000000,$self->saveStatus(STATUS_OK);
0.000000,0,0.000000,
0.000000,0,0.000000,return {
0.000000,0,0.000000,'Type'          => 'rfc1951',
0.000000,0,0.000000,'HeaderLength'  => 0,
0.000000,0,0.000000,'TrailerLength' => 0,
0.000000,0,0.000000,'Header'        => ''
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub inflateSync
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,# inflateSync is a no-op in Plain mode
0.000000,0,0.000000,return 1
0.000000,0,0.000000,if *$self->{Plain} ;
0.000000,0,0.000000,
0.000000,0,0.000000,return 0 if *$self->{Closed} ;
0.000000,0,0.000000,#return G_EOF if !length *$self->{Pending} && *$self->{EndStream} ;
0.000000,0,0.000000,return 0 if ! length *$self->{Pending} && *$self->{EndStream} ;
0.000000,0,0.000000,
0.000000,0,0.000000,# Disable CRC check
0.000000,0,0.000000,*$self->{Strict} = 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $status ;
0.000000,0,0.000000,while (1)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $temp_buf ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (length *$self->{Pending} )
0.000000,0,0.000000,{
0.000000,0,0.000000,$temp_buf = *$self->{Pending} ;
0.000000,0,0.000000,*$self->{Pending} = '';
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,$status = $self->smartRead(\$temp_buf, *$self->{BlockSize}) ;
0.000000,0,0.000000,return $self->saveErrorString(0, "Error Reading Data")
0.000000,0,0.000000,if $status < 0  ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($status == 0 ) {
0.000000,0,0.000000,*$self->{EndStream} = 1 ;
0.000000,0,0.000000,return $self->saveErrorString(0, "unexpected end of file", STATUS_ERROR);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$status = *$self->{Uncomp}->sync($temp_buf) ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($status == STATUS_OK)
0.000000,0,0.000000,{
0.000000,0,0.000000,*$self->{Pending} .= $temp_buf ;
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,last unless $status == STATUS_ERROR ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#sub performScan
0.000000,0,0.000000,#{
0.000000,0,0.000000,#    my $self = shift ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#    my $status ;
0.000000,0,0.000000,#    my $end_offset = 0;
0.000000,0,0.000000,#
0.000000,0,0.000000,#    $status = $self->scan()
0.000000,0,0.000000,#    #or return $self->saveErrorString(undef, "Error Scanning: $$error_ref", $self->errorNo) ;
0.000000,0,0.000000,#        or return $self->saveErrorString(G_ERR, "Error Scanning: $status")
0.000000,0,0.000000,#
0.000000,0,0.000000,#    $status = $self->zap($end_offset)
0.000000,0,0.000000,#        or return $self->saveErrorString(G_ERR, "Error Zapping: $status");
0.000000,0,0.000000,#    #or return $self->saveErrorString(undef, "Error Zapping: $$error_ref", $self->errorNo) ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#    #(*$obj->{Deflate}, $status) = $inf->createDeflate();
0.000000,0,0.000000,#
0.000000,0,0.000000,##    *$obj->{Header} = *$inf->{Info}{Header};
0.000000,0,0.000000,##    *$obj->{UnCompSize_32bit} =
0.000000,0,0.000000,##        *$obj->{BytesWritten} = *$inf->{UnCompSize_32bit} ;
0.000000,0,0.000000,##    *$obj->{CompSize_32bit} = *$inf->{CompSize_32bit} ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#
0.000000,0,0.000000,##    if ( $outType eq 'buffer')
0.000000,0,0.000000,##      { substr( ${ *$self->{Buffer} }, $end_offset) = '' }
0.000000,0,0.000000,##    elsif ($outType eq 'handle' || $outType eq 'filename') {
0.000000,0,0.000000,##        *$self->{FH} = *$inf->{FH} ;
0.000000,0,0.000000,##        delete *$inf->{FH};
0.000000,0,0.000000,##        *$obj->{FH}->flush() ;
0.000000,0,0.000000,##        *$obj->{Handle} = 1 if $outType eq 'handle';
0.000000,0,0.000000,##
0.000000,0,0.000000,##        #seek(*$obj->{FH}, $end_offset, SEEK_SET)
0.000000,0,0.000000,##        *$obj->{FH}->seek($end_offset, SEEK_SET)
0.000000,0,0.000000,##            or return $obj->saveErrorString(undef, $!, $!) ;
0.000000,0,0.000000,##    }
0.000000,0,0.000000,#
0.000000,0,0.000000,#}
0.000000,0,0.000000,
0.000000,0,0.000000,sub scan
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if *$self->{Closed} ;
0.000000,0,0.000000,return 1 if !length *$self->{Pending} && *$self->{EndStream} ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $buffer = '' ;
0.000000,0,0.000000,my $len = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,$len = $self->_raw_read(\$buffer, 1)
0.000000,0,0.000000,while ! *$self->{EndStream} && $len >= 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,#return $len if $len < 0 ? $len : 0 ;
0.000000,0,0.000000,return $len < 0 ? 0 : 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub zap
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self  = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $headerLength = *$self->{Info}{HeaderLength};
0.000000,0,0.000000,my $block_offset =  $headerLength + *$self->{Uncomp}->getLastBlockOffset();
0.000000,0,0.000000,$_[0] = $headerLength + *$self->{Uncomp}->getEndOffset();
0.000000,0,0.000000,#printf "# End $_[0], headerlen $headerLength \n";;
0.000000,0,0.000000,#printf "# block_offset $block_offset %x\n", $block_offset;
0.000000,0,0.000000,my $byte ;
0.000000,0,0.000000,( $self->smartSeek($block_offset) &&
0.000000,0,0.000000,$self->smartRead(\$byte, 1) )
0.000000,0,0.000000,or return $self->saveErrorString(0, $!, $!);
0.000000,0,0.000000,
0.000000,0,0.000000,#printf "#byte is %x\n", unpack('C*',$byte);
0.000000,0,0.000000,*$self->{Uncomp}->resetLastBlockByte($byte);
0.000000,0,0.000000,#printf "#to byte is %x\n", unpack('C*',$byte);
0.000000,0,0.000000,
0.000000,0,0.000000,( $self->smartSeek($block_offset) &&
0.000000,0,0.000000,$self->smartWrite($byte) )
0.000000,0,0.000000,or return $self->saveErrorString(0, $!, $!);
0.000000,0,0.000000,
0.000000,0,0.000000,#$self->smartSeek($end_offset, 1);
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub createDeflate
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self  = shift ;
0.000000,0,0.000000,my ($def, $status) = *$self->{Uncomp}->createDeflateStream(
0.000000,0,0.000000,-AppendOutput   => 1,
0.000000,0,0.000000,-WindowBits => - MAX_WBITS,
0.000000,0,0.000000,-CRC32      => *$self->{Params}->getValue('crc32'),
0.000000,0,0.000000,-ADLER32    => *$self->{Params}->getValue('adler32'),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,return wantarray ? ($status, $def) : $def ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000007,1,0.000007,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
