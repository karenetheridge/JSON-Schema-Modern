# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package re;
0.000000,0,0.000000,
0.000000,0,0.000000,# pragma for controlling the regexp engine
0.000018,2,0.000009,use strict;
0.000847,2,0.000424,use warnings;
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION     = "0.43";
0.000006,1,0.000006,our @ISA         = qw(Exporter);
0.000001,1,0.000001,our @EXPORT_OK   = qw{
0.000000,0,0.000000,is_regexp regexp_pattern
0.000000,0,0.000000,regname regnames regnames_count
0.000000,0,0.000000,regmust optimization
0.000000,0,0.000000,};
0.000007,1,0.000007,our %EXPORT_OK = map { $_ => 1 } @EXPORT_OK;
0.000000,0,0.000000,
0.000001,1,0.000001,my %bitmask = (
0.000000,0,0.000000,taint   => 0x00100000, # HINT_RE_TAINT
0.000000,0,0.000000,eval    => 0x00200000, # HINT_RE_EVAL
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,1,0.000000,my $flags_hint = 0x02000000; # HINT_RE_FLAGS
0.000000,1,0.000000,my $PMMOD_SHIFT = 0;
0.000004,1,0.000004,my %reflags = (
0.000000,0,0.000000,m => 1 << ($PMMOD_SHIFT + 0),
0.000000,0,0.000000,s => 1 << ($PMMOD_SHIFT + 1),
0.000000,0,0.000000,i => 1 << ($PMMOD_SHIFT + 2),
0.000000,0,0.000000,x => 1 << ($PMMOD_SHIFT + 3),
0.000000,0,0.000000,xx => 1 << ($PMMOD_SHIFT + 4),
0.000000,0,0.000000,n => 1 << ($PMMOD_SHIFT + 5),
0.000000,0,0.000000,p => 1 << ($PMMOD_SHIFT + 6),
0.000000,0,0.000000,strict => 1 << ($PMMOD_SHIFT + 10),
0.000000,0,0.000000,# special cases:
0.000000,0,0.000000,d => 0,
0.000000,0,0.000000,l => 1,
0.000000,0,0.000000,u => 2,
0.000000,0,0.000000,a => 3,
0.000000,0,0.000000,aa => 4,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub setcolor {
0.000000,0,0.000000,eval {				# Ignore errors
0.000000,0,0.000000,require Term::Cap;
0.000000,0,0.000000,
0.000000,0,0.000000,my $terminal = Tgetent Term::Cap ({OSPEED => 9600}); # Avoid warning.
0.000000,0,0.000000,my $props = $ENV{PERL_RE_TC} || 'md,me,so,se,us,ue';
0.000000,0,0.000000,my @props = split /,/, $props;
0.000000,0,0.000000,my $colors = join "\t", map {$terminal->Tputs($_,1)} @props;
0.000000,0,0.000000,
0.000000,0,0.000000,$colors =~ s/\0//g;
0.000000,0,0.000000,$ENV{PERL_RE_COLORS} = $colors;
0.000000,0,0.000000,};
0.000000,0,0.000000,if ($@) {
0.000000,0,0.000000,$ENV{PERL_RE_COLORS} ||= qq'\t\t> <\t> <\t\t';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,my %flags = (
0.000000,0,0.000000,COMPILE           => 0x0000FF,
0.000000,0,0.000000,PARSE             => 0x000001,
0.000000,0,0.000000,OPTIMISE          => 0x000002,
0.000000,0,0.000000,TRIEC             => 0x000004,
0.000000,0,0.000000,DUMP              => 0x000008,
0.000000,0,0.000000,FLAGS             => 0x000010,
0.000000,0,0.000000,TEST              => 0x000020,
0.000000,0,0.000000,
0.000000,0,0.000000,EXECUTE           => 0x00FF00,
0.000000,0,0.000000,INTUIT            => 0x000100,
0.000000,0,0.000000,MATCH             => 0x000200,
0.000000,0,0.000000,TRIEE             => 0x000400,
0.000000,0,0.000000,
0.000000,0,0.000000,EXTRA             => 0x3FF0000,
0.000000,0,0.000000,TRIEM             => 0x0010000,
0.000000,0,0.000000,STATE             => 0x0080000,
0.000000,0,0.000000,OPTIMISEM         => 0x0100000,
0.000000,0,0.000000,STACK             => 0x0280000,
0.000000,0,0.000000,BUFFERS           => 0x0400000,
0.000000,0,0.000000,GPOS              => 0x0800000,
0.000000,0,0.000000,DUMP_PRE_OPTIMIZE => 0x1000000,
0.000000,0,0.000000,WILDCARD          => 0x2000000,
0.000000,0,0.000000,);
0.000000,0,0.000000,$flags{ALL} = -1 & ~($flags{BUFFERS}
0.000000,0,0.000000,|$flags{DUMP_PRE_OPTIMIZE}
0.000000,0,0.000000,|$flags{WILDCARD}
0.000001,1,0.000001,);
0.000001,1,0.000001,$flags{All} = $flags{all} = $flags{DUMP} | $flags{EXECUTE};
0.000001,1,0.000001,$flags{Extra} = $flags{EXECUTE} | $flags{COMPILE} | $flags{GPOS};
0.000000,0,0.000000,$flags{More} = $flags{MORE} =
0.000000,1,0.000000,$flags{All} | $flags{TRIEC} | $flags{TRIEM} | $flags{STATE};
0.000001,1,0.000001,$flags{State} = $flags{DUMP} | $flags{EXECUTE} | $flags{STATE};
0.000000,1,0.000000,$flags{TRIE} = $flags{DUMP} | $flags{EXECUTE} | $flags{TRIEC};
0.000000,0,0.000000,
0.000001,1,0.000001,if (defined &DynaLoader::boot_DynaLoader) {
0.000000,1,0.000000,require XSLoader;
0.000414,1,0.000414,XSLoader::load();
0.000000,0,0.000000,}
0.000000,0,0.000000,# else we're miniperl
0.000000,0,0.000000,# We need to work for miniperl, because the XS toolchain uses Text::Wrap, which
0.000000,0,0.000000,# uses re 'taint'.
0.000000,0,0.000000,
0.000000,0,0.000000,sub _load_unload {
0.000000,0,0.000000,my ($on)= @_;
0.000000,0,0.000000,if ($on) {
0.000000,0,0.000000,# We call install() every time, as if we didn't, we wouldn't
0.000000,0,0.000000,# "see" any changes to the color environment var since
0.000000,0,0.000000,# the last time it was called.
0.000000,0,0.000000,
0.000000,0,0.000000,# install() returns an integer, which if casted properly
0.000000,0,0.000000,# in C resolves to a structure containing the regexp
0.000000,0,0.000000,# hooks. Setting it to a random integer will guarantee
0.000000,0,0.000000,# segfaults.
0.000000,0,0.000000,$^H{regcomp} = install();
0.000000,0,0.000000,} else {
0.000000,0,0.000000,delete $^H{regcomp};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub bits {
0.000000,0,0.000000,my $on = shift;
0.000000,0,0.000000,my $bits = 0;
0.000000,0,0.000000,my $turning_all_off = ! @_ && ! $on;
0.000000,0,0.000000,my $seen_Debug = 0;
0.000000,0,0.000000,my $seen_debug = 0;
0.000000,0,0.000000,if ($turning_all_off) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Pretend were called with certain parameters, which are best dealt
0.000000,0,0.000000,# with that way.
0.000000,0,0.000000,push @_, keys %bitmask; # taint and eval
0.000000,0,0.000000,push @_, 'strict';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Process each subpragma parameter
0.000000,0,0.000000,ARG:
0.000000,0,0.000000,foreach my $idx (0..$#_){
0.000000,0,0.000000,my $s=$_[$idx];
0.000000,0,0.000000,if ($s eq 'Debug' or $s eq 'Debugcolor') {
0.000000,0,0.000000,if (! $seen_Debug) {
0.000000,0,0.000000,$seen_Debug = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,# Reset to nothing, and then add what follows.  $seen_Debug
0.000000,0,0.000000,# allows, though unlikely someone would do it, more than one
0.000000,0,0.000000,# Debug and flags in the arguments
0.000000,0,0.000000,${^RE_DEBUG_FLAGS} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,setcolor() if $s =~/color/i;
0.000000,0,0.000000,for my $idx ($idx+1..$#_) {
0.000000,0,0.000000,if ($flags{$_[$idx]}) {
0.000000,0,0.000000,if ($on) {
0.000000,0,0.000000,${^RE_DEBUG_FLAGS} |= $flags{$_[$idx]};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,${^RE_DEBUG_FLAGS} &= ~ $flags{$_[$idx]};
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::carp("Unknown \"re\" Debug flag '$_[$idx]', possible flags: ",
0.000000,0,0.000000,join(", ",sort keys %flags ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,_load_unload($on ? 1 : ${^RE_DEBUG_FLAGS});
0.000000,0,0.000000,last;
0.000000,0,0.000000,} elsif ($s eq 'debug' or $s eq 'debugcolor') {
0.000000,0,0.000000,
0.000000,0,0.000000,# These default flags should be kept in sync with the same values
0.000000,0,0.000000,# in regcomp.h
0.000000,0,0.000000,${^RE_DEBUG_FLAGS} = $flags{'EXECUTE'} | $flags{'DUMP'};
0.000000,0,0.000000,setcolor() if $s =~/color/i;
0.000000,0,0.000000,_load_unload($on);
0.000000,0,0.000000,$seen_debug = 1;
0.000000,0,0.000000,} elsif (exists $bitmask{$s}) {
0.000000,0,0.000000,$bits |= $bitmask{$s};
0.000000,0,0.000000,} elsif ($EXPORT_OK{$s}) {
0.000000,0,0.000000,require Exporter;
0.000000,0,0.000000,re->export_to_level(2, 're', $s);
0.000000,0,0.000000,} elsif ($s eq 'strict') {
0.000000,0,0.000000,if ($on) {
0.000000,0,0.000000,$^H{reflags} |= $reflags{$s};
0.000000,0,0.000000,warnings::warnif('experimental::re_strict',
0.000000,0,0.000000,"\"use re 'strict'\" is experimental");
0.000000,0,0.000000,
0.000000,0,0.000000,# Turn on warnings if not already done.
0.000000,0,0.000000,if (! warnings::enabled('regexp')) {
0.000000,0,0.000000,require warnings;
0.000000,0,0.000000,warnings->import('regexp');
0.000000,0,0.000000,$^H{re_strict} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$^H{reflags} &= ~$reflags{$s} if $^H{reflags};
0.000000,0,0.000000,
0.000000,0,0.000000,# Turn off warnings if we turned them on.
0.000000,0,0.000000,warnings->unimport('regexp') if $^H{re_strict};
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($^H{reflags}) {
0.000000,0,0.000000,$^H |= $flags_hint;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$^H &= ~$flags_hint;
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif ($s =~ s/^\///) {
0.000000,0,0.000000,my $reflags = $^H{reflags} || 0;
0.000000,0,0.000000,my $seen_charset;
0.000000,0,0.000000,my $x_count = 0;
0.000000,0,0.000000,while ($s =~ m/( . )/gx) {
0.000000,0,0.000000,local $_ = $1;
0.000000,0,0.000000,if (/[adul]/) {
0.000000,0,0.000000,# The 'a' may be repeated; hide this from the rest of the
0.000000,0,0.000000,# code by counting and getting rid of all of them, then
0.000000,0,0.000000,# changing to 'aa' if there is a repeat.
0.000000,0,0.000000,if ($_ eq 'a') {
0.000000,0,0.000000,my $sav_pos = pos $s;
0.000000,0,0.000000,my $a_count = $s =~ s/a//g;
0.000000,0,0.000000,pos $s = $sav_pos - 1;  # -1 because got rid of the 'a'
0.000000,0,0.000000,if ($a_count > 2) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::carp(
0.000000,0,0.000000,qq 'The "a" flag may only appear a maximum of twice'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($a_count == 2) {
0.000000,0,0.000000,$_ = 'aa';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($on) {
0.000000,0,0.000000,if ($seen_charset) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,if ($seen_charset ne $_) {
0.000000,0,0.000000,Carp::carp(
0.000000,0,0.000000,qq 'The "$seen_charset" and "$_" flags '
0.000000,0,0.000000,.qq 'are exclusive'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Carp::carp(
0.000000,0,0.000000,qq 'The "$seen_charset" flag may not appear '
0.000000,0,0.000000,.qq 'twice'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$^H{reflags_charset} = $reflags{$_};
0.000000,0,0.000000,$seen_charset = $_;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,delete $^H{reflags_charset}
0.000000,0,0.000000,if defined $^H{reflags_charset}
0.000000,0,0.000000,&& $^H{reflags_charset} == $reflags{$_};
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif (exists $reflags{$_}) {
0.000000,0,0.000000,if ($_ eq 'x') {
0.000000,0,0.000000,$x_count++;
0.000000,0,0.000000,if ($x_count > 2) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::carp(
0.000000,0,0.000000,qq 'The "x" flag may only appear a maximum of twice'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($x_count == 2) {
0.000000,0,0.000000,$_ = 'xx';  # First time through got the /x
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$on
0.000000,0,0.000000,? $reflags |= $reflags{$_}
0.000000,0,0.000000,: ($reflags &= ~$reflags{$_});
0.000000,0,0.000000,} else {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::carp(
0.000000,0,0.000000,qq'Unknown regular expression flag "$_"'
0.000000,0,0.000000,);
0.000000,0,0.000000,next ARG;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,($^H{reflags} = $reflags or defined $^H{reflags_charset})
0.000000,0,0.000000,? $^H |= $flags_hint
0.000000,0,0.000000,: ($^H &= ~$flags_hint);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,if ($seen_debug && defined $flags{$s}) {
0.000000,0,0.000000,Carp::carp("Use \"Debug\" not \"debug\", to list debug types"
0.000000,0,0.000000,. " in \"re\".  \"$s\" ignored");
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Carp::carp("Unknown \"re\" subpragma '$s' (known ones are: ",
0.000000,0,0.000000,join(', ', map {qq('$_')} 'debug', 'debugcolor', sort keys %bitmask),
0.000000,0,0.000000,")");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($turning_all_off) {
0.000000,0,0.000000,_load_unload(0);
0.000000,0,0.000000,$^H{reflags} = 0;
0.000000,0,0.000000,$^H{reflags_charset} = 0;
0.000000,0,0.000000,$^H &= ~$flags_hint;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$bits;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,$^H |= bits(1, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unimport {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,$^H &= ~ bits(0, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000015,1,0.000015,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
