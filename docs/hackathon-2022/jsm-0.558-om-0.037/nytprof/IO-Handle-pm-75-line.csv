# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package IO::Handle;
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,IO::Handle - supply object methods for I/O handles
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use IO::Handle;
0.000000,0,0.000000,
0.000000,0,0.000000,$io = IO::Handle->new();
0.000000,0,0.000000,if ($io->fdopen(fileno(STDIN),"r")) {
0.000000,0,0.000000,print $io->getline;
0.000000,0,0.000000,$io->close;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$io = IO::Handle->new();
0.000000,0,0.000000,if ($io->fdopen(fileno(STDOUT),"w")) {
0.000000,0,0.000000,$io->print("Some text\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# setvbuf is not available by default on Perls 5.8.0 and later.
0.000000,0,0.000000,use IO::Handle '_IOLBF';
0.000000,0,0.000000,$io->setvbuf($buffer_var, _IOLBF, 1024);
0.000000,0,0.000000,
0.000000,0,0.000000,undef $io;       # automatically closes the file if it's open
0.000000,0,0.000000,
0.000000,0,0.000000,autoflush STDOUT 1;
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,C<IO::Handle> is the base class for all other IO handle classes. It is
0.000000,0,0.000000,not intended that objects of C<IO::Handle> would be created directly,
0.000000,0,0.000000,but instead C<IO::Handle> is inherited from by several other classes
0.000000,0,0.000000,in the IO hierarchy.
0.000000,0,0.000000,
0.000000,0,0.000000,If you are reading this documentation, looking for a replacement for
0.000000,0,0.000000,the C<FileHandle> package, then I suggest you read the documentation
0.000000,0,0.000000,for C<IO::File> too.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 CONSTRUCTOR
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item new ()
0.000000,0,0.000000,
0.000000,0,0.000000,Creates a new C<IO::Handle> object.
0.000000,0,0.000000,
0.000000,0,0.000000,=item new_from_fd ( FD, MODE )
0.000000,0,0.000000,
0.000000,0,0.000000,Creates an C<IO::Handle> like C<new> does.
0.000000,0,0.000000,It requires two parameters, which are passed to the method C<fdopen>;
0.000000,0,0.000000,if the fdopen fails, the object is destroyed. Otherwise, it is returned
0.000000,0,0.000000,to the caller.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 METHODS
0.000000,0,0.000000,
0.000000,0,0.000000,See L<perlfunc> for complete descriptions of each of the following
0.000000,0,0.000000,supported C<IO::Handle> methods, which are just front ends for the
0.000000,0,0.000000,corresponding built-in functions:
0.000000,0,0.000000,
0.000000,0,0.000000,$io->close
0.000000,0,0.000000,$io->eof
0.000000,0,0.000000,$io->fcntl( FUNCTION, SCALAR )
0.000000,0,0.000000,$io->fileno
0.000000,0,0.000000,$io->format_write( [FORMAT_NAME] )
0.000000,0,0.000000,$io->getc
0.000000,0,0.000000,$io->ioctl( FUNCTION, SCALAR )
0.000000,0,0.000000,$io->read ( BUF, LEN, [OFFSET] )
0.000000,0,0.000000,$io->print ( ARGS )
0.000000,0,0.000000,$io->printf ( FMT, [ARGS] )
0.000000,0,0.000000,$io->say ( ARGS )
0.000000,0,0.000000,$io->stat
0.000000,0,0.000000,$io->sysread ( BUF, LEN, [OFFSET] )
0.000000,0,0.000000,$io->syswrite ( BUF, [LEN, [OFFSET]] )
0.000000,0,0.000000,$io->truncate ( LEN )
0.000000,0,0.000000,
0.000000,0,0.000000,See L<perlvar> for complete descriptions of each of the following
0.000000,0,0.000000,supported C<IO::Handle> methods.  All of them return the previous
0.000000,0,0.000000,value of the attribute and takes an optional single argument that when
0.000000,0,0.000000,given will set the value.  If no argument is given the previous value
0.000000,0,0.000000,is unchanged (except for $io->autoflush will actually turn ON
0.000000,0,0.000000,autoflush by default).
0.000000,0,0.000000,
0.000000,0,0.000000,$io->autoflush ( [BOOL] )                         $|
0.000000,0,0.000000,$io->format_page_number( [NUM] )                  $%
0.000000,0,0.000000,$io->format_lines_per_page( [NUM] )               $=
0.000000,0,0.000000,$io->format_lines_left( [NUM] )                   $-
0.000000,0,0.000000,$io->format_name( [STR] )                         $~
0.000000,0,0.000000,$io->format_top_name( [STR] )                     $^
0.000000,0,0.000000,$io->input_line_number( [NUM])                    $.
0.000000,0,0.000000,
0.000000,0,0.000000,The following methods are not supported on a per-filehandle basis.
0.000000,0,0.000000,
0.000000,0,0.000000,IO::Handle->format_line_break_characters( [STR] ) $:
0.000000,0,0.000000,IO::Handle->format_formfeed( [STR])               $^L
0.000000,0,0.000000,IO::Handle->output_field_separator( [STR] )       $,
0.000000,0,0.000000,IO::Handle->output_record_separator( [STR] )      $\
0.000000,0,0.000000,
0.000000,0,0.000000,IO::Handle->input_record_separator( [STR] )       $/
0.000000,0,0.000000,
0.000000,0,0.000000,Furthermore, for doing normal I/O you might need these:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item $io->fdopen ( FD, MODE )
0.000000,0,0.000000,
0.000000,0,0.000000,C<fdopen> is like an ordinary C<open> except that its first parameter
0.000000,0,0.000000,is not a filename but rather a file handle name, an IO::Handle object,
0.000000,0,0.000000,or a file descriptor number.  (For the documentation of the C<open>
0.000000,0,0.000000,method, see L<IO::File>.)
0.000000,0,0.000000,
0.000000,0,0.000000,=item $io->opened
0.000000,0,0.000000,
0.000000,0,0.000000,Returns true if the object is currently a valid file descriptor, false
0.000000,0,0.000000,otherwise.
0.000000,0,0.000000,
0.000000,0,0.000000,=item $io->getline
0.000000,0,0.000000,
0.000000,0,0.000000,This works like <$io> described in L<perlop/"I/O Operators">
0.000000,0,0.000000,except that it's more readable and can be safely called in a
0.000000,0,0.000000,list context but still returns just one line.  If used as the conditional
0.000000,0,0.000000,within a C<while> or C-style C<for> loop, however, you will need to
0.000000,0,0.000000,emulate the functionality of <$io> with C<< defined($_ = $io->getline) >>.
0.000000,0,0.000000,
0.000000,0,0.000000,=item $io->getlines
0.000000,0,0.000000,
0.000000,0,0.000000,This works like <$io> when called in a list context to read all
0.000000,0,0.000000,the remaining lines in a file, except that it's more readable.
0.000000,0,0.000000,It will also croak() if accidentally called in a scalar context.
0.000000,0,0.000000,
0.000000,0,0.000000,=item $io->ungetc ( ORD )
0.000000,0,0.000000,
0.000000,0,0.000000,Pushes a character with the given ordinal value back onto the given
0.000000,0,0.000000,handle's input stream.  Only one character of pushback per handle is
0.000000,0,0.000000,guaranteed.
0.000000,0,0.000000,
0.000000,0,0.000000,=item $io->write ( BUF, LEN [, OFFSET ] )
0.000000,0,0.000000,
0.000000,0,0.000000,This C<write> is somewhat like C<write> found in C, in that it is the
0.000000,0,0.000000,opposite of read. The wrapper for the perl C<write> function is
0.000000,0,0.000000,called C<format_write>. However, whilst the C C<write> function returns
0.000000,0,0.000000,the number of bytes written, this C<write> function simply returns true
0.000000,0,0.000000,if successful (like C<print>). A more C-like C<write> is C<syswrite>
0.000000,0,0.000000,(see above).
0.000000,0,0.000000,
0.000000,0,0.000000,=item $io->error
0.000000,0,0.000000,
0.000000,0,0.000000,Returns a true value if the given handle has experienced any errors
0.000000,0,0.000000,since it was opened or since the last call to C<clearerr>, or if the
0.000000,0,0.000000,handle is invalid. It only returns false for a valid handle with no
0.000000,0,0.000000,outstanding errors.
0.000000,0,0.000000,
0.000000,0,0.000000,=item $io->clearerr
0.000000,0,0.000000,
0.000000,0,0.000000,Clear the given handle's error indicator. Returns -1 if the handle is
0.000000,0,0.000000,invalid, 0 otherwise.
0.000000,0,0.000000,
0.000000,0,0.000000,=item $io->sync
0.000000,0,0.000000,
0.000000,0,0.000000,C<sync> synchronizes a file's in-memory state  with  that  on the
0.000000,0,0.000000,physical medium. C<sync> does not operate at the perlio api level, but
0.000000,0,0.000000,operates on the file descriptor (similar to sysread, sysseek and
0.000000,0,0.000000,systell). This means that any data held at the perlio api level will not
0.000000,0,0.000000,be synchronized. To synchronize data that is buffered at the perlio api
0.000000,0,0.000000,level you must use the flush method. C<sync> is not implemented on all
0.000000,0,0.000000,platforms. Returns "0 but true" on success, C<undef> on error, C<undef>
0.000000,0,0.000000,for an invalid handle. See L<fsync(3c)>.
0.000000,0,0.000000,
0.000000,0,0.000000,=item $io->flush
0.000000,0,0.000000,
0.000000,0,0.000000,C<flush> causes perl to flush any buffered data at the perlio api level.
0.000000,0,0.000000,Any unread data in the buffer will be discarded, and any unwritten data
0.000000,0,0.000000,will be written to the underlying file descriptor. Returns "0 but true"
0.000000,0,0.000000,on success, C<undef> on error.
0.000000,0,0.000000,
0.000000,0,0.000000,=item $io->printflush ( ARGS )
0.000000,0,0.000000,
0.000000,0,0.000000,Turns on autoflush, print ARGS and then restores the autoflush status of the
0.000000,0,0.000000,C<IO::Handle> object. Returns the return value from print.
0.000000,0,0.000000,
0.000000,0,0.000000,=item $io->blocking ( [ BOOL ] )
0.000000,0,0.000000,
0.000000,0,0.000000,If called with an argument C<blocking> will turn on non-blocking IO if
0.000000,0,0.000000,C<BOOL> is false, and turn it off if C<BOOL> is true.
0.000000,0,0.000000,
0.000000,0,0.000000,C<blocking> will return the value of the previous setting, or the
0.000000,0,0.000000,current setting if C<BOOL> is not given. 
0.000000,0,0.000000,
0.000000,0,0.000000,If an error occurs C<blocking> will return undef and C<$!> will be set.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,If the C functions setbuf() and/or setvbuf() are available, then
0.000000,0,0.000000,C<IO::Handle::setbuf> and C<IO::Handle::setvbuf> set the buffering
0.000000,0,0.000000,policy for an IO::Handle.  The calling sequences for the Perl functions
0.000000,0,0.000000,are the same as their C counterparts--including the constants C<_IOFBF>,
0.000000,0,0.000000,C<_IOLBF>, and C<_IONBF> for setvbuf()--except that the buffer parameter
0.000000,0,0.000000,specifies a scalar variable to use as a buffer. You should only
0.000000,0,0.000000,change the buffer before any I/O, or immediately after calling flush.
0.000000,0,0.000000,
0.000000,0,0.000000,WARNING: The IO::Handle::setvbuf() is not available by default on
0.000000,0,0.000000,Perls 5.8.0 and later because setvbuf() is rather specific to using
0.000000,0,0.000000,the stdio library, while Perl prefers the new perlio subsystem instead.
0.000000,0,0.000000,
0.000000,0,0.000000,WARNING: A variable used as a buffer by C<setbuf> or C<setvbuf> B<must not
0.000000,0,0.000000,be modified> in any way until the IO::Handle is closed or C<setbuf> or
0.000000,0,0.000000,C<setvbuf> is called again, or memory corruption may result! Remember that
0.000000,0,0.000000,the order of global destruction is undefined, so even if your buffer
0.000000,0,0.000000,variable remains in scope until program termination, it may be undefined
0.000000,0,0.000000,before the file IO::Handle is closed. Note that you need to import the
0.000000,0,0.000000,constants C<_IOFBF>, C<_IOLBF>, and C<_IONBF> explicitly. Like C, setbuf
0.000000,0,0.000000,returns nothing. setvbuf returns "0 but true", on success, C<undef> on
0.000000,0,0.000000,failure.
0.000000,0,0.000000,
0.000000,0,0.000000,Lastly, there is a special method for working under B<-T> and setuid/gid
0.000000,0,0.000000,scripts:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item $io->untaint
0.000000,0,0.000000,
0.000000,0,0.000000,Marks the object as taint-clean, and as such data read from it will also
0.000000,0,0.000000,be considered taint-clean. Note that this is a very trusting action to
0.000000,0,0.000000,take, and appropriate consideration for the data source and potential
0.000000,0,0.000000,vulnerability should be kept in mind. Returns 0 on success, -1 if setting
0.000000,0,0.000000,the taint-clean flag failed. (eg invalid handle)
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NOTE
0.000000,0,0.000000,
0.000000,0,0.000000,An C<IO::Handle> object is a reference to a symbol/GLOB reference (see
0.000000,0,0.000000,the C<Symbol> package).  Some modules that
0.000000,0,0.000000,inherit from C<IO::Handle> may want to keep object related variables
0.000000,0,0.000000,in the hash table part of the GLOB. In an attempt to prevent modules
0.000000,0,0.000000,trampling on each other I propose the that any such module should prefix
0.000000,0,0.000000,its variables with its own name separated by _'s. For example the IO::Socket
0.000000,0,0.000000,module keeps a C<timeout> variable in 'io_socket_timeout'.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,L<perlfunc>, 
0.000000,0,0.000000,L<perlop/"I/O Operators">,
0.000000,0,0.000000,L<IO::File>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 BUGS
0.000000,0,0.000000,
0.000000,0,0.000000,Due to backwards compatibility, all filehandles resemble objects
0.000000,0,0.000000,of class C<IO::Handle>, or actually classes derived from that class.
0.000000,0,0.000000,They actually aren't.  Which means you can't derive your own 
0.000000,0,0.000000,class from C<IO::Handle> and inherit those methods.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 HISTORY
0.000000,0,0.000000,
0.000000,0,0.000000,Derived from FileHandle.pm by Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000040,2,0.000020,use 5.008_001;
0.000021,2,0.000010,use strict;
0.000026,2,0.000013,use Carp;
0.000016,2,0.000008,use Symbol;
0.000027,2,0.000013,use SelectSaver;
0.001682,2,0.000841,use IO ();	# Load the XS module
0.000000,0,0.000000,
0.000002,1,0.000002,require Exporter;
0.000016,1,0.000016,our @ISA = qw(Exporter);
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = "1.48";
0.000000,0,0.000000,
0.000003,1,0.000003,our @EXPORT_OK = qw(
0.000000,0,0.000000,autoflush
0.000000,0,0.000000,output_field_separator
0.000000,0,0.000000,output_record_separator
0.000000,0,0.000000,input_record_separator
0.000000,0,0.000000,input_line_number
0.000000,0,0.000000,format_page_number
0.000000,0,0.000000,format_lines_per_page
0.000000,0,0.000000,format_lines_left
0.000000,0,0.000000,format_name
0.000000,0,0.000000,format_top_name
0.000000,0,0.000000,format_line_break_characters
0.000000,0,0.000000,format_formfeed
0.000000,0,0.000000,format_write
0.000000,0,0.000000,
0.000000,0,0.000000,print
0.000000,0,0.000000,printf
0.000000,0,0.000000,say
0.000000,0,0.000000,getline
0.000000,0,0.000000,getlines
0.000000,0,0.000000,
0.000000,0,0.000000,printflush
0.000000,0,0.000000,flush
0.000000,0,0.000000,
0.000000,0,0.000000,SEEK_SET
0.000000,0,0.000000,SEEK_CUR
0.000000,0,0.000000,SEEK_END
0.000000,0,0.000000,_IOFBF
0.000000,0,0.000000,_IOLBF
0.000000,0,0.000000,_IONBF
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,################################################
0.000000,0,0.000000,## Constructors, destructors.
0.000000,0,0.000000,##
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my $class = ref($_[0]) || $_[0] || "IO::Handle";
0.000000,0,0.000000,if (@_ != 1) {
0.000000,0,0.000000,# Since perl will automatically require IO::File if needed, but
0.000000,0,0.000000,# also initialises IO::File's @ISA as part of the core we must
0.000000,0,0.000000,# ensure IO::File is loaded if IO::Handle is. This avoids effect-
0.000000,0,0.000000,# ively "half-loading" IO::File.
0.000000,0,0.000000,if ($] > 5.013 && $class eq 'IO::File' && !$INC{"IO/File.pm"}) {
0.000000,0,0.000000,require IO::File;
0.000000,0,0.000000,shift;
0.000000,0,0.000000,return IO::File::->new(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,croak "usage: $class->new()";
0.000000,0,0.000000,}
0.000000,0,0.000000,my $io = gensym;
0.000000,0,0.000000,bless $io, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub new_from_fd {
0.000000,0,0.000000,my $class = ref($_[0]) || $_[0] || "IO::Handle";
0.000000,0,0.000000,@_ == 3 or croak "usage: $class->new_from_fd(FD, MODE)";
0.000000,0,0.000000,my $io = gensym;
0.000000,0,0.000000,shift;
0.000000,0,0.000000,IO::Handle::fdopen($io, @_)
0.000000,0,0.000000,or return undef;
0.000000,0,0.000000,bless $io, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# There is no need for DESTROY to do anything, because when the
0.000000,0,0.000000,# last reference to an IO object is gone, Perl automatically
0.000000,0,0.000000,# closes its associated files (if any).  However, to avoid any
0.000000,0,0.000000,# attempts to autoload DESTROY, we here define it to do nothing.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub DESTROY {}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,################################################
0.000000,0,0.000000,## Open and close.
0.000000,0,0.000000,##
0.000000,0,0.000000,
0.000000,0,0.000000,sub _open_mode_string {
0.000000,0,0.000000,my ($mode) = @_;
0.000000,0,0.000000,$mode =~ /^\+?(<|>>?)$/
0.000000,0,0.000000,or $mode =~ s/^r(\+?)$/$1</
0.000000,0,0.000000,or $mode =~ s/^w(\+?)$/$1>/
0.000000,0,0.000000,or $mode =~ s/^a(\+?)$/$1>>/
0.000000,0,0.000000,or croak "IO::Handle: bad open mode: $mode";
0.000000,0,0.000000,$mode;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fdopen {
0.000000,0,0.000000,@_ == 3 or croak 'usage: $io->fdopen(FD, MODE)';
0.000000,0,0.000000,my ($io, $fd, $mode) = @_;
0.000000,0,0.000000,local(*GLOB);
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref($fd) && "$fd" =~ /GLOB\(/o) {
0.000000,0,0.000000,# It's a glob reference; Alias it as we cannot get name of anon GLOBs
0.000000,0,0.000000,my $n = qualify(*GLOB);
0.000000,0,0.000000,*GLOB = *{*$fd};
0.000000,0,0.000000,$fd =  $n;
0.000000,0,0.000000,} elsif ($fd =~ m#^\d+$#) {
0.000000,0,0.000000,# It's an FD number; prefix with "=".
0.000000,0,0.000000,$fd = "=$fd";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,open($io, _open_mode_string($mode) . '&' . $fd)
0.000000,0,0.000000,? $io : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub close {
0.000000,0,0.000000,@_ == 1 or croak 'usage: $io->close()';
0.000000,0,0.000000,my($io) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,close($io);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,################################################
0.000000,0,0.000000,## Normal I/O functions.
0.000000,0,0.000000,##
0.000000,0,0.000000,
0.000000,0,0.000000,# flock
0.000000,0,0.000000,# select
0.000000,0,0.000000,
0.000000,0,0.000000,sub opened {
0.000000,0,0.000000,@_ == 1 or croak 'usage: $io->opened()';
0.000000,0,0.000000,defined fileno($_[0]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fileno {
0.000000,0,0.000000,@_ == 1 or croak 'usage: $io->fileno()';
0.000000,0,0.000000,fileno($_[0]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getc {
0.000000,0,0.000000,@_ == 1 or croak 'usage: $io->getc()';
0.000000,0,0.000000,getc($_[0]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub eof {
0.000000,0,0.000000,@_ == 1 or croak 'usage: $io->eof()';
0.000000,0,0.000000,eof($_[0]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub print {
0.000000,0,0.000000,@_ or croak 'usage: $io->print(ARGS)';
0.000000,0,0.000000,my $this = shift;
0.000000,0,0.000000,print $this @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub printf {
0.000000,0,0.000000,@_ >= 2 or croak 'usage: $io->printf(FMT,[ARGS])';
0.000000,0,0.000000,my $this = shift;
0.000000,0,0.000000,printf $this @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub say {
0.000000,0,0.000000,@_ or croak 'usage: $io->say(ARGS)';
0.000000,0,0.000000,my $this = shift;
0.000000,0,0.000000,local $\ = "\n";
0.000000,0,0.000000,print $this @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub truncate {
0.000000,0,0.000000,@_ == 2 or croak 'usage: $io->truncate(LEN)';
0.000000,0,0.000000,truncate($_[0], $_[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub read {
0.000000,0,0.000000,@_ == 3 || @_ == 4 or croak 'usage: $io->read(BUF, LEN [, OFFSET])';
0.000000,0,0.000000,read($_[0], $_[1], $_[2], $_[3] || 0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sysread {
0.000000,0,0.000000,@_ == 3 || @_ == 4 or croak 'usage: $io->sysread(BUF, LEN [, OFFSET])';
0.000000,0,0.000000,sysread($_[0], $_[1], $_[2], $_[3] || 0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub write {
0.000000,0,0.000000,@_ >= 2 && @_ <= 4 or croak 'usage: $io->write(BUF [, LEN [, OFFSET]])';
0.000000,0,0.000000,local($\) = "";
0.000000,0,0.000000,$_[2] = length($_[1]) unless defined $_[2];
0.000000,0,0.000000,print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub syswrite {
0.000000,0,0.000000,@_ >= 2 && @_ <= 4 or croak 'usage: $io->syswrite(BUF [, LEN [, OFFSET]])';
0.000000,0,0.000000,if (defined($_[2])) {
0.000000,0,0.000000,syswrite($_[0], $_[1], $_[2], $_[3] || 0);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,syswrite($_[0], $_[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub stat {
0.000000,0,0.000000,@_ == 1 or croak 'usage: $io->stat()';
0.000000,0,0.000000,stat($_[0]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,################################################
0.000000,0,0.000000,## State modification functions.
0.000000,0,0.000000,##
0.000000,0,0.000000,
0.000000,0,0.000000,sub autoflush {
0.000000,0,0.000000,my $old = SelectSaver->new(qualify($_[0], caller));
0.000000,0,0.000000,my $prev = $|;
0.000000,0,0.000000,$| = @_ > 1 ? $_[1] : 1;
0.000000,0,0.000000,$prev;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub output_field_separator {
0.000000,0,0.000000,carp "output_field_separator is not supported on a per-handle basis"
0.000000,0,0.000000,if ref($_[0]);
0.000000,0,0.000000,my $prev = $,;
0.000000,0,0.000000,$, = $_[1] if @_ > 1;
0.000000,0,0.000000,$prev;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub output_record_separator {
0.000000,0,0.000000,carp "output_record_separator is not supported on a per-handle basis"
0.000000,0,0.000000,if ref($_[0]);
0.000000,0,0.000000,my $prev = $\;
0.000000,0,0.000000,$\ = $_[1] if @_ > 1;
0.000000,0,0.000000,$prev;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub input_record_separator {
0.000000,0,0.000000,carp "input_record_separator is not supported on a per-handle basis"
0.000000,0,0.000000,if ref($_[0]);
0.000000,0,0.000000,my $prev = $/;
0.000000,0,0.000000,$/ = $_[1] if @_ > 1;
0.000000,0,0.000000,$prev;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub input_line_number {
0.000000,0,0.000000,local $.;
0.000000,0,0.000000,() = tell qualify($_[0], caller) if ref($_[0]);
0.000000,0,0.000000,my $prev = $.;
0.000000,0,0.000000,$. = $_[1] if @_ > 1;
0.000000,0,0.000000,$prev;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub format_page_number {
0.000000,0,0.000000,my $old;
0.000000,0,0.000000,$old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
0.000000,0,0.000000,my $prev = $%;
0.000000,0,0.000000,$% = $_[1] if @_ > 1;
0.000000,0,0.000000,$prev;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub format_lines_per_page {
0.000000,0,0.000000,my $old;
0.000000,0,0.000000,$old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
0.000000,0,0.000000,my $prev = $=;
0.000000,0,0.000000,$= = $_[1] if @_ > 1;
0.000000,0,0.000000,$prev;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub format_lines_left {
0.000000,0,0.000000,my $old;
0.000000,0,0.000000,$old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
0.000000,0,0.000000,my $prev = $-;
0.000000,0,0.000000,$- = $_[1] if @_ > 1;
0.000000,0,0.000000,$prev;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub format_name {
0.000000,0,0.000000,my $old;
0.000000,0,0.000000,$old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
0.000000,0,0.000000,my $prev = $~;
0.000000,0,0.000000,$~ = qualify($_[1], caller) if @_ > 1;
0.000000,0,0.000000,$prev;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub format_top_name {
0.000000,0,0.000000,my $old;
0.000000,0,0.000000,$old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
0.000000,0,0.000000,my $prev = $^;
0.000000,0,0.000000,$^ = qualify($_[1], caller) if @_ > 1;
0.000000,0,0.000000,$prev;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub format_line_break_characters {
0.000000,0,0.000000,carp "format_line_break_characters is not supported on a per-handle basis"
0.000000,0,0.000000,if ref($_[0]);
0.000000,0,0.000000,my $prev = $:;
0.000000,0,0.000000,$: = $_[1] if @_ > 1;
0.000000,0,0.000000,$prev;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub format_formfeed {
0.000000,0,0.000000,carp "format_formfeed is not supported on a per-handle basis"
0.000000,0,0.000000,if ref($_[0]);
0.000000,0,0.000000,my $prev = $^L;
0.000000,0,0.000000,$^L = $_[1] if @_ > 1;
0.000000,0,0.000000,$prev;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub formline {
0.000000,0,0.000000,my $io = shift;
0.000000,0,0.000000,my $picture = shift;
0.000000,0,0.000000,local($^A) = $^A;
0.000000,0,0.000000,local($\) = "";
0.000000,0,0.000000,formline($picture, @_);
0.000000,0,0.000000,print $io $^A;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub format_write {
0.000000,0,0.000000,@_ < 3 || croak 'usage: $io->write( [FORMAT_NAME] )';
0.000000,0,0.000000,if (@_ == 2) {
0.000000,0,0.000000,my ($io, $fmt) = @_;
0.000000,0,0.000000,my $oldfmt = $io->format_name(qualify($fmt,caller));
0.000000,0,0.000000,CORE::write($io);
0.000000,0,0.000000,$io->format_name($oldfmt);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,CORE::write($_[0]);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fcntl {
0.000000,0,0.000000,@_ == 3 || croak 'usage: $io->fcntl( OP, VALUE );';
0.000000,0,0.000000,my ($io, $op) = @_;
0.000000,0,0.000000,return fcntl($io, $op, $_[2]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ioctl {
0.000000,0,0.000000,@_ == 3 || croak 'usage: $io->ioctl( OP, VALUE );';
0.000000,0,0.000000,my ($io, $op) = @_;
0.000000,0,0.000000,return ioctl($io, $op, $_[2]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# this sub is for compatibility with older releases of IO that used
0.000000,0,0.000000,# a sub called constant to determine if a constant existed -- GMB
0.000000,0,0.000000,#
0.000000,0,0.000000,# The SEEK_* and _IO?BF constants were the only constants at that time
0.000000,0,0.000000,# any new code should just check defined(&CONSTANT_NAME)
0.000000,0,0.000000,
0.000000,0,0.000000,sub constant {
0.000321,2,0.000160,no strict 'refs';
0.000000,0,0.000000,my $name = shift;
0.000000,0,0.000000,(($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})
0.000000,0,0.000000,? &{$name}() : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# so that flush.pl can be deprecated
0.000000,0,0.000000,
0.000000,0,0.000000,sub printflush {
0.000000,0,0.000000,my $io = shift;
0.000000,0,0.000000,my $old;
0.000000,0,0.000000,$old = SelectSaver->new(qualify($io, caller)) if ref($io);
0.000000,0,0.000000,local $| = 1;
0.000000,0,0.000000,if(ref($io)) {
0.000000,0,0.000000,print $io @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,print @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,1;
