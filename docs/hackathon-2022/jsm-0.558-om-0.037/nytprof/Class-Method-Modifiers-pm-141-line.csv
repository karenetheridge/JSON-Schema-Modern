# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000051,2,0.000025,use strict;
0.000056,2,0.000028,use warnings;
0.000000,0,0.000000,package Class::Method::Modifiers; # git description: v2.12-17-gbc38636
0.000000,0,0.000000,# ABSTRACT: Provides Moose-like method modifiers
0.000000,0,0.000000,# KEYWORDS: method wrap modification patch
0.000000,0,0.000000,# vim: set ts=8 sts=4 sw=4 tw=115 et :
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '2.13';
0.000000,0,0.000000,
0.000108,2,0.000054,use base 'Exporter';
0.000000,0,0.000000,
0.000001,1,0.000001,our @EXPORT = qw(before after around);
0.000000,1,0.000000,our @EXPORT_OK = (@EXPORT, qw(fresh install_modifier));
0.000003,1,0.000003,our %EXPORT_TAGS = (
0.000000,0,0.000000,moose => [qw(before after around)],
0.000000,0,0.000000,all   => \@EXPORT_OK,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000005,1,0.000005,*_HAS_READONLY = $] >= 5.008 ? sub(){1} : sub(){0};
0.000185,1,0.000185,}
0.000000,0,0.000000,
0.000000,0,0.000000,our %MODIFIER_CACHE;
0.000000,0,0.000000,
0.000000,0,0.000000,# for backward compatibility
0.000000,0,0.000000,sub _install_modifier; # -w
0.000002,1,0.000002,*_install_modifier = \&install_modifier;
0.000000,0,0.000000,
0.000000,0,0.000000,sub install_modifier {
0.000008,19,0.000000,my $into  = shift;
0.000011,19,0.000001,my $type  = shift;
0.000009,19,0.000000,my $code  = pop;
0.000007,19,0.000000,my @names = @_;
0.000000,0,0.000000,
0.000015,19,0.000001,@names = @{ $names[0] } if ref($names[0]) eq 'ARRAY';
0.000000,0,0.000000,
0.000006,19,0.000000,return _fresh($into, $code, @names) if $type eq 'fresh';
0.000000,0,0.000000,
0.000073,19,0.000004,for my $name (@names) {
0.000204,35,0.000006,my $hit = $into->can($name) or do {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::confess("The method '$name' is not found in the inheritance hierarchy for class $into");
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000021,35,0.000001,my $qualified = $into.'::'.$name;
0.000087,35,0.000002,my $cache = $MODIFIER_CACHE{$into}{$name} ||= {
0.000000,0,0.000000,before => [],
0.000000,0,0.000000,after  => [],
0.000000,0,0.000000,around => [],
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,# this must be the first modifier we're installing
0.000017,35,0.000000,if (!exists($cache->{"orig"})) {
0.000220,2,0.000110,no strict 'refs';
0.000000,0,0.000000,
0.000000,0,0.000000,# grab the original method (or undef if the method is inherited)
0.000065,35,0.000002,$cache->{"orig"} = *{$qualified}{CODE};
0.000000,0,0.000000,
0.000000,0,0.000000,# the "innermost" method, the one that "around" will ultimately wrap
0.000015,35,0.000000,$cache->{"wrapped"} = $cache->{"orig"} || $hit; #sub {
0.000000,0,0.000000,#    # we can't cache this, because new methods or modifiers may be
0.000000,0,0.000000,#    # added between now and when this method is called
0.000000,0,0.000000,#    for my $package (@{ mro::get_linear_isa($into) }) {
0.000000,0,0.000000,#        next if $package eq $into;
0.000000,0,0.000000,#        my $code = *{$package.'::'.$name}{CODE};
0.000000,0,0.000000,#        goto $code if $code;
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#    require Carp;
0.000000,0,0.000000,#    Carp::confess("$qualified\::$name disappeared?");
0.000000,0,0.000000,#};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# keep these lists in the order the modifiers are called
0.000021,35,0.000001,if ($type eq 'after') {
0.000000,0,0.000000,push @{ $cache->{$type} }, $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000025,35,0.000001,unshift @{ $cache->{$type} }, $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# wrap the method with another layer of around. much simpler than
0.000000,0,0.000000,# the Moose equivalent. :)
0.000016,35,0.000000,if ($type eq 'around') {
0.000007,12,0.000001,my $method = $cache->{wrapped};
0.000028,12,0.000002,my $attrs = _sub_attrs($code);
0.000000,0,0.000000,# a bare "sub :lvalue {...}" will be parsed as a label and an
0.000000,0,0.000000,# indirect method call. force it to be treated as an expression
0.000000,0,0.000000,# using +
0.266324,12,0.022194,$cache->{wrapped} = eval "package $into; +sub $attrs { \$code->(\$method, \@_); };";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# install our new method which dispatches the modifiers, but only
0.000000,0,0.000000,# if a new type was added
0.000051,35,0.000001,if (@{ $cache->{$type} } == 1) {
0.000000,0,0.000000,
0.000000,0,0.000000,# avoid these hash lookups every method invocation
0.000008,35,0.000000,my $before  = $cache->{"before"};
0.000005,35,0.000000,my $after   = $cache->{"after"};
0.000000,0,0.000000,
0.000000,0,0.000000,# this is a coderef that changes every new "around". so we need
0.000000,0,0.000000,# to take a reference to it. better a deref than a hash lookup
0.000011,35,0.000000,my $wrapped = \$cache->{"wrapped"};
0.000000,0,0.000000,
0.000102,35,0.000003,my $attrs = _sub_attrs($cache->{wrapped});
0.000000,0,0.000000,
0.000017,35,0.000000,my $generated = "package $into;\n";
0.000013,35,0.000000,$generated .= "sub $name $attrs {";
0.000000,0,0.000000,
0.000000,0,0.000000,# before is easy, it doesn't affect the return value(s)
0.000022,35,0.000001,if (@$before) {
0.000000,0,0.000000,$generated .= '
0.000000,0,0.000000,for my $method (@$before) {
0.000000,0,0.000000,$method->(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000016,35,0.000000,if (@$after) {
0.000000,0,0.000000,$generated .= '
0.000000,0,0.000000,my $ret;
0.000000,0,0.000000,if (wantarray) {
0.000000,0,0.000000,$ret = [$$wrapped->(@_)];
0.000000,0,0.000000,'.(_HAS_READONLY ? 'Internals::SvREADONLY(@$ret, 1);' : '').'
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (defined wantarray) {
0.000000,0,0.000000,$ret = \($$wrapped->(@_));
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$$wrapped->(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for my $method (@$after) {
0.000000,0,0.000000,$method->(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,wantarray ? @$ret : $ret ? $$ret : ();
0.000000,0,0.000000,'
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000066,35,0.000002,$generated .= '$$wrapped->(@_);';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,35,0.000000,$generated .= '}';
0.000000,0,0.000000,
0.000029,2,0.000015,no strict 'refs';
0.000019,2,0.000010,no warnings 'redefine';
0.000308,2,0.000154,no warnings 'closure';
0.236096,35,0.006746,eval $generated;
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub before {
0.000000,0,0.000000,_install_modifier(scalar(caller), 'before', @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub after {
0.000000,0,0.000000,_install_modifier(scalar(caller), 'after', @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub around {
0.000013,2,0.000007,_install_modifier(scalar(caller), 'around', @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fresh {
0.000000,0,0.000000,my $code = pop;
0.000000,0,0.000000,my @names = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,@names = @{ $names[0] } if ref($names[0]) eq 'ARRAY';
0.000000,0,0.000000,
0.000000,0,0.000000,_fresh(scalar(caller), $code, @names);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fresh {
0.000000,0,0.000000,my ($into, $code, @names) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $name (@names) {
0.000000,0,0.000000,if ($name !~ /\A [a-zA-Z_] [a-zA-Z0-9_]* \z/xms) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::confess("Invalid method name '$name'");
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($into->can($name)) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::confess("Class $into already has a method named '$name'");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# We need to make sure that the installed method has its CvNAME in
0.000000,0,0.000000,# the appropriate package; otherwise, it would be subject to
0.000000,0,0.000000,# deletion if callers use namespace::autoclean.  If $code was
0.000000,0,0.000000,# compiled in the target package, we can just install it directly;
0.000000,0,0.000000,# otherwise, we'll need a different approach.  Using Sub::Name would
0.000000,0,0.000000,# be fine in all cases, at the cost of introducing a dependency on
0.000000,0,0.000000,# an XS-using, non-core module.  So instead we'll use string-eval to
0.000000,0,0.000000,# create a new subroutine that wraps $code.
0.000000,0,0.000000,if (_is_in_package($code, $into)) {
0.000039,2,0.000019,no strict 'refs';
0.000000,0,0.000000,*{"$into\::$name"} = $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000216,2,0.000108,no warnings 'closure'; # for 5.8.x
0.000000,0,0.000000,my $attrs = _sub_attrs($code);
0.000000,0,0.000000,eval "package $into; sub $name $attrs { \$code->(\@_) }";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _sub_attrs {
0.000010,47,0.000000,my ($coderef) = @_;
0.000038,47,0.000001,local *_sub = $coderef;
0.000009,47,0.000000,local $@;
0.000000,0,0.000000,# this assignment will fail to compile if it isn't an lvalue sub.  we
0.000000,0,0.000000,# never want to actually call the sub though, so we return early.
0.002192,47,0.000047,(eval 'return 1; &_sub = 1') ? ':lvalue' : '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _is_in_package {
0.000000,0,0.000000,my ($coderef, $package) = @_;
0.000000,0,0.000000,require B;
0.000000,0,0.000000,my $cv = B::svref_2object($coderef);
0.000000,0,0.000000,return $cv->GV->STASH->NAME eq $package;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
