# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Encode::Alias;
0.000026,2,0.000013,use strict;
0.000070,2,0.000035,use warnings;
0.000023,3,0.000008,our $VERSION = do { my @r = ( q$Revision: 2.24 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
0.000024,2,0.000012,use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
0.000000,0,0.000000,
0.000553,2,0.000276,use Exporter 'import';
0.000000,0,0.000000,
0.000000,0,0.000000,# Public, encouraged API is exported by default
0.000000,0,0.000000,
0.000001,1,0.000001,our @EXPORT =
0.000000,0,0.000000,qw (
0.000000,0,0.000000,define_alias
0.000000,0,0.000000,find_alias
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,our @Alias;    # ordered matching list
0.000000,0,0.000000,our %Alias;    # cached known aliases
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_alias {
0.000001,2,0.000000,my $class = shift;
0.000001,2,0.000000,my $find  = shift;
0.000003,2,0.000002,unless ( exists $Alias{$find} ) {
0.000001,1,0.000001,$Alias{$find} = undef;    # Recursion guard
0.000003,1,0.000003,for ( my $i = 0 ; $i < @Alias ; $i += 2 ) {
0.000001,2,0.000000,my $alias = $Alias[$i];
0.000002,2,0.000001,my $val   = $Alias[ $i + 1 ];
0.000000,2,0.000000,my $new;
0.000125,2,0.000063,if ( ref($alias) eq 'Regexp' && $find =~ $alias ) {
0.000000,0,0.000000,DEBUG and warn "eval $val";
0.000100,1,0.000100,$new = eval $val;
0.000000,1,0.000000,DEBUG and $@ and warn "$val, $@";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( ref($alias) eq 'CODE' ) {
0.000000,0,0.000000,DEBUG and warn "$alias", "->", "($find)";
0.000000,0,0.000000,$new = $alias->($find);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( lc($find) eq lc($alias) ) {
0.000000,0,0.000000,$new = $val;
0.000000,0,0.000000,}
0.000003,2,0.000002,if ( defined($new) ) {
0.000024,1,0.000024,next if $new eq $find;    # avoid (direct) recursion on bugs
0.000000,0,0.000000,DEBUG and warn "$alias, $new";
0.000007,1,0.000007,my $enc =
0.000000,0,0.000000,( ref($new) ) ? $new : Encode::find_encoding($new);
0.000018,1,0.000018,if ($enc) {
0.000001,1,0.000001,$Alias{$find} = $enc;
0.000005,1,0.000005,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# case insensitive search when canonical is not in all lowercase
0.000000,0,0.000000,# RT ticket #7835
0.000001,1,0.000001,unless ( $Alias{$find} ) {
0.000000,0,0.000000,my $lcfind = lc($find);
0.000000,0,0.000000,for my $name ( keys %Encode::Encoding, keys %Encode::ExtModule )
0.000000,0,0.000000,{
0.000000,0,0.000000,$lcfind eq lc($name) or next;
0.000000,0,0.000000,$Alias{$find} = Encode::find_encoding($name);
0.000000,0,0.000000,DEBUG and warn "$find => $name";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if (DEBUG) {
0.000000,0,0.000000,my $name;
0.000000,0,0.000000,if ( my $e = $Alias{$find} ) {
0.000000,0,0.000000,$name = $e->name;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$name = "";
0.000000,0,0.000000,}
0.000000,0,0.000000,warn "find_alias($class, $find)->name = $name";
0.000000,0,0.000000,}
0.000008,2,0.000004,return $Alias{$find};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub define_alias {
0.000121,47,0.000003,while (@_) {
0.000009,56,0.000000,my $alias = shift;
0.000035,56,0.000001,my $name = shift;
0.000026,56,0.000000,unshift( @Alias, $alias => $name )    # newer one has precedence
0.000000,0,0.000000,if defined $alias;
0.000032,56,0.000001,if ( ref($alias) ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# clear %Alias cache to allow overrides
0.000008,49,0.000000,my @a = keys %Alias;
0.000018,49,0.000000,for my $k (@a) {
0.000000,0,0.000000,if ( ref($alias) eq 'Regexp' && $k =~ $alias ) {
0.000000,0,0.000000,DEBUG and warn "delete \$Alias\{$k\}";
0.000000,0,0.000000,delete $Alias{$k};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( ref($alias) eq 'CODE' && $alias->($k) ) {
0.000000,0,0.000000,DEBUG and warn "delete \$Alias\{$k\}";
0.000000,0,0.000000,delete $Alias{$k};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (defined $alias) {
0.000000,0,0.000000,DEBUG and warn "delete \$Alias\{$alias\}";
0.000001,7,0.000000,delete $Alias{$alias};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (DEBUG) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("undef \$alias");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# HACK: Encode must be used after define_alias is declarated as Encode calls define_alias
0.001435,2,0.000717,use Encode ();
0.000000,0,0.000000,
0.000000,0,0.000000,# Allow latin-1 style names as well
0.000000,0,0.000000,# 0  1  2  3  4  5   6   7   8   9  10
0.000001,1,0.000001,our @Latin2iso = ( 0, 1, 2, 3, 4, 9, 10, 13, 14, 15, 16 );
0.000000,0,0.000000,
0.000000,0,0.000000,# Allow winlatin1 style names as well
0.000007,1,0.000007,our %Winlatin2cp = (
0.000000,0,0.000000,'latin1'     => 1252,
0.000000,0,0.000000,'latin2'     => 1250,
0.000000,0,0.000000,'cyrillic'   => 1251,
0.000000,0,0.000000,'greek'      => 1253,
0.000000,0,0.000000,'turkish'    => 1254,
0.000000,0,0.000000,'hebrew'     => 1255,
0.000000,0,0.000000,'arabic'     => 1256,
0.000000,0,0.000000,'baltic'     => 1257,
0.000000,0,0.000000,'vietnamese' => 1258,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000001,1,0.000001,init_aliases();
0.000000,0,0.000000,
0.000000,0,0.000000,sub undef_aliases {
0.000001,1,0.000001,@Alias = ();
0.000004,1,0.000004,%Alias = ();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub init_aliases {
0.000000,1,0.000000,undef_aliases();
0.000000,0,0.000000,
0.000000,0,0.000000,# Try all-lower-case version should all else fails
0.000012,1,0.000012,define_alias( qr/^(.*)$/ => '"\L$1"' );
0.000000,0,0.000000,
0.000000,0,0.000000,# UTF/UCS stuff
0.000004,1,0.000004,define_alias( qr/^(unicode-1-1-)?UTF-?7$/i     => '"UTF-7"' );
0.000005,1,0.000005,define_alias( qr/^UCS-?2-?LE$/i => '"UCS-2LE"' );
0.000007,1,0.000007,define_alias(
0.000000,0,0.000000,qr/^UCS-?2-?(BE)?$/i    => '"UCS-2BE"',
0.000000,0,0.000000,qr/^UCS-?4-?(BE|LE|)?$/i => 'uc("UTF-32$1")',
0.000000,0,0.000000,qr/^iso-10646-1$/i      => '"UCS-2BE"'
0.000000,0,0.000000,);
0.000007,1,0.000007,define_alias(
0.000000,0,0.000000,qr/^UTF-?(16|32)-?BE$/i => '"UTF-$1BE"',
0.000000,0,0.000000,qr/^UTF-?(16|32)-?LE$/i => '"UTF-$1LE"',
0.000000,0,0.000000,qr/^UTF-?(16|32)$/i     => '"UTF-$1"',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# ASCII
0.000007,1,0.000007,define_alias( qr/^(?:US-?)ascii$/i       => '"ascii"' );
0.000000,1,0.000000,define_alias( 'C'                        => 'ascii' );
0.000006,1,0.000006,define_alias( qr/\b(?:ISO[-_]?)?646(?:[-_]?US)?$/i => '"ascii"' );
0.000000,0,0.000000,
0.000000,0,0.000000,# Allow variants of iso-8859-1 etc.
0.000005,1,0.000005,define_alias( qr/\biso[-_]?(\d+)[-_](\d+)$/i => '"iso-$1-$2"' );
0.000000,0,0.000000,
0.000000,0,0.000000,# At least HP-UX has these.
0.000009,1,0.000009,define_alias( qr/\biso8859(\d+)$/i => '"iso-8859-$1"' );
0.000000,0,0.000000,
0.000000,0,0.000000,# More HP stuff.
0.000005,1,0.000005,define_alias(
0.000000,0,0.000000,qr/\b(?:hp-)?(arabic|greek|hebrew|kana|roman|thai|turkish)8$/i =>
0.000000,0,0.000000,'"${1}8"' );
0.000000,0,0.000000,
0.000000,0,0.000000,# The Official name of ASCII.
0.000003,1,0.000003,define_alias( qr/\bANSI[-_]?X3\.4[-_]?1968$/i => '"ascii"' );
0.000000,0,0.000000,
0.000000,0,0.000000,# This is a font issue, not an encoding issue.
0.000000,0,0.000000,# (The currency symbol of the Latin 1 upper half
0.000000,0,0.000000,#  has been redefined as the euro symbol.)
0.000004,1,0.000004,define_alias( qr/^(.+)\@euro$/i => '"$1"' );
0.000000,0,0.000000,
0.000003,1,0.000003,define_alias( qr/\b(?:iso[-_]?)?latin[-_]?(\d+)$/i =>
0.000000,0,0.000000,'defined $Encode::Alias::Latin2iso[$1] ? "iso-8859-$Encode::Alias::Latin2iso[$1]" : undef'
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000004,1,0.000004,define_alias(
0.000000,0,0.000000,qr/\bwin(latin[12]|cyrillic|baltic|greek|turkish|
0.000000,0,0.000000,hebrew|arabic|baltic|vietnamese)$/ix =>
0.000000,0,0.000000,'"cp" . $Encode::Alias::Winlatin2cp{lc($1)}'
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Common names for non-latin preferred MIME names
0.000000,1,0.000000,define_alias(
0.000000,0,0.000000,'ascii'    => 'US-ascii',
0.000000,0,0.000000,'cyrillic' => 'iso-8859-5',
0.000000,0,0.000000,'arabic'   => 'iso-8859-6',
0.000000,0,0.000000,'greek'    => 'iso-8859-7',
0.000000,0,0.000000,'hebrew'   => 'iso-8859-8',
0.000000,0,0.000000,'thai'     => 'iso-8859-11',
0.000000,0,0.000000,);
0.000000,0,0.000000,# RT #20781
0.000006,1,0.000006,define_alias(qr/\btis-?620\b/i  => '"iso-8859-11"');
0.000000,0,0.000000,
0.000000,0,0.000000,# At least AIX has IBM-NNN (surprisingly...) instead of cpNNN.
0.000000,0,0.000000,# And Microsoft has their own naming (again, surprisingly).
0.000000,0,0.000000,# And windows-* is registered in IANA!
0.000004,1,0.000004,define_alias(
0.000000,0,0.000000,qr/\b(?:cp|ibm|ms|windows)[-_ ]?(\d{2,4})$/i => '"cp$1"' );
0.000000,0,0.000000,
0.000000,0,0.000000,# Sometimes seen with a leading zero.
0.000000,0,0.000000,# define_alias( qr/\bcp037\b/i => '"cp37"');
0.000000,0,0.000000,
0.000000,0,0.000000,# Mac Mappings
0.000000,0,0.000000,# predefined in *.ucm; unneeded
0.000000,0,0.000000,# define_alias( qr/\bmacIcelandic$/i => '"macIceland"');
0.000005,1,0.000005,define_alias( qr/^(?:x[_-])?mac[_-](.*)$/i => '"mac$1"' );
0.000000,0,0.000000,# http://rt.cpan.org/Ticket/Display.html?id=36326
0.000003,1,0.000003,define_alias( qr/^macintosh$/i => '"MacRoman"' );
0.000000,0,0.000000,# https://rt.cpan.org/Ticket/Display.html?id=78125
0.000003,1,0.000003,define_alias( qr/^macce$/i => '"MacCentralEurRoman"' );
0.000000,0,0.000000,# Ououououou. gone.  They are different!
0.000000,0,0.000000,# define_alias( qr/\bmacRomanian$/i => '"macRumanian"');
0.000000,0,0.000000,
0.000000,0,0.000000,# Standardize on the dashed versions.
0.000003,1,0.000003,define_alias( qr/\bkoi8[\s\-_]*([ru])$/i => '"koi8-$1"' );
0.000000,0,0.000000,
0.000000,1,0.000000,unless ($Encode::ON_EBCDIC) {
0.000000,0,0.000000,
0.000000,0,0.000000,# for Encode::CN
0.000005,1,0.000005,define_alias( qr/\beuc.*cn$/i => '"euc-cn"' );
0.000003,1,0.000003,define_alias( qr/\bcn.*euc$/i => '"euc-cn"' );
0.000000,0,0.000000,
0.000000,0,0.000000,# define_alias( qr/\bGB[- ]?(\d+)$/i => '"euc-cn"' )
0.000000,0,0.000000,# CP936 doesn't have vendor-addon for GBK, so they're identical.
0.000004,1,0.000004,define_alias( qr/^gbk$/i => '"cp936"' );
0.000000,0,0.000000,
0.000000,0,0.000000,# This fixes gb2312 vs. euc-cn confusion, practically
0.000004,1,0.000004,define_alias( qr/\bGB[-_ ]?2312(?!-?raw)/i => '"euc-cn"' );
0.000000,0,0.000000,
0.000000,0,0.000000,# for Encode::JP
0.000003,1,0.000003,define_alias( qr/\bjis$/i         => '"7bit-jis"' );
0.000004,1,0.000004,define_alias( qr/\beuc.*jp$/i     => '"euc-jp"' );
0.000005,1,0.000005,define_alias( qr/\bjp.*euc$/i     => '"euc-jp"' );
0.000003,1,0.000003,define_alias( qr/\bujis$/i        => '"euc-jp"' );
0.000005,1,0.000005,define_alias( qr/\bshift.*jis$/i  => '"shiftjis"' );
0.000003,1,0.000003,define_alias( qr/\bsjis$/i        => '"shiftjis"' );
0.000003,1,0.000003,define_alias( qr/\bwindows-31j$/i => '"cp932"' );
0.000000,0,0.000000,
0.000000,0,0.000000,# for Encode::KR
0.000004,1,0.000004,define_alias( qr/\beuc.*kr$/i => '"euc-kr"' );
0.000003,1,0.000003,define_alias( qr/\bkr.*euc$/i => '"euc-kr"' );
0.000000,0,0.000000,
0.000000,0,0.000000,# This fixes ksc5601 vs. euc-kr confusion, practically
0.000016,1,0.000016,define_alias( qr/(?:x-)?uhc$/i         => '"cp949"' );
0.000003,1,0.000003,define_alias( qr/(?:x-)?windows-949$/i => '"cp949"' );
0.000002,1,0.000002,define_alias( qr/\bks_c_5601-1987$/i   => '"cp949"' );
0.000000,0,0.000000,
0.000000,0,0.000000,# for Encode::TW
0.000003,1,0.000003,define_alias( qr/\bbig-?5$/i              => '"big5-eten"' );
0.000003,1,0.000003,define_alias( qr/\bbig5-?et(?:en)?$/i     => '"big5-eten"' );
0.000005,1,0.000005,define_alias( qr/\btca[-_]?big5$/i        => '"big5-eten"' );
0.000002,1,0.000002,define_alias( qr/\bbig5-?hk(?:scs)?$/i    => '"big5-hkscs"' );
0.000004,1,0.000004,define_alias( qr/\bhk(?:scs)?[-_]?big5$/i => '"big5-hkscs"' );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# https://github.com/dankogai/p5-encode/issues/37
0.000005,1,0.000005,define_alias(qr/cp65000/i => '"UTF-7"');
0.000003,1,0.000003,define_alias(qr/cp65001/i => '"utf-8-strict"');
0.000000,0,0.000000,
0.000000,0,0.000000,# utf8 is blessed :)
0.000004,1,0.000004,define_alias( qr/\bUTF-8$/i => '"utf-8-strict"' );
0.000000,0,0.000000,
0.000000,0,0.000000,# At last, Map white space and _ to '-'
0.000010,1,0.000010,define_alias( qr/^([^\s_]+)[\s_]+([^\s_]*)$/i => '"$1-$2"' );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000013,1,0.000013,1;
0.000000,0,0.000000,__END__
