# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# ABSTRACT: Construct data structure from Parser Events
0.000039,2,0.000019,use strict;
0.000069,2,0.000034,use warnings;
0.000000,0,0.000000,package YAML::PP::Constructor;
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000086,2,0.000043,use YAML::PP;
0.000002,1,0.000002,use YAML::PP::Common qw/
0.000000,0,0.000000,PRESERVE_ORDER PRESERVE_SCALAR_STYLE PRESERVE_FLOW_STYLE PRESERVE_ALIAS
0.000047,1,0.000047,/;
0.000029,2,0.000015,use Scalar::Util qw/ reftype /;
0.000057,2,0.000029,use Carp qw/ croak /;
0.000000,0,0.000000,
0.000046,2,0.000023,use constant DEBUG => ($ENV{YAML_PP_LOAD_DEBUG} or $ENV{YAML_PP_LOAD_TRACE}) ? 1 : 0;
0.004248,2,0.002124,use constant TRACE => $ENV{YAML_PP_LOAD_TRACE} ? 1 : 0;
0.000000,0,0.000000,
0.000008,1,0.000008,my %cyclic_refs = qw/ allow 1 ignore 1 warn 1 fatal 1 /;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000002,1,0.000002,my ($class, %args) = @_;
0.000000,0,0.000000,
0.000001,1,0.000001,my $default_yaml_version = delete $args{default_yaml_version};
0.000000,1,0.000000,my $duplicate_keys = delete $args{duplicate_keys};
0.000001,1,0.000001,unless (defined $duplicate_keys) {
0.000000,0,0.000000,$duplicate_keys = 0;
0.000000,0,0.000000,}
0.000001,1,0.000001,my $preserve = delete $args{preserve} || 0;
0.000001,1,0.000001,if ($preserve == 1) {
0.000000,0,0.000000,$preserve = PRESERVE_ORDER | PRESERVE_SCALAR_STYLE | PRESERVE_FLOW_STYLE | PRESERVE_ALIAS;
0.000000,0,0.000000,}
0.000001,1,0.000001,my $cyclic_refs = delete $args{cyclic_refs} || 'allow';
0.000000,0,0.000000,die "Invalid value for cyclic_refs: $cyclic_refs"
0.000001,1,0.000001,unless $cyclic_refs{ $cyclic_refs };
0.000000,1,0.000000,my $schemas = delete $args{schemas};
0.000000,0,0.000000,
0.000000,1,0.000000,if (keys %args) {
0.000000,0,0.000000,die "Unexpected arguments: " . join ', ', sort keys %args;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,my $self = bless {
0.000000,0,0.000000,default_yaml_version => $default_yaml_version,
0.000000,0,0.000000,schemas => $schemas,
0.000000,0,0.000000,cyclic_refs => $cyclic_refs,
0.000000,0,0.000000,preserve => $preserve,
0.000000,0,0.000000,duplicate_keys => $duplicate_keys,
0.000000,0,0.000000,}, $class;
0.000002,1,0.000002,$self->init;
0.000019,1,0.000019,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my $clone = {
0.000000,0,0.000000,schemas => $self->{schemas},
0.000000,0,0.000000,schema => $self->{schema},
0.000000,0,0.000000,default_yaml_version => $self->{default_yaml_version},
0.000000,0,0.000000,cyclic_refs => $self->cyclic_refs,
0.000000,0,0.000000,preserve => $self->{preserve},
0.000000,0,0.000000,};
0.000000,0,0.000000,return bless $clone, ref $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub init {
0.000002,2,0.000001,my ($self) = @_;
0.000004,2,0.000002,$self->set_docs([]);
0.000002,2,0.000001,$self->set_stack([]);
0.000002,2,0.000001,$self->set_anchors({});
0.000007,2,0.000003,$self->set_yaml_version($self->default_yaml_version);
0.000029,2,0.000015,$self->set_schema($self->schemas->{ $self->yaml_version } );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,2,0.000004,sub docs { return $_[0]->{docs} }
0.053559,36111,0.000001,sub stack { return $_[0]->{stack} }
0.000000,0,0.000000,sub anchors { return $_[0]->{anchors} }
0.000017,2,0.000008,sub set_docs { $_[0]->{docs} = $_[1] }
0.000007,3,0.000002,sub set_stack { $_[0]->{stack} = $_[1] }
0.000007,3,0.000002,sub set_anchors { $_[0]->{anchors} = $_[1] }
0.000004,2,0.000002,sub schemas { return $_[0]->{schemas} }
0.043016,28525,0.000002,sub schema { return $_[0]->{schema} }
0.000004,2,0.000002,sub set_schema { $_[0]->{schema} = $_[1] }
0.000000,0,0.000000,sub cyclic_refs { return $_[0]->{cyclic_refs} }
0.000000,0,0.000000,sub set_cyclic_refs { $_[0]->{cyclic_refs} = $_[1] }
0.000004,2,0.000002,sub yaml_version { return $_[0]->{yaml_version} }
0.000004,2,0.000002,sub set_yaml_version { $_[0]->{yaml_version} = $_[1] }
0.000008,2,0.000004,sub default_yaml_version { return $_[0]->{default_yaml_version} }
0.013543,6939,0.000002,sub preserve_order { return $_[0]->{preserve} & PRESERVE_ORDER }
0.033911,20941,0.000002,sub preserve_scalar_style { return $_[0]->{preserve} & PRESERVE_SCALAR_STYLE }
0.013768,7584,0.000002,sub preserve_flow_style { return $_[0]->{preserve} & PRESERVE_FLOW_STYLE }
0.042201,28525,0.000001,sub preserve_alias { return $_[0]->{preserve} & PRESERVE_ALIAS }
0.000000,0,0.000000,sub duplicate_keys { return $_[0]->{duplicate_keys} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub document_start_event {
0.000001,1,0.000001,my ($self, $event) = @_;
0.000019,1,0.000019,my $stack = $self->stack;
0.000001,1,0.000001,if ($event->{version_directive}) {
0.000000,0,0.000000,my $version = $event->{version_directive};
0.000000,0,0.000000,$version = "$version->{major}.$version->{minor}";
0.000000,0,0.000000,if ($self->{schemas}->{ $version }) {
0.000000,0,0.000000,$self->set_yaml_version($version);
0.000000,0,0.000000,$self->set_schema($self->schemas->{ $version });
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->set_yaml_version($self->default_yaml_version);
0.000000,0,0.000000,$self->set_schema($self->schemas->{ $self->default_yaml_version });
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000001,1,0.000001,my $ref = [];
0.000008,1,0.000008,push @$stack, { type => 'document', ref => $ref, data => $ref, event => $event };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub document_end_event {
0.000001,1,0.000001,my ($self, $event) = @_;
0.000001,1,0.000001,my $stack = $self->stack;
0.000000,1,0.000000,my $last = pop @$stack;
0.000001,1,0.000001,$last->{type} eq 'document' or die "Expected mapping, but got $last->{type}";
0.000000,1,0.000000,if (@$stack) {
0.000000,0,0.000000,die "Got unexpected end of document";
0.000000,0,0.000000,}
0.000003,1,0.000003,my $docs = $self->docs;
0.000001,1,0.000001,push @$docs, $last->{ref}->[0];
0.000002,1,0.000002,$self->set_anchors({});
0.000006,1,0.000006,$self->set_stack([]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mapping_start_event {
0.003573,6939,0.000001,my ($self, $event) = @_;
0.017184,6939,0.000002,my ($data, $on_data) = $self->schema->create_mapping($self, $event);
0.019729,6939,0.000003,my $ref = {
0.000000,0,0.000000,type => 'mapping',
0.000000,0,0.000000,ref => [],
0.000000,0,0.000000,data => \$data,
0.000000,0,0.000000,event => $event,
0.000000,0,0.000000,on_data => $on_data,
0.000000,0,0.000000,};
0.006419,6939,0.000001,my $stack = $self->stack;
0.000000,0,0.000000,
0.008616,6939,0.000001,my $preserve_order = $self->preserve_order;
0.007103,6939,0.000001,my $preserve_style = $self->preserve_flow_style;
0.006663,6939,0.000001,my $preserve_alias = $self->preserve_alias;
0.003065,6939,0.000000,if (($preserve_order or $preserve_style or $preserve_alias) and not tied(%$data)) {
0.000000,0,0.000000,tie %$data, 'YAML::PP::Preserve::Hash', %$data;
0.000000,0,0.000000,}
0.001427,6939,0.000000,if ($preserve_style) {
0.000000,0,0.000000,my $t = tied %$data;
0.000000,0,0.000000,$t->{style} = $event->{style};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002062,6939,0.000000,push @$stack, $ref;
0.016724,6939,0.000002,if (defined(my $anchor = $event->{anchor})) {
0.000000,0,0.000000,if ($preserve_alias) {
0.000000,0,0.000000,my $t = tied %$data;
0.000000,0,0.000000,unless (exists $self->anchors->{ $anchor }) {
0.000000,0,0.000000,# Repeated anchors cannot be preserved
0.000000,0,0.000000,$t->{alias} = $anchor;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->anchors->{ $anchor } = { data => $ref->{data} };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mapping_end_event {
0.001452,6939,0.000000,my ($self, $event) = @_;
0.005303,6939,0.000001,my $stack = $self->stack;
0.000000,0,0.000000,
0.002152,6939,0.000000,my $last = pop @$stack;
0.004813,6939,0.000001,my ($ref, $data) = @{ $last }{qw/ ref data /};
0.003314,6939,0.000000,$last->{type} eq 'mapping' or die "Expected mapping, but got $last->{type}";
0.000000,0,0.000000,
0.000968,6939,0.000000,my @merge_keys;
0.000000,0,0.000000,my @ref;
0.008472,6939,0.000001,for (my $i = 0; $i < @$ref; $i += 2) {
0.005742,13444,0.000000,my $key = $ref->[ $i ];
0.004532,13444,0.000000,if (ref $key eq 'YAML::PP::Type::MergeKey') {
0.000000,0,0.000000,my $merge = $ref->[ $i + 1 ];
0.000000,0,0.000000,if ((reftype($merge) || '') eq 'HASH') {
0.000000,0,0.000000,push @merge_keys, $merge;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ((reftype($merge) || '') eq 'ARRAY') {
0.000000,0,0.000000,for my $item (@$merge) {
0.000000,0,0.000000,if ((reftype($item) || '') eq 'HASH') {
0.000000,0,0.000000,push @merge_keys, $item;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die "Expected hash for merge key";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die "Expected hash or array for merge key";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.007267,13444,0.000001,push @ref, $key, $ref->[ $i + 1 ];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.003266,6939,0.000000,for my $merge (@merge_keys) {
0.000000,0,0.000000,for my $key (keys %$merge) {
0.000000,0,0.000000,unless (exists $$data->{ $key }) {
0.000000,0,0.000000,$$data->{ $key } = $merge->{ $key };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my $on_data = $last->{on_data} || sub {
0.001624,6939,0.000000,my ($self, $hash, $items) = @_;
0.001203,6939,0.000000,my %seen;
0.025529,6939,0.000004,for (my $i = 0; $i < @$items; $i += 2) {
0.007484,13444,0.000001,my ($key, $value) = @$items[ $i, $i + 1 ];
0.001885,13444,0.000000,$key = '' unless defined $key;
0.001316,13444,0.000000,if (ref $key) {
0.000000,0,0.000000,$key = $self->stringify_complex($key);
0.000000,0,0.000000,}
0.016547,13444,0.000001,if ($seen{ $key }++ and not $self->duplicate_keys) {
0.000000,0,0.000000,croak "Duplicate key '$key'";
0.000000,0,0.000000,}
0.009396,13444,0.000001,$$hash->{ $key } = $value;
0.000000,0,0.000000,}
0.019657,6939,0.000003,};
0.008222,6939,0.000001,$on_data->($self, $data, \@ref);
0.006905,6939,0.000001,push @{ $stack->[-1]->{ref} }, $$data;
0.004423,6939,0.000001,if (defined(my $anchor = $last->{event}->{anchor})) {
0.000000,0,0.000000,$self->anchors->{ $anchor }->{finished} = 1;
0.000000,0,0.000000,}
0.044689,6939,0.000006,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sequence_start_event {
0.000241,645,0.000000,my ($self, $event) = @_;
0.001814,645,0.000003,my ($data, $on_data) = $self->schema->create_sequence($self, $event);
0.001984,645,0.000003,my $ref = {
0.000000,0,0.000000,type => 'sequence',
0.000000,0,0.000000,ref => [],
0.000000,0,0.000000,data => \$data,
0.000000,0,0.000000,event => $event,
0.000000,0,0.000000,on_data => $on_data,
0.000000,0,0.000000,};
0.000822,645,0.000001,my $stack = $self->stack;
0.000000,0,0.000000,
0.000757,645,0.000001,my $preserve_style = $self->preserve_flow_style;
0.000609,645,0.000001,my $preserve_alias = $self->preserve_alias;
0.000377,645,0.000001,if ($preserve_style or $preserve_alias and not tied(@$data)) {
0.000000,0,0.000000,tie @$data, 'YAML::PP::Preserve::Array', @$data;
0.000000,0,0.000000,my $t = tied @$data;
0.000000,0,0.000000,$t->{style} = $event->{style};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000260,645,0.000000,push @$stack, $ref;
0.001837,645,0.000003,if (defined(my $anchor = $event->{anchor})) {
0.000000,0,0.000000,if ($preserve_alias) {
0.000000,0,0.000000,my $t = tied @$data;
0.000000,0,0.000000,unless (exists $self->anchors->{ $anchor }) {
0.000000,0,0.000000,# Repeated anchors cannot be preserved
0.000000,0,0.000000,$t->{alias} = $anchor;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->anchors->{ $anchor } = { data => $ref->{data} };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sequence_end_event {
0.000255,645,0.000000,my ($self, $event) = @_;
0.000591,645,0.000001,my $stack = $self->stack;
0.000211,645,0.000000,my $last = pop @$stack;
0.000475,645,0.000001,$last->{type} eq 'sequence' or die "Expected mapping, but got $last->{type}";
0.000612,645,0.000001,my ($ref, $data) = @{ $last }{qw/ ref data /};
0.000000,0,0.000000,
0.000000,0,0.000000,my $on_data = $last->{on_data} || sub {
0.000128,645,0.000000,my ($self, $array, $items) = @_;
0.002141,645,0.000003,push @$$array, @$items;
0.002309,645,0.000004,};
0.000768,645,0.000001,$on_data->($self, $data, $ref);
0.000843,645,0.000001,push @{ $stack->[-1]->{ref} }, $$data;
0.000550,645,0.000001,if (defined(my $anchor = $last->{event}->{anchor})) {
0.000000,0,0.000000,my $test = $self->anchors->{ $anchor };
0.000000,0,0.000000,$self->anchors->{ $anchor }->{finished} = 1;
0.000000,0,0.000000,}
0.003652,645,0.000006,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,sub stream_start_event {}
0.000000,0,0.000000,
0.000003,1,0.000003,sub stream_end_event {}
0.000000,0,0.000000,
0.000000,0,0.000000,sub scalar_event {
0.003625,20941,0.000000,my ($self, $event) = @_;
0.000000,0,0.000000,DEBUG and warn "CONTENT $event->{value} ($event->{style})\n";
0.042262,20941,0.000002,my $value = $self->schema->load_scalar($self, $event);
0.022477,20941,0.000001,my $last = $self->stack->[-1];
0.017392,20941,0.000001,my $preserve_alias = $self->preserve_alias;
0.019112,20941,0.000001,my $preserve_style = $self->preserve_scalar_style;
0.004349,20941,0.000000,if (($preserve_style or $preserve_alias) and not ref $value) {
0.000000,0,0.000000,my %args = (
0.000000,0,0.000000,value => $value,
0.000000,0,0.000000,tag => $event->{tag},
0.000000,0,0.000000,);
0.000000,0,0.000000,if ($preserve_style) {
0.000000,0,0.000000,$args{style} = $event->{style};
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($preserve_alias and defined $event->{anchor}) {
0.000000,0,0.000000,my $anchor = $event->{anchor};
0.000000,0,0.000000,unless (exists $self->anchors->{ $anchor }) {
0.000000,0,0.000000,# Repeated anchors cannot be preserved
0.000000,0,0.000000,$args{alias} = $event->{anchor};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$value = YAML::PP::Preserve::Scalar->new( %args );
0.000000,0,0.000000,}
0.006598,20941,0.000000,if (defined (my $name = $event->{anchor})) {
0.000000,0,0.000000,$self->anchors->{ $name } = { data => \$value, finished => 1 };
0.000000,0,0.000000,}
0.052711,20941,0.000003,push @{ $last->{ref} }, $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub alias_event {
0.000000,0,0.000000,my ($self, $event) = @_;
0.000000,0,0.000000,my $value;
0.000000,0,0.000000,my $name = $event->{value};
0.000000,0,0.000000,if (my $anchor = $self->anchors->{ $name }) {
0.000000,0,0.000000,# We know this is a cyclic ref since the node hasn't
0.000000,0,0.000000,# been constructed completely yet
0.000000,0,0.000000,unless ($anchor->{finished} ) {
0.000000,0,0.000000,my $cyclic_refs = $self->cyclic_refs;
0.000000,0,0.000000,if ($cyclic_refs ne 'allow') {
0.000000,0,0.000000,if ($cyclic_refs eq 'fatal') {
0.000000,0,0.000000,die "Found cyclic ref for alias '$name'";
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($cyclic_refs eq 'warn') {
0.000000,0,0.000000,$anchor = { data => \undef };
0.000000,0,0.000000,warn "Found cyclic ref for alias '$name'";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($cyclic_refs eq 'ignore') {
0.000000,0,0.000000,$anchor = { data => \undef };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$value = $anchor->{data};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,croak "No anchor defined for alias '$name'";
0.000000,0,0.000000,}
0.000000,0,0.000000,my $last = $self->stack->[-1];
0.000000,0,0.000000,push @{ $last->{ref} }, $$value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub stringify_complex {
0.000000,0,0.000000,my ($self, $data) = @_;
0.000000,0,0.000000,return $data if (
0.000000,0,0.000000,ref $data eq 'YAML::PP::Preserve::Scalar'
0.000000,0,0.000000,and ($self->preserve_scalar_style or $self->preserve_alias)
0.000000,0,0.000000,);
0.000000,0,0.000000,require Data::Dumper;
0.000000,0,0.000000,local $Data::Dumper::Quotekeys = 0;
0.000000,0,0.000000,local $Data::Dumper::Terse = 1;
0.000000,0,0.000000,local $Data::Dumper::Indent = 0;
0.000000,0,0.000000,local $Data::Dumper::Useqq = 0;
0.000000,0,0.000000,local $Data::Dumper::Sortkeys = 1;
0.000000,0,0.000000,my $string = Data::Dumper->Dump([$data], ['data']);
0.000000,0,0.000000,$string =~ s/^\$data = //;
0.000000,0,0.000000,return $string;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
