# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package List::MoreUtils::PP;
0.000000,0,0.000000,
0.000090,2,0.000045,use 5.008_001;
0.000019,2,0.000010,use strict;
0.000336,2,0.000168,use warnings;
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.430';
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,List::MoreUtils::PP - Provide List::MoreUtils pure Perl implementation
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN { $ENV{LIST_MOREUTILS_PP} = 1; }
0.000000,0,0.000000,use List::MoreUtils qw(:all);
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,## no critic (Subroutines::ProhibitSubroutinePrototypes, Subroutines::RequireArgUnpacking)
0.000000,0,0.000000,## no critic (Subroutines::ProhibitManyArgs)
0.000000,0,0.000000,
0.000000,0,0.000000,sub any (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,foreach (@_)
0.000000,0,0.000000,{
0.000000,0,0.000000,return 1 if $f->();
0.000000,0,0.000000,}
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub all (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,foreach (@_)
0.000000,0,0.000000,{
0.000000,0,0.000000,return 0 unless $f->();
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub none (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,foreach (@_)
0.000000,0,0.000000,{
0.000000,0,0.000000,return 0 if $f->();
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub notall (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,foreach (@_)
0.000000,0,0.000000,{
0.000000,0,0.000000,return 1 unless $f->();
0.000000,0,0.000000,}
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub one (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $f     = shift;
0.000000,0,0.000000,my $found = 0;
0.000000,0,0.000000,foreach (@_)
0.000000,0,0.000000,{
0.000000,0,0.000000,$f->() and $found++ and return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $found;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub any_u (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,return if !@_;
0.000000,0,0.000000,$f->() and return 1 foreach (@_);
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub all_u (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,return if !@_;
0.000000,0,0.000000,$f->() or return 0 foreach (@_);
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub none_u (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,return if !@_;
0.000000,0,0.000000,$f->() and return 0 foreach (@_);
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub notall_u (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,return if !@_;
0.000000,0,0.000000,$f->() or return 1 foreach (@_);
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub one_u (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,return if !@_;
0.000000,0,0.000000,my $found = 0;
0.000000,0,0.000000,foreach (@_)
0.000000,0,0.000000,{
0.000000,0,0.000000,$f->() and $found++ and return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $found;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub reduce_u(&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $code = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Localise $a, $b
0.000000,0,0.000000,my ($caller_a, $caller_b) = do
0.000000,0,0.000000,{
0.000000,0,0.000000,my $pkg = caller();
0.000000,0,0.000000,## no critic (TestingAndDebugging::ProhibitNoStrict, ValuesAndExpressions::ProhibitCommaSeparatedStatements)
0.000087,2,0.000044,no strict 'refs';
0.000000,0,0.000000,\*{$pkg . '::a'}, \*{$pkg . '::b'};
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,## no critic (Variables::RequireInitializationForLocalVars)
0.000000,0,0.000000,local (*$caller_a, *$caller_b);
0.000000,0,0.000000,*$caller_a = \();
0.000000,0,0.000000,for (0 .. $#_)
0.000000,0,0.000000,{
0.000000,0,0.000000,*$caller_b = \$_[$_];
0.000000,0,0.000000,*$caller_a = \($code->());
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ${*$caller_a};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub reduce_0(&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $code = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Localise $a, $b
0.000000,0,0.000000,my ($caller_a, $caller_b) = do
0.000000,0,0.000000,{
0.000000,0,0.000000,my $pkg = caller();
0.000000,0,0.000000,## no critic (TestingAndDebugging::ProhibitNoStrict, ValuesAndExpressions::ProhibitCommaSeparatedStatements)
0.000063,2,0.000031,no strict 'refs';
0.000000,0,0.000000,\*{$pkg . '::a'}, \*{$pkg . '::b'};
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,## no critic (Variables::RequireInitializationForLocalVars)
0.000000,0,0.000000,local (*$caller_a, *$caller_b);
0.000000,0,0.000000,*$caller_a = \0;
0.000000,0,0.000000,for (0 .. $#_)
0.000000,0,0.000000,{
0.000000,0,0.000000,*$caller_b = \$_[$_];
0.000000,0,0.000000,*$caller_a = \($code->());
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ${*$caller_a};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub reduce_1(&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $code = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Localise $a, $b
0.000000,0,0.000000,my ($caller_a, $caller_b) = do
0.000000,0,0.000000,{
0.000000,0,0.000000,my $pkg = caller();
0.000000,0,0.000000,## no critic (TestingAndDebugging::ProhibitNoStrict, ValuesAndExpressions::ProhibitCommaSeparatedStatements)
0.000568,2,0.000284,no strict 'refs';
0.000000,0,0.000000,\*{$pkg . '::a'}, \*{$pkg . '::b'};
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,## no critic (Variables::RequireInitializationForLocalVars)
0.000000,0,0.000000,local (*$caller_a, *$caller_b);
0.000000,0,0.000000,*$caller_a = \1;
0.000000,0,0.000000,for (0 .. $#_)
0.000000,0,0.000000,{
0.000000,0,0.000000,*$caller_b = \$_[$_];
0.000000,0,0.000000,*$caller_a = \($code->());
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ${*$caller_a};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub true (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $f     = shift;
0.000000,0,0.000000,my $count = 0;
0.000000,0,0.000000,$f->() and ++$count foreach (@_);
0.000000,0,0.000000,return $count;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub false (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $f     = shift;
0.000000,0,0.000000,my $count = 0;
0.000000,0,0.000000,$f->() or ++$count foreach (@_);
0.000000,0,0.000000,return $count;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub firstidx (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,foreach my $i (0 .. $#_)
0.000000,0,0.000000,{
0.000000,0,0.000000,local *_ = \$_[$i];
0.000000,0,0.000000,return $i if $f->();
0.000000,0,0.000000,}
0.000000,0,0.000000,return -1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub firstval (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,foreach (@_)
0.000000,0,0.000000,{
0.000000,0,0.000000,return $_ if $test->();
0.000000,0,0.000000,}
0.000000,0,0.000000,## no critic (Subroutines::ProhibitExplicitReturnUndef)
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub firstres (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,foreach (@_)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $testval = $test->();
0.000000,0,0.000000,$testval and return $testval;
0.000000,0,0.000000,}
0.000000,0,0.000000,## no critic (Subroutines::ProhibitExplicitReturnUndef)
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub onlyidx (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,my $found;
0.000000,0,0.000000,foreach my $i (0 .. $#_)
0.000000,0,0.000000,{
0.000000,0,0.000000,local *_ = \$_[$i];
0.000000,0,0.000000,$f->() or next;
0.000000,0,0.000000,defined $found and return -1;
0.000000,0,0.000000,$found = $i;
0.000000,0,0.000000,}
0.000000,0,0.000000,return defined $found ? $found : -1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub onlyval (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $test   = shift;
0.000000,0,0.000000,my $result = undef;
0.000000,0,0.000000,my $found  = 0;
0.000000,0,0.000000,foreach (@_)
0.000000,0,0.000000,{
0.000000,0,0.000000,$test->() or next;
0.000000,0,0.000000,$result = $_;
0.000000,0,0.000000,## no critic (Subroutines::ProhibitExplicitReturnUndef)
0.000000,0,0.000000,$found++ and return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $result;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub onlyres (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $test   = shift;
0.000000,0,0.000000,my $result = undef;
0.000000,0,0.000000,my $found  = 0;
0.000000,0,0.000000,foreach (@_)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $rv = $test->() or next;
0.000000,0,0.000000,$result = $rv;
0.000000,0,0.000000,## no critic (Subroutines::ProhibitExplicitReturnUndef)
0.000000,0,0.000000,$found++ and return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $found ? $result : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub lastidx (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,foreach my $i (reverse 0 .. $#_)
0.000000,0,0.000000,{
0.000000,0,0.000000,local *_ = \$_[$i];
0.000000,0,0.000000,return $i if $f->();
0.000000,0,0.000000,}
0.000000,0,0.000000,return -1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub lastval (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,my $ix;
0.000000,0,0.000000,for ($ix = $#_; $ix >= 0; $ix--)
0.000000,0,0.000000,{
0.000000,0,0.000000,local *_ = \$_[$ix];
0.000000,0,0.000000,my $testval = $test->();
0.000000,0,0.000000,
0.000000,0,0.000000,# Simulate $_ as alias
0.000000,0,0.000000,$_[$ix] = $_;
0.000000,0,0.000000,return $_ if $testval;
0.000000,0,0.000000,}
0.000000,0,0.000000,## no critic (Subroutines::ProhibitExplicitReturnUndef)
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub lastres (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,my $ix;
0.000000,0,0.000000,for ($ix = $#_; $ix >= 0; $ix--)
0.000000,0,0.000000,{
0.000000,0,0.000000,local *_ = \$_[$ix];
0.000000,0,0.000000,my $testval = $test->();
0.000000,0,0.000000,
0.000000,0,0.000000,# Simulate $_ as alias
0.000000,0,0.000000,$_[$ix] = $_;
0.000000,0,0.000000,return $testval if $testval;
0.000000,0,0.000000,}
0.000000,0,0.000000,## no critic (Subroutines::ProhibitExplicitReturnUndef)
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub insert_after (&$\@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($f, $val, $list) = @_;
0.000000,0,0.000000,my $c = &firstidx($f, @$list);
0.000000,0,0.000000,@$list = (@{$list}[0 .. $c], $val, @{$list}[$c + 1 .. $#$list],) and return 1 if $c != -1;
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub insert_after_string ($$\@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($string, $val, $list) = @_;
0.000000,0,0.000000,my $c = firstidx { defined $_ and $string eq $_ } @$list;
0.000000,0,0.000000,@$list = (@{$list}[0 .. $c], $val, @{$list}[$c + 1 .. $#$list],) and return 1 if $c != -1;
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $action = shift;
0.000000,0,0.000000,&$action foreach my @values = @_;
0.000000,0,0.000000,return wantarray ? @values : $values[-1];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub after (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,my $started;
0.000000,0,0.000000,my $lag;
0.000000,0,0.000000,## no critic (BuiltinFunctions::RequireBlockGrep)
0.000000,0,0.000000,return grep $started ||= do
0.000000,0,0.000000,{
0.000000,0,0.000000,my $x = $lag;
0.000000,0,0.000000,$lag = $test->();
0.000000,0,0.000000,$x;
0.000000,0,0.000000,}, @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub after_incl (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,my $started;
0.000000,0,0.000000,return grep { $started ||= $test->() } @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub before (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,my $more = 1;
0.000000,0,0.000000,return grep { $more &&= !$test->() } @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub before_incl (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,my $more = 1;
0.000000,0,0.000000,my $lag  = 1;
0.000000,0,0.000000,## no critic (BuiltinFunctions::RequireBlockGrep)
0.000000,0,0.000000,return grep $more &&= do
0.000000,0,0.000000,{
0.000000,0,0.000000,my $x = $lag;
0.000000,0,0.000000,$lag = !$test->();
0.000000,0,0.000000,$x;
0.000000,0,0.000000,}, @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub indexes (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,return grep {
0.000000,0,0.000000,local *_ = \$_[$_];
0.000000,0,0.000000,$test->()
0.000000,0,0.000000,} 0 .. $#_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub pairwise (&\@\@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $op = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Symbols for caller's input arrays
0.000038,2,0.000019,use vars qw{ @A @B };
0.000000,0,0.000000,local (*A, *B) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Localise $a, $b
0.000000,0,0.000000,my ($caller_a, $caller_b) = do
0.000000,0,0.000000,{
0.000000,0,0.000000,my $pkg = caller();
0.000000,0,0.000000,## no critic (TestingAndDebugging::ProhibitNoStrict, ValuesAndExpressions::ProhibitCommaSeparatedStatements)
0.002085,2,0.001043,no strict 'refs';
0.000000,0,0.000000,\*{$pkg . '::a'}, \*{$pkg . '::b'};
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,# Loop iteration limit
0.000000,0,0.000000,my $limit = $#A > $#B ? $#A : $#B;
0.000000,0,0.000000,
0.000000,0,0.000000,## no critic (Variables::RequireInitializationForLocalVars)
0.000000,0,0.000000,# This map expression is also the return value
0.000000,0,0.000000,local (*$caller_a, *$caller_b);
0.000000,0,0.000000,## no critic (BuiltinFunctions::ProhibitComplexMappings)
0.000000,0,0.000000,return map {
0.000000,0,0.000000,# Assign to $a, $b as refs to caller's array elements
0.000000,0,0.000000,(*$caller_a, *$caller_b) = \($#A < $_ ? undef : $A[$_], $#B < $_ ? undef : $B[$_]);
0.000000,0,0.000000,
0.000000,0,0.000000,# Perform the transformation
0.000000,0,0.000000,$op->();
0.000000,0,0.000000,} 0 .. $limit;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub each_array (\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
0.000000,0,0.000000,{
0.000000,0,0.000000,return each_arrayref(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub each_arrayref
0.000000,0,0.000000,{
0.000000,0,0.000000,my @list  = @_;    # The list of references to the arrays
0.000000,0,0.000000,my $index = 0;     # Which one the caller will get next
0.000000,0,0.000000,my $max   = 0;     # Number of elements in longest array
0.000000,0,0.000000,
0.000000,0,0.000000,# Get the length of the longest input array
0.000000,0,0.000000,foreach (@list)
0.000000,0,0.000000,{
0.000000,0,0.000000,unless (ref $_ eq 'ARRAY')
0.000000,0,0.000000,{
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("each_arrayref: argument is not an array reference\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,$max = @$_ if @$_ > $max;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Return the iterator as a closure wrt the above variables.
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,if (@_)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $method = shift;
0.000000,0,0.000000,unless ($method eq 'index')
0.000000,0,0.000000,{
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("each_array: unknown argument '$method' passed to iterator.");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## no critic (Subroutines::ProhibitExplicitReturnUndef)
0.000000,0,0.000000,return undef if $index == 0 || $index > $max;
0.000000,0,0.000000,# Return current (last fetched) index
0.000000,0,0.000000,return $index - 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# No more elements to return
0.000000,0,0.000000,return if $index >= $max;
0.000000,0,0.000000,my $i = $index++;
0.000000,0,0.000000,
0.000000,0,0.000000,# Return ith elements
0.000000,0,0.000000,## no critic (BuiltinFunctions::RequireBlockMap)
0.000000,0,0.000000,return map $_->[$i], @list;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub natatime ($@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $n    = shift;
0.000000,0,0.000000,my @list = @_;
0.000000,0,0.000000,return sub { return splice @list, 0, $n; }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# "leaks" when lexically hidden in arrayify
0.000001,1,0.000001,my $flatten;
0.000000,0,0.000000,$flatten = sub {
0.000000,0,0.000000,return map { (ref $_ and ("ARRAY" eq ref $_ or overload::Method($_, '@{}'))) ? ($flatten->(@{$_})) : ($_) } @_;
0.000003,1,0.000003,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub arrayify
0.000000,0,0.000000,{
0.000000,0,0.000000,return map { $flatten->($_) } @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $max = -1;
0.000000,0,0.000000,$max < $#$_ && ($max = $#$_) foreach @_;
0.000000,0,0.000000,## no critic (BuiltinFunctions::ProhibitComplexMappings)
0.000000,0,0.000000,return map {
0.000000,0,0.000000,my $ix = $_;
0.000000,0,0.000000,## no critic (BuiltinFunctions::RequireBlockMap)
0.000000,0,0.000000,map $_->[$ix], @_;
0.000000,0,0.000000,} 0 .. $max;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub zip6 (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $max = -1;
0.000000,0,0.000000,$max < $#$_ && ($max = $#$_) foreach @_;
0.000000,0,0.000000,## no critic (BuiltinFunctions::ProhibitComplexMappings)
0.000000,0,0.000000,return map {
0.000000,0,0.000000,my $ix = $_;
0.000000,0,0.000000,## no critic (BuiltinFunctions::RequireBlockMap)
0.000000,0,0.000000,[map $_->[$ix], @_];
0.000000,0,0.000000,} 0 .. $max;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub listcmp (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my %ret;
0.000000,0,0.000000,for (my $i = 0; $i < scalar @_; ++$i)
0.000000,0,0.000000,{
0.000000,0,0.000000,my %seen;
0.000000,0,0.000000,my $k;
0.000000,0,0.000000,foreach my $w (grep { defined $_ and not $seen{$k = $_}++ } @{$_[$i]})
0.000000,0,0.000000,{
0.000000,0,0.000000,$ret{$w} ||= [];
0.000000,0,0.000000,push @{$ret{$w}}, $i;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return %ret;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub uniq (@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my %seen = ();
0.000000,0,0.000000,my $k;
0.000000,0,0.000000,my $seen_undef;
0.000000,0,0.000000,return grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub singleton (@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my %seen = ();
0.000000,0,0.000000,my $k;
0.000000,0,0.000000,my $seen_undef;
0.000000,0,0.000000,return grep { 1 == (defined $_ ? $seen{$k = $_} : $seen_undef) }
0.000000,0,0.000000,grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub duplicates (@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my %seen = ();
0.000000,0,0.000000,my $k;
0.000000,0,0.000000,my $seen_undef;
0.000000,0,0.000000,return grep { 1 < (defined $_ ? $seen{$k = $_} : $seen_undef) }
0.000000,0,0.000000,grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub frequency (@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my %seen = ();
0.000000,0,0.000000,my $k;
0.000000,0,0.000000,my $seen_undef;
0.000000,0,0.000000,my %h = map { defined $_ ? ($_ => $seen{$k = $_}) : () }
0.000000,0,0.000000,grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
0.000000,0,0.000000,wantarray or return (scalar keys %h) + ($seen_undef ? 1 : 0);
0.000000,0,0.000000,undef $k;
0.000000,0,0.000000,return (%h, $seen_undef ? (\$k => $seen_undef) : ());
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub occurrences (@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my %seen = ();
0.000000,0,0.000000,my $k;
0.000000,0,0.000000,my $seen_undef;
0.000000,0,0.000000,my @ret;
0.000000,0,0.000000,foreach my $l (map { $_ } grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $n = defined $l ? $seen{$l} : $seen_undef;
0.000000,0,0.000000,defined $ret[$n] or $ret[$n] = [];
0.000000,0,0.000000,push @{$ret[$n]}, $l;
0.000000,0,0.000000,}
0.000000,0,0.000000,return @ret;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mode (@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my %seen = ();
0.000000,0,0.000000,my ($max, $k, $seen_undef) = (1);
0.000000,0,0.000000,
0.000000,0,0.000000,foreach (@_) { defined $_ ? ($max < ++$seen{$k = $_} and ++$max) : ($max < ++$seen_undef and ++$max) }
0.000000,0,0.000000,wantarray or return $max;
0.000000,0,0.000000,
0.000000,0,0.000000,my @ret = ($max);
0.000000,0,0.000000,foreach my $l (grep { $seen{$_} == $max } keys %seen)
0.000000,0,0.000000,{
0.000000,0,0.000000,push @ret, $l;
0.000000,0,0.000000,}
0.000000,0,0.000000,$seen_undef and $seen_undef == $max and push @ret, undef;
0.000000,0,0.000000,return @ret;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub samples ($@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $n = shift;
0.000000,0,0.000000,if ($n > @_)
0.000000,0,0.000000,{
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak(sprintf("Cannot get %d samples from %d elements", $n, scalar @_));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for (my $i = @_; @_ - $i > $n;)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $idx  = @_ - $i;
0.000000,0,0.000000,my $swp  = $idx + int(rand(--$i));
0.000000,0,0.000000,my $xchg = $_[$swp];
0.000000,0,0.000000,$_[$swp] = $_[$idx];
0.000000,0,0.000000,$_[$idx] = $xchg;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return splice @_, 0, $n;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub minmax (@)
0.000000,0,0.000000,{
0.000000,0,0.000000,return unless @_;
0.000000,0,0.000000,my $min = my $max = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,for (my $i = 1; $i < @_; $i += 2)
0.000000,0,0.000000,{
0.000000,0,0.000000,if ($_[$i - 1] <= $_[$i])
0.000000,0,0.000000,{
0.000000,0,0.000000,$min = $_[$i - 1] if $min > $_[$i - 1];
0.000000,0,0.000000,$max = $_[$i]     if $max < $_[$i];
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,$min = $_[$i]     if $min > $_[$i];
0.000000,0,0.000000,$max = $_[$i - 1] if $max < $_[$i - 1];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (@_ & 1)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $i = $#_;
0.000000,0,0.000000,if ($_[$i - 1] <= $_[$i])
0.000000,0,0.000000,{
0.000000,0,0.000000,$min = $_[$i - 1] if $min > $_[$i - 1];
0.000000,0,0.000000,$max = $_[$i]     if $max < $_[$i];
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,$min = $_[$i]     if $min > $_[$i];
0.000000,0,0.000000,$max = $_[$i - 1] if $max < $_[$i - 1];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ($min, $max);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub minmaxstr (@)
0.000000,0,0.000000,{
0.000000,0,0.000000,return unless @_;
0.000000,0,0.000000,my $min = my $max = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,for (my $i = 1; $i < @_; $i += 2)
0.000000,0,0.000000,{
0.000000,0,0.000000,if ($_[$i - 1] le $_[$i])
0.000000,0,0.000000,{
0.000000,0,0.000000,$min = $_[$i - 1] if $min gt $_[$i - 1];
0.000000,0,0.000000,$max = $_[$i]     if $max lt $_[$i];
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,$min = $_[$i]     if $min gt $_[$i];
0.000000,0,0.000000,$max = $_[$i - 1] if $max lt $_[$i - 1];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (@_ & 1)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $i = $#_;
0.000000,0,0.000000,if ($_[$i - 1] le $_[$i])
0.000000,0,0.000000,{
0.000000,0,0.000000,$min = $_[$i - 1] if $min gt $_[$i - 1];
0.000000,0,0.000000,$max = $_[$i]     if $max lt $_[$i];
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,$min = $_[$i]     if $min gt $_[$i];
0.000000,0,0.000000,$max = $_[$i - 1] if $max lt $_[$i - 1];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ($min, $max);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub part (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($code, @list) = @_;
0.000000,0,0.000000,my @parts;
0.000000,0,0.000000,push @{$parts[$code->($_)]}, $_ foreach @list;
0.000000,0,0.000000,return @parts;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub bsearch(&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $code = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $rc;
0.000000,0,0.000000,my $i = 0;
0.000000,0,0.000000,my $j = @_;
0.000000,0,0.000000,## no critic (ControlStructures::ProhibitNegativeExpressionsInUnlessAndUntilConditions)
0.000000,0,0.000000,do
0.000000,0,0.000000,{
0.000000,0,0.000000,my $k = int(($i + $j) / 2);
0.000000,0,0.000000,
0.000000,0,0.000000,$k >= @_ and return;
0.000000,0,0.000000,
0.000000,0,0.000000,local *_ = \$_[$k];
0.000000,0,0.000000,$rc = $code->();
0.000000,0,0.000000,
0.000000,0,0.000000,$rc == 0
0.000000,0,0.000000,and return wantarray ? $_ : 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($rc < 0)
0.000000,0,0.000000,{
0.000000,0,0.000000,$i = $k + 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,$j = $k - 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,} until $i > $j;
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub bsearchidx(&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $code = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $rc;
0.000000,0,0.000000,my $i = 0;
0.000000,0,0.000000,my $j = @_;
0.000000,0,0.000000,## no critic (ControlStructures::ProhibitNegativeExpressionsInUnlessAndUntilConditions)
0.000000,0,0.000000,do
0.000000,0,0.000000,{
0.000000,0,0.000000,my $k = int(($i + $j) / 2);
0.000000,0,0.000000,
0.000000,0,0.000000,$k >= @_ and return -1;
0.000000,0,0.000000,
0.000000,0,0.000000,local *_ = \$_[$k];
0.000000,0,0.000000,$rc = $code->();
0.000000,0,0.000000,
0.000000,0,0.000000,$rc == 0 and return $k;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($rc < 0)
0.000000,0,0.000000,{
0.000000,0,0.000000,$i = $k + 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,$j = $k - 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,} until $i > $j;
0.000000,0,0.000000,
0.000000,0,0.000000,return -1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub lower_bound(&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $code  = shift;
0.000000,0,0.000000,my $count = @_;
0.000000,0,0.000000,my $first = 0;
0.000000,0,0.000000,while ($count > 0)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $step = $count >> 1;
0.000000,0,0.000000,my $it   = $first + $step;
0.000000,0,0.000000,local *_ = \$_[$it];
0.000000,0,0.000000,if ($code->() < 0)
0.000000,0,0.000000,{
0.000000,0,0.000000,$first = ++$it;
0.000000,0,0.000000,$count -= $step + 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,$count = $step;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $first;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub upper_bound(&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $code  = shift;
0.000000,0,0.000000,my $count = @_;
0.000000,0,0.000000,my $first = 0;
0.000000,0,0.000000,while ($count > 0)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $step = $count >> 1;
0.000000,0,0.000000,my $it   = $first + $step;
0.000000,0,0.000000,local *_ = \$_[$it];
0.000000,0,0.000000,if ($code->() <= 0)
0.000000,0,0.000000,{
0.000000,0,0.000000,$first = ++$it;
0.000000,0,0.000000,$count -= $step + 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,$count = $step;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $first;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub equal_range(&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $lb = &lower_bound(@_);
0.000000,0,0.000000,my $ub = &upper_bound(@_);
0.000000,0,0.000000,return ($lb, $ub);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub binsert (&$\@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $lb = &lower_bound($_[0], @{$_[2]});
0.000000,0,0.000000,splice @{$_[2]}, $lb, 0, $_[1];
0.000000,0,0.000000,return $lb;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub bremove (&\@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $lb = &lower_bound($_[0], @{$_[1]});
0.000000,0,0.000000,return splice @{$_[1]}, $lb, 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub qsort(&\@)
0.000000,0,0.000000,{
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("It's insane to use a pure-perl qsort");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub slide(&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $op = shift;
0.000000,0,0.000000,my @l  = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,## no critic (TestingAndDebugging::ProhibitNoStrict, ValuesAndExpressions::ProhibitCommaSeparatedStatements)
0.000000,0,0.000000,# Localise $a, $b
0.000000,0,0.000000,my ($caller_a, $caller_b) = do
0.000000,0,0.000000,{
0.000000,0,0.000000,my $pkg = caller();
0.000390,2,0.000195,no strict 'refs';
0.000000,0,0.000000,\*{$pkg . '::a'}, \*{$pkg . '::b'};
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,## no critic (Variables::RequireInitializationForLocalVars)
0.000000,0,0.000000,# This map expression is also the return value
0.000000,0,0.000000,local (*$caller_a, *$caller_b);
0.000000,0,0.000000,## no critic (BuiltinFunctions::ProhibitComplexMappings)
0.000000,0,0.000000,return map {
0.000000,0,0.000000,# Assign to $a, $b as refs to caller's array elements
0.000000,0,0.000000,(*$caller_a, *$caller_b) = \($l[$_], $l[$_ + 1]);
0.000000,0,0.000000,
0.000000,0,0.000000,# Perform the transformation
0.000000,0,0.000000,$op->();
0.000000,0,0.000000,} 0 .. ($#l - 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub slideatatime ($$@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($m, $w, @list) = @_;
0.000000,0,0.000000,my $n = $w - $m - 1;
0.000000,0,0.000000,return $n >= 0
0.000000,0,0.000000,? sub { my @r = splice @list, 0, $m; $#list < $n and $n = $#list; @r and push @r, (@list ? @list[0 .. $n] : ()); return @r; }
0.000000,0,0.000000,: sub { return splice @list, 0, $m; };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sort_by(&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($code, @list) = @_;
0.000000,0,0.000000,return map { $_->[0] }
0.000000,0,0.000000,sort     { $a->[1] cmp $b->[1] }
0.000000,0,0.000000,map      { [$_, scalar($code->())] } @list;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub nsort_by(&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($code, @list) = @_;
0.000000,0,0.000000,return map { $_->[0] }
0.000000,0,0.000000,sort     { $a->[1] <=> $b->[1] }
0.000000,0,0.000000,map      { [$_, scalar($code->())] } @list;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
0.000000,0,0.000000,sub _XScompiled { return 0 }
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,L<List::Util>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHOR
0.000000,0,0.000000,
0.000000,0,0.000000,Jens Rehsack E<lt>rehsack AT cpan.orgE<gt>
0.000000,0,0.000000,
0.000000,0,0.000000,Adam Kennedy E<lt>adamk@cpan.orgE<gt>
0.000000,0,0.000000,
0.000000,0,0.000000,Tassilo von Parseval E<lt>tassilo.von.parseval@rwth-aachen.deE<gt>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT AND LICENSE
0.000000,0,0.000000,
0.000000,0,0.000000,Some parts copyright 2011 Aaron Crane.
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright 2004 - 2010 by Tassilo von Parseval
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright 2013 - 2017 by Jens Rehsack
0.000000,0,0.000000,
0.000000,0,0.000000,All code added with 0.417 or later is licensed under the Apache License,
0.000000,0,0.000000,Version 2.0 (the "License"); you may not use this file except in compliance
0.000000,0,0.000000,with the License. You may obtain a copy of the License at
0.000000,0,0.000000,
0.000000,0,0.000000,http://www.apache.org/licenses/LICENSE-2.0
0.000000,0,0.000000,
0.000000,0,0.000000,Unless required by applicable law or agreed to in writing, software
0.000000,0,0.000000,distributed under the License is distributed on an "AS IS" BASIS,
0.000000,0,0.000000,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0.000000,0,0.000000,See the License for the specific language governing permissions and
0.000000,0,0.000000,limitations under the License.
0.000000,0,0.000000,
0.000000,0,0.000000,All code until 0.416 is licensed under the same terms as Perl itself,
0.000000,0,0.000000,either Perl version 5.8.4 or, at your option, any later version of
0.000000,0,0.000000,Perl 5 you may have available.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000004,1,0.000004,1;
