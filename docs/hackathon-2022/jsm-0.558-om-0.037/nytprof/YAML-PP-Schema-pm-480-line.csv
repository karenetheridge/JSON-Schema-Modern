# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000028,2,0.000014,use strict;
0.000048,2,0.000024,use warnings;
0.000000,0,0.000000,package YAML::PP::Schema;
0.000019,2,0.000010,use B;
0.000337,2,0.000169,use Module::Load qw//;
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000692,2,0.000346,use YAML::PP::Common qw/ YAML_PLAIN_SCALAR_STYLE /;
0.000000,0,0.000000,
0.002638,2,0.001319,use Scalar::Util qw/ blessed /;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000002,1,0.000002,my ($class, %args) = @_;
0.000000,0,0.000000,
0.000001,1,0.000001,my $yaml_version = delete $args{yaml_version};
0.000002,1,0.000002,my $bool = delete $args{boolean};
0.000001,1,0.000001,$bool = 'perl' unless defined $bool;
0.000000,1,0.000000,if (keys %args) {
0.000000,0,0.000000,die "Unexpected arguments: " . join ', ', sort keys %args;
0.000000,0,0.000000,}
0.000001,1,0.000001,my $true;
0.000000,0,0.000000,my $false;
0.000000,0,0.000000,my @bool_class;
0.000005,1,0.000005,my @bools = split m/,/, $bool;
0.000000,1,0.000000,for my $b (@bools) {
0.000003,1,0.000003,if ($b eq '*') {
0.000000,0,0.000000,push @bool_class, ('boolean', 'JSON::PP::Boolean');
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($b eq 'JSON::PP') {
0.000003,1,0.000003,require JSON::PP;
0.000002,1,0.000002,$true ||= \&_bool_jsonpp_true;
0.000001,1,0.000001,$false ||= \&_bool_jsonpp_false;
0.000001,1,0.000001,push @bool_class, 'JSON::PP::Boolean';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($b eq 'boolean') {
0.000000,0,0.000000,require boolean;
0.000000,0,0.000000,$true ||= \&_bool_booleanpm_true;
0.000000,0,0.000000,$false ||= \&_bool_booleanpm_false;
0.000000,0,0.000000,push @bool_class, 'boolean';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($b eq 'perl') {
0.000000,0,0.000000,$true ||= \&_bool_perl_true;
0.000000,0,0.000000,$false ||= \&_bool_perl_false;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($b eq 'perl_experimental') {
0.000000,0,0.000000,$true ||= \&_bool_perl_true;
0.000000,0,0.000000,$false ||= \&_bool_perl_false;
0.000000,0,0.000000,push @bool_class, 'perl_experimental';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die "Invalid value for 'boolean': '$b'. Allowed: ('perl', 'boolean', 'JSON::PP')";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000016,1,0.000016,my %representers = (
0.000000,0,0.000000,'undef' => undef,
0.000000,0,0.000000,flags => [],
0.000000,0,0.000000,equals => {},
0.000000,0,0.000000,regex => [],
0.000000,0,0.000000,class_equals => {},
0.000000,0,0.000000,class_matches => [],
0.000000,0,0.000000,class_isa => [],
0.000000,0,0.000000,scalarref => undef,
0.000000,0,0.000000,refref => undef,
0.000000,0,0.000000,coderef => undef,
0.000000,0,0.000000,glob => undef,
0.000000,0,0.000000,tied_equals => {},
0.000000,0,0.000000,);
0.000007,1,0.000007,my $self = bless {
0.000000,0,0.000000,yaml_version => $yaml_version,
0.000000,0,0.000000,resolvers => {},
0.000000,0,0.000000,representers => \%representers,
0.000000,0,0.000000,true => $true,
0.000000,0,0.000000,false => $false,
0.000000,0,0.000000,bool_class => \@bool_class,
0.000000,0,0.000000,}, $class;
0.000007,1,0.000007,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.064400,28553,0.000002,sub resolvers { return $_[0]->{resolvers} }
0.000041,28,0.000001,sub representers { return $_[0]->{representers} }
0.000000,0,0.000000,
0.000010,3,0.000003,sub true { return $_[0]->{true} }
0.000030,3,0.000010,sub false { return $_[0]->{false} }
0.000009,2,0.000005,sub bool_class { return @{ $_[0]->{bool_class} } ? $_[0]->{bool_class} : undef }
0.000014,1,0.000014,sub yaml_version { return $_[0]->{yaml_version} }
0.000000,0,0.000000,
0.000001,1,0.000001,my %LOADED_SCHEMA = (
0.000000,0,0.000000,JSON => 1,
0.000000,0,0.000000,);
0.000001,1,0.000001,my %DEFAULT_SCHEMA = (
0.000000,0,0.000000,'1.2' => 'Core',
0.000000,0,0.000000,'1.1' => 'YAML1_1',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub load_subschemas {
0.000001,1,0.000001,my ($self, @schemas) = @_;
0.000002,1,0.000002,my $yaml_version = $self->yaml_version;
0.000000,1,0.000000,my $i = 0;
0.000026,1,0.000026,while ($i < @schemas) {
0.000000,1,0.000000,my $item = $schemas[ $i ];
0.000002,1,0.000002,if ($item eq '+') {
0.000000,0,0.000000,$item = $DEFAULT_SCHEMA{ $yaml_version };
0.000000,0,0.000000,}
0.000000,1,0.000000,$i++;
0.000005,1,0.000005,if (blessed($item)) {
0.000000,0,0.000000,$item->register(
0.000000,0,0.000000,schema => $self,
0.000000,0,0.000000,);
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,1,0.000000,my @options;
0.000001,1,0.000001,while ($i < @schemas
0.000000,0,0.000000,and (
0.000000,0,0.000000,$schemas[ $i ] =~ m/^[^A-Za-z]/
0.000000,0,0.000000,or
0.000000,0,0.000000,$schemas[ $i ] =~ m/^[a-zA-Z0-9]+=/
0.000000,0,0.000000,)
0.000000,0,0.000000,) {
0.000000,0,0.000000,push @options, $schemas[ $i ];
0.000000,0,0.000000,$i++;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,my $class;
0.000016,1,0.000016,if ($item =~ m/^\:(.*)/) {
0.000000,0,0.000000,$class = "$1";
0.000000,0,0.000000,unless ($class =~ m/\A[A-Za-z0-9_:]+\z/) {
0.000000,0,0.000000,die "Module name '$class' is invalid";
0.000000,0,0.000000,}
0.000000,0,0.000000,Module::Load::load $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000002,1,0.000002,$class = "YAML::PP::Schema::$item";
0.000012,1,0.000012,unless ($class =~ m/\A[A-Za-z0-9_:]+\z/) {
0.000000,0,0.000000,die "Module name '$class' is invalid";
0.000000,0,0.000000,}
0.000006,1,0.000006,$LOADED_SCHEMA{ $item } ||= Module::Load::load $class;
0.000000,0,0.000000,}
0.000009,1,0.000009,$class->register(
0.000000,0,0.000000,schema => $self,
0.000000,0,0.000000,options => \@options,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_resolver {
0.000025,28,0.000001,my ($self, %args) = @_;
0.000006,28,0.000000,my $tag = $args{tag};
0.000009,28,0.000000,my $rule = $args{match};
0.000037,28,0.000001,my $resolvers = $self->resolvers;
0.000008,28,0.000000,my ($type, @rule) = @$rule;
0.000006,28,0.000000,my $implicit = $args{implicit};
0.000005,28,0.000000,$implicit = 1 unless defined $implicit;
0.000014,28,0.000001,my $resolver_list = [];
0.000013,28,0.000000,if ($tag) {
0.000006,28,0.000000,if (ref $tag eq 'Regexp') {
0.000000,0,0.000000,my $res = $resolvers->{tags} ||= [];
0.000000,0,0.000000,push @$res, [ $tag, {} ];
0.000000,0,0.000000,push @$resolver_list, $res->[-1]->[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000017,28,0.000001,my $res = $resolvers->{tag}->{ $tag } ||= {};
0.000015,28,0.000001,push @$resolver_list, $res;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000008,28,0.000000,if ($implicit) {
0.000000,0,0.000000,push @$resolver_list, $resolvers->{value} ||= {};
0.000000,0,0.000000,}
0.000126,28,0.000004,for my $res (@$resolver_list) {
0.000021,56,0.000000,if ($type eq 'equals') {
0.000012,46,0.000000,my ($match, $value) = @rule;
0.000038,46,0.000001,unless (exists $res->{equals}->{ $match }) {
0.000000,0,0.000000,$res->{equals}->{ $match } = $value;
0.000000,0,0.000000,}
0.000016,46,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type eq 'regex') {
0.000014,8,0.000002,my ($match, $value) = @rule;
0.000028,8,0.000003,push @{ $res->{regex} }, [ $match => $value ];
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type eq 'all') {
0.000001,2,0.000000,my ($value) = @rule;
0.000001,2,0.000000,$res->{all} = $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_sequence_resolver {
0.000000,0,0.000000,my ($self, %args) = @_;
0.000000,0,0.000000,return $self->add_collection_resolver(sequence => %args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_mapping_resolver {
0.000000,0,0.000000,my ($self, %args) = @_;
0.000000,0,0.000000,return $self->add_collection_resolver(mapping => %args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_collection_resolver {
0.000000,0,0.000000,my ($self, $type, %args) = @_;
0.000000,0,0.000000,my $tag = $args{tag};
0.000000,0,0.000000,my $implicit = $args{implicit};
0.000000,0,0.000000,my $resolvers = $self->resolvers;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($tag and ref $tag eq 'Regexp') {
0.000000,0,0.000000,my $res = $resolvers->{ $type }->{tags} ||= [];
0.000000,0,0.000000,push @$res, [ $tag, {
0.000000,0,0.000000,on_create => $args{on_create},
0.000000,0,0.000000,on_data => $args{on_data},
0.000000,0,0.000000,} ];
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($tag) {
0.000000,0,0.000000,my $res = $resolvers->{ $type }->{tag}->{ $tag } ||= {
0.000000,0,0.000000,on_create => $args{on_create},
0.000000,0,0.000000,on_data => $args{on_data},
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_representer {
0.000017,28,0.000001,my ($self, %args) = @_;
0.000000,0,0.000000,
0.000024,28,0.000001,my $representers = $self->representers;
0.000005,28,0.000000,if (my $flags = $args{flags}) {
0.000001,2,0.000000,my $rep = $representers->{flags};
0.000001,2,0.000000,push @$rep, \%args;
0.000006,2,0.000003,return;
0.000000,0,0.000000,}
0.000006,26,0.000000,if (my $regex = $args{regex}) {
0.000001,1,0.000001,my $rep = $representers->{regex};
0.000001,1,0.000001,push @$rep, \%args;
0.000002,1,0.000002,return;
0.000000,0,0.000000,}
0.000005,25,0.000000,if (my $regex = $args{class_matches}) {
0.000000,0,0.000000,my $rep = $representers->{class_matches};
0.000000,0,0.000000,push @$rep, [ $args{class_matches}, $args{code} ];
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000007,25,0.000000,if (my $class_equals = $args{class_equals}) {
0.000000,1,0.000000,if ($] >= 5.036000 and $class_equals eq 'perl_experimental') {
0.000000,0,0.000000,$representers->{bool} = {
0.000000,0,0.000000,code => $args{code},
0.000000,0,0.000000,};
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,1,0.000000,my $rep = $representers->{class_equals};
0.000000,0,0.000000,$rep->{ $class_equals } = {
0.000000,0,0.000000,code => $args{code},
0.000001,1,0.000001,};
0.000003,1,0.000003,return;
0.000000,0,0.000000,}
0.000005,24,0.000000,if (my $class_isa = $args{class_isa}) {
0.000000,0,0.000000,my $rep = $representers->{class_isa};
0.000000,0,0.000000,push @$rep, [ $args{class_isa}, $args{code} ];
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000009,24,0.000000,if (my $tied_equals = $args{tied_equals}) {
0.000000,0,0.000000,my $rep = $representers->{tied_equals};
0.000000,0,0.000000,$rep->{ $tied_equals } = {
0.000000,0,0.000000,code => $args{code},
0.000000,0,0.000000,};
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000008,24,0.000000,if (defined(my $equals = $args{equals})) {
0.000006,23,0.000000,my $rep = $representers->{equals};
0.000000,0,0.000000,$rep->{ $equals } = {
0.000000,0,0.000000,code => $args{code},
0.000033,23,0.000001,};
0.000045,23,0.000002,return;
0.000000,0,0.000000,}
0.000000,1,0.000000,if (defined(my $scalarref = $args{scalarref})) {
0.000000,0,0.000000,$representers->{scalarref} = {
0.000000,0,0.000000,code => $args{code},
0.000000,0,0.000000,};
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,1,0.000000,if (defined(my $refref = $args{refref})) {
0.000000,0,0.000000,$representers->{refref} = {
0.000000,0,0.000000,code => $args{code},
0.000000,0,0.000000,};
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000001,1,0.000001,if (defined(my $coderef = $args{coderef})) {
0.000000,0,0.000000,$representers->{coderef} = {
0.000000,0,0.000000,code => $args{code},
0.000000,0,0.000000,};
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,1,0.000000,if (defined(my $glob = $args{glob})) {
0.000000,0,0.000000,$representers->{glob} = {
0.000000,0,0.000000,code => $args{code},
0.000000,0,0.000000,};
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000001,1,0.000001,if (my $undef = $args{undefined}) {
0.000001,1,0.000001,$representers->{undef} = $undef;
0.000003,1,0.000003,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub load_scalar {
0.004554,20941,0.000000,my ($self, $constructor, $event) = @_;
0.006312,20941,0.000000,my $tag = $event->{tag};
0.007090,20941,0.000000,my $value = $event->{value};
0.000000,0,0.000000,
0.017254,20941,0.000001,my $resolvers = $self->resolvers;
0.002476,20941,0.000000,my $res;
0.008295,20941,0.000000,if ($tag) {
0.000000,0,0.000000,$res = $resolvers->{tag}->{ $tag };
0.000000,0,0.000000,if (not $res and my $matches = $resolvers->{tags}) {
0.000000,0,0.000000,for my $match (@$matches) {
0.000000,0,0.000000,my ($re, $rule) = @$match;
0.000000,0,0.000000,if ($tag =~ $re) {
0.000000,0,0.000000,$res = $rule;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.004313,20941,0.000000,$res = $resolvers->{value};
0.012337,20941,0.000001,if ($event->{style} ne YAML_PLAIN_SCALAR_STYLE) {
0.000000,0,0.000000,return $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.008851,18884,0.000000,if (my $equals = $res->{equals}) {
0.017863,18884,0.000001,if (exists $equals->{ $value }) {
0.000507,1024,0.000000,my $res = $equals->{ $value };
0.003698,1024,0.000004,if (ref $res eq 'CODE') {
0.000000,0,0.000000,return $res->($constructor, $event);
0.000000,0,0.000000,}
0.000057,35,0.000002,return $res;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.007255,17860,0.000000,if (my $regex = $res->{regex}) {
0.010345,17860,0.000001,for my $item (@$regex) {
0.019852,70999,0.000000,my ($re, $sub) = @$item;
0.362301,70999,0.000005,my @matches = $value =~ $re;
0.030921,70999,0.000000,if (@matches) {
0.000000,0,0.000000,return $sub->($constructor, $event, \@matches);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.006726,17713,0.000000,if (my $catch_all = $res->{all}) {
0.059914,17713,0.000003,if (ref $catch_all eq 'CODE') {
0.000000,0,0.000000,return $catch_all->($constructor, $event);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $catch_all;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_sequence {
0.000297,645,0.000000,my ($self, $constructor, $event) = @_;
0.000333,645,0.000001,my $tag = $event->{tag};
0.000290,645,0.000000,my $data = [];
0.000110,645,0.000000,my $on_data;
0.000000,0,0.000000,
0.000911,645,0.000001,my $resolvers = $self->resolvers->{sequence};
0.000211,645,0.000000,if ($tag) {
0.000000,0,0.000000,if (my $equals = $resolvers->{tag}->{ $tag }) {
0.000000,0,0.000000,my $on_create = $equals->{on_create};
0.000000,0,0.000000,$on_data = $equals->{on_data};
0.000000,0,0.000000,$on_create and $data = $on_create->($constructor, $event);
0.000000,0,0.000000,return ($data, $on_data);
0.000000,0,0.000000,}
0.000000,0,0.000000,if (my $matches = $resolvers->{tags}) {
0.000000,0,0.000000,for my $match (@$matches) {
0.000000,0,0.000000,my ($re, $actions) = @$match;
0.000000,0,0.000000,my $on_create = $actions->{on_create};
0.000000,0,0.000000,if ($tag =~ $re) {
0.000000,0,0.000000,$on_data = $actions->{on_data};
0.000000,0,0.000000,$on_create and $data = $on_create->($constructor, $event);
0.000000,0,0.000000,return ($data, $on_data);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001533,645,0.000002,return ($data, $on_data);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_mapping {
0.001965,6939,0.000000,my ($self, $constructor, $event) = @_;
0.002861,6939,0.000000,my $tag = $event->{tag};
0.002708,6939,0.000000,my $data = {};
0.000949,6939,0.000000,my $on_data;
0.000000,0,0.000000,
0.009233,6939,0.000001,my $resolvers = $self->resolvers->{mapping};
0.001280,6939,0.000000,if ($tag) {
0.000000,0,0.000000,if (my $equals = $resolvers->{tag}->{ $tag }) {
0.000000,0,0.000000,my $on_create = $equals->{on_create};
0.000000,0,0.000000,$on_data = $equals->{on_data};
0.000000,0,0.000000,$on_create and $data = $on_create->($constructor, $event);
0.000000,0,0.000000,return ($data, $on_data);
0.000000,0,0.000000,}
0.000000,0,0.000000,if (my $matches = $resolvers->{tags}) {
0.000000,0,0.000000,for my $match (@$matches) {
0.000000,0,0.000000,my ($re, $actions) = @$match;
0.000000,0,0.000000,my $on_create = $actions->{on_create};
0.000000,0,0.000000,if ($tag =~ $re) {
0.000000,0,0.000000,$on_data = $actions->{on_data};
0.000000,0,0.000000,$on_create and $data = $on_create->($constructor, $event);
0.000000,0,0.000000,return ($data, $on_data);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.014960,6939,0.000002,return ($data, $on_data);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002680,581,0.000005,sub _bool_jsonpp_true { JSON::PP::true() }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _bool_booleanpm_true { boolean::true() }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _bool_perl_true { !!1 }
0.000000,0,0.000000,
0.001766,408,0.000004,sub _bool_jsonpp_false { JSON::PP::false() }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _bool_booleanpm_false { boolean::false() }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _bool_perl_false { !!0 }
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
