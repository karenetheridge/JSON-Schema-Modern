# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Type::Tiny;
0.000000,0,0.000000,
0.000069,2,0.000034,use 5.008001;
0.000017,2,0.000008,use strict;
0.000046,2,0.000023,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000002,1,0.000002,if ( $] < 5.010 ) { require Devel::TypeTiny::Perl58Compat }
0.000021,1,0.000021,}
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,$Type::Tiny::AUTHORITY  = 'cpan:TOBYINK';
0.000000,1,0.000000,$Type::Tiny::VERSION    = '2.000001';
0.000004,1,0.000004,$Type::Tiny::XS_VERSION = '0.016';
0.000026,1,0.000026,}
0.000000,0,0.000000,
0.000002,1,0.000002,$Type::Tiny::VERSION    =~ tr/_//d;
0.000000,1,0.000000,$Type::Tiny::XS_VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000016,2,0.000008,use Scalar::Util qw( blessed );
0.000783,2,0.000392,use Types::TypeTiny ();
0.000000,0,0.000000,
0.000001,1,0.000001,our $SafePackage = sprintf 'package %s;', __PACKAGE__;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
0.000000,0,0.000000,
0.000003,1,0.000003,sub _swap { $_[2] ? @_[ 1, 0 ] : @_[ 0, 1 ] }
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000001,1,0.000001,my $support_smartmatch = 0+ !!( $] >= 5.010001 );
0.000027,1,0.000027,eval qq{ sub SUPPORT_SMARTMATCH () { !! $support_smartmatch } };
0.000000,0,0.000000,
0.000000,1,0.000000,my $fixed_precedence = 0+ !!( $] >= 5.014 );
0.000017,1,0.000017,eval qq{ sub _FIXED_PRECEDENCE () { !! $fixed_precedence } };
0.000000,0,0.000000,
0.000000,0,0.000000,my $try_xs =
0.000000,0,0.000000,exists( $ENV{PERL_TYPE_TINY_XS} ) ? !!$ENV{PERL_TYPE_TINY_XS}
0.000000,0,0.000000,: exists( $ENV{PERL_ONLY} )       ? !$ENV{PERL_ONLY}
0.000001,1,0.000001,:                                   1;
0.000000,0,0.000000,
0.000000,1,0.000000,my $use_xs = 0;
0.000001,1,0.000001,$try_xs and eval {
0.000098,1,0.000098,require Type::Tiny::XS;
0.000000,0,0.000000,'Type::Tiny::XS'->VERSION( $Type::Tiny::XS_VERSION );
0.000000,0,0.000000,$use_xs++;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,*_USE_XS =
0.000000,0,0.000000,$use_xs
0.000000,0,0.000000,? sub () { !!1 }
0.000001,1,0.000001,: sub () { !!0 };
0.000000,0,0.000000,
0.000000,0,0.000000,*_USE_MOUSE =
0.000000,0,0.000000,$try_xs
0.000151,43,0.000004,? sub () { $INC{'Mouse/Util.pm'} and Mouse::Util::MOUSE_XS() }
0.000002,1,0.000002,: sub () { !!0 };
0.000000,0,0.000000,
0.000000,1,0.000000,my $strict_mode = 0;
0.000006,1,0.000006,$ENV{$_} && ++$strict_mode for qw(
0.000000,0,0.000000,EXTENDED_TESTING
0.000000,0,0.000000,AUTHOR_TESTING
0.000000,0,0.000000,RELEASE_TESTING
0.000000,0,0.000000,PERL_STRICT
0.000000,0,0.000000,);
0.000004,1,0.000004,*_STRICT_MODE = $strict_mode ? sub () { !!1 } : sub () { !!0 };
0.000029,1,0.000029,} #/ BEGIN
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_overloads {
0.000041,2,0.000021,no strict 'refs';
0.007222,2,0.003611,no warnings 'redefine', 'once';
0.000000,0,0.000000,
0.000000,0,0.000000,# Coverage is checked on Perl 5.26
0.000005,8,0.000001,if ( $] < 5.010 ) {    # uncoverable statement
0.000000,0,0.000000,require overload;             # uncoverable statement
0.000000,0,0.000000,push @_, fallback => 1;       # uncoverable statement
0.000000,0,0.000000,goto \&overload::OVERLOAD;    # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,8,0.000000,my $class = shift;
0.000036,8,0.000005,*{ $class . '::((' } = sub { };
0.000014,8,0.000002,*{ $class . '::()' } = sub { };
0.000014,24,0.000001,*{ $class . '::()' } = do { my $x = 1; \$x };
0.000043,8,0.000005,while ( @_ ) {
0.000007,25,0.000000,my $f = shift;
0.000036,25,0.000001,*{ $class . '::(' . $f } = ref $_[0] ? shift : do {
0.000000,2,0.000000,my $m = shift;
0.000759,183,0.000004,sub { shift->$m( @_ ) }
0.000003,2,0.000002,};
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ sub _install_overloads
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,__PACKAGE__->_install_overloads(
0.000000,0,0.000000,q("") => sub {
0.001812,367,0.000005,caller =~ m{^(Moo::HandleMoose|Sub::Quote)}
0.000000,0,0.000000,? $_[0]->_stringify_no_magic
0.000000,0,0.000000,: $_[0]->display_name;
0.000000,0,0.000000,},
0.000466,240,0.000002,q(bool) => sub { 1 },
0.000000,0,0.000000,q(&{})  => "_overload_coderef",
0.000000,0,0.000000,q(|)    => sub {
0.000003,1,0.000003,my @tc = _swap @_;
0.000000,0,0.000000,if ( !_FIXED_PRECEDENCE && $_[2] ) {
0.000000,0,0.000000,if ( blessed $tc[0] ) {
0.000000,0,0.000000,if ( blessed $tc[0] eq "Type::Tiny::_HalfOp" ) {
0.000000,0,0.000000,my $type  = $tc[0]->{type};
0.000000,0,0.000000,my $param = $tc[0]->{param};
0.000000,0,0.000000,my $op    = $tc[0]->{op};
0.000000,0,0.000000,require Type::Tiny::Union;
0.000000,0,0.000000,return "Type::Tiny::_HalfOp"->new(
0.000000,0,0.000000,$op,
0.000000,0,0.000000,$param,
0.000000,0,0.000000,"Type::Tiny::Union"->new_by_overload( type_constraints => [ $type, $tc[1] ] ),
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ if ( blessed $tc[0] eq...)
0.000000,0,0.000000,} #/ if ( blessed $tc[0] )
0.000000,0,0.000000,elsif ( ref $tc[0] eq 'ARRAY' ) {
0.000000,0,0.000000,require Type::Tiny::_HalfOp;
0.000000,0,0.000000,return "Type::Tiny::_HalfOp"->new( '|', @tc );
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( !_FIXED_PRECEDENCE...)
0.000498,1,0.000498,require Type::Tiny::Union;
0.000004,1,0.000004,return "Type::Tiny::Union"->new_by_overload( type_constraints => \@tc );
0.000000,0,0.000000,},
0.000000,0,0.000000,q(&) => sub {
0.000000,0,0.000000,my @tc = _swap @_;
0.000000,0,0.000000,if ( !_FIXED_PRECEDENCE && $_[2] ) {
0.000000,0,0.000000,if ( blessed $tc[0] ) {
0.000000,0,0.000000,if ( blessed $tc[0] eq "Type::Tiny::_HalfOp" ) {
0.000000,0,0.000000,my $type  = $tc[0]->{type};
0.000000,0,0.000000,my $param = $tc[0]->{param};
0.000000,0,0.000000,my $op    = $tc[0]->{op};
0.000000,0,0.000000,require Type::Tiny::Intersection;
0.000000,0,0.000000,return "Type::Tiny::_HalfOp"->new(
0.000000,0,0.000000,$op,
0.000000,0,0.000000,$param,
0.000000,0,0.000000,"Type::Tiny::Intersection"->new_by_overload( type_constraints => [ $type, $tc[1] ] ),
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ if ( blessed $tc[0] eq...)
0.000000,0,0.000000,} #/ if ( blessed $tc[0] )
0.000000,0,0.000000,elsif ( ref $tc[0] eq 'ARRAY' ) {
0.000000,0,0.000000,require Type::Tiny::_HalfOp;
0.000000,0,0.000000,return "Type::Tiny::_HalfOp"->new( '&', @tc );
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( !_FIXED_PRECEDENCE...)
0.000000,0,0.000000,require Type::Tiny::Intersection;
0.000000,0,0.000000,"Type::Tiny::Intersection"->new_by_overload( type_constraints => \@tc );
0.000000,0,0.000000,},
0.000000,0,0.000000,q(~)  => sub { shift->complementary_type },
0.000000,0,0.000000,q(==) => sub { $_[0]->equals( $_[1] ) },
0.000000,0,0.000000,q(!=) => sub { not $_[0]->equals( $_[1] ) },
0.000000,0,0.000000,q(<)  => sub { my $m = $_[0]->can( 'is_subtype_of' ); $m->( _swap @_ ) },
0.000000,0,0.000000,q(>)  => sub {
0.000000,0,0.000000,my $m = $_[0]->can( 'is_subtype_of' );
0.000000,0,0.000000,$m->( reverse _swap @_ );
0.000000,0,0.000000,},
0.000000,0,0.000000,q(<=) => sub { my $m = $_[0]->can( 'is_a_type_of' ); $m->( _swap @_ ) },
0.000000,0,0.000000,q(>=) => sub {
0.000000,0,0.000000,my $m = $_[0]->can( 'is_a_type_of' );
0.000000,0,0.000000,$m->( reverse _swap @_ );
0.000000,0,0.000000,},
0.000000,0,0.000000,q(eq)  => sub { "$_[0]" eq "$_[1]" },
0.000000,0,0.000000,q(cmp) => sub { $_[2] ? ( "$_[1]" cmp "$_[0]" ) : ( "$_[0]" cmp "$_[1]" ) },
0.000000,0,0.000000,q(0+)  => sub { $_[0]{uniq} },
0.000000,0,0.000000,q(/)   => sub { ( _STRICT_MODE xor $_[2] ) ? $_[0] : $_[1] },
0.000016,1,0.000016,);
0.000000,0,0.000000,
0.000000,0,0.000000,__PACKAGE__->_install_overloads(
0.000000,0,0.000000,q(~~) => sub { $_[0]->check( $_[1] ) },
0.000001,1,0.000001,) if Type::Tiny::SUPPORT_SMARTMATCH;
0.000000,0,0.000000,
0.000000,0,0.000000,# Would be easy to just return sub { $self->assert_return(@_) }
0.000000,0,0.000000,# but try to build a more efficient coderef whenever possible.
0.000000,0,0.000000,#
0.000000,0,0.000000,sub _overload_coderef {
0.000039,220,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Bypass generating a coderef if we've already got the best possible one.
0.000000,0,0.000000,#
0.000517,220,0.000002,return $self->{_overload_coderef} if $self->{_overload_coderef_no_rebuild};
0.000000,0,0.000000,
0.000000,0,0.000000,# Subclasses of Type::Tiny might override assert_return to do some kind
0.000000,0,0.000000,# of interesting thing. In that case, we can't rely on it having identical
0.000000,0,0.000000,# behaviour to Type::Tiny::inline_assert.
0.000000,0,0.000000,#
0.000000,0,0.000000,$self->{_overrides_assert_return} =
0.000000,0,0.000000,( $self->can( 'assert_return' ) != \&assert_return )
0.000193,64,0.000003,unless exists $self->{_overrides_assert_return};
0.000000,0,0.000000,
0.000104,64,0.000002,if ( $self->{_overrides_assert_return} ) {
0.000000,0,0.000000,$self->{_overload_coderef} ||= do {
0.000000,0,0.000000,Scalar::Util::weaken( my $weak = $self );
0.000000,0,0.000000,sub { $weak->assert_return( @_ ) };
0.000000,0,0.000000,};
0.000000,0,0.000000,++$self->{_overload_coderef_no_rebuild};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( exists( &Sub::Quote::quote_sub ) ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Use `=` instead of `||=` because we want to overwrite non-Sub::Quote
0.000000,0,0.000000,# coderef if possible.
0.000170,27,0.000006,$self->{_overload_coderef} = $self->can_be_inlined
0.000000,0,0.000000,? Sub::Quote::quote_sub(
0.000000,0,0.000000,$self->inline_assert( '$_[0]' ),
0.000000,0,0.000000,)
0.000000,0,0.000000,: Sub::Quote::quote_sub(
0.000000,0,0.000000,$self->inline_assert( '$_[0]', '$type' ),
0.000000,0,0.000000,{ '$type' => \$self },
0.000000,0,0.000000,);
0.000044,27,0.000002,++$self->{_overload_coderef_no_rebuild};
0.000000,0,0.000000,} #/ elsif ( exists( &Sub::Quote::quote_sub...))
0.000000,0,0.000000,else {
0.000018,37,0.000000,require Eval::TypeTiny;
0.000294,37,0.000008,$self->{_overload_coderef} ||= $self->can_be_inlined
0.000000,0,0.000000,? Eval::TypeTiny::eval_closure(
0.000000,0,0.000000,source => sprintf(
0.000000,0,0.000000,'sub { %s }', $self->inline_assert( '$_[0]', undef, no_wrapper => 1 )
0.000000,0,0.000000,),
0.000000,0,0.000000,description => sprintf( "compiled assertion 'assert_%s'", $self ),
0.000000,0,0.000000,)
0.000000,0,0.000000,: Eval::TypeTiny::eval_closure(
0.000000,0,0.000000,source => sprintf(
0.000000,0,0.000000,'sub { %s }', $self->inline_assert( '$_[0]', '$type', no_wrapper => 1 )
0.000000,0,0.000000,),
0.000000,0,0.000000,description => sprintf( "compiled assertion 'assert_%s'", $self ),
0.000000,0,0.000000,environment => { '$type' => \$self },
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ else [ if ( $self->{_overrides_assert_return...})]
0.000000,0,0.000000,
0.000156,64,0.000002,$self->{_overload_coderef};
0.000000,0,0.000000,} #/ sub _overload_coderef
0.000000,0,0.000000,
0.000000,0,0.000000,our %ALL_TYPES;
0.000000,0,0.000000,
0.000000,1,0.000000,my $QFS;
0.000000,1,0.000000,my $uniq = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000037,82,0.000000,my $class  = shift;
0.000197,82,0.000002,my %params = ( @_ == 1 ) ? %{ $_[0] } : @_;
0.000000,0,0.000000,
0.000050,82,0.000001,for ( qw/ name display_name library / ) {
0.000197,246,0.000001,$params{$_} = $params{$_} . '' if defined $params{$_};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000057,82,0.000001,if ( exists $params{parent} ) {
0.000000,0,0.000000,$params{parent} =
0.000000,0,0.000000,ref( $params{parent} ) =~ /^Type::Tiny\b/
0.000000,0,0.000000,? $params{parent}
0.000317,63,0.000005,: Types::TypeTiny::to_TypeTiny( $params{parent} );
0.000000,0,0.000000,
0.000000,0,0.000000,_croak "Parent must be an instance of %s", __PACKAGE__
0.000000,0,0.000000,unless blessed( $params{parent} )
0.000254,63,0.000004,&& $params{parent}->isa( __PACKAGE__ );
0.000000,0,0.000000,
0.000094,63,0.000001,if ( $params{parent}->deprecated and not exists $params{deprecated} ) {
0.000000,0,0.000000,$params{deprecated} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( exists $params{parent...})
0.000000,0,0.000000,
0.000076,82,0.000001,if ( exists $params{constraint}
0.000000,0,0.000000,and defined $params{constraint}
0.000000,0,0.000000,and not ref $params{constraint} )
0.000000,0,0.000000,{
0.000002,5,0.000000,require Eval::TypeTiny;
0.000002,5,0.000000,my $code = $params{constraint};
0.000012,5,0.000002,$params{constraint} = Eval::TypeTiny::eval_closure(
0.000000,0,0.000000,source      => sprintf( 'sub ($) { %s }', $code ),
0.000000,0,0.000000,description => "anonymous check",
0.000000,0,0.000000,);
0.000000,0,0.000000,$params{inlined} ||= sub {
0.000018,30,0.000001,my ( $type ) = @_;
0.000045,30,0.000002,my $inlined  = $_ eq '$_' ? "do { $code }" : "do { local \$_ = $_; $code }";
0.000117,30,0.000004,$type->has_parent ? ( undef, $inlined ) : $inlined;
0.000000,0,0.000000,}
0.000019,5,0.000004,if ( !exists $params{parent} or $params{parent}->can_be_inlined );
0.000000,0,0.000000,} #/ if ( exists $params{constraint...})
0.000000,0,0.000000,
0.000000,0,0.000000,# canonicalize to a boolean
0.000112,82,0.000001,$params{deprecated} = !!$params{deprecated};
0.000000,0,0.000000,
0.000061,82,0.000001,$params{name} = "__ANON__" unless exists $params{name};
0.000089,82,0.000001,$params{uniq} = $uniq++;
0.000000,0,0.000000,
0.000062,82,0.000001,if ( $params{name} ne "__ANON__" ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# First try a fast ASCII-only expression, but fall back to Unicode
0.000000,0,0.000000,$params{name} =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm
0.000000,0,0.000000,or eval q( use 5.008; $params{name} =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm )
0.000164,39,0.000004,or _croak '"%s" is not a valid type name', $params{name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000024,82,0.000000,if ( exists $params{coercion} and !ref $params{coercion} and $params{coercion} )
0.000000,0,0.000000,{
0.000000,0,0.000000,$params{parent}->has_coercion
0.000000,0,0.000000,or _croak
0.000000,0,0.000000,"coercion => 1 requires type to have a direct parent with a coercion";
0.000000,0,0.000000,
0.000000,0,0.000000,$params{coercion} = $params{parent}->coercion->type_coercion_map;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000045,82,0.000001,if ( !exists $params{inlined}
0.000000,0,0.000000,and exists $params{constraint}
0.000000,0,0.000000,and ( !exists $params{parent} or $params{parent}->can_be_inlined )
0.000000,0,0.000000,and $QFS ||= "Sub::Quote"->can( "quoted_from_sub" ) )
0.000000,0,0.000000,{
0.000000,0,0.000000,my ( undef, $perlstring, $captures ) = @{ $QFS->( $params{constraint} ) || [] };
0.000000,0,0.000000,
0.000000,0,0.000000,$params{inlined} = sub {
0.000000,0,0.000000,my ( $self, $var ) = @_;
0.000000,0,0.000000,my $code = Sub::Quote::inlinify(
0.000000,0,0.000000,$perlstring,
0.000000,0,0.000000,$var,
0.000000,0,0.000000,$var eq q($_) ? '' : "local \$_ = $var;",
0.000000,0,0.000000,1,
0.000000,0,0.000000,);
0.000000,0,0.000000,$code = sprintf( '%s and %s', $self->parent->inline_check( $var ), $code )
0.000000,0,0.000000,if $self->has_parent;
0.000000,0,0.000000,return $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,if $perlstring && !$captures;
0.000000,0,0.000000,} #/ if ( !exists $params{inlined...})
0.000000,0,0.000000,
0.000102,82,0.000001,my $self = bless \%params, $class;
0.000000,0,0.000000,
0.000093,82,0.000001,unless ( $params{tmp} ) {
0.000189,82,0.000002,my $uniq = $self->{uniq};
0.000000,0,0.000000,
0.000096,82,0.000001,$ALL_TYPES{$uniq} = $self;
0.000281,82,0.000003,Scalar::Util::weaken( $ALL_TYPES{$uniq} );
0.000000,0,0.000000,
0.000018,82,0.000000,my $tmp = $self;
0.000155,82,0.000002,Scalar::Util::weaken( $tmp );
0.000395,82,0.000005,$Moo::HandleMoose::TYPE_MAP{ $self->_stringify_no_magic } = sub { $tmp };
0.000000,0,0.000000,} #/ unless ( $params{tmp} )
0.000000,0,0.000000,
0.000086,82,0.000001,if ( ref( $params{coercion} ) eq q(CODE) ) {
0.000000,0,0.000000,require Types::Standard;
0.000000,0,0.000000,my $code = delete( $params{coercion} );
0.000000,0,0.000000,$self->{coercion} = $self->_build_coercion;
0.000000,0,0.000000,$self->coercion->add_type_coercions( Types::Standard::Any(), $code );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( ref( $params{coercion} ) eq q(ARRAY) ) {
0.000000,0,0.000000,my $arr = delete( $params{coercion} );
0.000000,0,0.000000,$self->{coercion} = $self->_build_coercion;
0.000000,0,0.000000,$self->coercion->add_type_coercions( @$arr );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Documenting this here because it's too weird to be in the pod.
0.000000,0,0.000000,# There's a secret attribute called "_build_coercion" which takes a
0.000000,0,0.000000,# coderef. If present, then when $type->coercion is lazy built,
0.000000,0,0.000000,# the blank Type::Coercion object gets passed to the coderef,
0.000000,0,0.000000,# allowing the coderef to manipulate it a little. This is used by
0.000000,0,0.000000,# Types::TypeTiny to allow it to build a coercion for the TypeTiny
0.000000,0,0.000000,# type constraint without needing to load Type::Coercion yet.
0.000000,0,0.000000,
0.000033,82,0.000000,if ( $params{my_methods} ) {
0.000001,4,0.000000,require Eval::TypeTiny;
0.000000,0,0.000000,Scalar::Util::reftype( $params{my_methods}{$_} ) eq 'CODE'
0.000000,0,0.000000,and Eval::TypeTiny::set_subname(
0.000000,0,0.000000,sprintf( "%s::my_%s", $self->qualified_name, $_ ),
0.000000,0,0.000000,$params{my_methods}{$_},
0.000027,4,0.000007,) for keys %{ $params{my_methods} };
0.000000,0,0.000000,} #/ if ( $params{my_methods...})
0.000000,0,0.000000,
0.000193,82,0.000002,return $self;
0.000000,0,0.000000,} #/ sub new
0.000000,0,0.000000,
0.000000,0,0.000000,sub DESTROY {
0.000001,1,0.000001,my $self = shift;
0.000014,1,0.000014,delete( $ALL_TYPES{ $self->{uniq} } );
0.000003,1,0.000003,delete( $Moo::HandleMoose::TYPE_MAP{ $self->_stringify_no_magic } );
0.000005,1,0.000005,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _clone {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %opts;
0.000000,0,0.000000,$opts{$_} = $self->{$_} for qw< name display_name message >;
0.000000,0,0.000000,$self->create_child_type( %opts );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _stringify_no_magic {
0.001089,83,0.000013,sprintf(
0.000000,0,0.000000,'%s=%s(0x%08x)', blessed( $_[0] ), Scalar::Util::reftype( $_[0] ),
0.000000,0,0.000000,Scalar::Util::refaddr( $_[0] )
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,our $DD;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _dd {
0.000000,0,0.000000,@_ = $_ unless @_;
0.000000,0,0.000000,my ( $value ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,goto $DD if ref( $DD ) eq q(CODE);
0.000000,0,0.000000,
0.000000,0,0.000000,require B;
0.000000,0,0.000000,
0.000000,0,0.000000,!defined $value  ? 'Undef'
0.000000,0,0.000000,: !ref $value ? sprintf( 'Value %s', B::perlstring( $value ) )
0.000000,0,0.000000,: do {
0.000000,0,0.000000,my $N = 0+ ( defined( $DD ) ? $DD : 72 );
0.000000,0,0.000000,require Data::Dumper;
0.000000,0,0.000000,local $Data::Dumper::Indent   = 0;
0.000000,0,0.000000,local $Data::Dumper::Useqq    = 1;
0.000000,0,0.000000,local $Data::Dumper::Terse    = 1;
0.000000,0,0.000000,local $Data::Dumper::Sortkeys = 1;
0.000000,0,0.000000,local $Data::Dumper::Maxdepth = 2;
0.000000,0,0.000000,my $str;
0.000000,0,0.000000,eval {
0.000000,0,0.000000,$str = Data::Dumper::Dumper( $value );
0.000000,0,0.000000,$str = substr( $str, 0, $N - 12 ) . '...' . substr( $str, -1, 1 )
0.000000,0,0.000000,if length( $str ) >= $N;
0.000000,0,0.000000,1;
0.000000,0,0.000000,} or do { $str = 'which cannot be dumped' };
0.000000,0,0.000000,"Reference $str";
0.000000,0,0.000000,} #/ do
0.000000,0,0.000000,} #/ sub _dd
0.000000,0,0.000000,
0.000000,0,0.000000,sub _loose_to_TypeTiny {
0.000450,1691,0.000000,my $caller = caller( 1 ); # assumption
0.000000,0,0.000000,map +(
0.000000,0,0.000000,ref( $_ )
0.000000,0,0.000000,? Types::TypeTiny::to_TypeTiny( $_ )
0.004768,1691,0.000003,: do { require Type::Utils; Type::Utils::dwim_type( $_, for => $caller ) }
0.000000,0,0.000000,), @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000566,297,0.000002,sub name         { $_[0]{name} }
0.000865,367,0.000002,sub display_name { $_[0]{display_name} ||= $_[0]->_build_display_name }
0.001658,1139,0.000001,sub parent       { $_[0]{parent} }
0.002099,1539,0.000001,sub constraint   { $_[0]{constraint} ||= $_[0]->_build_constraint }
0.000000,0,0.000000,
0.000000,0,0.000000,sub compiled_check {
0.000482,169,0.000003,$_[0]{compiled_type_constraint} ||= $_[0]->_build_compiled_check;
0.000000,0,0.000000,}
0.000241,58,0.000004,sub coercion             { $_[0]{coercion} ||= $_[0]->_build_coercion }
0.000000,0,0.000000,sub message              { $_[0]{message} }
0.000000,0,0.000000,sub library              { $_[0]{library} }
0.000945,525,0.000002,sub inlined              { $_[0]{inlined} }
0.000245,103,0.000002,sub deprecated           { $_[0]{deprecated} }
0.000098,34,0.000003,sub constraint_generator { $_[0]{constraint_generator} }
0.000034,20,0.000002,sub inline_generator     { $_[0]{inline_generator} }
0.000070,22,0.000003,sub name_generator       { $_[0]{name_generator} ||= $_[0]->_build_name_generator }
0.000006,3,0.000002,sub coercion_generator   { $_[0]{coercion_generator} }
0.000008,5,0.000002,sub parameters           { $_[0]{parameters} }
0.000000,0,0.000000,sub moose_type           { $_[0]{moose_type} ||= $_[0]->_build_moose_type }
0.000000,0,0.000000,sub mouse_type           { $_[0]{mouse_type} ||= $_[0]->_build_mouse_type }
0.000000,0,0.000000,sub deep_explanation     { $_[0]{deep_explanation} }
0.000034,18,0.000002,sub my_methods           { $_[0]{my_methods} ||= $_[0]->_build_my_methods }
0.000000,0,0.000000,sub sorter               { $_[0]{sorter} }
0.000000,0,0.000000,
0.005352,3624,0.000001,sub has_parent               { exists $_[0]{parent} }
0.000000,0,0.000000,sub has_library              { exists $_[0]{library} }
0.001186,796,0.000001,sub has_inlined              { exists $_[0]{inlined} }
0.000245,106,0.000002,sub has_constraint_generator { exists $_[0]{constraint_generator} }
0.000045,20,0.000002,sub has_inline_generator     { exists $_[0]{inline_generator} }
0.000163,54,0.000003,sub has_coercion_generator   { exists $_[0]{coercion_generator} }
0.000005,3,0.000002,sub has_parameters           { exists $_[0]{parameters} }
0.000000,0,0.000000,sub has_message              { defined $_[0]{message} }
0.000000,0,0.000000,sub has_deep_explanation     { exists $_[0]{deep_explanation} }
0.000000,0,0.000000,sub has_sorter               { exists $_[0]{sorter} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _default_message {
0.000000,0,0.000000,$_[0]{_default_message} ||= $_[0]->_build_default_message;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_coercion {
0.000037,85,0.000000,$_[0]->coercion if $_[0]{_build_coercion};    # trigger auto build thing
0.000255,85,0.000003,$_[0]{coercion} and !!@{ $_[0]{coercion}->type_coercion_map };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _assert_coercion {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return $self->coercion if $self->{_build_coercion};    # trigger auto build thing
0.000000,0,0.000000,_croak "No coercion for this type constraint"
0.000000,0,0.000000,unless $self->has_coercion
0.000000,0,0.000000,&& @{ $self->coercion->type_coercion_map };
0.000000,0,0.000000,$self->coercion;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my $null_constraint = sub { !!1 };
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_display_name {
0.000105,44,0.000002,shift->name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_constraint {
0.000020,15,0.000001,return $null_constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _is_null_constraint {
0.003299,1539,0.000002,shift->constraint == $null_constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_coercion {
0.000581,54,0.000011,require Type::Coercion;
0.000014,54,0.000000,my $self = shift;
0.000037,54,0.000001,my %opts = ( type_constraint => $self );
0.000197,54,0.000004,$opts{display_name} = "to_$self" unless $self->is_anon;
0.000106,54,0.000002,my $coercion = "Type::Coercion"->new( %opts );
0.000035,54,0.000001,$self->{_build_coercion}->( $coercion ) if ref $self->{_build_coercion};
0.000107,54,0.000002,$coercion;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_default_message {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->{is_using_default_message} = 1;
0.000000,0,0.000000,return sub { sprintf '%s did not pass type constraint', _dd( $_[0] ) }
0.000000,0,0.000000,if "$self" eq "__ANON__";
0.000000,0,0.000000,my $name = "$self";
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,sprintf '%s did not pass type constraint "%s"', _dd( $_[0] ), $name;
0.000000,0,0.000000,};
0.000000,0,0.000000,} #/ sub _build_default_message
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_name_generator {
0.000001,5,0.000000,my $self = shift;
0.000000,0,0.000000,return sub {
0.000185,16,0.000012,defined && s/[\x00-\x1F]//smg for ( my ( $s, @a ) = @_ );
0.000160,16,0.000010,sprintf( '%s[%s]', $s, join q[,], map !defined() ? 'undef' : !ref() && /\W/ ? B::perlstring($_) : $_, @a );
0.000025,5,0.000005,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_compiled_check {
0.000027,62,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000028,62,0.000000,local our $AvoidCallbacks = 0;
0.000000,0,0.000000,
0.000186,62,0.000003,if ( $self->_is_null_constraint and $self->has_parent ) {
0.000000,0,0.000000,return $self->parent->compiled_check;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000030,48,0.000001,require Eval::TypeTiny;
0.000568,48,0.000012,return Eval::TypeTiny::eval_closure(
0.000000,0,0.000000,source      => sprintf( 'sub ($) { %s }',      $self->inline_check( '$_[0]' ) ),
0.000000,0,0.000000,description => sprintf( "compiled check '%s'", $self ),
0.000000,0,0.000000,) if $self->can_be_inlined;
0.000000,0,0.000000,
0.000000,0,0.000000,my @constraints;
0.000000,0,0.000000,push @constraints, $self->parent->compiled_check if $self->has_parent;
0.000000,0,0.000000,push @constraints, $self->constraint             if !$self->_is_null_constraint;
0.000000,0,0.000000,return $null_constraint unless @constraints;
0.000000,0,0.000000,
0.000000,0,0.000000,return sub ($) {
0.000000,0,0.000000,local $_ = $_[0];
0.000000,0,0.000000,for my $c ( @constraints ) {
0.000000,0,0.000000,return unless $c->( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,return !!1;
0.000000,0,0.000000,};
0.000000,0,0.000000,} #/ sub _build_compiled_check
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_constraining_type {
0.000001,6,0.000000,my $self = shift;
0.000006,6,0.000001,if ( $self->_is_null_constraint and $self->has_parent ) {
0.000000,0,0.000000,return $self->parent->find_constraining_type;
0.000000,0,0.000000,}
0.000008,6,0.000001,$self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub type_default {
0.000006,17,0.000000,my ( $self, @args ) = @_;
0.000011,17,0.000001,if ( exists $self->{type_default} ) {
0.000001,16,0.000000,if ( @args ) {
0.000000,0,0.000000,my $td = $self->{type_default};
0.000000,0,0.000000,return sub { local $_ = \@args; &$td; };
0.000000,0,0.000000,}
0.000073,16,0.000005,return $self->{type_default};
0.000000,0,0.000000,}
0.000016,1,0.000016,if ( my $parent = $self->parent ) {
0.000000,0,0.000000,return $parent->type_default( @args ) if $self->_is_null_constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,our @CMP;
0.000000,0,0.000000,
0.000000,0,0.000000,sub CMP_SUPERTYPE ()  { -1 }
0.000000,0,0.000000,sub CMP_EQUAL ()      { 0 }
0.000000,0,0.000000,sub CMP_EQUIVALENT () { '0E0' }
0.000000,0,0.000000,sub CMP_SUBTYPE ()    { 1 }
0.000000,0,0.000000,sub CMP_UNKNOWN ()    { ''; }
0.000000,0,0.000000,
0.000000,0,0.000000,# avoid getting mixed up with cmp operator at compile time
0.000000,0,0.000000,*cmp = sub {
0.000008,3,0.000003,my ( $A, $B ) = _loose_to_TypeTiny( $_[0], $_[1] );
0.000011,3,0.000004,return unless blessed( $A ) && $A->isa( "Type::Tiny" );
0.000008,3,0.000003,return unless blessed( $B ) && $B->isa( "Type::Tiny" );
0.000004,3,0.000001,for my $comparator ( @CMP ) {
0.000006,3,0.000002,my $result = $comparator->( $A, $B );
0.000002,3,0.000001,next if $result eq CMP_UNKNOWN;
0.000001,3,0.000000,if ( $result eq CMP_EQUIVALENT ) {
0.000000,0,0.000000,my $prefer = @_ == 3 ? $_[2] : CMP_EQUAL;
0.000000,0,0.000000,return $prefer;
0.000000,0,0.000000,}
0.000008,3,0.000003,return $result;
0.000000,0,0.000000,}
0.000000,0,0.000000,return CMP_UNKNOWN;
0.000001,1,0.000001,};
0.000000,0,0.000000,
0.000000,0,0.000000,push @CMP, sub {
0.000002,3,0.000001,my ( $A, $B ) = @_;
0.000016,3,0.000005,return CMP_EQUAL
0.000000,0,0.000000,if Scalar::Util::refaddr( $A ) == Scalar::Util::refaddr( $B );
0.000000,0,0.000000,
0.000014,3,0.000005,return CMP_EQUIVALENT
0.000000,0,0.000000,if Scalar::Util::refaddr( $A->compiled_check ) ==
0.000000,0,0.000000,Scalar::Util::refaddr( $B->compiled_check );
0.000000,0,0.000000,
0.000006,3,0.000002,my $A_stem = $A->find_constraining_type;
0.000002,3,0.000001,my $B_stem = $B->find_constraining_type;
0.000011,3,0.000004,return CMP_EQUIVALENT
0.000000,0,0.000000,if Scalar::Util::refaddr( $A_stem ) == Scalar::Util::refaddr( $B_stem );
0.000021,3,0.000007,return CMP_EQUIVALENT
0.000000,0,0.000000,if Scalar::Util::refaddr( $A_stem->compiled_check ) ==
0.000000,0,0.000000,Scalar::Util::refaddr( $B_stem->compiled_check );
0.000000,0,0.000000,
0.000014,3,0.000005,if ( $A_stem->can_be_inlined and $B_stem->can_be_inlined ) {
0.000000,0,0.000000,return CMP_EQUIVALENT
0.000000,0,0.000000,if $A_stem->inline_check( '$WOLFIE' ) eq $B_stem->inline_check( '$WOLFIE' );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,A_IS_SUBTYPE: {
0.000003,6,0.000000,my $A_prime = $A_stem;
0.000005,3,0.000002,while ( $A_prime->has_parent ) {
0.000011,12,0.000001,$A_prime = $A_prime->parent;
0.000044,12,0.000004,return CMP_SUBTYPE
0.000000,0,0.000000,if Scalar::Util::refaddr( $A_prime ) == Scalar::Util::refaddr( $B_stem );
0.000046,12,0.000004,return CMP_SUBTYPE
0.000000,0,0.000000,if Scalar::Util::refaddr( $A_prime->compiled_check ) ==
0.000000,0,0.000000,Scalar::Util::refaddr( $B_stem->compiled_check );
0.000054,12,0.000004,if ( $A_prime->can_be_inlined and $B_stem->can_be_inlined ) {
0.000000,0,0.000000,return CMP_SUBTYPE
0.000000,0,0.000000,if $A_prime->inline_check( '$WOLFIE' ) eq $B_stem->inline_check( '$WOLFIE' );
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ while ( $A_prime->has_parent)
0.000000,0,0.000000,} #/ A_IS_SUBTYPE:
0.000000,0,0.000000,
0.000000,0,0.000000,B_IS_SUBTYPE: {
0.000003,6,0.000000,my $B_prime = $B_stem;
0.000002,3,0.000001,while ( $B_prime->has_parent ) {
0.000004,3,0.000001,$B_prime = $B_prime->parent;
0.000019,3,0.000006,return CMP_SUPERTYPE
0.000000,0,0.000000,if Scalar::Util::refaddr( $B_prime ) == Scalar::Util::refaddr( $A_stem );
0.000000,0,0.000000,return CMP_SUPERTYPE
0.000000,0,0.000000,if Scalar::Util::refaddr( $B_prime->compiled_check ) ==
0.000000,0,0.000000,Scalar::Util::refaddr( $A_stem->compiled_check );
0.000000,0,0.000000,if ( $A_stem->can_be_inlined and $B_prime->can_be_inlined ) {
0.000000,0,0.000000,return CMP_SUPERTYPE
0.000000,0,0.000000,if $B_prime->inline_check( '$WOLFIE' ) eq $A_stem->inline_check( '$WOLFIE' );
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ while ( $B_prime->has_parent)
0.000000,0,0.000000,} #/ B_IS_SUBTYPE:
0.000000,0,0.000000,
0.000000,0,0.000000,return CMP_UNKNOWN;
0.000002,1,0.000002,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub equals {
0.000000,0,0.000000,my $result = Type::Tiny::cmp( $_[0], $_[1] );
0.000000,0,0.000000,return unless defined $result;
0.000000,0,0.000000,$result eq CMP_EQUAL;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_subtype_of {
0.000000,0,0.000000,my $result = Type::Tiny::cmp( $_[0], $_[1], CMP_SUBTYPE );
0.000000,0,0.000000,return unless defined $result;
0.000000,0,0.000000,$result eq CMP_SUBTYPE;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_supertype_of {
0.000000,0,0.000000,my $result = Type::Tiny::cmp( $_[0], $_[1], CMP_SUBTYPE );
0.000000,0,0.000000,return unless defined $result;
0.000000,0,0.000000,$result eq CMP_SUPERTYPE;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_a_type_of {
0.000009,3,0.000003,my $result = Type::Tiny::cmp( $_[0], $_[1] );
0.000001,3,0.000000,return unless defined $result;
0.000008,3,0.000003,$result eq CMP_SUBTYPE or $result eq CMP_EQUAL or $result eq CMP_EQUIVALENT;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub strictly_equals {
0.000643,794,0.000001,my ( $self, $other ) = _loose_to_TypeTiny( @_ );
0.002146,794,0.000003,return unless blessed( $self )  && $self->isa( "Type::Tiny" );
0.001870,794,0.000002,return unless blessed( $other ) && $other->isa( "Type::Tiny" );
0.001782,794,0.000002,$self->{uniq} == $other->{uniq};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_strictly_subtype_of {
0.000528,703,0.000001,my ( $self, $other ) = _loose_to_TypeTiny( @_ );
0.001880,703,0.000003,return unless blessed( $self )  && $self->isa( "Type::Tiny" );
0.001702,703,0.000002,return unless blessed( $other ) && $other->isa( "Type::Tiny" );
0.000000,0,0.000000,
0.000705,703,0.000001,return unless $self->has_parent;
0.002475,597,0.000004,$self->parent->strictly_equals( $other )
0.000000,0,0.000000,or $self->parent->is_strictly_subtype_of( $other );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_strictly_supertype_of {
0.000000,0,0.000000,my ( $self, $other ) = _loose_to_TypeTiny( @_ );
0.000000,0,0.000000,return unless blessed( $self )  && $self->isa( "Type::Tiny" );
0.000000,0,0.000000,return unless blessed( $other ) && $other->isa( "Type::Tiny" );
0.000000,0,0.000000,
0.000000,0,0.000000,$other->is_strictly_subtype_of( $self );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_strictly_a_type_of {
0.000184,191,0.000001,my ( $self, $other ) = _loose_to_TypeTiny( @_ );
0.000669,191,0.000004,return unless blessed( $self )  && $self->isa( "Type::Tiny" );
0.000528,191,0.000003,return unless blessed( $other ) && $other->isa( "Type::Tiny" );
0.000000,0,0.000000,
0.000621,191,0.000003,$self->strictly_equals( $other ) or $self->is_strictly_subtype_of( $other );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub qualified_name {
0.000011,46,0.000000,my $self = shift;
0.000000,0,0.000000,( exists $self->{library} and $self->name ne "__ANON__" )
0.000000,0,0.000000,? "$self->{library}::$self->{name}"
0.000167,46,0.000004,: $self->{name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_anon {
0.000038,129,0.000000,my $self = shift;
0.000365,129,0.000003,$self->name eq "__ANON__";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parents {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return unless $self->has_parent;
0.000000,0,0.000000,return ( $self->parent, $self->parent->parents );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_parent {
0.000000,2,0.000000,my $self = shift;
0.000000,2,0.000000,my ( $test ) = @_;
0.000000,0,0.000000,
0.000004,2,0.000002,local ( $_, $. );
0.000000,2,0.000000,my $type  = $self;
0.000002,2,0.000001,my $count = 0;
0.000004,2,0.000002,while ( $type ) {
0.000013,2,0.000007,if ( $test->( $_ = $type, $. = $count ) ) {
0.000000,0,0.000000,return wantarray ? ( $type, $count ) : $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$type = $type->parent;
0.000000,0,0.000000,$count++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,} #/ sub find_parent
0.000000,0,0.000000,
0.000000,0,0.000000,sub check {
0.000060,381,0.000000,my $self = shift;
0.001009,381,0.000003,( $self->{compiled_type_constraint} ||= $self->_build_compiled_check )->( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _strict_check {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,local $_ = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,my @constraints =
0.000000,0,0.000000,reverse
0.000000,0,0.000000,map { $_->constraint }
0.000000,0,0.000000,grep { not $_->_is_null_constraint } ( $self, $self->parents );
0.000000,0,0.000000,
0.000000,0,0.000000,for my $c ( @constraints ) {
0.000000,0,0.000000,return unless $c->( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return !!1;
0.000000,0,0.000000,} #/ sub _strict_check
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_message {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,local $_ = $_[0];
0.000000,0,0.000000,$self->has_message
0.000000,0,0.000000,? $self->message->( @_ )
0.000000,0,0.000000,: $self->_default_message->( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub validate {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef
0.000000,0,0.000000,if ( $self->{compiled_type_constraint} ||= $self->_build_compiled_check )
0.000000,0,0.000000,->( @_ );
0.000000,0,0.000000,
0.000000,0,0.000000,local $_ = $_[0];
0.000000,0,0.000000,return $self->get_message( @_ );
0.000000,0,0.000000,} #/ sub validate
0.000000,0,0.000000,
0.000000,0,0.000000,sub validate_explain {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $value, $varname ) = @_;
0.000000,0,0.000000,$varname = '$_' unless defined $varname;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef if $self->check( $value );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->has_parent ) {
0.000000,0,0.000000,my $parent = $self->parent->validate_explain( $value, $varname );
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf( '"%s" is a subtype of "%s"', $self, $self->parent ),
0.000000,0,0.000000,@$parent
0.000000,0,0.000000,]
0.000000,0,0.000000,if $parent;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $message = sprintf(
0.000000,0,0.000000,'%s%s',
0.000000,0,0.000000,$self->get_message( $value ),
0.000000,0,0.000000,$varname eq q{$_} ? '' : sprintf( ' (in %s)', $varname ),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->is_parameterized and $self->parent->has_deep_explanation ) {
0.000000,0,0.000000,my $deep = $self->parent->deep_explanation->( $self, $value, $varname );
0.000000,0,0.000000,return [ $message, @$deep ] if $deep;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,local $SIG{__WARN__} = sub {};
0.000000,0,0.000000,return [
0.000000,0,0.000000,$message,
0.000000,0,0.000000,sprintf( '"%s" is defined as: %s', $self, $self->_perlcode )
0.000000,0,0.000000,];
0.000000,0,0.000000,} #/ sub validate_explain
0.000000,0,0.000000,
0.000000,1,0.000000,my $b;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _perlcode {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,local our $AvoidCallbacks = 1;
0.000000,0,0.000000,return $self->inline_check( '$_' )
0.000000,0,0.000000,if $self->can_be_inlined;
0.000000,0,0.000000,
0.000000,0,0.000000,$b ||= do {
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,require B::Deparse;
0.000000,0,0.000000,my $tmp = "B::Deparse"->new;
0.000000,0,0.000000,$tmp->ambient_pragmas( strict => "all", warnings => "all" )
0.000000,0,0.000000,if $tmp->can( 'ambient_pragmas' );
0.000000,0,0.000000,$tmp;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,my $code = $b->coderef2text( $self->constraint );
0.000000,0,0.000000,$code =~ s/\s+/ /g;
0.000000,0,0.000000,return "sub $code";
0.000000,0,0.000000,} #/ sub _perlcode
0.000000,0,0.000000,
0.000000,0,0.000000,sub assert_valid {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return !!1
0.000000,0,0.000000,if ( $self->{compiled_type_constraint} ||= $self->_build_compiled_check )
0.000000,0,0.000000,->( @_ );
0.000000,0,0.000000,
0.000000,0,0.000000,local $_ = $_[0];
0.000000,0,0.000000,$self->_failed_check( "$self", $_ );
0.000000,0,0.000000,} #/ sub assert_valid
0.000000,0,0.000000,
0.000000,0,0.000000,sub assert_return {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $_[0]
0.000000,0,0.000000,if ( $self->{compiled_type_constraint} ||= $self->_build_compiled_check )
0.000000,0,0.000000,->( @_ );
0.000000,0,0.000000,
0.000000,0,0.000000,local $_ = $_[0];
0.000000,0,0.000000,$self->_failed_check( "$self", $_ );
0.000000,0,0.000000,} #/ sub assert_return
0.000000,0,0.000000,
0.000000,0,0.000000,sub can_be_inlined {
0.000141,1016,0.000000,my $self = shift;
0.001571,1016,0.000002,return $self->parent->can_be_inlined
0.000000,0,0.000000,if $self->has_parent && $self->_is_null_constraint;
0.000779,956,0.000001,return !!1
0.000000,0,0.000000,if !$self->has_parent && $self->_is_null_constraint;
0.002247,901,0.000002,return $self->has_inlined;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub inline_check {
0.000090,633,0.000000,my $self = shift;
0.000432,633,0.000001,_croak 'Cannot inline type constraint check for "%s"', $self
0.000000,0,0.000000,unless $self->can_be_inlined;
0.000000,0,0.000000,
0.000778,633,0.000001,return $self->parent->inline_check( @_ )
0.000000,0,0.000000,if $self->has_parent && $self->_is_null_constraint;
0.000493,613,0.000001,return '(!!1)'
0.000000,0,0.000000,if !$self->has_parent && $self->_is_null_constraint;
0.000000,0,0.000000,
0.000159,587,0.000000,local $_ = $_[0];
0.001479,587,0.000003,my @r = $self->inlined->( $self, @_ );
0.000176,587,0.000000,if ( @r and not defined $r[0] ) {
0.000020,32,0.000001,_croak 'Inlining type constraint check for "%s" returned undef!', $self
0.000000,0,0.000000,unless $self->has_parent;
0.000075,32,0.000002,$r[0] = $self->parent->inline_check( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,my $r = join " && " => map {
0.003281,1206,0.000003,/[;{}]/ && !/\Ado \{.+\}\z/
0.000000,0,0.000000,? "do { $SafePackage $_ }"
0.000000,0,0.000000,: "($_)"
0.000000,0,0.000000,} @r;
0.001356,587,0.000002,return @r == 1 ? $r : "($r)";
0.000000,0,0.000000,} #/ sub inline_check
0.000000,0,0.000000,
0.000000,0,0.000000,sub inline_assert {
0.000367,132,0.000003,require B;
0.000045,132,0.000000,my $self = shift;
0.000289,132,0.000002,my ( $varname, $typevarname, %extras ) = @_;
0.000000,0,0.000000,
0.000021,132,0.000000,my $inline_check;
0.000527,132,0.000004,if ( $self->can_be_inlined ) {
0.000000,0,0.000000,$inline_check = sprintf( '(%s)', $self->inline_check( $varname ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $typevarname ) {
0.000000,0,0.000000,$inline_check = sprintf( '%s->check(%s)', $typevarname, $varname );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,_croak 'Cannot inline type constraint check for "%s"', $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000127,132,0.000001,my $do_wrapper = !delete $extras{no_wrapper};
0.000000,0,0.000000,
0.000017,132,0.000000,my $inline_throw;
0.000180,132,0.000001,if ( $typevarname ) {
0.000000,0,0.000000,$inline_throw = sprintf(
0.000000,0,0.000000,'Type::Tiny::_failed_check(%s, %s, %s, %s)',
0.000000,0,0.000000,$typevarname,
0.000000,0,0.000000,B::perlstring( "$self" ),
0.000000,0,0.000000,$varname,
0.000000,0,0.000000,join(
0.001874,68,0.000028,',', map +( B::perlstring( $_ ) => B::perlstring( $extras{$_} ) ),
0.000000,0,0.000000,sort keys %extras
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ if ( $typevarname )
0.000000,0,0.000000,else {
0.000000,0,0.000000,$inline_throw = sprintf(
0.000000,0,0.000000,'Type::Tiny::_failed_check(%s, %s, %s, %s)',
0.000000,0,0.000000,$self->{uniq},
0.000000,0,0.000000,B::perlstring( "$self" ),
0.000000,0,0.000000,$varname,
0.000000,0,0.000000,join(
0.000739,64,0.000012,',', map +( B::perlstring( $_ ) => B::perlstring( $extras{$_} ) ),
0.000000,0,0.000000,sort keys %extras
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ else [ if ( $typevarname ) ]
0.000000,0,0.000000,
0.000580,132,0.000004,$do_wrapper
0.000000,0,0.000000,? qq[do { no warnings "void"; $SafePackage $inline_check or $inline_throw; $varname };]
0.000000,0,0.000000,: qq[     no warnings "void"; $SafePackage $inline_check or $inline_throw; $varname   ];
0.000000,0,0.000000,} #/ sub inline_assert
0.000000,0,0.000000,
0.000000,0,0.000000,sub _failed_check {
0.000000,0,0.000000,require Error::TypeTiny::Assertion;
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $self, $name, $value, %attrs ) = @_;
0.000000,0,0.000000,$self = $ALL_TYPES{$self} if defined $self && !ref $self;
0.000000,0,0.000000,
0.000000,0,0.000000,my $exception_class =
0.000000,0,0.000000,delete( $attrs{exception_class} ) || "Error::TypeTiny::Assertion";
0.000000,0,0.000000,my $callback = delete( $attrs{on_die} );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self ) {
0.000000,0,0.000000,return $exception_class->throw_cb(
0.000000,0,0.000000,$callback,
0.000000,0,0.000000,message => $self->get_message( $value ),
0.000000,0,0.000000,type    => $self,
0.000000,0,0.000000,value   => $value,
0.000000,0,0.000000,%attrs,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $exception_class->throw_cb(
0.000000,0,0.000000,$callback,
0.000000,0,0.000000,message => sprintf( '%s did not pass type constraint "%s"', _dd( $value ), $name ),
0.000000,0,0.000000,value => $value,
0.000000,0,0.000000,%attrs,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ sub _failed_check
0.000000,0,0.000000,
0.000000,0,0.000000,sub coerce {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->_assert_coercion->coerce( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub assert_coerce {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->_assert_coercion->assert_coerce( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_parameterizable {
0.000298,106,0.000003,shift->has_constraint_generator;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_parameterized {
0.000008,3,0.000003,shift->has_parameters;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,1,0.000000,my %seen;
0.000000,0,0.000000,
0.000000,0,0.000000,sub ____make_key {
0.000000,0,0.000000,#<<<
0.000000,0,0.000000,join ',', map {
0.000334,69,0.000005,Types::TypeTiny::is_TypeTiny( $_ )  ? sprintf( '$Type::Tiny::ALL_TYPES{%s}', defined( $_->{uniq} ) ? $_->{uniq} : '____CANNOT_KEY____' ) :
0.000000,0,0.000000,ref() eq 'ARRAY'                    ? do { $seen{$_}++ ? '____CANNOT_KEY____' : sprintf( '[%s]', ____make_key( @$_ ) ) } :
0.000000,0,0.000000,ref() eq 'HASH'                     ? do { $seen{$_}++ ? '____CANNOT_KEY____' : sprintf( '{%s}', ____make_key( do { my %h = %$_; map +( $_, $h{$_} ), sort keys %h; } ) ) } :
0.000000,0,0.000000,ref() eq 'SCALAR' || ref() eq 'REF' ? do { $seen{$_}++ ? '____CANNOT_KEY____' : sprintf( '\\(%s)', ____make_key( $$_ ) ) } :
0.000000,0,0.000000,!defined()                          ? 'undef' :
0.000704,388,0.000002,!ref()                              ? do { require B; B::perlstring( $_ ) } :
0.000000,0,0.000000,'____CANNOT_KEY____';
0.000000,0,0.000000,} @_;
0.000000,0,0.000000,#>>>
0.000000,0,0.000000,} #/ sub ____make_key
0.000000,1,0.000000,my %param_cache;
0.000000,0,0.000000,
0.000000,0,0.000000,sub parameterize {
0.000017,69,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000098,69,0.000001,$self->is_parameterizable
0.000000,0,0.000000,or @_
0.000000,0,0.000000,? _croak( "Type '%s' does not accept parameters", "$self" )
0.000000,0,0.000000,: return ( $self );
0.000000,0,0.000000,
0.000202,69,0.000003,@_ = map Types::TypeTiny::to_TypeTiny( $_ ), @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Generate a key for caching parameterized type constraints,
0.000000,0,0.000000,# but only if all the parameters are strings or type constraints.
0.000031,69,0.000000,%seen = ();
0.000118,69,0.000002,my $key = $self->____make_key( @_ );
0.000189,69,0.000003,undef( $key )             if $key =~ /____CANNOT_KEY____/;
0.000152,69,0.000002,return $param_cache{$key} if defined $key && defined $param_cache{$key};
0.000000,0,0.000000,
0.000011,34,0.000000,local $Type::Tiny::parameterize_type = $self;
0.000009,34,0.000000,local $_                             = $_[0];
0.000002,34,0.000000,my $P;
0.000000,0,0.000000,
0.000191,34,0.000006,my ( $constraint, $compiled ) = $self->constraint_generator->( @_ );
0.000000,0,0.000000,
0.000068,34,0.000002,if ( Types::TypeTiny::is_TypeTiny( $constraint ) ) {
0.000000,0,0.000000,$P = $constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000158,20,0.000008,my %options = (
0.000000,0,0.000000,constraint   => $constraint,
0.000000,0,0.000000,display_name => $self->name_generator->( $self, @_ ),
0.000000,0,0.000000,parameters   => [@_],
0.000000,0,0.000000,);
0.000004,20,0.000000,$options{compiled_type_constraint} = $compiled
0.000000,0,0.000000,if $compiled;
0.000097,20,0.000005,$options{inlined} = $self->inline_generator->( @_ )
0.000000,0,0.000000,if $self->has_inline_generator;
0.000000,0,0.000000,$options{type_default} = $self->{type_default_generator}->( @_ )
0.000070,20,0.000003,if exists $self->{type_default_generator}; # undocumented
0.000000,0,0.000000,exists $options{$_} && !defined $options{$_} && delete $options{$_}
0.000075,20,0.000004,for keys %options;
0.000000,0,0.000000,
0.000049,20,0.000002,$P = $self->create_child_type( %options );
0.000000,0,0.000000,
0.000056,20,0.000003,if ( $self->has_coercion_generator ) {
0.000069,20,0.000003,my @args = @_;
0.000000,0,0.000000,$P->{_build_coercion} = sub {
0.000002,3,0.000001,my $coercion = shift;
0.000012,3,0.000004,my $built    = $self->coercion_generator->( $self, $P, @args );
0.000000,3,0.000000,$coercion->add_type_coercions( @{ $built->type_coercion_map } ) if $built;
0.000009,3,0.000003,$coercion->freeze;
0.000086,20,0.000004,};
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ else [ if ( Types::TypeTiny::is_TypeTiny...)]
0.000000,0,0.000000,
0.000022,34,0.000001,if ( defined $key ) {
0.000040,34,0.000001,$param_cache{$key} = $P;
0.000088,34,0.000003,Scalar::Util::weaken( $param_cache{$key} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000109,34,0.000003,$P->coercion->freeze unless $self->has_coercion_generator;
0.000000,0,0.000000,
0.000120,34,0.000004,return $P;
0.000000,0,0.000000,} #/ sub parameterize
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,sub child_type_class {
0.000050,27,0.000002,__PACKAGE__;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_child_type {
0.000007,27,0.000000,my $self = shift;
0.000005,27,0.000000,my %moreopts;
0.000030,27,0.000001,$moreopts{is_object} = 1 if $self->{is_object};
0.000187,27,0.000007,return $self->child_type_class->new( parent => $self, %moreopts, @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub complementary_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $r    = ( $self->{complementary_type} ||= $self->_build_complementary_type );
0.000000,0,0.000000,Scalar::Util::weaken( $self->{complementary_type} )
0.000000,0,0.000000,unless Scalar::Util::isweak( $self->{complementary_type} );
0.000000,0,0.000000,return $r;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_complementary_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %opts = (
0.000000,0,0.000000,constraint   => sub { not $self->check( $_ ) },
0.000000,0,0.000000,display_name => sprintf( "~%s", $self ),
0.000000,0,0.000000,);
0.000000,0,0.000000,$opts{display_name} =~ s/^\~{2}//;
0.000000,0,0.000000,$opts{inlined} = sub { shift; "not(" . $self->inline_check( @_ ) . ")" }
0.000000,0,0.000000,if $self->can_be_inlined;
0.000000,0,0.000000,$opts{display_name} = $opts{name} = $self->{complement_name}
0.000000,0,0.000000,if $self->{complement_name};
0.000000,0,0.000000,return "Type::Tiny"->new( %opts );
0.000000,0,0.000000,} #/ sub _build_complementary_type
0.000000,0,0.000000,
0.000000,0,0.000000,sub _instantiate_moose_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %opts = @_;
0.000000,0,0.000000,require Moose::Meta::TypeConstraint;
0.000000,0,0.000000,return "Moose::Meta::TypeConstraint"->new( %opts );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_moose_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $r;
0.000000,0,0.000000,if ( $self->{_is_core} ) {
0.000000,0,0.000000,require Moose::Util::TypeConstraints;
0.000000,0,0.000000,$r = Moose::Util::TypeConstraints::find_type_constraint( $self->name );
0.000000,0,0.000000,$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
0.000000,0,0.000000,Scalar::Util::weaken( $r->{"Types::TypeTiny::to_TypeTiny"} );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# Type::Tiny is more flexible than Moose, allowing
0.000000,0,0.000000,# inlined to return a list. So we need to wrap the
0.000000,0,0.000000,# inlined coderef to make sure Moose gets a single
0.000000,0,0.000000,# string.
0.000000,0,0.000000,#
0.000000,0,0.000000,my $wrapped_inlined = sub {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,$self->inline_check( @_ );
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,my %opts;
0.000000,0,0.000000,$opts{name}   = $self->qualified_name if $self->has_library && !$self->is_anon;
0.000000,0,0.000000,$opts{parent} = $self->parent->moose_type if $self->has_parent;
0.000000,0,0.000000,$opts{constraint} = $self->constraint unless $self->_is_null_constraint;
0.000000,0,0.000000,$opts{message}    = $self->message   if $self->has_message;
0.000000,0,0.000000,$opts{inlined}    = $wrapped_inlined if $self->has_inlined;
0.000000,0,0.000000,
0.000000,0,0.000000,$r                                   = $self->_instantiate_moose_type( %opts );
0.000000,0,0.000000,$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
0.000000,0,0.000000,$self->{moose_type}                  = $r;                                     # prevent recursion
0.000000,0,0.000000,$r->coercion( $self->coercion->moose_coercion ) if $self->has_coercion;
0.000000,0,0.000000,} #/ else [ if ( $self->{_is_core})]
0.000000,0,0.000000,
0.000000,0,0.000000,return $r;
0.000000,0,0.000000,} #/ sub _build_moose_type
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_mouse_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my %options;
0.000000,0,0.000000,$options{name} = $self->qualified_name if $self->has_library && !$self->is_anon;
0.000000,0,0.000000,$options{parent}     = $self->parent->mouse_type if $self->has_parent;
0.000000,0,0.000000,$options{constraint} = $self->constraint unless $self->_is_null_constraint;
0.000000,0,0.000000,$options{message}    = $self->message if $self->has_message;
0.000000,0,0.000000,
0.000000,0,0.000000,require Mouse::Meta::TypeConstraint;
0.000000,0,0.000000,my $r = "Mouse::Meta::TypeConstraint"->new( %options );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{mouse_type} = $r;    # prevent recursion
0.000000,0,0.000000,$r->_add_type_coercions(
0.000000,0,0.000000,$self->coercion->freeze->_codelike_type_coercion_map( 'mouse_type' ) )
0.000000,0,0.000000,if $self->has_coercion;
0.000000,0,0.000000,
0.000000,0,0.000000,return $r;
0.000000,0,0.000000,} #/ sub _build_mouse_type
0.000000,0,0.000000,
0.000000,0,0.000000,sub exportables {
0.000028,38,0.000001,my ( $self, $base_name, $tag ) = ( shift, @_ ); # $tag is undocumented
0.000057,38,0.000001,if ( not $self->is_anon ) {
0.000000,0,0.000000,$base_name ||= $self->name;
0.000000,0,0.000000,}
0.000011,38,0.000000,$tag ||= 0;
0.000000,0,0.000000,
0.000011,38,0.000000,my @exportables;
0.000008,38,0.000000,return \@exportables if ! $base_name;
0.000000,0,0.000000,
0.000011,38,0.000000,require Eval::TypeTiny;
0.000000,0,0.000000,
0.000107,38,0.000003,push @exportables, {
0.000000,0,0.000000,name => $base_name,
0.000000,0,0.000000,code => Eval::TypeTiny::type_to_coderef( $self ),
0.000000,0,0.000000,tags => [ 'types' ],
0.000000,0,0.000000,} if $tag eq 'types' || !$tag;
0.000000,0,0.000000,
0.000116,38,0.000003,push @exportables, {
0.000000,0,0.000000,name => sprintf( 'is_%s', $base_name ),
0.000000,0,0.000000,code => $self->compiled_check,
0.000000,0,0.000000,tags => [ 'is' ],
0.000000,0,0.000000,} if $tag eq 'is' || !$tag;
0.000000,0,0.000000,
0.000117,38,0.000003,push @exportables, {
0.000000,0,0.000000,name => sprintf( 'assert_%s', $base_name ),
0.000000,0,0.000000,code => $self->_overload_coderef,
0.000000,0,0.000000,tags => [ 'assert' ],
0.000000,0,0.000000,} if $tag eq 'assert' || !$tag;
0.000000,0,0.000000,
0.000000,0,0.000000,push @exportables, {
0.000000,0,0.000000,name => sprintf( 'to_%s', $base_name ),
0.000000,0,0.000000,code => $self->has_coercion && $self->coercion->frozen
0.000000,0,0.000000,? $self->coercion->compiled_coercion
0.000000,0,0.000000,: sub ($) { $self->coerce( $_[0] ) },
0.000176,38,0.000005,tags => [ 'to' ],
0.000000,0,0.000000,} if $tag eq 'to' || !$tag;
0.000000,0,0.000000,
0.000083,38,0.000002,return \@exportables;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub exportables_by_tag {
0.000001,1,0.000001,my ( $self, $tag, $base_name ) = ( shift, @_ );
0.000000,0,0.000000,my @matched = grep {
0.000000,1,0.000000,my $e = $_;
0.000002,1,0.000002,grep $_ eq $tag, @{ $e->{tags} || [] };
0.000011,1,0.000011,} @{ $self->exportables( $base_name, $tag ) };
0.000004,1,0.000004,return @matched if wantarray;
0.000000,0,0.000000,_croak( 'Expected to find one exportable tagged "%s", found %d', $tag, scalar @matched )
0.000000,0,0.000000,unless @matched == 1;
0.000000,0,0.000000,return $matched[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_coercion_list {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my @pairs;
0.000000,0,0.000000,while ( @_ ) {
0.000000,0,0.000000,my $next = shift;
0.000000,0,0.000000,if ( blessed( $next )
0.000000,0,0.000000,and $next->isa( 'Type::Coercion' )
0.000000,0,0.000000,and $next->is_parameterized )
0.000000,0,0.000000,{
0.000000,0,0.000000,push @pairs => ( @{ $next->_reparameterize( $self )->type_coercion_map } );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( blessed( $next ) and $next->can( 'type_coercion_map' ) ) {
0.000000,0,0.000000,push @pairs => (
0.000000,0,0.000000,@{ $next->type_coercion_map },
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( ref( $next ) eq q(ARRAY) ) {
0.000000,0,0.000000,unshift @_, @$next;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @pairs => (
0.000000,0,0.000000,Types::TypeTiny::to_TypeTiny( $next ),
0.000000,0,0.000000,shift,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ while ( @_ )
0.000000,0,0.000000,
0.000000,0,0.000000,return @pairs;
0.000000,0,0.000000,} #/ sub _process_coercion_list
0.000000,0,0.000000,
0.000000,0,0.000000,sub plus_coercions {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $new  = $self->_clone;
0.000000,0,0.000000,$new->coercion->add_type_coercions(
0.000000,0,0.000000,$self->_process_coercion_list( @_ ),
0.000000,0,0.000000,@{ $self->coercion->type_coercion_map },
0.000000,0,0.000000,);
0.000000,0,0.000000,$new->coercion->freeze;
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,} #/ sub plus_coercions
0.000000,0,0.000000,
0.000000,0,0.000000,sub plus_fallback_coercions {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $new = $self->_clone;
0.000000,0,0.000000,$new->coercion->add_type_coercions(
0.000000,0,0.000000,@{ $self->coercion->type_coercion_map },
0.000000,0,0.000000,$self->_process_coercion_list( @_ ),
0.000000,0,0.000000,);
0.000000,0,0.000000,$new->coercion->freeze;
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,} #/ sub plus_fallback_coercions
0.000000,0,0.000000,
0.000000,0,0.000000,sub minus_coercions {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $new = $self->_clone;
0.000000,0,0.000000,my @not = grep Types::TypeTiny::is_TypeTiny( $_ ),
0.000000,0,0.000000,$self->_process_coercion_list( $new, @_ );
0.000000,0,0.000000,
0.000000,0,0.000000,my @keep;
0.000000,0,0.000000,my $c = $self->coercion->type_coercion_map;
0.000000,0,0.000000,for ( my $i = 0 ; $i <= $#$c ; $i += 2 ) {
0.000000,0,0.000000,my $keep_this = 1;
0.000000,0,0.000000,NOT: for my $n ( @not ) {
0.000000,0,0.000000,if ( $c->[$i] == $n ) {
0.000000,0,0.000000,$keep_this = 0;
0.000000,0,0.000000,last NOT;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @keep, $c->[$i], $c->[ $i + 1 ] if $keep_this;
0.000000,0,0.000000,} #/ for ( my $i = 0 ; $i <=...)
0.000000,0,0.000000,
0.000000,0,0.000000,$new->coercion->add_type_coercions( @keep );
0.000000,0,0.000000,$new->coercion->freeze;
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,} #/ sub minus_coercions
0.000000,0,0.000000,
0.000000,0,0.000000,sub no_coercions {
0.000000,0,0.000000,my $new = shift->_clone;
0.000000,0,0.000000,$new->coercion->freeze;
0.000000,0,0.000000,$new;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub coercibles {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->has_coercion ? $self->coercion->_source_type_union : $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub isa {
0.000462,3751,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000635,3751,0.000000,if ( $INC{"Moose.pm"}
0.000000,0,0.000000,and ref( $self )
0.000000,0,0.000000,and $_[0] =~ /^(?:Class::MOP|MooseX?::Meta)::(.+)$/ )
0.000000,0,0.000000,{
0.000000,0,0.000000,my $meta = $1;
0.000000,0,0.000000,
0.000000,0,0.000000,return !!1                       if $meta eq 'TypeConstraint';
0.000000,0,0.000000,return $self->is_parameterized   if $meta eq 'TypeConstraint::Parameterized';
0.000000,0,0.000000,return $self->is_parameterizable if $meta eq 'TypeConstraint::Parameterizable';
0.000000,0,0.000000,return $self->isa( 'Type::Tiny::Union' ) if $meta eq 'TypeConstraint::Union';
0.000000,0,0.000000,
0.000000,0,0.000000,my $inflate = $self->moose_type;
0.000000,0,0.000000,return $inflate->isa( @_ );
0.000000,0,0.000000,} #/ if ( $INC{"Moose.pm"} ...)
0.000000,0,0.000000,
0.000471,3751,0.000000,if ( $INC{"Mouse.pm"}
0.000000,0,0.000000,and ref( $self )
0.000000,0,0.000000,and $_[0] eq 'Mouse::Meta::TypeConstraint' )
0.000000,0,0.000000,{
0.000000,0,0.000000,return !!1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.010998,3751,0.000003,$self->SUPER::isa( @_ );
0.000000,0,0.000000,} #/ sub isa
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_my_methods {
0.000007,2,0.000004,return {};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _lookup_my_method {
0.000004,12,0.000000,my $self = shift;
0.000010,12,0.000001,my ( $name ) = @_;
0.000000,0,0.000000,
0.000033,12,0.000003,if ( $self->my_methods->{$name} ) {
0.000000,0,0.000000,return $self->my_methods->{$name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000025,6,0.000004,if ( $self->has_parent ) {
0.000000,0,0.000000,return $self->parent->_lookup_my_method( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,} #/ sub _lookup_my_method
0.000000,0,0.000000,
0.000002,1,0.000002,my %object_methods = (
0.000000,0,0.000000,with_attribute_values => 1, stringifies_to => 1,
0.000000,0,0.000000,numifies_to           => 1
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub can {
0.000020,67,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000026,67,0.000000,return !!0
0.000000,0,0.000000,if $_[0] eq 'type_parameter'
0.000000,0,0.000000,&& blessed( $_[0] )
0.000000,0,0.000000,&& $_[0]->has_parameters;
0.000000,0,0.000000,
0.000348,67,0.000005,my $can = $self->SUPER::can( @_ );
0.000117,67,0.000002,return $can if $can;
0.000000,0,0.000000,
0.000004,6,0.000001,if ( ref( $self ) ) {
0.000003,6,0.000000,if ( $INC{"Moose.pm"} ) {
0.000000,0,0.000000,my $method = $self->moose_type->can( @_ );
0.000000,0,0.000000,return sub { shift->moose_type->$method( @_ ) }
0.000000,0,0.000000,if $method;
0.000000,0,0.000000,}
0.000018,6,0.000003,if ( $_[0] =~ /\Amy_(.+)\z/ ) {
0.000000,0,0.000000,my $method = $self->_lookup_my_method( $1 );
0.000000,0,0.000000,return $method if $method;
0.000000,0,0.000000,}
0.000002,6,0.000000,if ( $self->{is_object} && $object_methods{ $_[0] } ) {
0.000000,0,0.000000,require Type::Tiny::ConstrainedObject;
0.000000,0,0.000000,return Type::Tiny::ConstrainedObject->can( $_[0] );
0.000000,0,0.000000,}
0.000004,6,0.000001,for my $util ( qw/ grep map sort rsort first any all assert_any assert_all / ) {
0.000013,54,0.000000,if ( $_[0] eq $util ) {
0.000000,0,0.000000,$self->{'_util'}{$util} ||= eval { $self->_build_util( $util ) };
0.000000,0,0.000000,return unless $self->{'_util'}{$util};
0.000000,0,0.000000,return sub { my $s = shift; $s->{'_util'}{$util}( @_ ) };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( ref( $self ) )
0.000000,0,0.000000,
0.000011,6,0.000002,return;
0.000000,0,0.000000,} #/ sub can
0.000000,0,0.000000,
0.000000,0,0.000000,sub AUTOLOAD {
0.000002,6,0.000000,my $self = shift;
0.000041,6,0.000007,my ( $m ) = ( our $AUTOLOAD =~ /::(\w+)$/ );
0.000004,6,0.000001,return if $m eq 'DESTROY';
0.000000,0,0.000000,
0.000003,6,0.000000,if ( ref( $self ) ) {
0.000002,6,0.000000,if ( $INC{"Moose.pm"} ) {
0.000000,0,0.000000,my $method = $self->moose_type->can( $m );
0.000000,0,0.000000,return $self->moose_type->$method( @_ ) if $method;
0.000000,0,0.000000,}
0.000056,6,0.000009,if ( $m =~ /\Amy_(.+)\z/ ) {
0.000023,6,0.000004,my $method = $self->_lookup_my_method( $1 );
0.000027,6,0.000005,return &$method( $self, @_ ) if $method;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( $self->{is_object} && $object_methods{$m} ) {
0.000000,0,0.000000,require Type::Tiny::ConstrainedObject;
0.000000,0,0.000000,unshift @_, $self;
0.001419,2,0.000709,no strict 'refs';
0.000000,0,0.000000,goto \&{"Type::Tiny::ConstrainedObject::$m"};
0.000000,0,0.000000,}
0.000000,0,0.000000,for my $util ( qw/ grep map sort rsort first any all assert_any assert_all / ) {
0.000000,0,0.000000,if ( $m eq $util ) {
0.000000,0,0.000000,return ( $self->{'_util'}{$util} ||= $self->_build_util( $util ) )->( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( ref( $self ) )
0.000000,0,0.000000,
0.000000,0,0.000000,_croak q[Can't locate object method "%s" via package "%s"], $m,
0.000000,0,0.000000,ref( $self ) || $self;
0.000000,0,0.000000,} #/ sub AUTOLOAD
0.000000,0,0.000000,
0.000000,0,0.000000,sub DOES {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return !!1
0.000000,0,0.000000,if ref( $self )
0.000000,0,0.000000,&& $_[0] =~ m{^ Type::API::Constraint (?: ::Coercible | ::Inlinable )? $}x;
0.000000,0,0.000000,return !!1 if !ref( $self ) && $_[0] eq 'Type::API::Constraint::Constructor';
0.000000,0,0.000000,
0.000000,0,0.000000,"UNIVERSAL"->can( "DOES" ) ? $self->SUPER::DOES( @_ ) : $self->isa( @_ );
0.000000,0,0.000000,} #/ sub DOES
0.000000,0,0.000000,
0.000000,0,0.000000,sub _has_xsub {
0.000000,0,0.000000,require B;
0.000000,0,0.000000,!!B::svref_2object( shift->compiled_check )->XSUB;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_util {
0.000000,0,0.000000,my ( $self, $func ) = @_;
0.000000,0,0.000000,Scalar::Util::weaken( my $type = $self );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $func eq 'grep'
0.000000,0,0.000000,|| $func eq 'first'
0.000000,0,0.000000,|| $func eq 'any'
0.000000,0,0.000000,|| $func eq 'all'
0.000000,0,0.000000,|| $func eq 'assert_any'
0.000000,0,0.000000,|| $func eq 'assert_all' )
0.000000,0,0.000000,{
0.000000,0,0.000000,my ( $inline, $compiled );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->can_be_inlined ) {
0.000000,0,0.000000,$inline = $self->inline_check( '$_' );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$compiled = $self->compiled_check;
0.000000,0,0.000000,$inline   = '$compiled->($_)';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $func eq 'grep' ) {
0.000000,0,0.000000,return eval "sub { grep { $inline } \@_ }";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $func eq 'first' ) {
0.000000,0,0.000000,return eval "sub { for (\@_) { return \$_ if ($inline) }; undef; }";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $func eq 'any' ) {
0.000000,0,0.000000,return eval "sub { for (\@_) { return !!1 if ($inline) }; !!0; }";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $func eq 'assert_any' ) {
0.000000,0,0.000000,my $qname = B::perlstring( $self->name );
0.000000,0,0.000000,return
0.000000,0,0.000000,eval
0.000000,0,0.000000,"sub { for (\@_) { return \@_ if ($inline) }; Type::Tiny::_failed_check(\$type, $qname, \@_ ? \$_[-1] : undef); }";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $func eq 'all' ) {
0.000000,0,0.000000,return eval "sub { for (\@_) { return !!0 unless ($inline) }; !!1; }";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $func eq 'assert_all' ) {
0.000000,0,0.000000,my $qname = B::perlstring( $self->name );
0.000000,0,0.000000,return
0.000000,0,0.000000,eval
0.000000,0,0.000000,"sub { my \$idx = 0; for (\@_) { Type::Tiny::_failed_check(\$type, $qname, \$_, varname => sprintf('\$_[%d]', \$idx)) unless ($inline); ++\$idx }; \@_; }";
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( $func eq 'grep' ||...)
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $func eq 'map' ) {
0.000000,0,0.000000,my ( $inline, $compiled );
0.000000,0,0.000000,my $c = $self->_assert_coercion;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $c->can_be_inlined ) {
0.000000,0,0.000000,$inline = $c->inline_coercion( '$_' );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$compiled = $c->compiled_coercion;
0.000000,0,0.000000,$inline   = '$compiled->($_)';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return eval "sub { map { $inline } \@_ }";
0.000000,0,0.000000,} #/ if ( $func eq 'map' )
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $func eq 'sort' || $func eq 'rsort' ) {
0.000000,0,0.000000,my ( $inline, $compiled );
0.000000,0,0.000000,
0.000000,0,0.000000,my $ptype = $self->find_parent( sub { $_->has_sorter } );
0.000000,0,0.000000,_croak "No sorter for this type constraint" unless $ptype;
0.000000,0,0.000000,
0.000000,0,0.000000,my $sorter = $ptype->sorter;
0.000000,0,0.000000,
0.000000,0,0.000000,# Schwarzian transformation
0.000000,0,0.000000,if ( ref( $sorter ) eq 'ARRAY' ) {
0.000000,0,0.000000,my $sort_key;
0.000000,0,0.000000,( $sorter, $sort_key ) = @$sorter;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $func eq 'sort' ) {
0.000000,0,0.000000,return
0.000000,0,0.000000,eval
0.000000,0,0.000000,"our (\$a, \$b); sub { map \$_->[0], sort { \$sorter->(\$a->[1],\$b->[1]) } map [\$_,\$sort_key->(\$_)], \@_ }";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $func eq 'rsort' ) {
0.000000,0,0.000000,return
0.000000,0,0.000000,eval
0.000000,0,0.000000,"our (\$a, \$b); sub { map \$_->[0], sort { \$sorter->(\$b->[1],\$a->[1]) } map [\$_,\$sort_key->(\$_)], \@_ }";
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( ref( $sorter ) eq...)
0.000000,0,0.000000,
0.000000,0,0.000000,# Simple sort
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ( $func eq 'sort' ) {
0.000000,0,0.000000,return eval "our (\$a, \$b); sub { sort { \$sorter->(\$a,\$b) } \@_ }";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $func eq 'rsort' ) {
0.000000,0,0.000000,return eval "our (\$a, \$b); sub { sort { \$sorter->(\$b,\$a) } \@_ }";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( $func eq 'sort' ||...)
0.000000,0,0.000000,
0.000000,0,0.000000,die "Unknown function: $func";
0.000000,0,0.000000,} #/ sub _build_util
0.000000,0,0.000000,
0.000000,0,0.000000,sub of    { shift->parameterize( @_ ) }
0.000023,5,0.000005,sub where { shift->create_child_type( constraint => @_ ) }
0.000000,0,0.000000,
0.000000,0,0.000000,# fill out Moose-compatible API
0.000000,0,0.000000,sub inline_environment        { +{} }
0.000000,0,0.000000,sub _inline_check             { shift->inline_check( @_ ) }
0.000000,0,0.000000,sub _compiled_type_constraint { shift->compiled_check( @_ ) }
0.000000,0,0.000000,sub meta { _croak( "Not really a Moose::Meta::TypeConstraint. Sorry!" ) }
0.000000,0,0.000000,sub compile_type_constraint           { shift->compiled_check }
0.000000,0,0.000000,sub _actually_compile_type_constraint { shift->_build_compiled_check }
0.000000,0,0.000000,sub hand_optimized_type_constraint { shift->{hand_optimized_type_constraint} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_hand_optimized_type_constraint {
0.000000,0,0.000000,exists( shift->{hand_optimized_type_constraint} );
0.000000,0,0.000000,}
0.000008,2,0.000004,sub type_parameter { ( shift->parameters || [] )->[0] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub parameterized_from {
0.000000,0,0.000000,$_[0]->is_parameterized ? shift->parent : _croak( "Not a parameterized type" );
0.000000,0,0.000000,}
0.000000,0,0.000000,sub has_parameterized_from { $_[0]->is_parameterized }
0.000000,0,0.000000,
0.000000,0,0.000000,# some stuff for Mouse-compatible API
0.000000,0,0.000000,sub __is_parameterized      { shift->is_parameterized( @_ ) }
0.000000,0,0.000000,sub _add_type_coercions     { shift->coercion->add_type_coercions( @_ ) }
0.000000,0,0.000000,sub _as_string              { shift->qualified_name( @_ ) }
0.000000,0,0.000000,sub _compiled_type_coercion { shift->coercion->compiled_coercion( @_ ) }
0.000000,0,0.000000,sub _identity               { Scalar::Util::refaddr( shift ) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _unite {
0.000000,0,0.000000,require Type::Tiny::Union;
0.000000,0,0.000000,"Type::Tiny::Union"->new( type_constraints => \@_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Hooks for Type::Tie
0.000000,0,0.000000,sub TIESCALAR {
0.000000,0,0.000000,require Type::Tie;
0.000000,0,0.000000,unshift @_, 'Type::Tie::SCALAR';
0.000000,0,0.000000,goto \&Type::Tie::SCALAR::TIESCALAR;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub TIEARRAY {
0.000000,0,0.000000,require Type::Tie;
0.000000,0,0.000000,unshift @_, 'Type::Tie::ARRAY';
0.000000,0,0.000000,goto \&Type::Tie::ARRAY::TIEARRAY;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub TIEHASH {
0.000000,0,0.000000,require Type::Tie;
0.000000,0,0.000000,unshift @_, 'Type::Tie::HASH';
0.000000,0,0.000000,goto \&Type::Tie::HASH::TIEHASH;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000010,1,0.000010,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
