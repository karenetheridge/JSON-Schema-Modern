# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package IO::Compress::Base::Common;
0.000000,0,0.000000,
0.000030,2,0.000015,use strict ;
0.000017,2,0.000008,use warnings;
0.000015,2,0.000008,use bytes;
0.000000,0,0.000000,
0.000020,2,0.000010,use Carp;
0.000013,2,0.000007,use Scalar::Util qw(blessed readonly);
0.000562,2,0.000281,use File::GlobMapper;
0.000000,0,0.000000,
0.000001,1,0.000001,require Exporter;
0.000000,0,0.000000,our ($VERSION, @ISA, @EXPORT, %EXPORT_TAGS, $HAS_ENCODE);
0.000012,1,0.000012,@ISA = qw(Exporter);
0.000000,1,0.000000,$VERSION = '2.106';
0.000000,0,0.000000,
0.000003,1,0.000003,@EXPORT = qw( isaFilehandle isaFilename isaScalar
0.000000,0,0.000000,whatIsInput whatIsOutput
0.000000,0,0.000000,isaFileGlobString cleanFileGlobString oneTarget
0.000000,0,0.000000,setBinModeInput setBinModeOutput
0.000000,0,0.000000,ckInOutParams
0.000000,0,0.000000,createSelfTiedObject
0.000000,0,0.000000,
0.000000,0,0.000000,isGeMax32
0.000000,0,0.000000,
0.000000,0,0.000000,MAX32
0.000000,0,0.000000,
0.000000,0,0.000000,WANT_CODE
0.000000,0,0.000000,WANT_EXT
0.000000,0,0.000000,WANT_UNDEF
0.000000,0,0.000000,WANT_HASH
0.000000,0,0.000000,
0.000000,0,0.000000,STATUS_OK
0.000000,0,0.000000,STATUS_ENDSTREAM
0.000000,0,0.000000,STATUS_EOF
0.000000,0,0.000000,STATUS_ERROR
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000002,1,0.000002,%EXPORT_TAGS = ( Status => [qw( STATUS_OK
0.000000,0,0.000000,STATUS_ENDSTREAM
0.000000,0,0.000000,STATUS_EOF
0.000000,0,0.000000,STATUS_ERROR
0.000000,0,0.000000,)]);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000022,2,0.000011,use constant STATUS_OK        => 0;
0.000013,2,0.000007,use constant STATUS_ENDSTREAM => 1;
0.000012,2,0.000006,use constant STATUS_EOF       => 2;
0.000011,2,0.000005,use constant STATUS_ERROR     => -1;
0.000010,2,0.000005,use constant MAX16            => 0xFFFF ;
0.000016,2,0.000008,use constant MAX32            => 0xFFFFFFFF ;
0.000264,2,0.000132,use constant MAX32cmp         => 0xFFFFFFFF + 1 - 1; # for 5.6.x on 32-bit need to force an non-IV value
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub isGeMax32
0.000000,0,0.000000,{
0.000000,0,0.000000,return $_[0] >= MAX32cmp ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub hasEncode()
0.000000,0,0.000000,{
0.000000,0,0.000000,if (! defined $HAS_ENCODE) {
0.000000,0,0.000000,eval
0.000000,0,0.000000,{
0.000000,0,0.000000,require Encode;
0.000000,0,0.000000,Encode->import();
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,$HAS_ENCODE = $@ ? 0 : 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $HAS_ENCODE;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getEncoding($$$)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $obj = shift;
0.000000,0,0.000000,my $class = shift ;
0.000000,0,0.000000,my $want_encoding = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->croakError("$class: Encode module needed to use -Encode")
0.000000,0,0.000000,if ! hasEncode();
0.000000,0,0.000000,
0.000000,0,0.000000,my $encoding = Encode::find_encoding($want_encoding);
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->croakError("$class: Encoding '$want_encoding' is not available")
0.000000,0,0.000000,if ! $encoding;
0.000000,0,0.000000,
0.000000,0,0.000000,return $encoding;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,our ($needBinmode);
0.000033,1,0.000033,$needBinmode = ($^O eq 'MSWin32' ||
0.000000,0,0.000000,($] >= 5.006 && eval ' ${^UNICODE} || ${^UTF8LOCALE} '))
0.000000,0,0.000000,? 1 : 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,sub setBinModeInput($)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $handle = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,binmode $handle
0.000000,0,0.000000,if  $needBinmode;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub setBinModeOutput($)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $handle = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,binmode $handle
0.000000,0,0.000000,if  $needBinmode;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub isaFilehandle($)
0.000000,0,0.000000,{
0.000391,2,0.000196,use utf8; # Pragma needed to keep Perl 5.6.0 happy
0.000000,0,0.000000,return (defined $_[0] and
0.000000,0,0.000000,(UNIVERSAL::isa($_[0],'GLOB') or
0.000000,0,0.000000,UNIVERSAL::isa($_[0],'IO::Handle') or
0.000000,0,0.000000,UNIVERSAL::isa(\$_[0],'GLOB'))
0.000000,0,0.000000,)
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub isaScalar
0.000000,0,0.000000,{
0.000000,0,0.000000,return ( defined($_[0]) and ref($_[0]) eq 'SCALAR' and defined ${ $_[0] } ) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub isaFilename($)
0.000000,0,0.000000,{
0.000000,0,0.000000,return (defined $_[0] and
0.000000,0,0.000000,! ref $_[0]    and
0.000000,0,0.000000,UNIVERSAL::isa(\$_[0], 'SCALAR'));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub isaFileGlobString
0.000000,0,0.000000,{
0.000000,0,0.000000,return defined $_[0] && $_[0] =~ /^<.*>$/;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cleanFileGlobString
0.000000,0,0.000000,{
0.000000,0,0.000000,my $string = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,$string =~ s/^\s*<\s*(.*)\s*>\s*$/$1/;
0.000000,0,0.000000,
0.000000,0,0.000000,return $string;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000026,2,0.000013,use constant WANT_CODE  => 1 ;
0.000054,2,0.000027,use constant WANT_EXT   => 2 ;
0.000054,2,0.000027,use constant WANT_UNDEF => 4 ;
0.000000,0,0.000000,#use constant WANT_HASH  => 8 ;
0.001122,2,0.000561,use constant WANT_HASH  => 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,sub whatIsInput($;$)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $got = whatIs(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined $got && $got eq 'filename' && defined $_[0] && $_[0] eq '-')
0.000000,0,0.000000,{
0.000000,0,0.000000,#use IO::File;
0.000000,0,0.000000,$got = 'handle';
0.000000,0,0.000000,$_[0] = *STDIN;
0.000000,0,0.000000,#$_[0] = IO::File->new("<-");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $got;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub whatIsOutput($;$)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $got = whatIs(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined $got && $got eq 'filename' && defined $_[0] && $_[0] eq '-')
0.000000,0,0.000000,{
0.000000,0,0.000000,$got = 'handle';
0.000000,0,0.000000,$_[0] = *STDOUT;
0.000000,0,0.000000,#$_[0] = IO::File->new(">-");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $got;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub whatIs ($;$)
0.000000,0,0.000000,{
0.000000,0,0.000000,return 'handle' if isaFilehandle($_[0]);
0.000000,0,0.000000,
0.000000,0,0.000000,my $wantCode = defined $_[1] && $_[1] & WANT_CODE ;
0.000000,0,0.000000,my $extended = defined $_[1] && $_[1] & WANT_EXT ;
0.000000,0,0.000000,my $undef    = defined $_[1] && $_[1] & WANT_UNDEF ;
0.000000,0,0.000000,my $hash     = defined $_[1] && $_[1] & WANT_HASH ;
0.000000,0,0.000000,
0.000000,0,0.000000,return 'undef'  if ! defined $_[0] && $undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref $_[0]) {
0.000000,0,0.000000,return ''       if blessed($_[0]); # is an object
0.000000,0,0.000000,#return ''       if UNIVERSAL::isa($_[0], 'UNIVERSAL'); # is an object
0.000000,0,0.000000,return 'buffer' if UNIVERSAL::isa($_[0], 'SCALAR');
0.000000,0,0.000000,return 'array'  if UNIVERSAL::isa($_[0], 'ARRAY')  && $extended ;
0.000000,0,0.000000,return 'hash'   if UNIVERSAL::isa($_[0], 'HASH')   && $hash ;
0.000000,0,0.000000,return 'code'   if UNIVERSAL::isa($_[0], 'CODE')   && $wantCode ;
0.000000,0,0.000000,return '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 'fileglob' if $extended && isaFileGlobString($_[0]);
0.000000,0,0.000000,return 'filename';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub oneTarget
0.000000,0,0.000000,{
0.000000,0,0.000000,return $_[0] =~ /^(code|handle|buffer|filename)$/;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Validator::new
0.000000,0,0.000000,{
0.000000,0,0.000000,my $class = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $Class = shift ;
0.000000,0,0.000000,my $error_ref = shift ;
0.000000,0,0.000000,my $reportClass = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my %data = (Class       => $Class,
0.000000,0,0.000000,Error       => $error_ref,
0.000000,0,0.000000,reportClass => $reportClass,
0.000000,0,0.000000,) ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $obj = bless \%data, $class ;
0.000000,0,0.000000,
0.000000,0,0.000000,local $Carp::CarpLevel = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $inType    = $data{inType}    = whatIsInput($_[0], WANT_EXT|WANT_HASH);
0.000000,0,0.000000,my $outType   = $data{outType}   = whatIsOutput($_[1], WANT_EXT|WANT_HASH);
0.000000,0,0.000000,
0.000000,0,0.000000,my $oneInput  = $data{oneInput}  = oneTarget($inType);
0.000000,0,0.000000,my $oneOutput = $data{oneOutput} = oneTarget($outType);
0.000000,0,0.000000,
0.000000,0,0.000000,if (! $inType)
0.000000,0,0.000000,{
0.000000,0,0.000000,$obj->croakError("$reportClass: illegal input parameter") ;
0.000000,0,0.000000,#return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#    if ($inType eq 'hash')
0.000000,0,0.000000,#    {
0.000000,0,0.000000,#        $obj->{Hash} = 1 ;
0.000000,0,0.000000,#        $obj->{oneInput} = 1 ;
0.000000,0,0.000000,#        return $obj->validateHash($_[0]);
0.000000,0,0.000000,#    }
0.000000,0,0.000000,
0.000000,0,0.000000,if (! $outType)
0.000000,0,0.000000,{
0.000000,0,0.000000,$obj->croakError("$reportClass: illegal output parameter") ;
0.000000,0,0.000000,#return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,if ($inType ne 'fileglob' && $outType eq 'fileglob')
0.000000,0,0.000000,{
0.000000,0,0.000000,$obj->croakError("Need input fileglob for outout fileglob");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#    if ($inType ne 'fileglob' && $outType eq 'hash' && $inType ne 'filename' )
0.000000,0,0.000000,#    {
0.000000,0,0.000000,#        $obj->croakError("input must ne filename or fileglob when output is a hash");
0.000000,0,0.000000,#    }
0.000000,0,0.000000,
0.000000,0,0.000000,if ($inType eq 'fileglob' && $outType eq 'fileglob')
0.000000,0,0.000000,{
0.000000,0,0.000000,$data{GlobMap} = 1 ;
0.000000,0,0.000000,$data{inType} = $data{outType} = 'filename';
0.000000,0,0.000000,my $mapper = File::GlobMapper->new($_[0], $_[1]);
0.000000,0,0.000000,if ( ! $mapper )
0.000000,0,0.000000,{
0.000000,0,0.000000,return $obj->saveErrorString($File::GlobMapper::Error) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,$data{Pairs} = $mapper->getFileMap();
0.000000,0,0.000000,
0.000000,0,0.000000,return $obj;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->croakError("$reportClass: input and output $inType are identical")
0.000000,0,0.000000,if $inType eq $outType && $_[0] eq $_[1] && $_[0] ne '-' ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($inType eq 'fileglob') # && $outType ne 'fileglob'
0.000000,0,0.000000,{
0.000000,0,0.000000,my $glob = cleanFileGlobString($_[0]);
0.000000,0,0.000000,my @inputs = glob($glob);
0.000000,0,0.000000,
0.000000,0,0.000000,if (@inputs == 0)
0.000000,0,0.000000,{
0.000000,0,0.000000,# TODO -- legal or die?
0.000000,0,0.000000,die "globmap matched zero file -- legal or die???" ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (@inputs == 1)
0.000000,0,0.000000,{
0.000000,0,0.000000,$obj->validateInputFilenames($inputs[0])
0.000000,0,0.000000,or return undef;
0.000000,0,0.000000,$_[0] = $inputs[0]  ;
0.000000,0,0.000000,$data{inType} = 'filename' ;
0.000000,0,0.000000,$data{oneInput} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,$obj->validateInputFilenames(@inputs)
0.000000,0,0.000000,or return undef;
0.000000,0,0.000000,$_[0] = [ @inputs ] ;
0.000000,0,0.000000,$data{inType} = 'filenames' ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($inType eq 'filename')
0.000000,0,0.000000,{
0.000000,0,0.000000,$obj->validateInputFilenames($_[0])
0.000000,0,0.000000,or return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($inType eq 'array')
0.000000,0,0.000000,{
0.000000,0,0.000000,$data{inType} = 'filenames' ;
0.000000,0,0.000000,$obj->validateInputArray($_[0])
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $obj->saveErrorString("$reportClass: output buffer is read-only")
0.000000,0,0.000000,if $outType eq 'buffer' && readonly(${ $_[1] });
0.000000,0,0.000000,
0.000000,0,0.000000,if ($outType eq 'filename' )
0.000000,0,0.000000,{
0.000000,0,0.000000,$obj->croakError("$reportClass: output filename is undef or null string")
0.000000,0,0.000000,if ! defined $_[1] || $_[1] eq ''  ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (-e $_[1])
0.000000,0,0.000000,{
0.000000,0,0.000000,if (-d _ )
0.000000,0,0.000000,{
0.000000,0,0.000000,return $obj->saveErrorString("output file '$_[1]' is a directory");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $obj ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Validator::saveErrorString
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,${ $self->{Error} } = shift ;
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Validator::croakError
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self   = shift ;
0.000000,0,0.000000,$self->saveErrorString($_[0]);
0.000000,0,0.000000,croak $_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Validator::validateInputFilenames
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $filename (@_)
0.000000,0,0.000000,{
0.000000,0,0.000000,$self->croakError("$self->{reportClass}: input filename is undef or null string")
0.000000,0,0.000000,if ! defined $filename || $filename eq ''  ;
0.000000,0,0.000000,
0.000000,0,0.000000,next if $filename eq '-';
0.000000,0,0.000000,
0.000000,0,0.000000,if (! -e $filename )
0.000000,0,0.000000,{
0.000000,0,0.000000,return $self->saveErrorString("input file '$filename' does not exist");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (-d _ )
0.000000,0,0.000000,{
0.000000,0,0.000000,return $self->saveErrorString("input file '$filename' is a directory");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#        if (! -r _ )
0.000000,0,0.000000,#        {
0.000000,0,0.000000,#            return $self->saveErrorString("cannot open file '$filename': $!");
0.000000,0,0.000000,#        }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Validator::validateInputArray
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( @{ $_[0] } == 0 )
0.000000,0,0.000000,{
0.000000,0,0.000000,return $self->saveErrorString("empty array reference") ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $element ( @{ $_[0] } )
0.000000,0,0.000000,{
0.000000,0,0.000000,my $inType  = whatIsInput($element);
0.000000,0,0.000000,
0.000000,0,0.000000,if (! $inType)
0.000000,0,0.000000,{
0.000000,0,0.000000,$self->croakError("unknown input parameter") ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif($inType eq 'filename')
0.000000,0,0.000000,{
0.000000,0,0.000000,$self->validateInputFilenames($element)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,$self->croakError("not a filename") ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#sub IO::Compress::Base::Validator::validateHash
0.000000,0,0.000000,#{
0.000000,0,0.000000,#    my $self = shift ;
0.000000,0,0.000000,#    my $href = shift ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#    while (my($k, $v) = each %$href)
0.000000,0,0.000000,#    {
0.000000,0,0.000000,#        my $ktype = whatIsInput($k);
0.000000,0,0.000000,#        my $vtype = whatIsOutput($v, WANT_EXT|WANT_UNDEF) ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#        if ($ktype ne 'filename')
0.000000,0,0.000000,#        {
0.000000,0,0.000000,#            return $self->saveErrorString("hash key not filename") ;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#
0.000000,0,0.000000,#        my %valid = map { $_ => 1 } qw(filename buffer array undef handle) ;
0.000000,0,0.000000,#        if (! $valid{$vtype})
0.000000,0,0.000000,#        {
0.000000,0,0.000000,#            return $self->saveErrorString("hash value not ok") ;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#
0.000000,0,0.000000,#    return $self ;
0.000000,0,0.000000,#}
0.000000,0,0.000000,
0.000000,0,0.000000,sub createSelfTiedObject
0.000000,0,0.000000,{
0.000000,0,0.000000,my $class = shift || (caller)[0] ;
0.000000,0,0.000000,my $error_ref = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $obj = bless Symbol::gensym(), ref($class) || $class;
0.000000,0,0.000000,tie *$obj, $obj if $] >= 5.005;
0.000000,0,0.000000,*$obj->{Closed} = 1 ;
0.000000,0,0.000000,$$error_ref = '';
0.000000,0,0.000000,*$obj->{Error} = $error_ref ;
0.000000,0,0.000000,my $errno = 0 ;
0.000000,0,0.000000,*$obj->{ErrorNo} = \$errno ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $obj;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#package Parse::Parameters ;
0.000000,0,0.000000,#
0.000000,0,0.000000,#
0.000000,0,0.000000,#require Exporter;
0.000000,0,0.000000,#our ($VERSION, @ISA, @EXPORT);
0.000000,0,0.000000,#$VERSION = '2.000_08';
0.000000,0,0.000000,#@ISA = qw(Exporter);
0.000000,0,0.000000,
0.000001,1,0.000001,$EXPORT_TAGS{Parse} = [qw( ParseParameters
0.000000,0,0.000000,Parse_any Parse_unsigned Parse_signed
0.000000,0,0.000000,Parse_boolean Parse_string
0.000000,0,0.000000,Parse_code
0.000000,0,0.000000,Parse_writable_scalar
0.000000,0,0.000000,)
0.000000,0,0.000000,];
0.000000,0,0.000000,
0.000007,1,0.000007,push @EXPORT, @{ $EXPORT_TAGS{Parse} } ;
0.000000,0,0.000000,
0.000020,2,0.000010,use constant Parse_any      => 0x01;
0.000016,2,0.000008,use constant Parse_unsigned => 0x02;
0.000011,2,0.000006,use constant Parse_signed   => 0x04;
0.000012,2,0.000006,use constant Parse_boolean  => 0x08;
0.000038,2,0.000019,use constant Parse_string   => 0x10;
0.000018,2,0.000009,use constant Parse_code     => 0x20;
0.000000,0,0.000000,
0.000000,0,0.000000,#use constant Parse_store_ref        => 0x100 ;
0.000000,0,0.000000,#use constant Parse_multiple         => 0x100 ;
0.000017,2,0.000008,use constant Parse_writable         => 0x200 ;
0.000018,2,0.000009,use constant Parse_writable_scalar  => 0x400 | Parse_writable ;
0.000000,0,0.000000,
0.000014,2,0.000007,use constant OFF_PARSED     => 0 ;
0.000011,2,0.000005,use constant OFF_TYPE       => 1 ;
0.000011,2,0.000005,use constant OFF_DEFAULT    => 2 ;
0.000028,2,0.000014,use constant OFF_FIXED      => 3 ;
0.000000,0,0.000000,#use constant OFF_FIRST_ONLY => 4 ;
0.000000,0,0.000000,#use constant OFF_STICKY     => 5 ;
0.000000,0,0.000000,
0.000022,2,0.000011,use constant IxError => 0;
0.000155,2,0.000077,use constant IxGot   => 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,sub ParseParameters
0.000000,0,0.000000,{
0.000000,0,0.000000,my $level = shift || 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $sub = (caller($level + 1))[3] ;
0.000000,0,0.000000,local $Carp::CarpLevel = 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $_[1]
0.000000,0,0.000000,if @_ == 2 && defined $_[1] && UNIVERSAL::isa($_[1], "IO::Compress::Base::Parameters");
0.000000,0,0.000000,
0.000000,0,0.000000,my $p = IO::Compress::Base::Parameters->new();
0.000000,0,0.000000,$p->parse(@_)
0.000000,0,0.000000,or croak "$sub: $p->[IxError]" ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $p;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000023,2,0.000012,use strict;
0.000000,0,0.000000,
0.000014,2,0.000007,use warnings;
0.000762,2,0.000381,use Carp;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub Init
0.000000,0,0.000000,{
0.000000,0,0.000000,my $default = shift ;
0.000000,0,0.000000,my %got ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $obj = IO::Compress::Base::Parameters::new();
0.000000,0,0.000000,while (my ($key, $v) = each %$default)
0.000000,0,0.000000,{
0.000000,0,0.000000,croak "need 2 params [@$v]"
0.000000,0,0.000000,if @$v != 2 ;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($type, $value) = @$v ;
0.000000,0,0.000000,#        my ($first_only, $sticky, $type, $value) = @$v ;
0.000000,0,0.000000,my $sticky = 0;
0.000000,0,0.000000,my $x ;
0.000000,0,0.000000,$obj->_checkType($key, \$value, $type, 0, \$x)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,$key = lc $key;
0.000000,0,0.000000,
0.000000,0,0.000000,#        if (! $sticky) {
0.000000,0,0.000000,#            $x = []
0.000000,0,0.000000,#                if $type & Parse_multiple;
0.000000,0,0.000000,
0.000000,0,0.000000,#            $got{$key} = [0, $type, $value, $x, $first_only, $sticky] ;
0.000000,0,0.000000,$got{$key} = [0, $type, $value, $x] ;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#
0.000000,0,0.000000,#        $got{$key}[OFF_PARSED] = 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return bless \%got, "IO::Compress::Base::Parameters::Defaults" ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Parameters::new
0.000000,0,0.000000,{
0.000000,0,0.000000,#my $class = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $obj;
0.000000,0,0.000000,$obj->[IxError] = '';
0.000000,0,0.000000,$obj->[IxGot] = {} ;
0.000000,0,0.000000,
0.000000,0,0.000000,return bless $obj, 'IO::Compress::Base::Parameters' ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Parameters::setError
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $error = shift ;
0.000000,0,0.000000,my $retval = @_ ? shift : undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,$self->[IxError] = $error ;
0.000000,0,0.000000,return $retval;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Parameters::getError
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,return $self->[IxError] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Parameters::parse
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $default = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $got = $self->[IxGot] ;
0.000000,0,0.000000,my $firstTime = keys %{ $got } == 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,my (@Bad) ;
0.000000,0,0.000000,my @entered = () ;
0.000000,0,0.000000,
0.000000,0,0.000000,# Allow the options to be passed as a hash reference or
0.000000,0,0.000000,# as the complete hash.
0.000000,0,0.000000,if (@_ == 0) {
0.000000,0,0.000000,@entered = () ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (@_ == 1) {
0.000000,0,0.000000,my $href = $_[0] ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->setError("Expected even number of parameters, got 1")
0.000000,0,0.000000,if ! defined $href or ! ref $href or ref $href ne "HASH" ;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $key (keys %$href) {
0.000000,0,0.000000,push @entered, $key ;
0.000000,0,0.000000,push @entered, \$href->{$key} ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,my $count = @_;
0.000000,0,0.000000,return $self->setError("Expected even number of parameters, got $count")
0.000000,0,0.000000,if $count % 2 != 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $i (0.. $count / 2 - 1) {
0.000000,0,0.000000,push @entered, $_[2 * $i] ;
0.000000,0,0.000000,push @entered, \$_[2 * $i + 1] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $key (keys %$default)
0.000000,0,0.000000,{
0.000000,0,0.000000,
0.000000,0,0.000000,my ($type, $value) = @{ $default->{$key} } ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($firstTime) {
0.000000,0,0.000000,$got->{$key} = [0, $type, $value, $value] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,$got->{$key}[OFF_PARSED] = 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,my %parsed = ();
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,for my $i (0.. @entered / 2 - 1) {
0.000000,0,0.000000,my $key = $entered[2* $i] ;
0.000000,0,0.000000,my $value = $entered[2* $i+1] ;
0.000000,0,0.000000,
0.000000,0,0.000000,#print "Key [$key] Value [$value]" ;
0.000000,0,0.000000,#print defined $$value ? "[$$value]\n" : "[undef]\n";
0.000000,0,0.000000,
0.000000,0,0.000000,$key =~ s/^-// ;
0.000000,0,0.000000,my $canonkey = lc $key;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($got->{$canonkey})
0.000000,0,0.000000,{
0.000000,0,0.000000,my $type = $got->{$canonkey}[OFF_TYPE] ;
0.000000,0,0.000000,my $parsed = $parsed{$canonkey};
0.000000,0,0.000000,++ $parsed{$canonkey};
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->setError("Muliple instances of '$key' found")
0.000000,0,0.000000,if $parsed ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $s ;
0.000000,0,0.000000,$self->_checkType($key, $value, $type, 1, \$s)
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,$value = $$value ;
0.000000,0,0.000000,$got->{$canonkey} = [1, $type, $value, $s] ;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{ push (@Bad, $key) }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (@Bad) {
0.000000,0,0.000000,my ($bad) = join(", ", @Bad) ;
0.000000,0,0.000000,return $self->setError("unknown key value(s) $bad") ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Parameters::_checkType
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $key   = shift ;
0.000000,0,0.000000,my $value = shift ;
0.000000,0,0.000000,my $type  = shift ;
0.000000,0,0.000000,my $validate  = shift ;
0.000000,0,0.000000,my $output  = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,#local $Carp::CarpLevel = $level ;
0.000000,0,0.000000,#print "PARSE $type $key $value $validate $sub\n" ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($type & Parse_writable_scalar)
0.000000,0,0.000000,{
0.000000,0,0.000000,return $self->setError("Parameter '$key' not writable")
0.000000,0,0.000000,if  readonly $$value ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref $$value)
0.000000,0,0.000000,{
0.000000,0,0.000000,return $self->setError("Parameter '$key' not a scalar reference")
0.000000,0,0.000000,if ref $$value ne 'SCALAR' ;
0.000000,0,0.000000,
0.000000,0,0.000000,$$output = $$value ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,return $self->setError("Parameter '$key' not a scalar")
0.000000,0,0.000000,if ref $value ne 'SCALAR' ;
0.000000,0,0.000000,
0.000000,0,0.000000,$$output = $value ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,$value = $$value ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($type & Parse_any)
0.000000,0,0.000000,{
0.000000,0,0.000000,$$output = $value ;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type & Parse_unsigned)
0.000000,0,0.000000,{
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->setError("Parameter '$key' must be an unsigned int, got 'undef'")
0.000000,0,0.000000,if ! defined $value ;
0.000000,0,0.000000,return $self->setError("Parameter '$key' must be an unsigned int, got '$value'")
0.000000,0,0.000000,if $value !~ /^\d+$/;
0.000000,0,0.000000,
0.000000,0,0.000000,$$output = defined $value ? $value : 0 ;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type & Parse_signed)
0.000000,0,0.000000,{
0.000000,0,0.000000,return $self->setError("Parameter '$key' must be a signed int, got 'undef'")
0.000000,0,0.000000,if ! defined $value ;
0.000000,0,0.000000,return $self->setError("Parameter '$key' must be a signed int, got '$value'")
0.000000,0,0.000000,if $value !~ /^-?\d+$/;
0.000000,0,0.000000,
0.000000,0,0.000000,$$output = defined $value ? $value : 0 ;
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type & Parse_boolean)
0.000000,0,0.000000,{
0.000000,0,0.000000,return $self->setError("Parameter '$key' must be an int, got '$value'")
0.000000,0,0.000000,if defined $value && $value !~ /^\d*$/;
0.000000,0,0.000000,
0.000000,0,0.000000,$$output =  defined $value && $value != 0 ? 1 : 0 ;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,elsif ($type & Parse_string)
0.000000,0,0.000000,{
0.000000,0,0.000000,$$output = defined $value ? $value : "" ;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type & Parse_code)
0.000000,0,0.000000,{
0.000000,0,0.000000,return $self->setError("Parameter '$key' must be a code reference, got '$value'")
0.000000,0,0.000000,if (! defined $value || ref $value ne 'CODE') ;
0.000000,0,0.000000,
0.000000,0,0.000000,$$output = defined $value ? $value : "" ;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$$output = $value ;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Parameters::parsed
0.000000,0,0.000000,{
0.000000,0,0.000000,return $_[0]->[IxGot]{$_[1]}[OFF_PARSED] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Parameters::getValue
0.000000,0,0.000000,{
0.000000,0,0.000000,return  $_[0]->[IxGot]{$_[1]}[OFF_FIXED] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub IO::Compress::Base::Parameters::setValue
0.000000,0,0.000000,{
0.000000,0,0.000000,$_[0]->[IxGot]{$_[1]}[OFF_PARSED]  = 1;
0.000000,0,0.000000,$_[0]->[IxGot]{$_[1]}[OFF_DEFAULT] = $_[2] ;
0.000000,0,0.000000,$_[0]->[IxGot]{$_[1]}[OFF_FIXED]   = $_[2] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Parameters::valueRef
0.000000,0,0.000000,{
0.000000,0,0.000000,return  $_[0]->[IxGot]{$_[1]}[OFF_FIXED]  ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Parameters::valueOrDefault
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $name = shift ;
0.000000,0,0.000000,my $default = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $value = $self->[IxGot]{$name}[OFF_DEFAULT] ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $value if defined $value ;
0.000000,0,0.000000,return $default ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Parameters::wantValue
0.000000,0,0.000000,{
0.000000,0,0.000000,return defined $_[0]->[IxGot]{$_[1]}[OFF_DEFAULT] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub IO::Compress::Base::Parameters::clone
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $obj = [] ;
0.000000,0,0.000000,my %got ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $hash = $self->[IxGot] ;
0.000000,0,0.000000,for my $k (keys %{ $hash })
0.000000,0,0.000000,{
0.000000,0,0.000000,$got{$k} = [ @{ $hash->{$k} } ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->[IxError] = $self->[IxError];
0.000000,0,0.000000,$obj->[IxGot] = \%got ;
0.000000,0,0.000000,
0.000000,0,0.000000,return bless $obj, 'IO::Compress::Base::Parameters' ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,package U64;
0.000000,0,0.000000,
0.000020,2,0.000010,use constant MAX32 => 0xFFFFFFFF ;
0.000013,2,0.000007,use constant HI_1 => MAX32 + 1 ;
0.000012,2,0.000006,use constant LOW   => 0 ;
0.000649,2,0.000325,use constant HIGH  => 1;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new
0.000000,0,0.000000,{
0.000000,0,0.000000,return bless [ 0, 0 ], $_[0]
0.000000,0,0.000000,if @_ == 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,return bless [ $_[1], 0 ], $_[0]
0.000000,0,0.000000,if @_ == 2 ;
0.000000,0,0.000000,
0.000000,0,0.000000,return bless [ $_[2], $_[1] ], $_[0]
0.000000,0,0.000000,if @_ == 3 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub newUnpack_V64
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($low, $hi) = unpack "V V", $_[0] ;
0.000000,0,0.000000,bless [ $low, $hi ], "U64";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub newUnpack_V32
0.000000,0,0.000000,{
0.000000,0,0.000000,my $string = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $low = unpack "V", $string ;
0.000000,0,0.000000,bless [ $low, 0 ], "U64";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub reset
0.000000,0,0.000000,{
0.000000,0,0.000000,$_[0]->[HIGH] = $_[0]->[LOW] = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone
0.000000,0,0.000000,{
0.000000,0,0.000000,bless [ @{$_[0]}  ], ref $_[0] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getHigh
0.000000,0,0.000000,{
0.000000,0,0.000000,return $_[0]->[HIGH];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getLow
0.000000,0,0.000000,{
0.000000,0,0.000000,return $_[0]->[LOW];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get32bit
0.000000,0,0.000000,{
0.000000,0,0.000000,return $_[0]->[LOW];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get64bit
0.000000,0,0.000000,{
0.000000,0,0.000000,# Not using << here because the result will still be
0.000000,0,0.000000,# a 32-bit value on systems where int size is 32-bits
0.000000,0,0.000000,return $_[0]->[HIGH] * HI_1 + $_[0]->[LOW];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add
0.000000,0,0.000000,{
0.000000,0,0.000000,#    my $self = shift;
0.000000,0,0.000000,my $value = $_[1];
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref $value eq 'U64') {
0.000000,0,0.000000,$_[0]->[HIGH] += $value->[HIGH] ;
0.000000,0,0.000000,$value = $value->[LOW];
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($value > MAX32) {
0.000000,0,0.000000,$_[0]->[HIGH] += int($value / HI_1) ;
0.000000,0,0.000000,$value = $value % HI_1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $available = MAX32 - $_[0]->[LOW] ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($value > $available) {
0.000000,0,0.000000,++ $_[0]->[HIGH] ;
0.000000,0,0.000000,$_[0]->[LOW] = $value - $available - 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$_[0]->[LOW] += $value ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add32
0.000000,0,0.000000,{
0.000000,0,0.000000,#    my $self = shift;
0.000000,0,0.000000,my $value = $_[1];
0.000000,0,0.000000,
0.000000,0,0.000000,if ($value > MAX32) {
0.000000,0,0.000000,$_[0]->[HIGH] += int($value / HI_1) ;
0.000000,0,0.000000,$value = $value % HI_1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $available = MAX32 - $_[0]->[LOW] ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($value > $available) {
0.000000,0,0.000000,++ $_[0]->[HIGH] ;
0.000000,0,0.000000,$_[0]->[LOW] = $value - $available - 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$_[0]->[LOW] += $value ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub subtract
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $value = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref $value eq 'U64') {
0.000000,0,0.000000,
0.000000,0,0.000000,if ($value->[HIGH]) {
0.000000,0,0.000000,die "bad"
0.000000,0,0.000000,if $self->[HIGH] == 0 ||
0.000000,0,0.000000,$value->[HIGH] > $self->[HIGH] ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->[HIGH] -= $value->[HIGH] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$value = $value->[LOW] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($value > $self->[LOW]) {
0.000000,0,0.000000,-- $self->[HIGH] ;
0.000000,0,0.000000,$self->[LOW] = MAX32 - $value + $self->[LOW] + 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->[LOW] -= $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub equal
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $other = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->[LOW]  == $other->[LOW] &&
0.000000,0,0.000000,$self->[HIGH] == $other->[HIGH] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub isZero
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->[LOW]  == 0 &&
0.000000,0,0.000000,$self->[HIGH] == 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub gt
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $other = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->cmp($other) > 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cmp
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $other = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->[LOW] == $other->[LOW]) {
0.000000,0,0.000000,return $self->[HIGH] - $other->[HIGH] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $self->[LOW] - $other->[LOW] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub is64bit
0.000000,0,0.000000,{
0.000000,0,0.000000,return $_[0]->[HIGH] > 0 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub isAlmost64bit
0.000000,0,0.000000,{
0.000000,0,0.000000,return $_[0]->[HIGH] > 0 ||  $_[0]->[LOW] == MAX32 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getPacked_V64
0.000000,0,0.000000,{
0.000000,0,0.000000,return pack "V V", @{ $_[0] } ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getPacked_V32
0.000000,0,0.000000,{
0.000000,0,0.000000,return pack "V", $_[0]->[LOW] ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub pack_V64
0.000000,0,0.000000,{
0.000000,0,0.000000,return pack "V V", $_[0], 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub full32
0.000000,0,0.000000,{
0.000000,0,0.000000,return $_[0] == MAX32 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Value_VV64
0.000000,0,0.000000,{
0.000000,0,0.000000,my $buffer = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($lo, $hi) = unpack ("V V" , $buffer);
0.000165,2,0.000082,no warnings 'uninitialized';
0.000000,0,0.000000,return $hi * HI_1 + $lo;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,package IO::Compress::Base::Common;
0.000000,0,0.000000,
0.000011,1,0.000011,1;
