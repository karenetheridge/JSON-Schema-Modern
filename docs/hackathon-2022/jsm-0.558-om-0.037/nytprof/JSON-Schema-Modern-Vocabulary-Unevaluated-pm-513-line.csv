# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000034,2,0.000017,use strict;
0.000061,2,0.000030,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Vocabulary::Unevaluated;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Implementation of the JSON Schema Unevaluated vocabulary
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.558';
0.000000,0,0.000000,
0.000049,2,0.000024,use 5.020;
0.000023,2,0.000012,use Moo;
0.000023,3,0.000008,use strictures 2;
0.000027,2,0.000013,use experimental qw(signatures postderef);
0.000022,2,0.000011,use if "$]" >= 5.022, experimental => 're_strict';
0.000018,2,0.000009,no if "$]" >= 5.031009, feature => 'indirect';
0.000014,2,0.000007,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000018,2,0.000009,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000025,3,0.000008,use List::Util 1.45 qw(any max);
0.000014,2,0.000007,use JSON::Schema::Modern::Utilities qw(is_type jsonp local_annotations E A abort true);
0.001451,2,0.000726,use namespace::clean;
0.000000,0,0.000000,
0.000002,1,0.000002,with 'JSON::Schema::Modern::Vocabulary';
0.000000,0,0.000000,
0.000000,0,0.000000,sub vocabulary {
0.000003,1,0.000003,'https://json-schema.org/draft/2020-12/vocab/unevaluated' => 'draft2020-12';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,2,0.000001,sub evaluation_order { 7 }
0.000000,0,0.000000,
0.000000,0,0.000000,# This vocabulary should be evaluated after the Applicator vocabulary.
0.000001,6,0.000000,sub keywords ($self, $spec_version) {
0.000007,2,0.000003,die 'Unevaluated not implemented in '.$spec_version if $spec_version =~ /^draft[467]$/;
0.000004,2,0.000002,qw(unevaluatedItems unevaluatedProperties);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_unevaluatedItems ($self, $schema, $state) {
0.000000,0,0.000000,my $valid = $self->traverse_subschema($schema, $state);
0.000000,0,0.000000,
0.000000,0,0.000000,# remember that annotations need to be collected in order to evaluate this keyword
0.000000,0,0.000000,$state->{configs}{collect_annotations} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_unevaluatedItems ($self, $data, $schema, $state) {
0.000000,0,0.000000,abort($state, 'EXCEPTION: "unevaluatedItems" keyword present, but annotation collection is disabled')
0.000000,0,0.000000,if not $state->{collect_annotations};
0.000000,0,0.000000,
0.000000,0,0.000000,abort($state, 'EXCEPTION: "unevaluatedItems" keyword present, but short_circuit is enabled: results unreliable')
0.000000,0,0.000000,if $state->{short_circuit};
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if not is_type('array', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,my @annotations = local_annotations($state);
0.000000,0,0.000000,
0.000000,0,0.000000,# a relevant keyword already produced a 'true' annotation at this location
0.000000,0,0.000000,my @boolean_annotation_keywords =
0.000000,0,0.000000,$state->{spec_version} eq 'draft2019-09' ? qw(items additionalItems unevaluatedItems)
0.000000,0,0.000000,: qw(prefixItems items contains unevaluatedItems);
0.000000,0,0.000000,my %bools; @bools{@boolean_annotation_keywords} = (1)x@boolean_annotation_keywords;
0.000000,0,0.000000,return 1
0.000000,0,0.000000,if any { $bools{$_->{keyword}} && is_type('boolean', $_->{annotation}) && $_->{annotation} }
0.000000,0,0.000000,@annotations;
0.000000,0,0.000000,
0.000000,0,0.000000,# otherwise, evaluate at every instance item greater than the max of all 'prefixItems'/numeric
0.000000,0,0.000000,# 'items' annotations that isn't in a 'contains' annotation
0.000000,0,0.000000,my $max_index_annotation_keyword = $state->{spec_version} eq 'draft2019-09' ? 'items' : 'prefixItems';
0.000000,0,0.000000,my $last_index = max(-1, grep is_type('integer', $_),
0.000000,0,0.000000,map +($_->{keyword} eq $max_index_annotation_keyword ? $_->{annotation} : ()), @annotations);
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if $last_index == $data->$#*;
0.000000,0,0.000000,
0.000000,0,0.000000,my @contains_annotation_indexes = $state->{spec_version} eq 'draft2019-09' ? ()
0.000000,0,0.000000,: map +($_->{keyword} eq 'contains' ? $_->{annotation}->@* : ()), @annotations;
0.000000,0,0.000000,
0.000000,0,0.000000,my $valid = 1;
0.000000,0,0.000000,foreach my $idx ($last_index+1 .. $data->$#*) {
0.000000,0,0.000000,next if any { $idx == $_ } @contains_annotation_indexes;
0.000000,0,0.000000,if (is_type('boolean', $schema->{unevaluatedItems})) {
0.000000,0,0.000000,next if $schema->{unevaluatedItems};
0.000000,0,0.000000,$valid = E({ %$state, data_path => $state->{data_path}.'/'.$idx },
0.000000,0,0.000000,'additional item not permitted')
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($self->eval($data->[$idx], $schema->{unevaluatedItems},
0.000000,0,0.000000,+{ %$state, data_path => $state->{data_path}.'/'.$idx,
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/unevaluatedItems' })) {
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,A($state, true);
0.000000,0,0.000000,return E($state, 'subschema is not valid against all additional items') if not $valid;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000120,624,0.000000,sub _traverse_keyword_unevaluatedProperties ($self, $schema, $state) {
0.000655,156,0.000004,my $valid = $self->traverse_subschema($schema, $state);
0.000000,0,0.000000,
0.000000,0,0.000000,# remember that annotations need to be collected in order to evaluate this keyword
0.000134,156,0.000001,$state->{configs}{collect_annotations} = 1;
0.000000,0,0.000000,
0.000304,156,0.000002,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.004475,18735,0.000000,sub _eval_keyword_unevaluatedProperties ($self, $data, $schema, $state) {
0.000000,0,0.000000,abort($state, 'EXCEPTION: "unevaluatedProperties" keyword present, but annotation collection is disabled')
0.001853,3747,0.000000,if not $state->{collect_annotations};
0.000000,0,0.000000,
0.000000,0,0.000000,abort($state, 'EXCEPTION: "unevaluatedProperties" keyword present, but short_circuit is enabled: results unreliable')
0.001869,3747,0.000000,if $state->{short_circuit};
0.000000,0,0.000000,
0.005430,3747,0.000001,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,my @evaluated_properties = map {
0.015232,12745,0.000001,my $keyword = $_->{keyword};
0.000000,0,0.000000,(grep $keyword eq $_, qw(properties additionalProperties patternProperties unevaluatedProperties))
0.011629,8998,0.000001,? $_->{annotation}->@* : ();
0.000000,0,0.000000,} local_annotations($state);
0.000000,0,0.000000,
0.000753,3747,0.000000,my $valid = 1;
0.000804,3747,0.000000,my @properties;
0.023806,3747,0.000006,foreach my $property (sort keys %$data) {
0.048273,54233,0.000001,next if any { $_ eq $property } @evaluated_properties;
0.000000,0,0.000000,push @properties, $property;
0.000000,0,0.000000,
0.000000,0,0.000000,if (is_type('boolean', $schema->{unevaluatedProperties})) {
0.000000,0,0.000000,next if $schema->{unevaluatedProperties};
0.000000,0,0.000000,$valid = E({ %$state, data_path => jsonp($state->{data_path}, $property) },
0.000000,0,0.000000,'additional property not permitted');
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($self->eval($data->{$property}, $schema->{unevaluatedProperties},
0.000000,0,0.000000,+{ %$state, data_path => jsonp($state->{data_path}, $property),
0.000000,0,0.000000,schema_path => $state->{schema_path}.'/unevaluatedProperties' })) {
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if $state->{short_circuit};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.004652,3747,0.000001,A($state, \@properties);
0.001052,3747,0.000000,return E($state, 'not all additional properties are valid') if not $valid;
0.010614,3747,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,1;
0.000000,0,0.000000,
0.000025,1,0.000025,__END__
