# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000040,2,0.000020,use strict;
0.000034,2,0.000017,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Utilities;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Internal utilities for JSON::Schema::Modern
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.558';
0.000000,0,0.000000,
0.000034,2,0.000017,use 5.020;
0.000027,3,0.000009,use strictures 2;
0.000031,2,0.000016,use experimental qw(signatures postderef);
0.000022,2,0.000011,use if "$]" >= 5.022, experimental => 're_strict';
0.000042,2,0.000021,no if "$]" >= 5.031009, feature => 'indirect';
0.000015,2,0.000007,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000036,2,0.000018,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000014,2,0.000007,use B;
0.000017,2,0.000008,use Carp 'croak';
0.000027,3,0.000009,use JSON::MaybeXS 1.004004 'is_bool';
0.000023,3,0.000008,use Ref::Util 0.100 qw(is_ref is_plain_arrayref is_plain_hashref);
0.000015,2,0.000008,use Scalar::Util 'blessed';
0.000013,2,0.000007,use Storable 'dclone';
0.000013,2,0.000007,use Feature::Compat::Try;
0.000025,2,0.000013,use JSON::Schema::Modern::Error;
0.000016,2,0.000008,use JSON::Schema::Modern::Annotation;
0.000023,2,0.000012,use namespace::clean;
0.000000,0,0.000000,
0.000185,2,0.000092,use Exporter 'import';
0.000000,0,0.000000,
0.000002,1,0.000002,our @EXPORT_OK = qw(
0.000000,0,0.000000,is_type
0.000000,0,0.000000,get_type
0.000000,0,0.000000,is_equal
0.000000,0,0.000000,is_elements_unique
0.000000,0,0.000000,jsonp
0.000000,0,0.000000,unjsonp
0.000000,0,0.000000,local_annotations
0.000000,0,0.000000,canonical_uri
0.000000,0,0.000000,E
0.000000,0,0.000000,A
0.000000,0,0.000000,abort
0.000000,0,0.000000,assert_keyword_exists
0.000000,0,0.000000,assert_keyword_type
0.000000,0,0.000000,assert_pattern
0.000000,0,0.000000,assert_uri_reference
0.000000,0,0.000000,assert_uri
0.000000,0,0.000000,annotate_self
0.000000,0,0.000000,sprintf_num
0.000000,0,0.000000,true
0.000000,0,0.000000,false
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000038,2,0.000019,use JSON::PP ();
0.002561,2,0.001281,use constant { true => JSON::PP::true, false => JSON::PP::false };
0.000000,0,0.000000,
0.053917,216930,0.000000,sub is_type ($type, $value) {
0.029928,72310,0.000000,if ($type eq 'null') {
0.000000,0,0.000000,return !(defined $value);
0.000000,0,0.000000,}
0.098079,72310,0.000001,if ($type eq 'boolean') {
0.000000,0,0.000000,return is_bool($value);
0.000000,0,0.000000,}
0.152377,55803,0.000003,if ($type eq 'object') {
0.000000,0,0.000000,return is_plain_hashref($value);
0.000000,0,0.000000,}
0.014790,8565,0.000002,if ($type eq 'array') {
0.000000,0,0.000000,return is_plain_arrayref($value);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001269,3748,0.000000,if ($type eq 'string' or $type eq 'number' or $type eq 'integer') {
0.000741,3748,0.000000,return 0 if not defined $value;
0.018862,3748,0.000005,my $flags = B::svref_2object(\$value)->FLAGS;
0.000000,0,0.000000,
0.008744,3748,0.000002,if ($type eq 'string') {
0.000000,0,0.000000,return !is_ref($value) && $flags & B::SVf_POK && !($flags & (B::SVf_IOK | B::SVf_NOK));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000098,196,0.000000,if ($type eq 'number') {
0.000610,109,0.000006,return ref($value) =~ /^Math::Big(?:Int|Float)$/
0.000000,0,0.000000,|| !($flags & B::SVf_POK) && ($flags & (B::SVf_IOK | B::SVf_NOK));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000027,87,0.000000,if ($type eq 'integer') {
0.000442,87,0.000005,return ref($value) =~ /^Math::Big(?:Int|Float)$/ && $value->is_int
0.000000,0,0.000000,|| !($flags & B::SVf_POK) && ($flags & (B::SVf_IOK | B::SVf_NOK)) && int($value) == $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($type =~ /^reference to (.+)$/) {
0.000000,0,0.000000,return !blessed($value) && ref($value) eq $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ref($value) eq $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.050689,323998,0.000000,sub get_type ($value) {
0.320456,161999,0.000002,return 'object' if is_plain_hashref($value);
0.048134,41632,0.000001,return 'boolean' if is_bool($value);
0.006600,36846,0.000000,return 'null' if not defined $value;
0.007543,36846,0.000000,return 'array' if is_plain_arrayref($value);
0.000000,0,0.000000,
0.004698,35741,0.000000,return ref($value) =~ /^Math::Big(?:Int|Float)$/ ? ($value->is_int ? 'integer' : 'number')
0.000000,0,0.000000,: (blessed($value) ? '' : 'reference to ').ref($value)
0.000000,0,0.000000,if is_ref($value);
0.000000,0,0.000000,
0.142051,35741,0.000004,my $flags = B::svref_2object(\$value)->FLAGS;
0.059101,35741,0.000002,return 'string' if $flags & B::SVf_POK && !($flags & (B::SVf_IOK | B::SVf_NOK));
0.000332,107,0.000003,return int($value) == $value ? 'integer' : 'number'
0.000000,0,0.000000,if !($flags & B::SVf_POK) && ($flags & (B::SVf_IOK | B::SVf_NOK));
0.000000,0,0.000000,
0.000000,0,0.000000,croak sprintf('ambiguous type for %s',
0.000000,0,0.000000,JSON::MaybeXS->new(allow_nonref => 1, canonical => 1, utf8 => 0, allow_bignum => 1, convert_blessed => 1)->encode($value));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# compares two arbitrary data payloads for equality, as per
0.000000,0,0.000000,# https://json-schema.org/draft/2020-12/json-schema-core.html#rfc.section.4.2.2
0.000000,0,0.000000,# if provided with a state hashref with a 'path' key, any differences are recorded within
0.012279,63784,0.000000,sub is_equal ($x, $y, $state = undef) {
0.006988,15946,0.000000,$state->{path} //= '';
0.000000,0,0.000000,
0.025875,15946,0.000002,my @types = map get_type($_), $x, $y;
0.000000,0,0.000000,
0.004593,15946,0.000000,if ($state->{scalarref_booleans}) {
0.000954,7244,0.000000,($x, $types[0]) = (0+!!$$x, 'boolean') if $types[0] eq 'reference to SCALAR';
0.000908,7244,0.000000,($y, $types[1]) = (0+!!$$y, 'boolean') if $types[1] eq 'reference to SCALAR';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.003736,15946,0.000000,return 0 if $types[0] ne $types[1];
0.002533,15484,0.000000,return 1 if $types[0] eq 'null';
0.025808,15484,0.000002,return $x eq $y if $types[0] eq 'string';
0.001328,173,0.000008,return $x == $y if grep $types[0] eq $_, qw(boolean number integer);
0.000000,0,0.000000,
0.000000,0,0.000000,my $path = $state->{path};
0.000000,0,0.000000,if ($types[0] eq 'object') {
0.000000,0,0.000000,return 0 if keys %$x != keys %$y;
0.000000,0,0.000000,return 0 if not is_equal([ sort keys %$x ], [ sort keys %$y ]);
0.000000,0,0.000000,foreach my $property (sort keys %$x) {
0.000000,0,0.000000,$state->{path} = jsonp($path, $property);
0.000000,0,0.000000,return 0 if not is_equal($x->{$property}, $y->{$property}, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($types[0] eq 'array') {
0.000000,0,0.000000,return 0 if @$x != @$y;
0.000000,0,0.000000,foreach my $idx (0 .. $x->$#*) {
0.000000,0,0.000000,$state->{path} = $path.'/'.$idx;
0.000000,0,0.000000,return 0 if not is_equal($x->[$idx], $y->[$idx], $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 0; # should never get here
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# checks array elements for uniqueness. short-circuits on first pair of matching elements
0.000000,0,0.000000,# if second arrayref is provided, it is populated with the indices of identical items
0.000394,1920,0.000000,sub is_elements_unique ($array, $equal_indices = undef) {
0.001123,640,0.000002,foreach my $idx0 (0 .. $array->$#*-1) {
0.001459,1141,0.000001,foreach my $idx1 ($idx0+1 .. $array->$#*) {
0.010473,7244,0.000001,if (is_equal($array->[$idx0], $array->[$idx1], { scalarref_booleans => 1 })) {
0.000000,0,0.000000,push @$equal_indices, $idx0, $idx1 if defined $equal_indices;
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.001375,640,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# shorthand for creating and appending json pointers
0.000000,0,0.000000,# the first argument is a a json pointer; remaining arguments are path segments to be encoded and
0.000000,0,0.000000,# appended
0.000000,0,0.000000,sub jsonp {
1.528895,221215,0.000007,return join('/', shift, map s/~/~0/gr =~ s!/!~1!gr, map +(is_plain_arrayref($_) ? @$_ : $_), grep defined, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# splits a json pointer apart into its path segments
0.000000,0,0.000000,sub unjsonp ($path) {
0.000000,0,0.000000,return map s!~0!~!gr =~ s!~1!/!gr, split m!/!, $path;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# get all annotations produced for the current instance data location (that are visible to this
0.000000,0,0.000000,# schema location) - remember these are hashrefs, not Annotation objects
0.001327,7494,0.000000,sub local_annotations ($state) {
0.145301,3747,0.000039,grep $_->{instance_location} eq $state->{data_path}, $state->{annotations}->@*;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# shorthand for finding the canonical uri of the present schema location
0.000000,0,0.000000,# last argument can be an arrayref, usually coming from $state->{_schema_path_suffix}
0.119314,505032,0.000000,sub canonical_uri ($state, @extra_path) {
0.138525,168344,0.000001,return $state->{initial_schema_uri} if not @extra_path and not length($state->{schema_path});
0.040776,126625,0.000000,splice(@extra_path, -1, 1, $extra_path[-1]->@*) if @extra_path and is_plain_arrayref($extra_path[-1]);
0.159036,126625,0.000001,my $uri = $state->{initial_schema_uri}->clone;
0.297076,126625,0.000002,my $fragment = ($uri->fragment//'').(@extra_path ? jsonp($state->{schema_path}, @extra_path) : $state->{schema_path});
0.027948,126625,0.000000,undef $fragment if not length($fragment);
0.083756,126625,0.000001,$uri->fragment($fragment);
0.234259,126625,0.000002,$uri;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# shorthand for creating error objects
0.000000,0,0.000000,# uses these keys from $state:
0.000000,0,0.000000,# - initial_schema_uri
0.000000,0,0.000000,# - keyword
0.000000,0,0.000000,# - data_path
0.000000,0,0.000000,# - traversed_schema_path
0.000000,0,0.000000,# - schema_path
0.000000,0,0.000000,# - _schema_path_suffix
0.000000,0,0.000000,# - errors
0.004879,16868,0.000000,sub E ($state, $error_string, @args) {
0.001358,4217,0.000000,croak 'E called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,# sometimes the keyword shouldn't be at the very end of the schema path
0.000000,0,0.000000,my $uri = canonical_uri($state, $state->{keyword}, $state->{_schema_path_suffix})
0.027533,4217,0.000007,->to_abs($state->{effective_base_uri});
0.000000,0,0.000000,
0.000000,0,0.000000,my $keyword_location = $state->{traversed_schema_path}
0.008985,4217,0.000002,.jsonp($state->{schema_path}, $state->{keyword}, delete $state->{_schema_path_suffix});
0.000000,0,0.000000,
0.017004,4217,0.000004,undef $uri if $uri eq '' and $keyword_location eq ''
0.000000,0,0.000000,or ($uri->fragment // '') eq $keyword_location and $uri->clone->fragment(undef) eq '';
0.000000,0,0.000000,
0.000000,0,0.000000,push $state->{errors}->@*, JSON::Schema::Modern::Error->new(
0.000000,0,0.000000,keyword => $state->{keyword},
0.000000,0,0.000000,instance_location => $state->{data_path},
0.000000,0,0.000000,keyword_location => $keyword_location,
0.000000,0,0.000000,defined $uri ? ( absolute_keyword_location => $uri ) : (),
0.000000,0,0.000000,error => @args ? sprintf($error_string, @args) : $error_string,
0.032415,4217,0.000008,$state->{exception} ? ( exception => $state->{exception} ) : (),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.012838,4217,0.000003,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# shorthand for creating annotations
0.000000,0,0.000000,# uses these keys from $state:
0.000000,0,0.000000,# - initial_schema_uri
0.000000,0,0.000000,# - keyword
0.000000,0,0.000000,# - data_path
0.000000,0,0.000000,# - traversed_schema_path
0.000000,0,0.000000,# - schema_path
0.000000,0,0.000000,# - _schema_path_suffix
0.000000,0,0.000000,# - annotations
0.000000,0,0.000000,# - collect_annotations
0.044739,215376,0.000000,sub A ($state, $annotation) {
0.052361,71792,0.000001,return 1 if not $state->{collect_annotations} or $state->{spec_version} eq 'draft7';
0.000000,0,0.000000,
0.000000,0,0.000000,# we store the absolute uri in unresolved form until needed,
0.000000,0,0.000000,# and perform the rest of the calculations later.
0.000000,0,0.000000,
0.000000,0,0.000000,my $uri = [ canonical_uri($state, $state->{keyword}, $state->{_schema_path_suffix}),
0.196237,71790,0.000003,$state->{effective_base_uri} ];
0.000000,0,0.000000,
0.000000,0,0.000000,my $keyword_location = $state->{traversed_schema_path}
0.136484,71790,0.000002,.jsonp($state->{schema_path}, $state->{keyword}, delete $state->{_schema_path_suffix});
0.000000,0,0.000000,
0.000000,0,0.000000,push $state->{annotations}->@*, {
0.000000,0,0.000000,keyword => $state->{keyword},
0.000000,0,0.000000,instance_location => $state->{data_path},
0.000000,0,0.000000,keyword_location => $keyword_location,
0.000000,0,0.000000,# we calculate absolute_keyword_location when instantiating the Annotation object for Result
0.000000,0,0.000000,_uri => $uri,
0.000000,0,0.000000,annotation => $annotation,
0.227973,71790,0.000003,$state->{_unknown} ? ( unknown => 1 ) : (),
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.150044,71790,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# creates an error object, but also aborts evaluation immediately
0.000000,0,0.000000,# only this error is returned, because other errors on the stack might not actually be "real"
0.000000,0,0.000000,# errors (consider if we were in the middle of evaluating a "not" or "if").
0.000000,0,0.000000,# Therefore this is only appropriate during the evaluation phase, not the traverse phase.
0.000000,0,0.000000,sub abort ($state, $error_string, @args) {
0.000000,0,0.000000,()= E({ %$state, exception => 1 }, $error_string, @args);
0.000000,0,0.000000,croak 'abort() called during traverse' if $state->{traverse};
0.000000,0,0.000000,die pop $state->{errors}->@*;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,3,0.000000,sub assert_keyword_exists ($state, $schema) {
0.000000,1,0.000000,croak 'assert_keyword_exists called in void context' if not defined wantarray;
0.000001,1,0.000001,return E($state, '%s keyword is required', $state->{keyword}) if not exists $schema->{$state->{keyword}};
0.000003,1,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002189,14360,0.000000,sub assert_keyword_type ($state, $schema, $type) {
0.000776,3590,0.000000,croak 'assert_keyword_type called in void context' if not defined wantarray;
0.002781,3590,0.000001,my $value = $schema->{$state->{keyword}};
0.000652,3590,0.000000,my $thing = 'value';
0.000000,0,0.000000,($value, $thing) = is_plain_hashref($value) ? ($value->{$state->{_schema_path_suffix}}, 'value at "'.$state->{_schema_path_suffix}.'"')
0.000000,0,0.000000,: is_plain_arrayref($value) ? ($value->[$state->{_schema_path_suffix}], 'item '.$state->{_schema_path_suffix})
0.000000,0,0.000000,: die 'unknown type'
0.000775,3590,0.000000,if exists $state->{_schema_path_suffix};
0.009952,3590,0.000003,return 1 if is_type($type, $value);
0.000000,0,0.000000,E($state, '%s %s is not a%s %s', $state->{keyword}, $thing, ($type =~ /^[aeiou]/ ? 'n' : ''), $type);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000041,225,0.000000,sub assert_pattern ($state, $pattern) {
0.000052,75,0.000001,croak 'assert_pattern called in void context' if not defined wantarray;
0.000032,75,0.000000,try {
0.000330,75,0.000004,local $SIG{__WARN__} = sub { die @_ };
0.002730,75,0.000036,qr/$pattern/;
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) { return E($state, $e); };
0.000162,75,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# this is only suitable for checking URIs within schemas themselves
0.000310,2238,0.000000,sub assert_uri_reference ($state, $schema) {
0.000227,746,0.000000,croak 'assert_uri_reference called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000454,746,0.000001,my $string = $schema->{$state->{keyword}};
0.000000,0,0.000000,return E($state, '%s value is not a valid URI reference', $state->{keyword})
0.000000,0,0.000000,# see also uri-reference format sub
0.012720,746,0.000017,if fc(Mojo::URL->new($string)->to_unsafe_string) ne fc($string)
0.000000,0,0.000000,or $string =~ /[^[:ascii:]]/
0.000000,0,0.000000,or $string =~ /#/
0.000000,0,0.000000,and $string !~ m{#$}                          # empty fragment
0.000000,0,0.000000,and $string !~ m{#[A-Za-z][A-Za-z0-9_:.-]*$}  # plain-name fragment
0.000000,0,0.000000,and $string !~ m{#/(?:[^~]|~[01])*$};         # json pointer fragment
0.000000,0,0.000000,
0.001459,746,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# this is only suitable for checking URIs within schemas themselves
0.000028,184,0.000000,sub assert_uri ($state, $schema, $override = undef) {
0.000018,46,0.000000,croak 'assert_uri called in void context' if not defined wantarray;
0.000000,0,0.000000,
0.000024,46,0.000001,my $string = $override // $schema->{$state->{keyword}};
0.000042,46,0.000001,my $uri = Mojo::URL->new($string);
0.000000,0,0.000000,
0.000295,46,0.000006,return E($state, '"%s" is not a valid URI', $string)
0.000000,0,0.000000,# see also uri format sub
0.000000,0,0.000000,if fc($uri->to_unsafe_string) ne fc($string)
0.000000,0,0.000000,or $string =~ /[^[:ascii:]]/
0.000000,0,0.000000,or not $uri->is_abs
0.000000,0,0.000000,or $string =~ /#/
0.000000,0,0.000000,and $string !~ m{#$}                          # empty fragment
0.000000,0,0.000000,and $string !~ m{#[A-Za-z][A-Za-z0-9_:.-]*$}  # plain-name fragment
0.000000,0,0.000000,and $string !~ m{#/(?:[^~]|~[01])*$};         # json pointer fragment
0.000000,0,0.000000,
0.000142,46,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# produces an annotation whose value is the same as that of the current keyword
0.015258,96642,0.000000,sub annotate_self ($state, $schema) {
0.000000,0,0.000000,A($state, is_ref($schema->{$state->{keyword}}) ? dclone($schema->{$state->{keyword}})
0.170183,32214,0.000005,: $schema->{$state->{keyword}});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sprintf_num ($value) {
0.000000,0,0.000000,# use original value as stored in the NV, without losing precision
0.000000,0,0.000000,ref($value) =~ /^Math::Big(?:Int|Float)$/ ? $value->bstr : sprintf('%s', $value);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,1;
0.000000,0,0.000000,
0.000030,1,0.000030,__END__
