# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
0.000000,0,0.000000,# This program is free software; you can redistribute it and/or
0.000000,0,0.000000,# modify it under the same terms as Perl itself.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
0.000000,0,0.000000,
0.000000,0,0.000000,package List::Util;
0.000000,0,0.000000,
0.000019,2,0.000010,use strict;
0.000074,2,0.000037,use warnings;
0.000001,1,0.000001,require Exporter;
0.000000,0,0.000000,
0.000005,1,0.000005,our @ISA        = qw(Exporter);
0.000002,1,0.000002,our @EXPORT_OK  = qw(
0.000000,0,0.000000,all any first min max minstr maxstr none notall product reduce reductions sum sum0
0.000000,0,0.000000,sample shuffle uniq uniqint uniqnum uniqstr zip zip_longest zip_shortest mesh mesh_longest mesh_shortest
0.000000,0,0.000000,head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
0.000000,0,0.000000,);
0.000001,1,0.000001,our $VERSION    = "1.62";
0.000000,1,0.000000,our $XS_VERSION = $VERSION;
0.000001,1,0.000001,$VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000000,1,0.000000,require XSLoader;
0.000368,1,0.000368,XSLoader::load('List::Util', $XS_VERSION);
0.000000,0,0.000000,
0.000000,0,0.000000,# Used by shuffle()
0.000000,0,0.000000,our $RAND;
0.000000,0,0.000000,
0.000000,0,0.000000,sub import
0.000000,0,0.000000,{
0.000012,10,0.000001,my $pkg = caller;
0.000000,0,0.000000,
0.000000,0,0.000000,# (RT88848) Touch the caller's $a and $b, to avoid the warning of
0.000000,0,0.000000,#   Name "main::a" used only once: possible typo" warning
0.000321,2,0.000160,no strict 'refs';
0.000043,10,0.000004,${"${pkg}::a"} = ${"${pkg}::a"};
0.000027,10,0.000003,${"${pkg}::b"} = ${"${pkg}::b"};
0.000000,0,0.000000,
0.000053,10,0.000005,goto &Exporter::import;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# For objects returned by pairs()
0.000000,0,0.000000,sub List::Util::_Pair::key   { shift->[0] }
0.000000,0,0.000000,sub List::Util::_Pair::value { shift->[1] }
0.000000,0,0.000000,sub List::Util::_Pair::TO_JSON { [ @{+shift} ] }
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,List::Util - A selection of general-utility list subroutines
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use List::Util qw(
0.000000,0,0.000000,reduce any all none notall first reductions
0.000000,0,0.000000,
0.000000,0,0.000000,max maxstr min minstr product sum sum0
0.000000,0,0.000000,
0.000000,0,0.000000,pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
0.000000,0,0.000000,
0.000000,0,0.000000,shuffle uniq uniqint uniqnum uniqstr zip mesh
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,C<List::Util> contains a selection of subroutines that people have expressed
0.000000,0,0.000000,would be nice to have in the perl core, but the usage would not really be high
0.000000,0,0.000000,enough to warrant the use of a keyword, and the size so small such that being
0.000000,0,0.000000,individual extensions would be wasteful.
0.000000,0,0.000000,
0.000000,0,0.000000,By default C<List::Util> does not export any subroutines.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 LIST-REDUCTION FUNCTIONS
0.000000,0,0.000000,
0.000000,0,0.000000,The following set of functions all apply a given block of code to a list of
0.000000,0,0.000000,values.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 reduce
0.000000,0,0.000000,
0.000000,0,0.000000,$result = reduce { BLOCK } @list
0.000000,0,0.000000,
0.000000,0,0.000000,Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
0.000000,0,0.000000,setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
0.000000,0,0.000000,set to the first two elements of the list, subsequent calls will be done by
0.000000,0,0.000000,setting C<$a> to the result of the previous call and C<$b> to the next element
0.000000,0,0.000000,in the list.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
0.000000,0,0.000000,C<undef> is returned. If C<@list> only contains one element then that element
0.000000,0,0.000000,is returned and C<BLOCK> is not executed.
0.000000,0,0.000000,
0.000000,0,0.000000,The following examples all demonstrate how C<reduce> could be used to implement
0.000000,0,0.000000,the other list-reduction functions in this module. (They are not in fact
0.000000,0,0.000000,implemented like this, but instead in a more efficient manner in individual C
0.000000,0,0.000000,functions).
0.000000,0,0.000000,
0.000000,0,0.000000,$foo = reduce { defined($a)            ? $a :
0.000000,0,0.000000,$code->(local $_ = $b) ? $b :
0.000000,0,0.000000,undef } undef, @list # first
0.000000,0,0.000000,
0.000000,0,0.000000,$foo = reduce { $a > $b ? $a : $b } 1..10       # max
0.000000,0,0.000000,$foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
0.000000,0,0.000000,$foo = reduce { $a < $b ? $a : $b } 1..10       # min
0.000000,0,0.000000,$foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
0.000000,0,0.000000,$foo = reduce { $a + $b } 1 .. 10               # sum
0.000000,0,0.000000,$foo = reduce { $a . $b } @bar                  # concat
0.000000,0,0.000000,
0.000000,0,0.000000,$foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
0.000000,0,0.000000,$foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
0.000000,0,0.000000,$foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
0.000000,0,0.000000,$foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
0.000000,0,0.000000,# Note that these implementations do not fully short-circuit
0.000000,0,0.000000,
0.000000,0,0.000000,If your algorithm requires that C<reduce> produce an identity value, then make
0.000000,0,0.000000,sure that you always pass that identity value as the first argument to prevent
0.000000,0,0.000000,C<undef> being returned
0.000000,0,0.000000,
0.000000,0,0.000000,$foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
0.000000,0,0.000000,
0.000000,0,0.000000,The above example code blocks also suggest how to use C<reduce> to build a
0.000000,0,0.000000,more efficient combined version of one of these basic functions and a C<map>
0.000000,0,0.000000,block. For example, to find the total length of all the strings in a list,
0.000000,0,0.000000,we could use
0.000000,0,0.000000,
0.000000,0,0.000000,$total = sum map { length } @strings;
0.000000,0,0.000000,
0.000000,0,0.000000,However, this produces a list of temporary integer values as long as the
0.000000,0,0.000000,original list of strings, only to reduce it down to a single value again. We
0.000000,0,0.000000,can compute the same result more efficiently by using C<reduce> with a code
0.000000,0,0.000000,block that accumulates lengths by writing this instead as:
0.000000,0,0.000000,
0.000000,0,0.000000,$total = reduce { $a + length $b } 0, @strings
0.000000,0,0.000000,
0.000000,0,0.000000,The other scalar-returning list reduction functions are all specialisations of
0.000000,0,0.000000,this generic idea.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 reductions
0.000000,0,0.000000,
0.000000,0,0.000000,@results = reductions { BLOCK } @list
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.54.>
0.000000,0,0.000000,
0.000000,0,0.000000,Similar to C<reduce> except that it also returns the intermediate values along
0.000000,0,0.000000,with the final result. As before, C<$a> is set to the first element of the
0.000000,0,0.000000,given list, and the C<BLOCK> is then called once for remaining item in the
0.000000,0,0.000000,list set into C<$b>, with the result being captured for return as well as
0.000000,0,0.000000,becoming the new value for C<$a>.
0.000000,0,0.000000,
0.000000,0,0.000000,The returned list will begin with the initial value for C<$a>, followed by
0.000000,0,0.000000,each return value from the block in order. The final value of the result will
0.000000,0,0.000000,be identical to what the C<reduce> function would have returned given the same
0.000000,0,0.000000,block and list.
0.000000,0,0.000000,
0.000000,0,0.000000,reduce     { "$a-$b" }  "a".."d"    # "a-b-c-d"
0.000000,0,0.000000,reductions { "$a-$b" }  "a".."d"    # "a", "a-b", "a-b-c", "a-b-c-d"
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 any
0.000000,0,0.000000,
0.000000,0,0.000000,my $bool = any { BLOCK } @list;
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.33.>
0.000000,0,0.000000,
0.000000,0,0.000000,Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
0.000000,0,0.000000,of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
0.000000,0,0.000000,return a true value. If C<BLOCK> never returns true or C<@list> was empty then
0.000000,0,0.000000,it returns false.
0.000000,0,0.000000,
0.000000,0,0.000000,Many cases of using C<grep> in a conditional can be written using C<any>
0.000000,0,0.000000,instead, as it can short-circuit after the first true result.
0.000000,0,0.000000,
0.000000,0,0.000000,if( any { length > 10 } @strings ) {
0.000000,0,0.000000,# at least one string has more than 10 characters
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,Note: Due to XS issues the block passed may be able to access the outer @_
0.000000,0,0.000000,directly. This is not intentional and will break under debugger.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 all
0.000000,0,0.000000,
0.000000,0,0.000000,my $bool = all { BLOCK } @list;
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.33.>
0.000000,0,0.000000,
0.000000,0,0.000000,Similar to L</any>, except that it requires all elements of the C<@list> to
0.000000,0,0.000000,make the C<BLOCK> return true. If any element returns false, then it returns
0.000000,0,0.000000,false. If the C<BLOCK> never returns false or the C<@list> was empty then it
0.000000,0,0.000000,returns true.
0.000000,0,0.000000,
0.000000,0,0.000000,Note: Due to XS issues the block passed may be able to access the outer @_
0.000000,0,0.000000,directly. This is not intentional and will break under debugger.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 none
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 notall
0.000000,0,0.000000,
0.000000,0,0.000000,my $bool = none { BLOCK } @list;
0.000000,0,0.000000,
0.000000,0,0.000000,my $bool = notall { BLOCK } @list;
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.33.>
0.000000,0,0.000000,
0.000000,0,0.000000,Similar to L</any> and L</all>, but with the return sense inverted. C<none>
0.000000,0,0.000000,returns true only if no value in the C<@list> causes the C<BLOCK> to return
0.000000,0,0.000000,true, and C<notall> returns true only if not all of the values do.
0.000000,0,0.000000,
0.000000,0,0.000000,Note: Due to XS issues the block passed may be able to access the outer @_
0.000000,0,0.000000,directly. This is not intentional and will break under debugger.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 first
0.000000,0,0.000000,
0.000000,0,0.000000,my $val = first { BLOCK } @list;
0.000000,0,0.000000,
0.000000,0,0.000000,Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
0.000000,0,0.000000,of C<@list> in turn. C<first> returns the first element where the result from
0.000000,0,0.000000,C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
0.000000,0,0.000000,then C<undef> is returned.
0.000000,0,0.000000,
0.000000,0,0.000000,$foo = first { defined($_) } @list    # first defined value in @list
0.000000,0,0.000000,$foo = first { $_ > $value } @list    # first value in @list which
0.000000,0,0.000000,# is greater than $value
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 max
0.000000,0,0.000000,
0.000000,0,0.000000,my $num = max @list;
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the entry in the list with the highest numerical value. If the list is
0.000000,0,0.000000,empty then C<undef> is returned.
0.000000,0,0.000000,
0.000000,0,0.000000,$foo = max 1..10                # 10
0.000000,0,0.000000,$foo = max 3,9,12               # 12
0.000000,0,0.000000,$foo = max @bar, @baz           # whatever
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 maxstr
0.000000,0,0.000000,
0.000000,0,0.000000,my $str = maxstr @list;
0.000000,0,0.000000,
0.000000,0,0.000000,Similar to L</max>, but treats all the entries in the list as strings and
0.000000,0,0.000000,returns the highest string as defined by the C<gt> operator. If the list is
0.000000,0,0.000000,empty then C<undef> is returned.
0.000000,0,0.000000,
0.000000,0,0.000000,$foo = maxstr 'A'..'Z'          # 'Z'
0.000000,0,0.000000,$foo = maxstr "hello","world"   # "world"
0.000000,0,0.000000,$foo = maxstr @bar, @baz        # whatever
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 min
0.000000,0,0.000000,
0.000000,0,0.000000,my $num = min @list;
0.000000,0,0.000000,
0.000000,0,0.000000,Similar to L</max> but returns the entry in the list with the lowest numerical
0.000000,0,0.000000,value. If the list is empty then C<undef> is returned.
0.000000,0,0.000000,
0.000000,0,0.000000,$foo = min 1..10                # 1
0.000000,0,0.000000,$foo = min 3,9,12               # 3
0.000000,0,0.000000,$foo = min @bar, @baz           # whatever
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 minstr
0.000000,0,0.000000,
0.000000,0,0.000000,my $str = minstr @list;
0.000000,0,0.000000,
0.000000,0,0.000000,Similar to L</min>, but treats all the entries in the list as strings and
0.000000,0,0.000000,returns the lowest string as defined by the C<lt> operator. If the list is
0.000000,0,0.000000,empty then C<undef> is returned.
0.000000,0,0.000000,
0.000000,0,0.000000,$foo = minstr 'A'..'Z'          # 'A'
0.000000,0,0.000000,$foo = minstr "hello","world"   # "hello"
0.000000,0,0.000000,$foo = minstr @bar, @baz        # whatever
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 product
0.000000,0,0.000000,
0.000000,0,0.000000,my $num = product @list;
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.35.>
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the numerical product of all the elements in C<@list>. If C<@list> is
0.000000,0,0.000000,empty then C<1> is returned.
0.000000,0,0.000000,
0.000000,0,0.000000,$foo = product 1..10            # 3628800
0.000000,0,0.000000,$foo = product 3,9,12           # 324
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 sum
0.000000,0,0.000000,
0.000000,0,0.000000,my $num_or_undef = sum @list;
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the numerical sum of all the elements in C<@list>. For backwards
0.000000,0,0.000000,compatibility, if C<@list> is empty then C<undef> is returned.
0.000000,0,0.000000,
0.000000,0,0.000000,$foo = sum 1..10                # 55
0.000000,0,0.000000,$foo = sum 3,9,12               # 24
0.000000,0,0.000000,$foo = sum @bar, @baz           # whatever
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 sum0
0.000000,0,0.000000,
0.000000,0,0.000000,my $num = sum0 @list;
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.26.>
0.000000,0,0.000000,
0.000000,0,0.000000,Similar to L</sum>, except this returns 0 when given an empty list, rather
0.000000,0,0.000000,than C<undef>.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 KEY/VALUE PAIR LIST FUNCTIONS
0.000000,0,0.000000,
0.000000,0,0.000000,The following set of functions, all inspired by L<List::Pairwise>, consume an
0.000000,0,0.000000,even-sized list of pairs. The pairs may be key/value associations from a hash,
0.000000,0,0.000000,or just a list of values. The functions will all preserve the original ordering
0.000000,0,0.000000,of the pairs, and will not be confused by multiple pairs having the same "key"
0.000000,0,0.000000,value - nor even do they require that the first of each pair be a plain string.
0.000000,0,0.000000,
0.000000,0,0.000000,B<NOTE>: At the time of writing, the following C<pair*> functions that take a
0.000000,0,0.000000,block do not modify the value of C<$_> within the block, and instead operate
0.000000,0,0.000000,using the C<$a> and C<$b> globals instead. This has turned out to be a poor
0.000000,0,0.000000,design, as it precludes the ability to provide a C<pairsort> function. Better
0.000000,0,0.000000,would be to pass pair-like objects as 2-element array references in C<$_>, in
0.000000,0,0.000000,a style similar to the return value of the C<pairs> function. At some future
0.000000,0,0.000000,version this behaviour may be added.
0.000000,0,0.000000,
0.000000,0,0.000000,Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
0.000000,0,0.000000,unmodified between the outside and the inside of the control block. In
0.000000,0,0.000000,particular, the following example is B<UNSAFE>:
0.000000,0,0.000000,
0.000000,0,0.000000,my @kvlist = ...
0.000000,0,0.000000,
0.000000,0,0.000000,foreach (qw( some keys here )) {
0.000000,0,0.000000,my @items = pairgrep { $a eq $_ } @kvlist;
0.000000,0,0.000000,...
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,Instead, write this using a lexical variable:
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $key (qw( some keys here )) {
0.000000,0,0.000000,my @items = pairgrep { $a eq $key } @kvlist;
0.000000,0,0.000000,...
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 pairs
0.000000,0,0.000000,
0.000000,0,0.000000,my @pairs = pairs @kvlist;
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.29.>
0.000000,0,0.000000,
0.000000,0,0.000000,A convenient shortcut to operating on even-sized lists of pairs, this function
0.000000,0,0.000000,returns a list of C<ARRAY> references, each containing two items from the
0.000000,0,0.000000,given list. It is a more efficient version of
0.000000,0,0.000000,
0.000000,0,0.000000,@pairs = pairmap { [ $a, $b ] } @kvlist
0.000000,0,0.000000,
0.000000,0,0.000000,It is most convenient to use in a C<foreach> loop, for example:
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $pair ( pairs @kvlist ) {
0.000000,0,0.000000,my ( $key, $value ) = @$pair;
0.000000,0,0.000000,...
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,Since version C<1.39> these C<ARRAY> references are blessed objects,
0.000000,0,0.000000,recognising the two methods C<key> and C<value>. The following code is
0.000000,0,0.000000,equivalent:
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $pair ( pairs @kvlist ) {
0.000000,0,0.000000,my $key   = $pair->key;
0.000000,0,0.000000,my $value = $pair->value;
0.000000,0,0.000000,...
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,Since version C<1.51> they also have a C<TO_JSON> method to ease
0.000000,0,0.000000,serialisation.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 unpairs
0.000000,0,0.000000,
0.000000,0,0.000000,my @kvlist = unpairs @pairs
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.42.>
0.000000,0,0.000000,
0.000000,0,0.000000,The inverse function to C<pairs>; this function takes a list of C<ARRAY>
0.000000,0,0.000000,references containing two elements each, and returns a flattened list of the
0.000000,0,0.000000,two values from each of the pairs, in order. This is notionally equivalent to
0.000000,0,0.000000,
0.000000,0,0.000000,my @kvlist = map { @{$_}[0,1] } @pairs
0.000000,0,0.000000,
0.000000,0,0.000000,except that it is implemented more efficiently internally. Specifically, for
0.000000,0,0.000000,any input item it will extract exactly two values for the output list; using
0.000000,0,0.000000,C<undef> if the input array references are short.
0.000000,0,0.000000,
0.000000,0,0.000000,Between C<pairs> and C<unpairs>, a higher-order list function can be used to
0.000000,0,0.000000,operate on the pairs as single scalars; such as the following near-equivalents
0.000000,0,0.000000,of the other C<pair*> higher-order functions:
0.000000,0,0.000000,
0.000000,0,0.000000,@kvlist = unpairs grep { FUNC } pairs @kvlist
0.000000,0,0.000000,# Like pairgrep, but takes $_ instead of $a and $b
0.000000,0,0.000000,
0.000000,0,0.000000,@kvlist = unpairs map { FUNC } pairs @kvlist
0.000000,0,0.000000,# Like pairmap, but takes $_ instead of $a and $b
0.000000,0,0.000000,
0.000000,0,0.000000,Note however that these versions will not behave as nicely in scalar context.
0.000000,0,0.000000,
0.000000,0,0.000000,Finally, this technique can be used to implement a sort on a keyvalue pair
0.000000,0,0.000000,list; e.g.:
0.000000,0,0.000000,
0.000000,0,0.000000,@kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 pairkeys
0.000000,0,0.000000,
0.000000,0,0.000000,my @keys = pairkeys @kvlist;
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.29.>
0.000000,0,0.000000,
0.000000,0,0.000000,A convenient shortcut to operating on even-sized lists of pairs, this function
0.000000,0,0.000000,returns a list of the the first values of each of the pairs in the given list.
0.000000,0,0.000000,It is a more efficient version of
0.000000,0,0.000000,
0.000000,0,0.000000,@keys = pairmap { $a } @kvlist
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 pairvalues
0.000000,0,0.000000,
0.000000,0,0.000000,my @values = pairvalues @kvlist;
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.29.>
0.000000,0,0.000000,
0.000000,0,0.000000,A convenient shortcut to operating on even-sized lists of pairs, this function
0.000000,0,0.000000,returns a list of the the second values of each of the pairs in the given list.
0.000000,0,0.000000,It is a more efficient version of
0.000000,0,0.000000,
0.000000,0,0.000000,@values = pairmap { $b } @kvlist
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 pairgrep
0.000000,0,0.000000,
0.000000,0,0.000000,my @kvlist = pairgrep { BLOCK } @kvlist;
0.000000,0,0.000000,
0.000000,0,0.000000,my $count = pairgrep { BLOCK } @kvlist;
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.29.>
0.000000,0,0.000000,
0.000000,0,0.000000,Similar to perl's C<grep> keyword, but interprets the given list as an
0.000000,0,0.000000,even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
0.000000,0,0.000000,context, with C<$a> and C<$b> set to successive pairs of values from the
0.000000,0,0.000000,C<@kvlist>.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns an even-sized list of those pairs for which the C<BLOCK> returned true
0.000000,0,0.000000,in list context, or the count of the B<number of pairs> in scalar context.
0.000000,0,0.000000,(Note, therefore, in scalar context that it returns a number half the size of
0.000000,0,0.000000,the count of items it would have returned in list context).
0.000000,0,0.000000,
0.000000,0,0.000000,@subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
0.000000,0,0.000000,
0.000000,0,0.000000,As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
0.000000,0,0.000000,C<$b> to elements of the given list. Any modifications of it by the code block
0.000000,0,0.000000,will be visible to the caller.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 pairfirst
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
0.000000,0,0.000000,
0.000000,0,0.000000,my $found = pairfirst { BLOCK } @kvlist;
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.30.>
0.000000,0,0.000000,
0.000000,0,0.000000,Similar to the L</first> function, but interprets the given list as an
0.000000,0,0.000000,even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
0.000000,0,0.000000,context, with C<$a> and C<$b> set to successive pairs of values from the
0.000000,0,0.000000,C<@kvlist>.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the first pair of values from the list for which the C<BLOCK> returned
0.000000,0,0.000000,true in list context, or an empty list of no such pair was found. In scalar
0.000000,0,0.000000,context it returns a simple boolean value, rather than either the key or the
0.000000,0,0.000000,value found.
0.000000,0,0.000000,
0.000000,0,0.000000,( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
0.000000,0,0.000000,
0.000000,0,0.000000,As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
0.000000,0,0.000000,C<$b> to elements of the given list. Any modifications of it by the code block
0.000000,0,0.000000,will be visible to the caller.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 pairmap
0.000000,0,0.000000,
0.000000,0,0.000000,my @list = pairmap { BLOCK } @kvlist;
0.000000,0,0.000000,
0.000000,0,0.000000,my $count = pairmap { BLOCK } @kvlist;
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.29.>
0.000000,0,0.000000,
0.000000,0,0.000000,Similar to perl's C<map> keyword, but interprets the given list as an
0.000000,0,0.000000,even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
0.000000,0,0.000000,context, with C<$a> and C<$b> set to successive pairs of values from the
0.000000,0,0.000000,C<@kvlist>.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the concatenation of all the values returned by the C<BLOCK> in list
0.000000,0,0.000000,context, or the count of the number of items that would have been returned in
0.000000,0,0.000000,scalar context.
0.000000,0,0.000000,
0.000000,0,0.000000,@result = pairmap { "The key $a has value $b" } @kvlist
0.000000,0,0.000000,
0.000000,0,0.000000,As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
0.000000,0,0.000000,C<$b> to elements of the given list. Any modifications of it by the code block
0.000000,0,0.000000,will be visible to the caller.
0.000000,0,0.000000,
0.000000,0,0.000000,See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 OTHER FUNCTIONS
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 shuffle
0.000000,0,0.000000,
0.000000,0,0.000000,my @values = shuffle @values;
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the values of the input in a random order
0.000000,0,0.000000,
0.000000,0,0.000000,@cards = shuffle 0..51      # 0..51 in a random order
0.000000,0,0.000000,
0.000000,0,0.000000,This function is affected by the C<$RAND> variable.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 sample
0.000000,0,0.000000,
0.000000,0,0.000000,my @items = sample $count, @values
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.54.>
0.000000,0,0.000000,
0.000000,0,0.000000,Randomly select the given number of elements from the input list. Any given
0.000000,0,0.000000,position in the input list will be selected at most once.
0.000000,0,0.000000,
0.000000,0,0.000000,If there are fewer than C<$count> items in the list then the function will
0.000000,0,0.000000,return once all of them have been randomly selected; effectively the function
0.000000,0,0.000000,behaves similarly to L</shuffle>.
0.000000,0,0.000000,
0.000000,0,0.000000,This function is affected by the C<$RAND> variable.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 uniq
0.000000,0,0.000000,
0.000000,0,0.000000,my @subset = uniq @values
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.45.>
0.000000,0,0.000000,
0.000000,0,0.000000,Filters a list of values to remove subsequent duplicates, as judged by a
0.000000,0,0.000000,DWIM-ish string equality or C<undef> test. Preserves the order of unique
0.000000,0,0.000000,elements, and retains the first value of any duplicate set.
0.000000,0,0.000000,
0.000000,0,0.000000,my $count = uniq @values
0.000000,0,0.000000,
0.000000,0,0.000000,In scalar context, returns the number of elements that would have been
0.000000,0,0.000000,returned as a list.
0.000000,0,0.000000,
0.000000,0,0.000000,The C<undef> value is treated by this function as distinct from the empty
0.000000,0,0.000000,string, and no warning will be produced. It is left as-is in the returned
0.000000,0,0.000000,list. Subsequent C<undef> values are still considered identical to the first,
0.000000,0,0.000000,and will be removed.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 uniqint
0.000000,0,0.000000,
0.000000,0,0.000000,my @subset = uniqint @values
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.55.>
0.000000,0,0.000000,
0.000000,0,0.000000,Filters a list of values to remove subsequent duplicates, as judged by an
0.000000,0,0.000000,integer numerical equality test. Preserves the order of unique elements, and
0.000000,0,0.000000,retains the first value of any duplicate set. Values in the returned list will
0.000000,0,0.000000,be coerced into integers.
0.000000,0,0.000000,
0.000000,0,0.000000,my $count = uniqint @values
0.000000,0,0.000000,
0.000000,0,0.000000,In scalar context, returns the number of elements that would have been
0.000000,0,0.000000,returned as a list.
0.000000,0,0.000000,
0.000000,0,0.000000,Note that C<undef> is treated much as other numerical operations treat it; it
0.000000,0,0.000000,compares equal to zero but additionally produces a warning if such warnings
0.000000,0,0.000000,are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
0.000000,0,0.000000,the returned list is coerced into a numerical zero, so that the entire list of
0.000000,0,0.000000,values returned by C<uniqint> are well-behaved as integers.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 uniqnum
0.000000,0,0.000000,
0.000000,0,0.000000,my @subset = uniqnum @values
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.44.>
0.000000,0,0.000000,
0.000000,0,0.000000,Filters a list of values to remove subsequent duplicates, as judged by a
0.000000,0,0.000000,numerical equality test. Preserves the order of unique elements, and retains
0.000000,0,0.000000,the first value of any duplicate set.
0.000000,0,0.000000,
0.000000,0,0.000000,my $count = uniqnum @values
0.000000,0,0.000000,
0.000000,0,0.000000,In scalar context, returns the number of elements that would have been
0.000000,0,0.000000,returned as a list.
0.000000,0,0.000000,
0.000000,0,0.000000,Note that C<undef> is treated much as other numerical operations treat it; it
0.000000,0,0.000000,compares equal to zero but additionally produces a warning if such warnings
0.000000,0,0.000000,are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
0.000000,0,0.000000,the returned list is coerced into a numerical zero, so that the entire list of
0.000000,0,0.000000,values returned by C<uniqnum> are well-behaved as numbers.
0.000000,0,0.000000,
0.000000,0,0.000000,Note also that multiple IEEE C<NaN> values are treated as duplicates of
0.000000,0,0.000000,each other, regardless of any differences in their payloads, and despite
0.000000,0,0.000000,the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 uniqstr
0.000000,0,0.000000,
0.000000,0,0.000000,my @subset = uniqstr @values
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.45.>
0.000000,0,0.000000,
0.000000,0,0.000000,Filters a list of values to remove subsequent duplicates, as judged by a
0.000000,0,0.000000,string equality test. Preserves the order of unique elements, and retains the
0.000000,0,0.000000,first value of any duplicate set.
0.000000,0,0.000000,
0.000000,0,0.000000,my $count = uniqstr @values
0.000000,0,0.000000,
0.000000,0,0.000000,In scalar context, returns the number of elements that would have been
0.000000,0,0.000000,returned as a list.
0.000000,0,0.000000,
0.000000,0,0.000000,Note that C<undef> is treated much as other string operations treat it; it
0.000000,0,0.000000,compares equal to the empty string but additionally produces a warning if such
0.000000,0,0.000000,warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
0.000000,0,0.000000,C<undef> in the returned list is coerced into an empty string, so that the
0.000000,0,0.000000,entire list of values returned by C<uniqstr> are well-behaved as strings.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 head
0.000000,0,0.000000,
0.000000,0,0.000000,my @values = head $size, @list;
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.50.>
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
0.000000,0,0.000000,all but the last C<$size> elements from C<@list>.
0.000000,0,0.000000,
0.000000,0,0.000000,@result = head 2, qw( foo bar baz );
0.000000,0,0.000000,# foo, bar
0.000000,0,0.000000,
0.000000,0,0.000000,@result = head -2, qw( foo bar baz );
0.000000,0,0.000000,# foo
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 tail
0.000000,0,0.000000,
0.000000,0,0.000000,my @values = tail $size, @list;
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.50.>
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
0.000000,0,0.000000,all but the first C<$size> elements from C<@list>.
0.000000,0,0.000000,
0.000000,0,0.000000,@result = tail 2, qw( foo bar baz );
0.000000,0,0.000000,# bar, baz
0.000000,0,0.000000,
0.000000,0,0.000000,@result = tail -2, qw( foo bar baz );
0.000000,0,0.000000,# baz
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 zip
0.000000,0,0.000000,
0.000000,0,0.000000,my @result = zip [1..3], ['a'..'c'];
0.000000,0,0.000000,# [1, 'a'], [2, 'b'], [3, 'c']
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.56.>
0.000000,0,0.000000,
0.000000,0,0.000000,Returns a list of array references, composed of elements from the given list
0.000000,0,0.000000,of array references. Each array in the returned list is composed of elements
0.000000,0,0.000000,at that corresponding position from each of the given input arrays. If any
0.000000,0,0.000000,input arrays run out of elements before others, then C<undef> will be inserted
0.000000,0,0.000000,into the result to fill in the gaps.
0.000000,0,0.000000,
0.000000,0,0.000000,The C<zip> function is particularly handy for iterating over multiple arrays
0.000000,0,0.000000,at the same time with a C<foreach> loop, taking one element from each:
0.000000,0,0.000000,
0.000000,0,0.000000,foreach ( zip \@xs, \@ys, \@zs ) {
0.000000,0,0.000000,my ($x, $y, $z) = @$_;
0.000000,0,0.000000,...
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,B<NOTE> to users of L<List::MoreUtils>: This function does not behave the same
0.000000,0,0.000000,as C<List::MoreUtils::zip>, but is actually a non-prototyped equivalent to
0.000000,0,0.000000,C<List::MoreUtils::zip_unflatten>. This function does not apply a prototype,
0.000000,0,0.000000,so make sure to invoke it with references to arrays.
0.000000,0,0.000000,
0.000000,0,0.000000,For a function similar to the C<zip> function from C<List::MoreUtils>, see
0.000000,0,0.000000,L<mesh>.
0.000000,0,0.000000,
0.000000,0,0.000000,my @result = zip_shortest ...
0.000000,0,0.000000,
0.000000,0,0.000000,A variation of the function that differs in how it behaves when given input
0.000000,0,0.000000,arrays of differing lengths. C<zip_shortest> will stop as soon as any one of
0.000000,0,0.000000,the input arrays run out of elements, discarding any remaining unused values
0.000000,0,0.000000,from the others.
0.000000,0,0.000000,
0.000000,0,0.000000,my @result = zip_longest ...
0.000000,0,0.000000,
0.000000,0,0.000000,C<zip_longest> is an alias to the C<zip> function, provided simply to be
0.000000,0,0.000000,explicit about that behaviour as compared to C<zip_shortest>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 mesh
0.000000,0,0.000000,
0.000000,0,0.000000,my @result = mesh [1..3], ['a'..'c'];
0.000000,0,0.000000,# (1, 'a', 2, 'b', 3, 'c')
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.56.>
0.000000,0,0.000000,
0.000000,0,0.000000,Returns a list of items collected from elements of the given list of array
0.000000,0,0.000000,references. Each section of items in the returned list is composed of elements
0.000000,0,0.000000,at the corresponding position from each of the given input arrays. If any
0.000000,0,0.000000,input arrays run out of elements before others, then C<undef> will be inserted
0.000000,0,0.000000,into the result to fill in the gaps.
0.000000,0,0.000000,
0.000000,0,0.000000,This is similar to L<zip>, except that all of the ranges in the result are
0.000000,0,0.000000,returned in one long flattened list, instead of being bundled into separate
0.000000,0,0.000000,arrays.
0.000000,0,0.000000,
0.000000,0,0.000000,Because it returns a flat list of items, the C<mesh> function is particularly
0.000000,0,0.000000,useful for building a hash out of two separate arrays of keys and values:
0.000000,0,0.000000,
0.000000,0,0.000000,my %hash = mesh \@keys, \@values;
0.000000,0,0.000000,
0.000000,0,0.000000,my $href = { mesh \@keys, \@values };
0.000000,0,0.000000,
0.000000,0,0.000000,B<NOTE> to users of L<List::MoreUtils>: This function is a non-prototyped
0.000000,0,0.000000,equivalent to C<List::MoreUtils::mesh> or C<List::MoreUtils::zip> (themselves
0.000000,0,0.000000,aliases of each other). This function does not apply a prototype, so make sure
0.000000,0,0.000000,to invoke it with references to arrays.
0.000000,0,0.000000,
0.000000,0,0.000000,my @result = mesh_shortest ...
0.000000,0,0.000000,
0.000000,0,0.000000,my @result = mesh_longest ...
0.000000,0,0.000000,
0.000000,0,0.000000,These variations are similar to those of L<zip>, in that they differ in
0.000000,0,0.000000,behaviour when one of the input lists runs out of elements before the others.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 CONFIGURATION VARIABLES
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 $RAND
0.000000,0,0.000000,
0.000000,0,0.000000,local $List::Util::RAND = sub { ... };
0.000000,0,0.000000,
0.000000,0,0.000000,I<Since version 1.54.>
0.000000,0,0.000000,
0.000000,0,0.000000,This package variable is used by code which needs to generate random numbers
0.000000,0,0.000000,(such as the L</shuffle> and L</sample> functions). If set to a CODE reference
0.000000,0,0.000000,it provides an alternative to perl's builtin C<rand()> function. When a new
0.000000,0,0.000000,random number is needed this function will be invoked with no arguments and is
0.000000,0,0.000000,expected to return a floating-point value, of which only the fractional part
0.000000,0,0.000000,will be used.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 KNOWN BUGS
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 RT #95409
0.000000,0,0.000000,
0.000000,0,0.000000,L<https://rt.cpan.org/Ticket/Display.html?id=95409>
0.000000,0,0.000000,
0.000000,0,0.000000,If the block of code given to L</pairmap> contains lexical variables that are
0.000000,0,0.000000,captured by a returned closure, and the closure is executed after the block
0.000000,0,0.000000,has been re-used for the next iteration, these lexicals will not see the
0.000000,0,0.000000,correct values. For example:
0.000000,0,0.000000,
0.000000,0,0.000000,my @subs = pairmap {
0.000000,0,0.000000,my $var = "$a is $b";
0.000000,0,0.000000,sub { print "$var\n" };
0.000000,0,0.000000,} one => 1, two => 2, three => 3;
0.000000,0,0.000000,
0.000000,0,0.000000,$_->() for @subs;
0.000000,0,0.000000,
0.000000,0,0.000000,Will incorrectly print
0.000000,0,0.000000,
0.000000,0,0.000000,three is 3
0.000000,0,0.000000,three is 3
0.000000,0,0.000000,three is 3
0.000000,0,0.000000,
0.000000,0,0.000000,This is due to the performance optimisation of using C<MULTICALL> for the code
0.000000,0,0.000000,block, which means that fresh SVs do not get allocated for each call to the
0.000000,0,0.000000,block. Instead, the same SV is re-assigned for each iteration, and all the
0.000000,0,0.000000,closures will share the value seen on the final iteration.
0.000000,0,0.000000,
0.000000,0,0.000000,To work around this bug, surround the code with a second set of braces. This
0.000000,0,0.000000,creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
0.000000,0,0.000000,SVs allocated each time:
0.000000,0,0.000000,
0.000000,0,0.000000,my @subs = pairmap {
0.000000,0,0.000000,{
0.000000,0,0.000000,my $var = "$a is $b";
0.000000,0,0.000000,sub { print "$var\n"; }
0.000000,0,0.000000,}
0.000000,0,0.000000,} one => 1, two => 2, three => 3;
0.000000,0,0.000000,
0.000000,0,0.000000,This bug only affects closures that are generated by the block but used
0.000000,0,0.000000,afterwards. Lexical variables that are only used during the lifetime of the
0.000000,0,0.000000,block's execution will take their individual values for each invocation, as
0.000000,0,0.000000,normal.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 uniqnum() on oversized bignums
0.000000,0,0.000000,
0.000000,0,0.000000,Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
0.000000,0,0.000000,differences between bignums (especially bigints) that are too large to fit in
0.000000,0,0.000000,the native platform types. For example,
0.000000,0,0.000000,
0.000000,0,0.000000,my $x = Math::BigInt->new( "1" x 100 );
0.000000,0,0.000000,my $y = $x + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,say for uniqnum( $x, $y );
0.000000,0,0.000000,
0.000000,0,0.000000,Will print just the value of C<$x>, believing that C<$y> is a numerically-
0.000000,0,0.000000,equivalent value. This bug does not affect C<uniqstr()>, which will correctly
0.000000,0,0.000000,observe that the two values stringify to different strings.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SUGGESTED ADDITIONS
0.000000,0,0.000000,
0.000000,0,0.000000,The following are additions that have been requested, but I have been reluctant
0.000000,0,0.000000,to add due to them being very simple to implement in perl
0.000000,0,0.000000,
0.000000,0,0.000000,# How many elements are true
0.000000,0,0.000000,
0.000000,0,0.000000,sub true { scalar grep { $_ } @_ }
0.000000,0,0.000000,
0.000000,0,0.000000,# How many elements are false
0.000000,0,0.000000,
0.000000,0,0.000000,sub false { scalar grep { !$_ } @_ }
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,L<Scalar::Util>, L<List::MoreUtils>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
0.000000,0,0.000000,This program is free software; you can redistribute it and/or
0.000000,0,0.000000,modify it under the same terms as Perl itself.
0.000000,0,0.000000,
0.000000,0,0.000000,Recent additions and current maintenance by
0.000000,0,0.000000,Paul Evans, <leonerd@leonerd.org.uk>.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000007,1,0.000007,1;
