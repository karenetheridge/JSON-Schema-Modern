# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Types::Standard;
0.000000,0,0.000000,
0.000155,2,0.000077,use 5.008001;
0.000047,2,0.000024,use strict;
0.000061,2,0.000030,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000146,2,0.000073,eval { require re };
0.000003,1,0.000003,if ( $] < 5.010 ) { require Devel::TypeTiny::Perl58Compat }
0.000029,1,0.000029,}
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000001,1,0.000001,$Types::Standard::AUTHORITY = 'cpan:TOBYINK';
0.000002,1,0.000002,$Types::Standard::VERSION   = '2.000001';
0.000026,1,0.000026,}
0.000000,0,0.000000,
0.000002,1,0.000002,$Types::Standard::VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000536,2,0.000268,use Type::Library -base;
0.000000,0,0.000000,
0.000002,1,0.000002,our @EXPORT_OK = qw( slurpy );
0.000000,0,0.000000,
0.000041,2,0.000020,use Eval::TypeTiny  qw( set_subname );
0.000024,2,0.000012,use Scalar::Util    qw( blessed looks_like_number );
0.000013,2,0.000006,use Type::Tiny      ();
0.000192,2,0.000096,use Types::TypeTiny ();
0.000000,0,0.000000,
0.000000,1,0.000000,my $is_class_loaded;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,$is_class_loaded = q{sub {
0.000000,0,0.000000,no strict 'refs';
0.000000,0,0.000000,return !!0 if ref $_[0];
0.000000,0,0.000000,return !!0 if not $_[0];
0.000000,0,0.000000,return !!0 if ref(do { my $tmpstr = $_[0]; \$tmpstr }) ne 'SCALAR';
0.000000,0,0.000000,my $stash = \%{"$_[0]\::"};
0.000000,0,0.000000,return !!1 if exists($stash->{'ISA'}) && *{$stash->{'ISA'}}{ARRAY} && @{$_[0].'::ISA'};
0.000000,0,0.000000,return !!1 if exists($stash->{'VERSION'});
0.000000,0,0.000000,foreach my $globref (values %$stash) {
0.000000,0,0.000000,return !!1
0.000000,0,0.000000,if ref \$globref eq 'GLOB'
0.000000,0,0.000000,? *{$globref}{CODE}
0.000000,0,0.000000,: ref $globref; # const or sub ref
0.000000,0,0.000000,}
0.000000,0,0.000000,return !!0;
0.000000,0,0.000000,}};
0.000000,0,0.000000,
0.003383,1,0.003383,*_is_class_loaded =
0.000000,0,0.000000,Type::Tiny::_USE_XS
0.000000,0,0.000000,? \&Type::Tiny::XS::Util::is_class_loaded
0.000000,0,0.000000,: eval $is_class_loaded;
0.000000,0,0.000000,
0.000000,0,0.000000,*_HAS_REFUTILXS = eval {
0.000001,1,0.000001,require Ref::Util::XS;
0.000023,1,0.000023,Ref::Util::XS::->VERSION( 0.100 );
0.000000,1,0.000000,1;
0.000000,0,0.000000,}
0.000000,0,0.000000,? sub () { !!1 }
0.000005,1,0.000005,: sub () { !!0 };
0.000679,1,0.000679,} #/ BEGIN
0.000000,0,0.000000,
0.000000,0,0.000000,my $add_core_type = sub {
0.000011,20,0.000001,my $meta = shift;
0.000005,20,0.000000,my ( $typedef ) = @_;
0.000000,0,0.000000,
0.000011,20,0.000001,my $name = $typedef->{name};
0.000002,20,0.000000,my ( $xsub, $xsubname );
0.000000,0,0.000000,
0.000000,0,0.000000,# We want Map and Tuple to be XSified, even if they're not
0.000000,0,0.000000,# really core.
0.000035,20,0.000002,$typedef->{_is_core} = 1
0.000000,0,0.000000,unless $name eq 'Map' || $name eq 'Tuple';
0.000000,0,0.000000,
0.000051,20,0.000003,if ( Type::Tiny::_USE_XS
0.000000,0,0.000000,and not( $name eq 'RegexpRef' ) )
0.000000,0,0.000000,{
0.000000,0,0.000000,$xsub     = Type::Tiny::XS::get_coderef_for( $name );
0.000000,0,0.000000,$xsubname = Type::Tiny::XS::get_subname_for( $name );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,elsif ( Type::Tiny::_USE_MOUSE
0.000000,0,0.000000,and not( $name eq 'RegexpRef' or $name eq 'Int' or $name eq 'Object' ) )
0.000000,0,0.000000,{
0.000000,0,0.000000,require Mouse::Util::TypeConstraints;
0.000000,0,0.000000,$xsub     = "Mouse::Util::TypeConstraints"->can( $name );
0.000000,0,0.000000,$xsubname = "Mouse::Util::TypeConstraints::$name" if $xsub;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( Type::Tiny::_USE_XS
0.000000,0,0.000000,and Type::Tiny::XS->VERSION < 0.014
0.000000,0,0.000000,and $name eq 'Bool' )
0.000000,0,0.000000,{
0.000000,0,0.000000,# Broken implementation of Bool
0.000000,0,0.000000,$xsub = $xsubname = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( Type::Tiny::_USE_XS
0.000000,0,0.000000,and ( Type::Tiny::XS->VERSION < 0.016 or $] < 5.018 )
0.000000,0,0.000000,and $name eq 'Int' )
0.000000,0,0.000000,{
0.000000,0,0.000000,# Broken implementation of Int
0.000000,0,0.000000,$xsub = $xsubname = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,20,0.000000,$typedef->{compiled_type_constraint} = $xsub if $xsub;
0.000000,0,0.000000,
0.000009,20,0.000000,my $orig_inlined = $typedef->{inlined};
0.000002,20,0.000000,if (
0.000000,0,0.000000,defined( $xsubname ) and (
0.000000,0,0.000000,
0.000000,0,0.000000,# These should be faster than their normal inlined
0.000000,0,0.000000,# equivalents
0.000000,0,0.000000,$name eq 'Str'
0.000000,0,0.000000,or $name eq 'Bool'
0.000000,0,0.000000,or $name eq 'ClassName'
0.000000,0,0.000000,or $name eq 'RegexpRef'
0.000000,0,0.000000,or $name eq 'FileHandle'
0.000000,0,0.000000,)
0.000000,0,0.000000,)
0.000000,0,0.000000,{
0.000000,0,0.000000,$typedef->{inlined} = sub {
0.000000,0,0.000000,$Type::Tiny::AvoidCallbacks ? goto( $orig_inlined ) : "$xsubname\($_[1])";
0.000000,0,0.000000,};
0.000000,0,0.000000,} #/ if ( defined( $xsubname...))
0.000000,0,0.000000,
0.000100,20,0.000005,$meta->add_type( $typedef );
0.000008,1,0.000008,};
0.000000,0,0.000000,
0.000000,0,0.000000,my $maybe_load_modules = sub {
0.000003,11,0.000000,my $code = pop;
0.000010,11,0.000001,if ( $Type::Tiny::AvoidCallbacks ) {
0.000000,0,0.000000,$code = sprintf(
0.000000,0,0.000000,'do { %s %s; %s }',
0.000000,0,0.000000,$Type::Tiny::SafePackage,
0.000000,0,0.000000,join( '; ', map "use $_ ()", @_ ),
0.000000,0,0.000000,$code,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000030,11,0.000003,$code;
0.000002,1,0.000002,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
0.000000,0,0.000000,
0.000010,1,0.000010,my $meta = __PACKAGE__->meta;
0.000000,0,0.000000,
0.000000,0,0.000000,# Stringable and LazyLoad are optimizations that complicate
0.000000,0,0.000000,# this module somewhat, but they have led to performance
0.000000,0,0.000000,# improvements. If Types::Standard wasn't such a key type
0.000000,0,0.000000,# library, I wouldn't use them. I strongly discourage anybody
0.000000,0,0.000000,# from using them in their own code. If you're looking for
0.000000,0,0.000000,# examples of how to write a type library sanely, you're
0.000000,0,0.000000,# better off looking at the code for Types::Common::Numeric
0.000000,0,0.000000,# and Types::Common::String.
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,
0.000000,1,0.000000,sub Stringable (&) {
0.000000,0,0.000000,bless +{ code => $_[0] }, 'Types::Standard::_Stringable';
0.000000,0,0.000000,}
0.000000,0,0.000000,Types::Standard::_Stringable->Type::Tiny::_install_overloads(
0.000005,1,0.000005,q[""] => sub { $_[0]{text} ||= $_[0]{code}->() } );
0.000000,0,0.000000,
0.000000,0,0.000000,sub LazyLoad ($$) {
0.000048,39,0.000001,bless \@_, 'Types::Standard::LazyLoad';
0.000000,0,0.000000,}
0.000000,0,0.000000,'Types::Standard::LazyLoad'->Type::Tiny::_install_overloads(
0.000000,0,0.000000,q[&{}] => sub {
0.000017,10,0.000002,my ( $typename, $function ) = @{ $_[0] };
0.000031,10,0.000003,my $type  = $meta->get_type( $typename );
0.000003,10,0.000000,my $class = "Types::Standard::$typename";
0.002832,10,0.000283,eval "require $class; 1" or die( $@ );
0.000000,0,0.000000,
0.000000,0,0.000000,# Majorly break encapsulation for Type::Tiny :-O
0.000070,10,0.000007,for my $key ( keys %$type ) {
0.000097,178,0.000001,next unless ref( $type->{$key} ) eq 'Types::Standard::LazyLoad';
0.000017,20,0.000001,my $f = $type->{$key}[1];
0.000126,20,0.000006,$type->{$key} = $class->can( "__$f" );
0.000000,0,0.000000,}
0.000008,10,0.000001,my $mm = $type->{my_methods} || {};
0.000010,10,0.000001,for my $key ( keys %$mm ) {
0.000008,14,0.000001,next unless ref( $mm->{$key} ) eq 'Types::Standard::LazyLoad';
0.000003,7,0.000000,my $f = $mm->{$key}[1];
0.000030,7,0.000004,$mm->{$key} = $class->can( "__$f" );
0.000000,0,0.000000,set_subname(
0.000000,0,0.000000,sprintf( "%s::my_%s", $type->qualified_name, $key ),
0.000031,7,0.000004,$mm->{$key},
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ for my $key ( keys %$mm)
0.000101,10,0.000010,return $class->can( "__$function" );
0.000000,0,0.000000,},
0.000004,1,0.000004,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000062,2,0.000031,no warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,*STRICTNUM =
0.000000,0,0.000000,$ENV{PERL_TYPES_STANDARD_STRICTNUM}
0.000000,0,0.000000,? sub() { !!1 }
0.000000,0,0.000000,: sub() { !!0 }
0.005612,1,0.005612,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $_any = $meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name            => "Any",
0.000000,0,0.000000,inlined         => sub { "!!1" },
0.000000,0,0.000000,complement_name => 'None',
0.000000,0,0.000000,type_default    => sub { return undef; },
0.000000,0,0.000000,}
0.000005,1,0.000005,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $_item = $meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name    => "Item",
0.000000,0,0.000000,inlined => sub { "!!1" },
0.000006,1,0.000006,parent  => $_any,
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $_bool = $meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "Bool",
0.000000,0,0.000000,parent     => $_item,
0.000000,0,0.000000,constraint => sub {
0.000000,0,0.000000,!ref $_ and ( !defined $_ or $_ eq q() or $_ eq '0' or $_ eq '1' );
0.000000,0,0.000000,},
0.000000,0,0.000000,inlined => sub {
0.000036,13,0.000003,"!ref $_[1] and (!defined $_[1] or $_[1] eq q() or $_[1] eq '0' or $_[1] eq '1')";
0.000000,0,0.000000,},
0.000000,0,0.000000,type_default => sub { return !!0; },
0.000000,0,0.000000,}
0.000011,1,0.000011,);
0.000000,0,0.000000,
0.000004,1,0.000004,$_bool->coercion->add_type_coercions( $_any, q{!!$_} );
0.000000,0,0.000000,
0.000000,0,0.000000,my $_undef = $meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "Undef",
0.000000,0,0.000000,parent     => $_item,
0.000000,0,0.000000,constraint => sub { !defined $_ },
0.000128,26,0.000005,inlined    => sub { "!defined($_[1])" },
0.000000,0,0.000000,type_default => sub { return undef; },
0.000000,0,0.000000,}
0.000010,1,0.000010,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $_def = $meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name               => "Defined",
0.000000,0,0.000000,parent             => $_item,
0.000000,0,0.000000,constraint         => sub { defined $_ },
0.000012,5,0.000002,inlined            => sub { "defined($_[1])" },
0.000013,1,0.000013,complementary_type => $_undef,
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# hackish, but eh
0.000005,1,0.000005,Scalar::Util::weaken( $_undef->{complementary_type} ||= $_def );
0.000000,0,0.000000,
0.000000,0,0.000000,my $_val = $meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "Value",
0.000000,0,0.000000,parent     => $_def,
0.000000,0,0.000000,constraint => sub { not ref $_ },
0.000011,4,0.000003,inlined    => sub { "defined($_[1]) and not ref($_[1])" },
0.000000,0,0.000000,}
0.000007,1,0.000007,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $_str = $meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "Str",
0.000000,0,0.000000,parent     => $_val,
0.000000,0,0.000000,constraint => sub {
0.000000,0,0.000000,ref( \$_ ) eq 'SCALAR' or ref( \( my $val = $_ ) ) eq 'SCALAR';
0.000000,0,0.000000,},
0.000000,0,0.000000,inlined    => sub {
0.000099,35,0.000003,"defined($_[1]) and do { ref(\\$_[1]) eq 'SCALAR' or ref(\\(my \$val = $_[1])) eq 'SCALAR' }";
0.000000,0,0.000000,},
0.000000,0,0.000000,sorter     => sub { $_[0] cmp $_[1] },
0.000000,0,0.000000,type_default => sub { return ''; },
0.000000,0,0.000000,}
0.000010,1,0.000010,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $_laxnum = $meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "LaxNum",
0.000000,0,0.000000,parent     => $_str,
0.000000,0,0.000000,constraint => sub { looks_like_number( $_ ) and ref( \$_ ) ne 'GLOB' },
0.000000,0,0.000000,inlined    => sub {
0.000042,3,0.000014,$maybe_load_modules->(
0.000000,0,0.000000,qw/ Scalar::Util /,
0.000000,0,0.000000,'Scalar::Util'->VERSION ge '1.18'    # RT 132426
0.000000,0,0.000000,? "defined($_[1]) && !ref($_[1]) && Scalar::Util::looks_like_number($_[1])"
0.000000,0,0.000000,: "defined($_[1]) && !ref($_[1]) && Scalar::Util::looks_like_number($_[1]) && ref(\\($_[1])) ne 'GLOB'"
0.000000,0,0.000000,);
0.000000,0,0.000000,},
0.000000,0,0.000000,sorter     => sub { $_[0] <=> $_[1] },
0.000000,0,0.000000,type_default => sub { return 0; },
0.000000,0,0.000000,}
0.000009,1,0.000009,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $_strictnum = $meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "StrictNum",
0.000000,0,0.000000,parent     => $_str,
0.000000,0,0.000000,constraint => sub {
0.000000,0,0.000000,my $val = $_;
0.000000,0,0.000000,( $val =~ /\A[+-]?[0-9]+\z/ )
0.000000,0,0.000000,|| (
0.000000,0,0.000000,$val =~ /\A(?:[+-]?)                #matches optional +- in the beginning
0.000000,0,0.000000,(?=[0-9]|\.[0-9])                #matches previous +- only if there is something like 3 or .3
0.000000,0,0.000000,[0-9]*                           #matches 0-9 zero or more times
0.000000,0,0.000000,(?:\.[0-9]+)?                    #matches optional .89 or nothing
0.000000,0,0.000000,(?:[Ee](?:[+-]?[0-9]+))?         #matches E1 or e1 or e-1 or e+1 etc
0.000000,0,0.000000,\z/x
0.000000,0,0.000000,);
0.000000,0,0.000000,},
0.000000,0,0.000000,inlined    => sub {
0.000008,2,0.000004,'my $val = '
0.000000,0,0.000000,. $_[1] . ';'
0.000000,0,0.000000,. Value()->inline_check( '$val' )
0.000000,0,0.000000,. ' && ( $val =~ /\A[+-]?[0-9]+\z/ || '
0.000000,0,0.000000,. '$val =~ /\A(?:[+-]?)              # matches optional +- in the beginning
0.000000,0,0.000000,(?=[0-9]|\.[0-9])                 # matches previous +- only if there is something like 3 or .3
0.000000,0,0.000000,[0-9]*                            # matches 0-9 zero or more times
0.000000,0,0.000000,(?:\.[0-9]+)?                     # matches optional .89 or nothing
0.000000,0,0.000000,(?:[Ee](?:[+-]?[0-9]+))?          # matches E1 or e1 or e-1 or e+1 etc
0.000000,0,0.000000,\z/x ); '
0.000000,0,0.000000,},
0.000000,0,0.000000,sorter     => sub { $_[0] <=> $_[1] },
0.000000,0,0.000000,type_default => sub { return 0; },
0.000000,0,0.000000,}
0.000007,1,0.000007,);
0.000000,0,0.000000,
0.000003,1,0.000003,my $_num = $meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name   => "Num",
0.000000,0,0.000000,parent => ( STRICTNUM ? $_strictnum : $_laxnum ),
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "Int",
0.000000,0,0.000000,parent     => $_num,
0.000000,0,0.000000,constraint => sub { /\A-?[0-9]+\z/ },
0.000000,0,0.000000,inlined    => sub {
0.000013,4,0.000003,"do { my \$tmp = $_[1]; defined(\$tmp) and !ref(\$tmp) and \$tmp =~ /\\A-?[0-9]+\\z/ }";
0.000000,0,0.000000,},
0.000000,0,0.000000,type_default => sub { return 0; },
0.000000,0,0.000000,}
0.000008,1,0.000008,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $_classn = $meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "ClassName",
0.000000,0,0.000000,parent     => $_str,
0.000000,0,0.000000,constraint => \&_is_class_loaded,
0.000000,0,0.000000,inlined    => sub {
0.000099,23,0.000004,$Type::Tiny::AvoidCallbacks
0.000000,0,0.000000,? "($is_class_loaded)->(do { my \$tmp = $_[1] })"
0.000000,0,0.000000,: "Types::Standard::_is_class_loaded(do { my \$tmp = $_[1] })";
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000008,1,0.000008,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "RoleName",
0.000000,0,0.000000,parent     => $_classn,
0.000000,0,0.000000,constraint => sub { not $_->can( "new" ) },
0.000000,0,0.000000,inlined    => sub {
0.000007,2,0.000003,$Type::Tiny::AvoidCallbacks
0.000000,0,0.000000,? "($is_class_loaded)->(do { my \$tmp = $_[1] }) and not $_[1]\->can('new')"
0.000000,0,0.000000,: "Types::Standard::_is_class_loaded(do { my \$tmp = $_[1] }) and not $_[1]\->can('new')";
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000005,1,0.000005,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $_ref = $meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name                 => "Ref",
0.000000,0,0.000000,parent               => $_def,
0.000000,0,0.000000,constraint           => sub { ref $_ },
0.000019,7,0.000003,inlined              => sub { "!!ref($_[1])" },
0.000000,0,0.000000,constraint_generator => sub {
0.000000,0,0.000000,return $meta->get_type( 'Ref' ) unless @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $reftype = shift;
0.000000,0,0.000000,$reftype =~
0.000000,0,0.000000,/^(SCALAR|ARRAY|HASH|CODE|REF|GLOB|LVALUE|FORMAT|IO|VSTRING|REGEXP|Regexp)$/i
0.000000,0,0.000000,or _croak(
0.000000,0,0.000000,"Parameter to Ref[`a] expected to be a Perl ref type; got $reftype" );
0.000000,0,0.000000,
0.000000,0,0.000000,$reftype = "$reftype";
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,ref( $_[0] ) and Scalar::Util::reftype( $_[0] ) eq $reftype;
0.000000,0,0.000000,}
0.000000,0,0.000000,},
0.000000,0,0.000000,inline_generator => sub {
0.000000,0,0.000000,my $reftype = shift;
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,my $v = $_[1];
0.000000,0,0.000000,$maybe_load_modules->(
0.000000,0,0.000000,qw/ Scalar::Util /,
0.000000,0,0.000000,"ref($v) and Scalar::Util::reftype($v) eq q($reftype)"
0.000000,0,0.000000,);
0.000000,0,0.000000,};
0.000000,0,0.000000,},
0.000000,0,0.000000,deep_explanation => sub {
0.000000,0,0.000000,require B;
0.000000,0,0.000000,my ( $type, $value, $varname ) = @_;
0.000000,0,0.000000,my $param = $type->parameters->[0];
0.000000,0,0.000000,return if $type->check( $value );
0.000000,0,0.000000,my $reftype = Scalar::Util::reftype( $value );
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'"%s" constrains reftype(%s) to be equal to %s', $type, $varname,
0.000000,0,0.000000,B::perlstring( $param )
0.000000,0,0.000000,),
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'reftype(%s) is %s', $varname,
0.000000,0,0.000000,defined( $reftype ) ? B::perlstring( $reftype ) : "undef"
0.000000,0,0.000000,),
0.000000,0,0.000000,];
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000012,1,0.000012,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "CodeRef",
0.000000,0,0.000000,parent     => $_ref,
0.000000,0,0.000000,constraint => sub { ref $_ eq "CODE" },
0.000000,0,0.000000,inlined    => sub {
0.000118,76,0.000002,_HAS_REFUTILXS && !$Type::Tiny::AvoidCallbacks
0.000000,0,0.000000,? "Ref::Util::XS::is_plain_coderef($_[1])"
0.000000,0,0.000000,: "ref($_[1]) eq 'CODE'";
0.000000,0,0.000000,},
0.000000,0,0.000000,type_default => sub { return sub {}; },
0.000000,0,0.000000,}
0.000008,1,0.000008,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $_regexp = $meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "RegexpRef",
0.000000,0,0.000000,parent     => $_ref,
0.000000,0,0.000000,constraint => sub {
0.000000,0,0.000000,ref( $_ ) && !!re::is_regexp( $_ ) or blessed( $_ ) && $_->isa( 'Regexp' );
0.000000,0,0.000000,},
0.000000,0,0.000000,inlined    => sub {
0.000000,2,0.000000,my $v = $_[1];
0.000006,2,0.000003,$maybe_load_modules->(
0.000000,0,0.000000,qw/ Scalar::Util re /,
0.000000,0,0.000000,"ref($v) && !!re::is_regexp($v) or Scalar::Util::blessed($v) && $v\->isa('Regexp')"
0.000000,0,0.000000,);
0.000000,0,0.000000,},
0.000000,0,0.000000,type_default => sub { return qr//; },
0.000000,0,0.000000,}
0.000007,1,0.000007,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "GlobRef",
0.000000,0,0.000000,parent     => $_ref,
0.000000,0,0.000000,constraint => sub { ref $_ eq "GLOB" },
0.000000,0,0.000000,inlined    => sub {
0.000004,2,0.000002,_HAS_REFUTILXS && !$Type::Tiny::AvoidCallbacks
0.000000,0,0.000000,? "Ref::Util::XS::is_plain_globref($_[1])"
0.000000,0,0.000000,: "ref($_[1]) eq 'GLOB'";
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000005,1,0.000005,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "FileHandle",
0.000000,0,0.000000,parent     => $_ref,
0.000000,0,0.000000,constraint => sub {
0.000000,0,0.000000,( ref( $_ ) && Scalar::Util::openhandle( $_ ) )
0.000000,0,0.000000,or ( blessed( $_ ) && $_->isa( "IO::Handle" ) );
0.000000,0,0.000000,},
0.000000,0,0.000000,inlined => sub {
0.000006,2,0.000003,$maybe_load_modules->(
0.000000,0,0.000000,qw/ Scalar::Util /,
0.000000,0,0.000000,"(ref($_[1]) && Scalar::Util::openhandle($_[1])) "
0.000000,0,0.000000,. "or (Scalar::Util::blessed($_[1]) && $_[1]\->isa(\"IO::Handle\"))"
0.000000,0,0.000000,);
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000005,1,0.000005,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $_arr = $meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "ArrayRef",
0.000000,0,0.000000,parent     => $_ref,
0.000000,0,0.000000,constraint => sub { ref $_ eq "ARRAY" },
0.000000,0,0.000000,inlined    => sub {
0.000103,38,0.000003,_HAS_REFUTILXS && !$Type::Tiny::AvoidCallbacks
0.000000,0,0.000000,? "Ref::Util::XS::is_plain_arrayref($_[1])"
0.000000,0,0.000000,: "ref($_[1]) eq 'ARRAY'";
0.000000,0,0.000000,},
0.000000,0,0.000000,constraint_generator => LazyLoad( ArrayRef => 'constraint_generator' ),
0.000000,0,0.000000,inline_generator     => LazyLoad( ArrayRef => 'inline_generator' ),
0.000000,0,0.000000,deep_explanation     => LazyLoad( ArrayRef => 'deep_explanation' ),
0.000000,0,0.000000,coercion_generator   => LazyLoad( ArrayRef => 'coercion_generator' ),
0.000000,0,0.000000,type_default         => sub { return []; },
0.000000,0,0.000000,type_default_generator => sub {
0.000017,4,0.000004,return $Type::Tiny::parameterize_type->type_default if @_ < 2;
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000014,1,0.000014,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $_hash = $meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "HashRef",
0.000000,0,0.000000,parent     => $_ref,
0.000000,0,0.000000,constraint => sub { ref $_ eq "HASH" },
0.000000,0,0.000000,inlined    => sub {
0.000241,81,0.000003,_HAS_REFUTILXS && !$Type::Tiny::AvoidCallbacks
0.000000,0,0.000000,? "Ref::Util::XS::is_plain_hashref($_[1])"
0.000000,0,0.000000,: "ref($_[1]) eq 'HASH'";
0.000000,0,0.000000,},
0.000000,0,0.000000,constraint_generator => LazyLoad( HashRef => 'constraint_generator' ),
0.000000,0,0.000000,inline_generator     => LazyLoad( HashRef => 'inline_generator' ),
0.000000,0,0.000000,deep_explanation     => LazyLoad( HashRef => 'deep_explanation' ),
0.000000,0,0.000000,coercion_generator   => LazyLoad( HashRef => 'coercion_generator' ),
0.000000,0,0.000000,type_default         => sub { return {}; },
0.000000,0,0.000000,type_default_generator => sub {
0.000033,8,0.000004,return $Type::Tiny::parameterize_type->type_default if @_ < 2;
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,},
0.000016,1,0.000016,my_methods           => {
0.000000,0,0.000000,hashref_allows_key   => LazyLoad( HashRef => 'hashref_allows_key' ),
0.000000,0,0.000000,hashref_allows_value => LazyLoad( HashRef => 'hashref_allows_value' ),
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name                 => "ScalarRef",
0.000000,0,0.000000,parent               => $_ref,
0.000000,0,0.000000,constraint           => sub { ref $_ eq "SCALAR" or ref $_ eq "REF" },
0.000006,2,0.000003,inlined              => sub { "ref($_[1]) eq 'SCALAR' or ref($_[1]) eq 'REF'" },
0.000000,0,0.000000,constraint_generator => LazyLoad( ScalarRef => 'constraint_generator' ),
0.000000,0,0.000000,inline_generator     => LazyLoad( ScalarRef => 'inline_generator' ),
0.000000,0,0.000000,deep_explanation     => LazyLoad( ScalarRef => 'deep_explanation' ),
0.000000,0,0.000000,coercion_generator   => LazyLoad( ScalarRef => 'coercion_generator' ),
0.000000,0,0.000000,type_default         => sub { my $x; return \$x; },
0.000000,0,0.000000,}
0.000010,1,0.000010,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $_obj = $meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "Object",
0.000000,0,0.000000,parent     => $_ref,
0.000000,0,0.000000,constraint => sub { blessed $_ },
0.000000,0,0.000000,inlined    => sub {
0.000011,5,0.000002,_HAS_REFUTILXS && !$Type::Tiny::AvoidCallbacks
0.000000,0,0.000000,? "Ref::Util::XS::is_blessed_ref($_[1])"
0.000000,0,0.000000,: $maybe_load_modules->(
0.000000,0,0.000000,'Scalar::Util',
0.000000,0,0.000000,"Scalar::Util::blessed($_[1])"
0.000000,0,0.000000,);
0.000000,0,0.000000,},
0.000009,1,0.000009,is_object => 1,
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name                 => "Maybe",
0.000000,0,0.000000,parent               => $_item,
0.000000,0,0.000000,constraint_generator => sub {
0.000000,0,0.000000,return $meta->get_type( 'Maybe' ) unless @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $param = Types::TypeTiny::to_TypeTiny( shift );
0.000000,0,0.000000,Types::TypeTiny::is_TypeTiny( $param )
0.000000,0,0.000000,or _croak(
0.000000,0,0.000000,"Parameter to Maybe[`a] expected to be a type constraint; got $param" );
0.000000,0,0.000000,
0.000000,0,0.000000,my $param_compiled_check = $param->compiled_check;
0.000000,0,0.000000,my @xsub;
0.000000,0,0.000000,if ( Type::Tiny::_USE_XS ) {
0.000000,0,0.000000,my $paramname = Type::Tiny::XS::is_known( $param_compiled_check );
0.000000,0,0.000000,push @xsub, Type::Tiny::XS::get_coderef_for( "Maybe[$paramname]" )
0.000000,0,0.000000,if $paramname;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( Type::Tiny::_USE_MOUSE and $param->_has_xsub ) {
0.000000,0,0.000000,require Mouse::Util::TypeConstraints;
0.000000,0,0.000000,my $maker = "Mouse::Util::TypeConstraints"->can( "_parameterize_Maybe_for" );
0.000000,0,0.000000,push @xsub, $maker->( $param ) if $maker;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.000000,0,0.000000,sub {
0.000000,0,0.000000,my $value = shift;
0.000000,0,0.000000,return !!1 unless defined $value;
0.000000,0,0.000000,return $param->check( $value );
0.000000,0,0.000000,},
0.000000,0,0.000000,@xsub,
0.000000,0,0.000000,);
0.000000,0,0.000000,},
0.000000,0,0.000000,inline_generator => sub {
0.000000,0,0.000000,my $param = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $param_compiled_check = $param->compiled_check;
0.000000,0,0.000000,my $xsubname;
0.000000,0,0.000000,if ( Type::Tiny::_USE_XS ) {
0.000000,0,0.000000,my $paramname = Type::Tiny::XS::is_known( $param_compiled_check );
0.000000,0,0.000000,$xsubname = Type::Tiny::XS::get_subname_for( "Maybe[$paramname]" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return unless $param->can_be_inlined;
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,my $v = $_[1];
0.000000,0,0.000000,return "$xsubname\($v\)" if $xsubname && !$Type::Tiny::AvoidCallbacks;
0.000000,0,0.000000,my $param_check = $param->inline_check( $v );
0.000000,0,0.000000,"!defined($v) or $param_check";
0.000000,0,0.000000,};
0.000000,0,0.000000,},
0.000000,0,0.000000,deep_explanation => sub {
0.000000,0,0.000000,my ( $type, $value, $varname ) = @_;
0.000000,0,0.000000,my $param = $type->parameters->[0];
0.000000,0,0.000000,
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf( '%s is defined', Type::Tiny::_dd( $value ) ),
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'"%s" constrains the value with "%s" if it is defined', $type, $param
0.000000,0,0.000000,),
0.000000,0,0.000000,@{ $param->validate_explain( $value, $varname ) },
0.000000,0,0.000000,];
0.000000,0,0.000000,},
0.000000,0,0.000000,coercion_generator => sub {
0.000000,0,0.000000,my ( $parent, $child, $param ) = @_;
0.000000,0,0.000000,return unless $param->has_coercion;
0.000000,0,0.000000,return $param->coercion;
0.000000,0,0.000000,},
0.000000,0,0.000000,type_default       => sub { return undef; },
0.000000,0,0.000000,type_default_generator => sub {
0.000000,0,0.000000,$_[0]->type_default || $Type::Tiny::parameterize_type->type_default ;
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000013,1,0.000013,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $_map = $meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name                 => "Map",
0.000000,0,0.000000,parent               => $_hash,
0.000000,0,0.000000,constraint_generator => LazyLoad( Map => 'constraint_generator' ),
0.000000,0,0.000000,inline_generator     => LazyLoad( Map => 'inline_generator' ),
0.000000,0,0.000000,deep_explanation     => LazyLoad( Map => 'deep_explanation' ),
0.000000,0,0.000000,coercion_generator   => LazyLoad( Map => 'coercion_generator' ),
0.000000,0,0.000000,my_methods           => {
0.000000,0,0.000000,hashref_allows_key   => LazyLoad( Map => 'hashref_allows_key' ),
0.000000,0,0.000000,hashref_allows_value => LazyLoad( Map => 'hashref_allows_value' ),
0.000000,0,0.000000,},
0.000000,0,0.000000,type_default_generator => sub {
0.000005,1,0.000005,return $Type::Tiny::parameterize_type->type_default;
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000010,1,0.000010,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $_Optional = $meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name                 => "Optional",
0.000000,0,0.000000,parent               => $_item,
0.000000,0,0.000000,constraint_generator => sub {
0.000001,1,0.000001,return $meta->get_type( 'Optional' ) unless @_;
0.000000,0,0.000000,
0.000002,1,0.000002,my $param = Types::TypeTiny::to_TypeTiny( shift );
0.000001,1,0.000001,Types::TypeTiny::is_TypeTiny( $param )
0.000000,0,0.000000,or _croak(
0.000000,0,0.000000,"Parameter to Optional[`a] expected to be a type constraint; got $param" );
0.000000,0,0.000000,
0.000000,0,0.000000,sub { $param->check( $_[0] ) }
0.000006,1,0.000006,},
0.000000,0,0.000000,inline_generator => sub {
0.000000,1,0.000000,my $param = shift;
0.000002,1,0.000002,return unless $param->can_be_inlined;
0.000000,0,0.000000,return sub {
0.000008,57,0.000000,my $v = $_[1];
0.000095,57,0.000002,$param->inline_check( $v );
0.000005,1,0.000005,};
0.000000,0,0.000000,},
0.000000,0,0.000000,deep_explanation => sub {
0.000000,0,0.000000,my ( $type, $value, $varname ) = @_;
0.000000,0,0.000000,my $param = $type->parameters->[0];
0.000000,0,0.000000,
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf( '%s exists', $varname ),
0.000000,0,0.000000,sprintf( '"%s" constrains %s with "%s" if it exists', $type, $varname, $param ),
0.000000,0,0.000000,@{ $param->validate_explain( $value, $varname ) },
0.000000,0,0.000000,];
0.000000,0,0.000000,},
0.000000,0,0.000000,coercion_generator => sub {
0.000000,0,0.000000,my ( $parent, $child, $param ) = @_;
0.000000,0,0.000000,return unless $param->has_coercion;
0.000000,0,0.000000,return $param->coercion;
0.000000,0,0.000000,},
0.000000,0,0.000000,type_default_generator => sub {
0.000008,1,0.000008,return $_[0]->type_default;
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000009,1,0.000009,);
0.000000,0,0.000000,
0.000001,1,0.000001,my $_slurpy;
0.000000,0,0.000000,$_slurpy = $meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name                 => "Slurpy",
0.000000,0,0.000000,slurpy               => 1,
0.000000,0,0.000000,parent               => $_item,
0.000000,0,0.000000,constraint_generator => sub {
0.000001,2,0.000000,my $self  = $_slurpy;
0.000002,2,0.000001,my $param = @_ ? Types::TypeTiny::to_TypeTiny(shift) : $_any;
0.000001,2,0.000000,Types::TypeTiny::is_TypeTiny( $param )
0.000000,0,0.000000,or _croak(
0.000000,0,0.000000,"Parameter to Slurpy[`a] expected to be a type constraint; got $param" );
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->create_child_type(
0.000000,0,0.000000,slurpy          => 1,
0.000000,0,0.000000,display_name    => $self->name_generator->( $self, $param ),
0.000000,0,0.000000,parameters      => [ $param ],
0.000000,0,0.000000,constraint      => sub { $param->check( $_[0] ) },
0.000000,0,0.000000,type_default    => $param->type_default,
0.000000,0,0.000000,_build_coercion => sub {
0.000001,2,0.000000,my $coercion = shift;
0.000004,2,0.000002,$coercion->add_type_coercions( @{ $param->coercion->type_coercion_map } )
0.000000,0,0.000000,if $param->has_coercion;
0.000005,2,0.000002,$coercion->freeze;
0.000000,0,0.000000,},
0.000000,0,0.000000,$param->can_be_inlined
0.000006,2,0.000003,? ( inlined => sub { $param->inline_check( $_[1] ) } )
0.000035,2,0.000018,: (),
0.000000,0,0.000000,);
0.000000,0,0.000000,},
0.000000,0,0.000000,deep_explanation => sub {
0.000000,0,0.000000,my ( $type, $value, $varname ) = @_;
0.000000,0,0.000000,my $param = $type->parameters->[0];
0.000000,0,0.000000,return [
0.000000,0,0.000000,sprintf( '%s is slurpy', $varname ),
0.000000,0,0.000000,@{ $param->validate_explain( $value, $varname ) },
0.000000,0,0.000000,];
0.000000,0,0.000000,},
0.000000,0,0.000000,my_methods => {
0.000000,0,0.000000,'unslurpy' => sub {
0.000001,6,0.000000,my $self  = shift;
0.000000,0,0.000000,$self->{_my_unslurpy} ||= $self->find_parent(
0.000006,2,0.000003,sub { $_->parent->{uniq} == $_slurpy->{uniq} }
0.000036,6,0.000006,)->type_parameter;
0.000000,0,0.000000,},
0.000000,0,0.000000,'slurp_into' => sub {
0.000000,0,0.000000,my $self  = shift;
0.000000,0,0.000000,my $parameters = $self->find_parent(
0.000000,0,0.000000,sub { $_->parent->{uniq} == $_slurpy->{uniq} }
0.000000,0,0.000000,)->parameters;
0.000000,0,0.000000,if ( $parameters->[1] ) {
0.000000,0,0.000000,return $parameters->[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,my $constraint = $parameters->[0];
0.000000,0,0.000000,return 'HASH'
0.000000,0,0.000000,if $constraint->is_a_type_of( HashRef() )
0.000000,0,0.000000,or $constraint->is_a_type_of( Map() )
0.000000,0,0.000000,or $constraint->is_a_type_of( Dict() );
0.000000,0,0.000000,return 'ARRAY';
0.000000,0,0.000000,},
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000011,1,0.000011,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub slurpy {
0.000000,0,0.000000,my $t = shift;
0.000000,0,0.000000,my $s = $_slurpy->of( $t );
0.000000,0,0.000000,$s->{slurpy} ||= 1;
0.000000,0,0.000000,wantarray ? ( $s, @_ ) : $s;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->$add_core_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name           => "Tuple",
0.000000,0,0.000000,parent         => $_arr,
0.000000,0,0.000000,name_generator => sub {
0.000002,2,0.000001,my ( $s, @a ) = @_;
0.000015,2,0.000007,sprintf( '%s[%s]', $s, join q[,], @a );
0.000000,0,0.000000,},
0.000007,1,0.000007,constraint_generator => LazyLoad( Tuple => 'constraint_generator' ),
0.000000,0,0.000000,inline_generator     => LazyLoad( Tuple => 'inline_generator' ),
0.000000,0,0.000000,deep_explanation     => LazyLoad( Tuple => 'deep_explanation' ),
0.000000,0,0.000000,coercion_generator   => LazyLoad( Tuple => 'coercion_generator' ),
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name           => "CycleTuple",
0.000000,0,0.000000,parent         => $_arr,
0.000000,0,0.000000,name_generator => sub {
0.000000,0,0.000000,my ( $s, @a ) = @_;
0.000000,0,0.000000,sprintf( '%s[%s]', $s, join q[,], @a );
0.000000,0,0.000000,},
0.000008,1,0.000008,constraint_generator => LazyLoad( CycleTuple => 'constraint_generator' ),
0.000000,0,0.000000,inline_generator     => LazyLoad( CycleTuple => 'inline_generator' ),
0.000000,0,0.000000,deep_explanation     => LazyLoad( CycleTuple => 'deep_explanation' ),
0.000000,0,0.000000,coercion_generator   => LazyLoad( CycleTuple => 'coercion_generator' ),
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name           => "Dict",
0.000000,0,0.000000,parent         => $_hash,
0.000000,0,0.000000,name_generator => sub {
0.000014,4,0.000004,my ( $s, @p ) = @_;
0.000022,4,0.000006,my $l = @p
0.000000,0,0.000000,&& Types::TypeTiny::is_TypeTiny( $p[-1] )
0.000000,0,0.000000,&& $p[-1]->is_strictly_a_type_of( Types::Standard::Slurpy() )
0.000000,0,0.000000,? pop(@p)
0.000000,0,0.000000,: undef;
0.000017,4,0.000004,my %a = @p;
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'%s[%s%s]', $s,
0.000216,4,0.000054,join( q[,], map sprintf( "%s=>%s", $_, $a{$_} ), sort keys %a ),
0.000000,0,0.000000,$l ? ",$l" : ''
0.000000,0,0.000000,);
0.000000,0,0.000000,},
0.000007,1,0.000007,constraint_generator => LazyLoad( Dict => 'constraint_generator' ),
0.000000,0,0.000000,inline_generator     => LazyLoad( Dict => 'inline_generator' ),
0.000000,0,0.000000,deep_explanation     => LazyLoad( Dict => 'deep_explanation' ),
0.000000,0,0.000000,coercion_generator   => LazyLoad( Dict => 'coercion_generator' ),
0.000000,0,0.000000,my_methods           => {
0.000000,0,0.000000,dict_is_slurpy       => LazyLoad( Dict => 'dict_is_slurpy' ),
0.000000,0,0.000000,hashref_allows_key   => LazyLoad( Dict => 'hashref_allows_key' ),
0.000000,0,0.000000,hashref_allows_value => LazyLoad( Dict => 'hashref_allows_value' ),
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "Overload",
0.000000,0,0.000000,parent     => $_obj,
0.000000,0,0.000000,constraint => sub { require overload; overload::Overloaded( $_ ) },
0.000000,0,0.000000,inlined    => sub {
0.000000,0,0.000000,$maybe_load_modules->(
0.000000,0,0.000000,qw/ Scalar::Util overload /,
0.000014,2,0.000007,$INC{'overload.pm'}
0.000000,0,0.000000,? "Scalar::Util::blessed($_[1]) and overload::Overloaded($_[1])"
0.000000,0,0.000000,: "Scalar::Util::blessed($_[1]) and do { use overload (); overload::Overloaded($_[1]) }"
0.000000,0,0.000000,);
0.000000,0,0.000000,},
0.000000,0,0.000000,constraint_generator => sub {
0.000000,0,0.000000,return $meta->get_type( 'Overload' ) unless @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @operations = map {
0.000000,0,0.000000,Types::TypeTiny::is_StringLike( $_ )
0.000000,0,0.000000,? "$_"
0.000000,0,0.000000,: _croak( "Parameters to Overload[`a] expected to be a strings; got $_" );
0.000000,0,0.000000,} @_;
0.000000,0,0.000000,
0.000000,0,0.000000,require overload;
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,my $value = shift;
0.000000,0,0.000000,for my $op ( @operations ) {
0.000000,0,0.000000,return unless overload::Method( $value, $op );
0.000000,0,0.000000,}
0.000000,0,0.000000,return !!1;
0.000000,0,0.000000,}
0.000000,0,0.000000,},
0.000000,0,0.000000,inline_generator => sub {
0.000000,0,0.000000,my @operations = @_;
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,require overload;
0.000000,0,0.000000,my $v = $_[1];
0.000000,0,0.000000,$maybe_load_modules->(
0.000000,0,0.000000,qw/ Scalar::Util overload /,
0.000000,0,0.000000,join " and ",
0.000000,0,0.000000,"Scalar::Util::blessed($v)",
0.000000,0,0.000000,map "overload::Method($v, q[$_])", @operations
0.000000,0,0.000000,);
0.000000,0,0.000000,};
0.000000,0,0.000000,},
0.000008,1,0.000008,is_object => 1,
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000004,1,0.000004,$meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name                 => "StrMatch",
0.000000,0,0.000000,parent               => $_str,
0.000000,0,0.000000,constraint_generator => LazyLoad( StrMatch => 'constraint_generator' ),
0.000000,0,0.000000,inline_generator     => LazyLoad( StrMatch => 'inline_generator' ),
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "OptList",
0.000000,0,0.000000,parent     => $_arr,
0.000000,0,0.000000,constraint => sub {
0.000000,0,0.000000,for my $inner ( @$_ ) {
0.000000,0,0.000000,return unless ref( $inner ) eq q(ARRAY);
0.000000,0,0.000000,return unless @$inner == 2;
0.000000,0,0.000000,return unless is_Str( $inner->[0] );
0.000000,0,0.000000,}
0.000000,0,0.000000,return !!1;
0.000000,0,0.000000,},
0.000000,0,0.000000,inlined => sub {
0.000002,2,0.000001,my ( $self, $var ) = @_;
0.000064,2,0.000032,my $Str_check = Str()->inline_check( '$inner->[0]' );
0.000002,2,0.000001,my @code      = 'do { my $ok = 1; ';
0.000002,2,0.000001,push @code, sprintf( 'for my $inner (@{%s}) { no warnings; ', $var );
0.000001,2,0.000000,push @code,
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'($ok=0) && last unless ref($inner) eq q(ARRAY) && @$inner == 2 && (%s); ',
0.000000,0,0.000000,$Str_check
0.000000,0,0.000000,);
0.000001,2,0.000000,push @code, '} ';
0.000001,2,0.000000,push @code, '$ok }';
0.000019,2,0.000010,return ( undef, join( q( ), @code ) );
0.000000,0,0.000000,},
0.000000,0,0.000000,type_default => sub { return [] },
0.000000,0,0.000000,}
0.000007,1,0.000007,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name       => "Tied",
0.000000,0,0.000000,parent     => $_ref,
0.000000,0,0.000000,constraint => sub {
0.000000,0,0.000000,!!tied(
0.000000,0,0.000000,Scalar::Util::reftype( $_ ) eq 'HASH'             ? %{$_}
0.000000,0,0.000000,: Scalar::Util::reftype( $_ ) eq 'ARRAY'          ? @{$_}
0.000000,0,0.000000,: Scalar::Util::reftype( $_ ) =~ /^(SCALAR|REF)$/ ? ${$_}
0.000000,0,0.000000,:                                                   undef
0.000000,0,0.000000,);
0.000000,0,0.000000,},
0.000000,0,0.000000,inlined => sub {
0.000000,2,0.000000,my ( $self, $var ) = @_;
0.000011,2,0.000005,$maybe_load_modules->(
0.000000,0,0.000000,qw/ Scalar::Util /,
0.000000,0,0.000000,$self->parent->inline_check( $var )
0.000000,0,0.000000,. " and !!tied(Scalar::Util::reftype($var) eq 'HASH' ? \%{$var} : Scalar::Util::reftype($var) eq 'ARRAY' ? \@{$var} : Scalar::Util::reftype($var) =~ /^(SCALAR|REF)\$/ ? \${$var} : undef)"
0.000000,0,0.000000,);
0.000000,0,0.000000,},
0.000000,0,0.000000,name_generator => sub {
0.000000,0,0.000000,my $self  = shift;
0.000000,0,0.000000,my $param = Types::TypeTiny::to_TypeTiny( shift );
0.000000,0,0.000000,unless ( Types::TypeTiny::is_TypeTiny( $param ) ) {
0.000000,0,0.000000,Types::TypeTiny::is_StringLike( $param )
0.000000,0,0.000000,or _croak( "Parameter to Tied[`a] expected to be a class name; got $param" );
0.000000,0,0.000000,require B;
0.000000,0,0.000000,return sprintf( "%s[%s]", $self, B::perlstring( $param ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,return sprintf( "%s[%s]", $self, $param );
0.000000,0,0.000000,},
0.000010,1,0.000010,constraint_generator => LazyLoad( Tied => 'constraint_generator' ),
0.000000,0,0.000000,inline_generator     => LazyLoad( Tied => 'inline_generator' ),
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name                 => "InstanceOf",
0.000000,0,0.000000,parent               => $_obj,
0.000000,0,0.000000,constraint_generator => sub {
0.000004,7,0.000001,return $meta->get_type( 'InstanceOf' ) unless @_;
0.000547,7,0.000078,require Type::Tiny::Class;
0.000000,0,0.000000,my @classes = map {
0.000078,14,0.000006,Types::TypeTiny::is_TypeTiny( $_ )
0.000000,0,0.000000,? $_
0.000000,0,0.000000,: "Type::Tiny::Class"->new(
0.000000,0,0.000000,class        => $_,
0.000000,0,0.000000,display_name => sprintf( 'InstanceOf[%s]', B::perlstring( $_ ) )
0.000000,0,0.000000,)
0.000000,0,0.000000,} @_;
0.000017,7,0.000002,return $classes[0] if @classes == 1;
0.000000,0,0.000000,
0.000000,0,0.000000,require B;
0.000000,0,0.000000,require Type::Tiny::Union;
0.000000,0,0.000000,return "Type::Tiny::Union"->new(
0.000000,0,0.000000,type_constraints => \@classes,
0.000000,0,0.000000,display_name     => sprintf(
0.000000,0,0.000000,'InstanceOf[%s]', join q[,], map B::perlstring( $_->class ), @classes
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000004,1,0.000004,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name                 => "ConsumerOf",
0.000000,0,0.000000,parent               => $_obj,
0.000000,0,0.000000,constraint_generator => sub {
0.000000,0,0.000000,return $meta->get_type( 'ConsumerOf' ) unless @_;
0.000000,0,0.000000,require B;
0.000000,0,0.000000,require Type::Tiny::Role;
0.000000,0,0.000000,my @roles = map {
0.000000,0,0.000000,Types::TypeTiny::is_TypeTiny( $_ )
0.000000,0,0.000000,? $_
0.000000,0,0.000000,: "Type::Tiny::Role"->new(
0.000000,0,0.000000,role         => $_,
0.000000,0,0.000000,display_name => sprintf( 'ConsumerOf[%s]', B::perlstring( $_ ) )
0.000000,0,0.000000,)
0.000000,0,0.000000,} @_;
0.000000,0,0.000000,return $roles[0] if @roles == 1;
0.000000,0,0.000000,
0.000000,0,0.000000,require Type::Tiny::Intersection;
0.000000,0,0.000000,return "Type::Tiny::Intersection"->new(
0.000000,0,0.000000,type_constraints => \@roles,
0.000000,0,0.000000,display_name     => sprintf(
0.000000,0,0.000000,'ConsumerOf[%s]', join q[,], map B::perlstring( $_->role ), @roles
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000004,1,0.000004,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name                 => "HasMethods",
0.000000,0,0.000000,parent               => $_obj,
0.000000,0,0.000000,constraint_generator => sub {
0.000000,1,0.000000,return $meta->get_type( 'HasMethods' ) unless @_;
0.000001,1,0.000001,require B;
0.000409,1,0.000409,require Type::Tiny::Duck;
0.000021,1,0.000021,return "Type::Tiny::Duck"->new(
0.000000,0,0.000000,methods      => \@_,
0.000000,0,0.000000,display_name =>
0.000000,0,0.000000,sprintf( 'HasMethods[%s]', join q[,], map B::perlstring( $_ ), @_ ),
0.000000,0,0.000000,);
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000010,1,0.000010,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->add_type(
0.000000,0,0.000000,{
0.000000,0,0.000000,name                 => "Enum",
0.000000,0,0.000000,parent               => $_str,
0.000000,0,0.000000,constraint_generator => sub {
0.000001,4,0.000000,return $meta->get_type( 'Enum' ) unless @_;
0.000002,4,0.000000,my $coercion;
0.000016,4,0.000004,if ( ref( $_[0] ) and ref( $_[0] ) eq 'SCALAR' ) {
0.000000,0,0.000000,$coercion = ${ +shift };
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( ref( $_[0] ) && !blessed( $_[0] )
0.000000,0,0.000000,or blessed( $_[0] ) && $_[0]->isa( 'Type::Coercion' ) )
0.000000,0,0.000000,{
0.000000,0,0.000000,$coercion = shift;
0.000000,0,0.000000,}
0.000003,4,0.000001,require B;
0.000375,4,0.000094,require Type::Tiny::Enum;
0.000076,4,0.000019,return "Type::Tiny::Enum"->new(
0.000000,0,0.000000,values       => \@_,
0.000000,0,0.000000,display_name => sprintf( 'Enum[%s]', join q[,], map B::perlstring( $_ ), @_ ),
0.000000,0,0.000000,$coercion ? ( coercion => $coercion ) : (),
0.000000,0,0.000000,);
0.000000,0,0.000000,},
0.000008,1,0.000008,type_default => undef,
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000019,1,0.000019,$meta->add_coercion(
0.000000,0,0.000000,{
0.000000,0,0.000000,name              => "MkOpt",
0.000000,0,0.000000,type_constraint   => $meta->get_type( "OptList" ),
0.000000,0,0.000000,type_coercion_map => [
0.000000,0,0.000000,$_arr,   q{ Exporter::Tiny::mkopt($_) },
0.000000,0,0.000000,$_hash,  q{ Exporter::Tiny::mkopt($_) },
0.000000,0,0.000000,$_undef, q{ [] },
0.000000,0,0.000000,],
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->add_coercion(
0.000000,0,0.000000,{
0.000000,0,0.000000,name               => "Join",
0.000000,0,0.000000,type_constraint    => $_str,
0.000000,0,0.000000,coercion_generator => sub {
0.000000,0,0.000000,my ( $self, $target, $sep ) = @_;
0.000000,0,0.000000,Types::TypeTiny::is_StringLike( $sep )
0.000000,0,0.000000,or _croak( "Parameter to Join[`a] expected to be a string; got $sep" );
0.000000,0,0.000000,require B;
0.000000,0,0.000000,$sep = B::perlstring( $sep );
0.000000,0,0.000000,return ( ArrayRef(), qq{ join($sep, \@\$_) } );
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000005,1,0.000005,);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->add_coercion(
0.000000,0,0.000000,{
0.000000,0,0.000000,name               => "Split",
0.000000,0,0.000000,type_constraint    => $_arr,
0.000000,0,0.000000,coercion_generator => sub {
0.000000,0,0.000000,my ( $self, $target, $re ) = @_;
0.000000,0,0.000000,ref( $re ) eq q(Regexp)
0.000000,0,0.000000,or _croak(
0.000000,0,0.000000,"Parameter to Split[`a] expected to be a regular expresssion; got $re" );
0.000000,0,0.000000,my $regexp_string = "$re";
0.000000,0,0.000000,$regexp_string =~ s/\\\//\\\\\//g;    # toothpicks
0.000000,0,0.000000,return ( Str(), qq{ [split /$regexp_string/, \$_] } );
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000004,1,0.000004,);
0.000000,0,0.000000,
0.000071,1,0.000071,__PACKAGE__->meta->make_immutable;
0.000000,0,0.000000,
0.000141,1,0.000141,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
