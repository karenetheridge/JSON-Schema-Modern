# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000026,2,0.000013,use strict;
0.000036,2,0.000018,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Vocabulary::FormatAssertion;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Implementation of the JSON Schema Format-Assertion vocabulary
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.558';
0.000000,0,0.000000,
0.000026,2,0.000013,use 5.020;
0.000021,2,0.000010,use Moo;
0.000048,3,0.000016,use strictures 2;
0.000034,2,0.000017,use experimental qw(signatures postderef);
0.000028,2,0.000014,use if "$]" >= 5.022, experimental => 're_strict';
0.000018,2,0.000009,no if "$]" >= 5.031009, feature => 'indirect';
0.000015,2,0.000007,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000015,2,0.000008,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000015,2,0.000007,use JSON::Schema::Modern::Utilities qw(is_type E A assert_keyword_type abort);
0.000017,2,0.000008,use Feature::Compat::Try;
0.001804,2,0.000902,use namespace::clean;
0.000000,0,0.000000,
0.000001,1,0.000001,with 'JSON::Schema::Modern::Vocabulary';
0.000000,0,0.000000,
0.000000,0,0.000000,sub vocabulary {
0.000004,1,0.000004,'https://json-schema.org/draft/2020-12/vocab/format-assertion' => 'draft2020-12';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub evaluation_order { 3 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub keywords {
0.000003,1,0.000003,qw(format);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,# for now, all built-in formats are constrained to the 'string' type
0.000000,0,0.000000,
0.000000,0,0.000000,my $is_datetime = sub {
0.000000,0,0.000000,eval { Time::Moment->from_string(uc($_[0])) } ? 1 : 0,
0.000001,1,0.000001,};
0.000000,0,0.000000,my $is_email = sub {
0.000000,0,0.000000,Email::Address::XS->parse($_[0])->is_valid;
0.000000,1,0.000000,};
0.000000,0,0.000000,my $is_hostname = sub {
0.000000,0,0.000000,Data::Validate::Domain::is_domain($_[0]);
0.000000,1,0.000000,};
0.000000,0,0.000000,my $idn_decode = sub {
0.000000,0,0.000000,try { return Net::IDN::Encode::domain_to_ascii($_[0]) } catch ($e) { return $_[0]; }
0.000001,1,0.000001,};
0.000000,0,0.000000,my $is_ipv4 = sub {
0.000000,0,0.000000,my @o = split(/\./, $_[0], 5);
0.000000,0,0.000000,@o == 4 && (grep /^(?:0|[1-9][0-9]{0,2})$/, @o) == 4 && (grep $_ < 256, @o) == 4;
0.000001,1,0.000001,};
0.000000,0,0.000000,# https://tools.ietf.org/html/rfc3339#appendix-A with some additions for the 2000 version
0.000000,0,0.000000,# as defined in https://en.wikipedia.org/wiki/ISO_8601#Durations
0.000001,1,0.000001,my $duration_re = do {
0.000005,1,0.000005,my $num = qr{[0-9]+(?:[.,][0-9]+)?};
0.000024,1,0.000024,my $second = qr{${num}S};
0.000011,1,0.000011,my $minute = qr{${num}M};
0.000042,1,0.000042,my $hour = qr{${num}H};
0.000027,1,0.000027,my $time = qr{T(?=[0-9])(?:$hour)?(?:$minute)?(?:$second)?};
0.000011,1,0.000011,my $day = qr{${num}D};
0.000009,1,0.000009,my $month = qr{${num}M};
0.000019,1,0.000019,my $year = qr{${num}Y};
0.000053,1,0.000053,my $week = qr{${num}W};
0.000026,1,0.000026,my $date = qr{(?=[0-9])(?:$year)?(?:$month)?(?:$day)?};
0.000057,1,0.000057,qr{^P(?:(?=.)(?:$date)?(?:$time)?|$week)$};
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,my $formats = +{
0.000000,0,0.000000,'date-time' => sub {
0.000000,0,0.000000,$is_datetime->($_[0]) || (
0.000000,0,0.000000,$_[0] =~ m/^(?:\d{4}-\d\d-\d\dT\d\d:\d\d):(\d\d)(?:\.\d+)?(?:[Zz]|[+-]\d\d:\d\d)$/a
0.000000,0,0.000000,&& $1 eq '60'
0.000000,0,0.000000,&& do {
0.000000,0,0.000000,require DateTime::Format::RFC3339;
0.000000,0,0.000000,eval { DateTime::Format::RFC3339->parse_datetime($_[0]) };
0.000000,0,0.000000,});
0.000000,0,0.000000,},
0.000000,0,0.000000,date => sub { $_[0] =~ /^\d{4}-(?:\d\d)-(?:\d\d)$/a && $is_datetime->($_[0].'T00:00:00Z') },
0.000000,0,0.000000,time => sub {
0.000000,0,0.000000,return if $_[0] !~ /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?([Zz]|([+-])(\d\d):(\d\d))$/a
0.000000,0,0.000000,or $1 > 23
0.000000,0,0.000000,or $2 > 59
0.000000,0,0.000000,or $3 > 60
0.000000,0,0.000000,or (defined($6) and $6 > 23)
0.000000,0,0.000000,or (defined($7) and $7 > 59);
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if $3 <= 59;
0.000000,0,0.000000,return $1 == 23 && $2 == 59 if uc($4) eq 'Z';
0.000000,0,0.000000,
0.000000,0,0.000000,my $sign = $5 eq '+' ? 1 : -1;
0.000000,0,0.000000,my $hour_zulu = $1 - $6*$sign;
0.000000,0,0.000000,my $min_zulu = $2 - $7*$sign;
0.000000,0,0.000000,$hour_zulu -= 1 if $min_zulu < 0;
0.000000,0,0.000000,
0.000000,0,0.000000,return $hour_zulu%24 == 23 && $min_zulu%60 == 59;
0.000000,0,0.000000,},
0.000000,0,0.000000,duration => sub { $_[0] =~ $duration_re && $_[0] !~ m{[.,][0-9]+[A-Z].} },
0.000000,0,0.000000,email => sub { $is_email->($_[0]) && $_[0] !~ /[^[:ascii:]]/ },
0.000000,0,0.000000,'idn-email' => $is_email,
0.000000,0,0.000000,hostname => $is_hostname,
0.000000,0,0.000000,'idn-hostname' => sub { $is_hostname->($idn_decode->($_[0])) },
0.000000,0,0.000000,ipv4 => $is_ipv4,
0.000000,0,0.000000,ipv6 => sub {
0.000000,0,0.000000,($_[0] =~ /^(?:[[:xdigit:]]{0,4}:){0,7}[[:xdigit:]]{0,4}$/
0.000000,0,0.000000,|| $_[0] =~ /^(?:[[:xdigit:]]{0,4}:){1,6}((?:[0-9]{1,3}\.){3}[0-9]{1,3})$/
0.000000,0,0.000000,&& $is_ipv4->($1))
0.000000,0,0.000000,&& $_[0] !~ /:::/
0.000000,0,0.000000,&& $_[0] !~ /^:[^:]/
0.000000,0,0.000000,&& $_[0] !~ /[^:]:$/
0.000000,0,0.000000,&& do {
0.000000,0,0.000000,my $double_colons = ()= ($_[0] =~ /::/g);
0.000000,0,0.000000,my $colon_components = grep length, split(/:+/, $_[0], -1);
0.000000,0,0.000000,$double_colons < 2 && ($double_colons > 0
0.000000,0,0.000000,|| ($colon_components == 8 && !defined $1)
0.000000,0,0.000000,|| ($colon_components == 7 && defined $1))
0.000000,0,0.000000,};
0.000000,0,0.000000,},
0.000000,0,0.000000,uri => sub {
0.000000,0,0.000000,my $uri = Mojo::URL->new($_[0]);
0.000000,0,0.000000,fc($uri->to_unsafe_string) eq fc($_[0]) && $uri->is_abs && $_[0] !~ /[^[:ascii:]]/;
0.000000,0,0.000000,},
0.000000,0,0.000000,'uri-reference' => sub {
0.000000,0,0.000000,fc(Mojo::URL->new($_[0])->to_unsafe_string) eq fc($_[0]) && $_[0] !~ /[^[:ascii:]]/;
0.000000,0,0.000000,},
0.000000,0,0.000000,iri => sub { Mojo::URL->new($_[0])->is_abs },
0.000000,0,0.000000,uuid => sub { $_[0] =~ /^[[:xdigit:]]{8}-(?:[[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$/ },
0.000000,0,0.000000,'json-pointer' => sub { (!length($_[0]) || $_[0] =~ m{^/}) && $_[0] !~ m{~(?![01])} },
0.000000,0,0.000000,'relative-json-pointer' => sub { $_[0] =~ m{^(?:0|[1-9][0-9]*)(?:#$|$|/)} && $_[0] !~ m{~(?![01])} },
0.000000,0,0.000000,regex => sub {
0.000373,63,0.000006,local $SIG{__WARN__} = sub { die @_ };
0.006097,189,0.000032,eval { qr/$_[0]/; 1 ? 1 : 0 };
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,'iri-reference' => sub { 1 },
0.000000,0,0.000000,'uri-template' => sub { 1 },
0.000018,1,0.000018,};
0.000000,0,0.000000,
0.000077,189,0.000000,sub _get_default_format_validation ($self, $format) {
0.000196,63,0.000003,return $formats->{$format};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,sub _traverse_keyword_format ($self, $schema, $state) {
0.000000,0,0.000000,return if not assert_keyword_type($state, $schema, 'string');
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000095,315,0.000000,sub _eval_keyword_format ($self, $data, $schema, $state) {
0.000000,0,0.000000,abort($state, 'unimplemented format "%s"', $schema->{format})
0.000042,63,0.000001,if $schema->{format} eq 'uri-template';
0.000000,0,0.000000,
0.000056,63,0.000001,try {
0.000242,63,0.000004,if ($schema->{format} eq 'date-time' or $schema->{format} eq 'date') {
0.000000,0,0.000000,require Time::Moment;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($schema->{format} eq 'email' or $schema->{format} eq 'idn-email') {
0.000000,0,0.000000,require Email::Address::XS; Email::Address::XS->VERSION(1.04);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($schema->{format} eq 'hostname' or $schema->{format} eq 'idn-hostname') {
0.000000,0,0.000000,require Data::Validate::Domain;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($schema->{format} eq 'idn-hostname') {
0.000000,0,0.000000,require Net::IDN::Encode;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,return E($state, 'cannot validate format "%s": %s', $schema->{format}, $e);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# first check the subrefs from JSON::Schema::Modern->new(format_evaluations => { ... })
0.000000,0,0.000000,# and add in the type if needed
0.000206,63,0.000003,my $evaluator_spec = $state->{evaluator}->_get_format_validation($schema->{format});
0.000181,63,0.000003,my $default_spec = $self->_get_default_format_validation($schema->{format});
0.000000,0,0.000000,
0.000145,63,0.000002,my $spec =
0.000000,0,0.000000,$evaluator_spec ? ($default_spec ? +{ type => 'string', sub => $evaluator_spec } : $evaluator_spec)
0.000000,0,0.000000,: $default_spec ? +{ type => 'string', sub => $default_spec }
0.000000,0,0.000000,: undef;
0.000000,0,0.000000,
0.000109,63,0.000002,A($state, $schema->{format});
0.000000,0,0.000000,return E($state, 'not a%s %s', $schema->{format} =~ /^[aeio]/ ? 'n' : '', $schema->{format})
0.000257,63,0.000004,if $spec and is_type($spec->{type}, $data) and not $spec->{sub}->($data);
0.000000,0,0.000000,
0.000317,63,0.000005,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000020,1,0.000020,1;
0.000000,0,0.000000,
0.000045,1,0.000045,__END__
