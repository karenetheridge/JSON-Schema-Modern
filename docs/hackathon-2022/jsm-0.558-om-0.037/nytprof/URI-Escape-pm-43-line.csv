# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package URI::Escape;
0.000000,0,0.000000,
0.000026,2,0.000013,use strict;
0.000074,2,0.000037,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,URI::Escape - Percent-encode and percent-decode unsafe characters
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use URI::Escape;
0.000000,0,0.000000,$safe = uri_escape("10% is enough\n");
0.000000,0,0.000000,$verysafe = uri_escape("foo", "\0-\377");
0.000000,0,0.000000,$str  = uri_unescape($safe);
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,This module provides functions to percent-encode and percent-decode URI strings as
0.000000,0,0.000000,defined by RFC 3986. Percent-encoding URI's is informally called "URI escaping".
0.000000,0,0.000000,This is the terminology used by this module, which predates the formalization of the
0.000000,0,0.000000,terms by the RFC by several years.
0.000000,0,0.000000,
0.000000,0,0.000000,A URI consists of a restricted set of characters.  The restricted set
0.000000,0,0.000000,of characters consists of digits, letters, and a few graphic symbols
0.000000,0,0.000000,chosen from those common to most of the character encodings and input
0.000000,0,0.000000,facilities available to Internet users.  They are made up of the
0.000000,0,0.000000,"unreserved" and "reserved" character sets as defined in RFC 3986.
0.000000,0,0.000000,
0.000000,0,0.000000,unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
0.000000,0,0.000000,reserved      = ":" / "/" / "?" / "#" / "[" / "]" / "@"
0.000000,0,0.000000,"!" / "$" / "&" / "'" / "(" / ")"
0.000000,0,0.000000,/ "*" / "+" / "," / ";" / "="
0.000000,0,0.000000,
0.000000,0,0.000000,In addition, any byte (octet) can be represented in a URI by an escape
0.000000,0,0.000000,sequence: a triplet consisting of the character "%" followed by two
0.000000,0,0.000000,hexadecimal digits.  A byte can also be represented directly by a
0.000000,0,0.000000,character, using the US-ASCII character for that octet.
0.000000,0,0.000000,
0.000000,0,0.000000,Some of the characters are I<reserved> for use as delimiters or as
0.000000,0,0.000000,part of certain URI components.  These must be escaped if they are to
0.000000,0,0.000000,be treated as ordinary data.  Read RFC 3986 for further details.
0.000000,0,0.000000,
0.000000,0,0.000000,The functions provided (and exported by default) from this module are:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item uri_escape( $string )
0.000000,0,0.000000,
0.000000,0,0.000000,=item uri_escape( $string, $unsafe )
0.000000,0,0.000000,
0.000000,0,0.000000,Replaces each unsafe character in the $string with the corresponding
0.000000,0,0.000000,escape sequence and returns the result.  The $string argument should
0.000000,0,0.000000,be a string of bytes.  The uri_escape() function will croak if given a
0.000000,0,0.000000,characters with code above 255.  Use uri_escape_utf8() if you know you
0.000000,0,0.000000,have such chars or/and want chars in the 128 .. 255 range treated as
0.000000,0,0.000000,UTF-8.
0.000000,0,0.000000,
0.000000,0,0.000000,The uri_escape() function takes an optional second argument that
0.000000,0,0.000000,overrides the set of characters that are to be escaped.  The set is
0.000000,0,0.000000,specified as a string that can be used in a regular expression
0.000000,0,0.000000,character class (between [ ]).  E.g.:
0.000000,0,0.000000,
0.000000,0,0.000000,"\x00-\x1f\x7f-\xff"          # all control and hi-bit characters
0.000000,0,0.000000,"a-z"                         # all lower case characters
0.000000,0,0.000000,"^A-Za-z"                     # everything not a letter
0.000000,0,0.000000,
0.000000,0,0.000000,The default set of characters to be escaped is all those which are
0.000000,0,0.000000,I<not> part of the C<unreserved> character class shown above as well
0.000000,0,0.000000,as the reserved characters.  I.e. the default is:
0.000000,0,0.000000,
0.000000,0,0.000000,"^A-Za-z0-9\-\._~"
0.000000,0,0.000000,
0.000000,0,0.000000,The second argument can also be specified as a regular expression object:
0.000000,0,0.000000,
0.000000,0,0.000000,qr/[^A-Za-z]/
0.000000,0,0.000000,
0.000000,0,0.000000,Any strings matched by this regular expression will have all of their
0.000000,0,0.000000,characters escaped.
0.000000,0,0.000000,
0.000000,0,0.000000,=item uri_escape_utf8( $string )
0.000000,0,0.000000,
0.000000,0,0.000000,=item uri_escape_utf8( $string, $unsafe )
0.000000,0,0.000000,
0.000000,0,0.000000,Works like uri_escape(), but will encode chars as UTF-8 before
0.000000,0,0.000000,escaping them.  This makes this function able to deal with characters
0.000000,0,0.000000,with code above 255 in $string.  Note that chars in the 128 .. 255
0.000000,0,0.000000,range will be escaped differently by this function compared to what
0.000000,0,0.000000,uri_escape() would.  For chars in the 0 .. 127 range there is no
0.000000,0,0.000000,difference.
0.000000,0,0.000000,
0.000000,0,0.000000,Equivalent to:
0.000000,0,0.000000,
0.000000,0,0.000000,utf8::encode($string);
0.000000,0,0.000000,my $uri = uri_escape($string);
0.000000,0,0.000000,
0.000000,0,0.000000,Note: JavaScript has a function called escape() that produces the
0.000000,0,0.000000,sequence "%uXXXX" for chars in the 256 .. 65535 range.  This function
0.000000,0,0.000000,has really nothing to do with URI escaping but some folks got confused
0.000000,0,0.000000,since it "does the right thing" in the 0 .. 255 range.  Because of
0.000000,0,0.000000,this you sometimes see "URIs" with these kind of escapes.  The
0.000000,0,0.000000,JavaScript encodeURIComponent() function is similar to uri_escape_utf8().
0.000000,0,0.000000,
0.000000,0,0.000000,=item uri_unescape($string,...)
0.000000,0,0.000000,
0.000000,0,0.000000,Returns a string with each %XX sequence replaced with the actual byte
0.000000,0,0.000000,(octet).
0.000000,0,0.000000,
0.000000,0,0.000000,This does the same as:
0.000000,0,0.000000,
0.000000,0,0.000000,$string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
0.000000,0,0.000000,
0.000000,0,0.000000,but does not modify the string in-place as this RE would.  Using the
0.000000,0,0.000000,uri_unescape() function instead of the RE might make the code look
0.000000,0,0.000000,cleaner and is a few characters less to type.
0.000000,0,0.000000,
0.000000,0,0.000000,In a simple benchmark test I did,
0.000000,0,0.000000,calling the function (instead of the inline RE above) if a few chars
0.000000,0,0.000000,were unescaped was something like 40% slower, and something like 700% slower if none were.  If
0.000000,0,0.000000,you are going to unescape a lot of times it might be a good idea to
0.000000,0,0.000000,inline the RE.
0.000000,0,0.000000,
0.000000,0,0.000000,If the uri_unescape() function is passed multiple strings, then each
0.000000,0,0.000000,one is returned unescaped.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,The module can also export the C<%escapes> hash, which contains the
0.000000,0,0.000000,mapping from all 256 bytes to the corresponding escape codes.  Lookup
0.000000,0,0.000000,in this hash is faster than evaluating C<sprintf("%%%02X", ord($byte))>
0.000000,0,0.000000,each time.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,L<URI>
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright 1995-2004 Gisle Aas.
0.000000,0,0.000000,
0.000000,0,0.000000,This program is free software; you can redistribute it and/or modify
0.000000,0,0.000000,it under the same terms as Perl itself.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000061,3,0.000020,use Exporter 5.57 'import';
0.000000,0,0.000000,our %escapes;
0.000001,1,0.000001,our @EXPORT = qw(uri_escape uri_unescape uri_escape_utf8);
0.000000,1,0.000000,our @EXPORT_OK = qw(%escapes);
0.000000,1,0.000000,our $VERSION = '5.17';
0.000000,0,0.000000,
0.000286,2,0.000143,use Carp ();
0.000000,0,0.000000,
0.000000,0,0.000000,# Build a char->hex map
0.000001,1,0.000001,for (0..255) {
0.000197,256,0.000001,$escapes{chr($_)} = sprintf("%%%02X", $_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my %subst;  # compiled patterns
0.000000,0,0.000000,
0.000009,1,0.000009,my %Unsafe = (
0.000000,0,0.000000,RFC2732 => qr/[^A-Za-z0-9\-_.!~*'()]/,
0.000000,0,0.000000,RFC3986 => qr/[^A-Za-z0-9\-\._~]/,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub uri_escape {
0.000000,0,0.000000,my($text, $patn) = @_;
0.000000,0,0.000000,return undef unless defined $text;
0.000000,0,0.000000,my $re;
0.000000,0,0.000000,if (defined $patn){
0.000000,0,0.000000,if (ref $patn eq 'Regexp') {
0.000000,0,0.000000,$text =~ s{($patn)}{
0.000000,0,0.000000,join('', map +($escapes{$_} || _fail_hi($_)), split //, "$1")
0.000000,0,0.000000,}ge;
0.000000,0,0.000000,return $text;
0.000000,0,0.000000,}
0.000000,0,0.000000,$re = $subst{$patn};
0.000000,0,0.000000,if (!defined $re) {
0.000000,0,0.000000,$re = $patn;
0.000000,0,0.000000,# we need to escape the [] characters, except for those used in
0.000000,0,0.000000,# posix classes. if they are prefixed by a backslash, allow them
0.000000,0,0.000000,# through unmodified.
0.000000,0,0.000000,$re =~ s{(\[:\w+:\])|(\\)?([\[\]]|\\\z)}{
0.000000,0,0.000000,defined $1 ? $1 : defined $2 ? "$2$3" : "\\$3"
0.000000,0,0.000000,}ge;
0.000000,0,0.000000,eval {
0.000000,0,0.000000,# disable the warnings here, since they will trigger later
0.000000,0,0.000000,# when used, and we only want them to appear once per call,
0.000000,0,0.000000,# but every time the same pattern is used.
0.000308,2,0.000154,no warnings 'regexp';
0.000000,0,0.000000,$re = $subst{$patn} = qr{[$re]};
0.000000,0,0.000000,1;
0.000000,0,0.000000,} or Carp::croak("uri_escape: $@");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$re = $Unsafe{RFC3986};
0.000000,0,0.000000,}
0.000000,0,0.000000,$text =~ s/($re)/$escapes{$1} || _fail_hi($1)/ge;
0.000000,0,0.000000,$text;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fail_hi {
0.000000,0,0.000000,my $chr = shift;
0.000000,0,0.000000,Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead", ord($chr));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub uri_escape_utf8 {
0.000000,0,0.000000,my $text = shift;
0.000000,0,0.000000,return undef unless defined $text;
0.000000,0,0.000000,utf8::encode($text);
0.000000,0,0.000000,return uri_escape($text, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub uri_unescape {
0.000000,0,0.000000,# Note from RFC1630:  "Sequences which start with a percent sign
0.000000,0,0.000000,# but are not followed by two hexadecimal characters are reserved
0.000000,0,0.000000,# for future extension"
0.000000,0,0.000000,my $str = shift;
0.000000,0,0.000000,if (@_ && wantarray) {
0.000000,0,0.000000,# not executed for the common case of a single argument
0.000000,0,0.000000,my @str = ($str, @_);  # need to copy
0.000000,0,0.000000,for (@str) {
0.000000,0,0.000000,s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
0.000000,0,0.000000,}
0.000000,0,0.000000,return @str;
0.000000,0,0.000000,}
0.000000,0,0.000000,$str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;
0.000000,0,0.000000,$str;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX FIXME escape_char is buggy as it assigns meaning to the string's storage format.
0.000000,0,0.000000,sub escape_char {
0.000000,0,0.000000,# Old versions of utf8::is_utf8() didn't properly handle magical vars (e.g. $1).
0.000000,0,0.000000,# The following forces a fetch to occur beforehand.
0.000000,0,0.000000,my $dummy = substr($_[0], 0, 0);
0.000000,0,0.000000,
0.000000,0,0.000000,if (utf8::is_utf8($_[0])) {
0.000000,0,0.000000,my $s = shift;
0.000000,0,0.000000,utf8::encode($s);
0.000000,0,0.000000,unshift(@_, $s);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return join '', @URI::Escape::escapes{split //, $_[0]};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
