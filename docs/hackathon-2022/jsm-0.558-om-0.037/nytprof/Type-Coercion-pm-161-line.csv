# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Type::Coercion;
0.000000,0,0.000000,
0.000053,2,0.000027,use 5.008001;
0.000025,2,0.000013,use strict;
0.000053,2,0.000027,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,1,0.000000,$Type::Coercion::AUTHORITY = 'cpan:TOBYINK';
0.000007,1,0.000007,$Type::Coercion::VERSION   = '2.000001';
0.000035,1,0.000035,}
0.000000,0,0.000000,
0.000002,1,0.000002,$Type::Coercion::VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000019,2,0.000010,use Eval::TypeTiny qw<>;
0.000048,2,0.000024,use Scalar::Util qw< blessed >;
0.003184,2,0.001592,use Types::TypeTiny qw<>;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
0.000000,0,0.000000,
0.000002,1,0.000002,require Type::Tiny;
0.000000,0,0.000000,
0.000000,0,0.000000,__PACKAGE__->Type::Tiny::_install_overloads(
0.000000,0,0.000000,q("") => sub {
0.000014,1,0.000014,caller =~ m{^(Moo::HandleMoose|Sub::Quote)}
0.000000,0,0.000000,? $_[0]->_stringify_no_magic
0.000000,0,0.000000,: $_[0]->display_name;
0.000000,0,0.000000,},
0.000114,52,0.000002,q(bool) => sub { 1 },
0.000009,1,0.000009,q(&{})  => "_overload_coderef",
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,__PACKAGE__->Type::Tiny::_install_overloads(
0.000000,0,0.000000,q(~~) => sub { $_[0]->has_coercion_for_value( $_[1] ) },
0.000003,1,0.000003,) if Type::Tiny::SUPPORT_SMARTMATCH();
0.000000,0,0.000000,
0.000000,0,0.000000,sub _overload_coderef {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( "Sub::Quote"->can( "quote_sub" ) && $self->can_be_inlined ) {
0.000000,0,0.000000,$self->{_overload_coderef} =
0.000000,0,0.000000,Sub::Quote::quote_sub( $self->inline_coercion( '$_[0]' ) )
0.000000,0,0.000000,if !$self->{_overload_coderef} || !$self->{_sub_quoted}++;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Scalar::Util::weaken( my $weak = $self );
0.000000,0,0.000000,$self->{_overload_coderef} ||= sub { $weak->coerce( @_ ) };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{_overload_coderef};
0.000000,0,0.000000,} #/ sub _overload_coderef
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000012,58,0.000000,my $class  = shift;
0.000075,58,0.000001,my %params = ( @_ == 1 ) ? %{ $_[0] } : @_;
0.000000,0,0.000000,
0.000031,58,0.000001,$params{name} = '__ANON__' unless exists( $params{name} );
0.000040,58,0.000001,my $C = delete( $params{type_coercion_map} ) || [];
0.000006,58,0.000000,my $F = delete( $params{frozen} );
0.000000,0,0.000000,
0.000027,58,0.000000,my $self = bless \%params, $class;
0.000019,58,0.000000,$self->add_type_coercions( @$C ) if @$C;
0.000086,58,0.000001,$self->_preserve_type_constraint;
0.000206,58,0.000004,Scalar::Util::weaken( $self->{type_constraint} );    # break ref cycle
0.000012,58,0.000000,$self->{frozen} = $F if $F;
0.000000,0,0.000000,
0.000072,58,0.000001,unless ( $self->is_anon ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# First try a fast ASCII-only expression, but fall back to Unicode
0.000016,3,0.000005,$self->name =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm
0.000000,0,0.000000,or eval q( use 5.008; $self->name =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm )
0.000000,0,0.000000,or _croak '"%s" is not a valid coercion name', $self->name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000116,58,0.000002,return $self;
0.000000,0,0.000000,} #/ sub new
0.000000,0,0.000000,
0.000000,0,0.000000,sub _stringify_no_magic {
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'%s=%s(0x%08x)', blessed( $_[0] ), Scalar::Util::reftype( $_[0] ),
0.000000,0,0.000000,Scalar::Util::refaddr( $_[0] )
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000123,70,0.000002,sub name         { $_[0]{name} }
0.000003,1,0.000003,sub display_name { $_[0]{display_name} ||= $_[0]->_build_display_name }
0.000000,0,0.000000,sub library      { $_[0]{library} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub type_constraint {
0.000023,6,0.000004,$_[0]{type_constraint} ||= $_[0]->_maybe_restore_type_constraint;
0.000000,0,0.000000,}
0.000118,56,0.000002,sub type_coercion_map { $_[0]{type_coercion_map} ||= [] }
0.000000,0,0.000000,sub moose_coercion { $_[0]{moose_coercion} ||= $_[0]->_build_moose_coercion }
0.000000,0,0.000000,
0.000000,0,0.000000,sub compiled_coercion {
0.000006,1,0.000006,$_[0]{compiled_coercion} ||= $_[0]->_build_compiled_coercion;
0.000000,0,0.000000,}
0.000016,6,0.000003,sub frozen             { $_[0]{frozen} ||= 0 }
0.000000,0,0.000000,sub coercion_generator { $_[0]{coercion_generator} }
0.000000,0,0.000000,sub parameters         { $_[0]{parameters} }
0.000000,0,0.000000,sub parameterized_from { $_[0]{parameterized_from} }
0.000000,0,0.000000,
0.000007,3,0.000002,sub has_library            { exists $_[0]{library} }
0.000016,3,0.000005,sub has_type_constraint    { defined $_[0]->type_constraint }     # sic
0.000007,3,0.000002,sub has_coercion_generator { exists $_[0]{coercion_generator} }
0.000000,0,0.000000,sub has_parameters         { exists $_[0]{parameters} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _preserve_type_constraint {
0.000017,58,0.000000,my $self = shift;
0.000000,0,0.000000,$self->{_compiled_type_constraint_check} =
0.000000,0,0.000000,$self->{type_constraint}->compiled_check
0.000271,58,0.000005,if $self->{type_constraint};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _maybe_restore_type_constraint {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,if ( my $check = $self->{_compiled_type_constraint_check} ) {
0.000000,0,0.000000,return Type::Tiny->new( constraint => $check );
0.000000,0,0.000000,}
0.000000,0,0.000000,return;    # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my ( $x, $y, $swap ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,Types::TypeTiny::is_TypeTiny( $x ) and return $x->plus_fallback_coercions( $y );
0.000000,0,0.000000,Types::TypeTiny::is_TypeTiny( $y ) and return $y->plus_coercions( $x );
0.000000,0,0.000000,
0.000000,0,0.000000,_croak "Attempt to add $class to something that is not a $class"
0.000000,0,0.000000,unless blessed( $x )
0.000000,0,0.000000,&& blessed( $y )
0.000000,0,0.000000,&& $x->isa( $class )
0.000000,0,0.000000,&& $y->isa( $class );
0.000000,0,0.000000,
0.000000,0,0.000000,( $y, $x ) = ( $x, $y ) if $swap;
0.000000,0,0.000000,
0.000000,0,0.000000,my %opts;
0.000000,0,0.000000,if ( $x->has_type_constraint
0.000000,0,0.000000,and $y->has_type_constraint
0.000000,0,0.000000,and $x->type_constraint == $y->type_constraint )
0.000000,0,0.000000,{
0.000000,0,0.000000,$opts{type_constraint} = $x->type_constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $x->has_type_constraint and $y->has_type_constraint ) {
0.000000,0,0.000000,
0.000000,0,0.000000,#		require Type::Tiny::Union;
0.000000,0,0.000000,#		$opts{type_constraint} = "Type::Tiny::Union"->new(
0.000000,0,0.000000,#			type_constraints => [ $x->type_constraint, $y->type_constraint ],
0.000000,0,0.000000,#		);
0.000000,0,0.000000,}
0.000000,0,0.000000,$opts{display_name} ||= "$x+$y";
0.000000,0,0.000000,delete $opts{display_name} if $opts{display_name} eq '__ANON__+__ANON__';
0.000000,0,0.000000,
0.000000,0,0.000000,my $new = $class->new( %opts );
0.000000,0,0.000000,$new->add_type_coercions( @{ $x->type_coercion_map } );
0.000000,0,0.000000,$new->add_type_coercions( @{ $y->type_coercion_map } );
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,} #/ sub add
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_display_name {
0.000000,0,0.000000,shift->name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub qualified_name {
0.000000,3,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000006,3,0.000002,if ( $self->has_library and not $self->is_anon ) {
0.000000,0,0.000000,return sprintf( "%s::%s", $self->library, $self->name );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000009,3,0.000003,return $self->name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_anon {
0.000008,61,0.000000,my $self = shift;
0.001129,61,0.000019,$self->name eq "__ANON__";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _clear_compiled_coercion {
0.000001,2,0.000000,delete $_[0]{_overload_coderef};
0.000005,2,0.000002,delete $_[0]{compiled_coercion};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000115,112,0.000001,sub freeze                    { $_[0]{frozen} = 1; $_[0] }
0.000000,0,0.000000,sub i_really_want_to_unfreeze { $_[0]{frozen} = 0; $_[0] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub coerce {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return $self->compiled_coercion->( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub assert_coerce {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $r    = $self->coerce( @_ );
0.000000,0,0.000000,$self->type_constraint->assert_valid( $r )
0.000000,0,0.000000,if $self->has_type_constraint;
0.000000,0,0.000000,return $r;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_coercion_for_type {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $type = Types::TypeTiny::to_TypeTiny( $_[0] );
0.000000,0,0.000000,
0.000000,0,0.000000,return "0 but true"
0.000000,0,0.000000,if $self->has_type_constraint
0.000000,0,0.000000,&& $type->is_a_type_of( $self->type_constraint );
0.000000,0,0.000000,
0.000000,0,0.000000,my $c = $self->type_coercion_map;
0.000000,0,0.000000,for ( my $i = 0 ; $i <= $#$c ; $i += 2 ) {
0.000000,0,0.000000,return !!1 if $type->is_a_type_of( $c->[$i] );
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,} #/ sub has_coercion_for_type
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_coercion_for_value {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,local $_ = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,return "0 but true"
0.000000,0,0.000000,if $self->has_type_constraint
0.000000,0,0.000000,&& $self->type_constraint->check( @_ );
0.000000,0,0.000000,
0.000000,0,0.000000,my $c = $self->type_coercion_map;
0.000000,0,0.000000,for ( my $i = 0 ; $i <= $#$c ; $i += 2 ) {
0.000000,0,0.000000,return !!1 if $c->[$i]->check( @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,} #/ sub has_coercion_for_value
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_type_coercions {
0.000000,2,0.000000,my $self = shift;
0.000003,2,0.000002,my @args = @_;
0.000000,0,0.000000,
0.000005,2,0.000002,_croak "Attempt to add coercion code to a Type::Coercion which has been frozen"
0.000000,0,0.000000,if $self->frozen;
0.000000,0,0.000000,
0.000001,2,0.000000,while ( @args ) {
0.000008,4,0.000002,my $type = Types::TypeTiny::to_TypeTiny( shift @args );
0.000000,0,0.000000,
0.000022,4,0.000006,if ( blessed $type and my $method = $type->can( 'type_coercion_map' ) ) {
0.000000,0,0.000000,push @{ $self->type_coercion_map }, @{ $method->( $type ) };
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000001,4,0.000000,my $coercion = shift @args;
0.000005,4,0.000001,_croak "Types must be blessed Type::Tiny objects"
0.000000,0,0.000000,unless Types::TypeTiny::is_TypeTiny( $type );
0.000005,4,0.000001,_croak "Coercions must be code references or strings"
0.000000,0,0.000000,unless Types::TypeTiny::is_StringLike( $coercion )
0.000000,0,0.000000,|| Types::TypeTiny::is_CodeLike( $coercion );
0.000008,4,0.000002,push @{ $self->type_coercion_map }, $type, $coercion;
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ while ( @args )
0.000000,0,0.000000,
0.000003,2,0.000002,$self->_clear_compiled_coercion;
0.000007,2,0.000003,return $self;
0.000000,0,0.000000,} #/ sub add_type_coercions
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_compiled_coercion {
0.000000,1,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000003,1,0.000003,my @mishmash = @{ $self->type_coercion_map };
0.000000,0,0.000000,return sub { $_[0] }
0.000005,1,0.000005,unless @mishmash;
0.000000,0,0.000000,
0.000015,1,0.000015,if ( $self->can_be_inlined ) {
0.000000,0,0.000000,return Eval::TypeTiny::eval_closure(
0.000000,0,0.000000,source      => sprintf( 'sub ($) { %s }', $self->inline_coercion( '$_[0]' ) ),
0.000000,0,0.000000,description => sprintf( "compiled coercion '%s'", $self ),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# These arrays will be closed over.
0.000000,0,0.000000,my ( @types, @codes );
0.000000,0,0.000000,while ( @mishmash ) {
0.000000,0,0.000000,push @types, shift @mishmash;
0.000000,0,0.000000,push @codes, shift @mishmash;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( $self->has_type_constraint ) {
0.000000,0,0.000000,unshift @types, $self->type_constraint;
0.000000,0,0.000000,unshift @codes, undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @sub;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $i ( 0 .. $#types ) {
0.000000,0,0.000000,push @sub,
0.000000,0,0.000000,$types[$i]->can_be_inlined
0.000000,0,0.000000,? sprintf( 'if (%s)',                $types[$i]->inline_check( '$_[0]' ) )
0.000000,0,0.000000,: sprintf( 'if ($checks[%d]->(@_))', $i );
0.000000,0,0.000000,push @sub,
0.000000,0,0.000000,!defined( $codes[$i] )
0.000000,0,0.000000,? sprintf( '  { return $_[0] }' )
0.000000,0,0.000000,: Types::TypeTiny::is_StringLike( $codes[$i] ) ? sprintf(
0.000000,0,0.000000,'  { local $_ = $_[0]; return scalar(%s); }',
0.000000,0,0.000000,$codes[$i]
0.000000,0,0.000000,)
0.000000,0,0.000000,: sprintf( '  { local $_ = $_[0]; return scalar($codes[%d]->(@_)) }', $i );
0.000000,0,0.000000,} #/ for my $i ( 0 .. $#types)
0.000000,0,0.000000,
0.000000,0,0.000000,push @sub, 'return $_[0];';
0.000000,0,0.000000,
0.000000,0,0.000000,return Eval::TypeTiny::eval_closure(
0.000000,0,0.000000,source      => sprintf( 'sub ($) { %s }', join qq[\n], @sub ),
0.000000,0,0.000000,description => sprintf( "compiled coercion '%s'", $self ),
0.000000,0,0.000000,environment => {
0.000000,0,0.000000,'@checks' => [ map $_->compiled_check, @types ],
0.000000,0,0.000000,'@codes'  => \@codes,
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ sub _build_compiled_coercion
0.000000,0,0.000000,
0.000000,0,0.000000,sub can_be_inlined {
0.000001,2,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000002,2,0.000001,return unless $self->frozen;
0.000000,0,0.000000,
0.000000,0,0.000000,return
0.000007,2,0.000003,if $self->has_type_constraint
0.000000,0,0.000000,&& !$self->type_constraint->can_be_inlined;
0.000000,0,0.000000,
0.000003,2,0.000002,my @mishmash = @{ $self->type_coercion_map };
0.000002,2,0.000001,while ( @mishmash ) {
0.000003,2,0.000002,my ( $type, $converter ) = splice( @mishmash, 0, 2 );
0.000004,2,0.000002,return unless $type->can_be_inlined;
0.000004,2,0.000002,return unless Types::TypeTiny::is_StringLike( $converter );
0.000000,0,0.000000,}
0.000007,2,0.000003,return !!1;
0.000000,0,0.000000,} #/ sub can_be_inlined
0.000000,0,0.000000,
0.000000,0,0.000000,sub _source_type_union {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my @r;
0.000000,0,0.000000,push @r, $self->type_constraint if $self->has_type_constraint;
0.000000,0,0.000000,
0.000000,0,0.000000,my @mishmash = @{ $self->type_coercion_map };
0.000000,0,0.000000,while ( @mishmash ) {
0.000000,0,0.000000,my ( $type ) = splice( @mishmash, 0, 2 );
0.000000,0,0.000000,push @r, $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,require Type::Tiny::Union;
0.000000,0,0.000000,return "Type::Tiny::Union"->new( type_constraints => \@r, tmp => 1 );
0.000000,0,0.000000,} #/ sub _source_type_union
0.000000,0,0.000000,
0.000000,0,0.000000,sub inline_coercion {
0.000001,1,0.000001,my $self    = shift;
0.000000,1,0.000000,my $varname = $_[0];
0.000000,0,0.000000,
0.000000,1,0.000000,_croak "This coercion cannot be inlined" unless $self->can_be_inlined;
0.000000,0,0.000000,
0.000006,1,0.000006,my @mishmash = @{ $self->type_coercion_map };
0.000001,1,0.000001,return "($varname)" unless @mishmash;
0.000000,0,0.000000,
0.000000,1,0.000000,my ( @types, @codes );
0.000001,1,0.000001,while ( @mishmash ) {
0.000001,1,0.000001,push @types, shift @mishmash;
0.000001,1,0.000001,push @codes, shift @mishmash;
0.000000,0,0.000000,}
0.000002,1,0.000002,if ( $self->has_type_constraint ) {
0.000000,1,0.000000,unshift @types, $self->type_constraint;
0.000000,1,0.000000,unshift @codes, undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my @sub;
0.000000,0,0.000000,
0.000003,1,0.000003,for my $i ( 0 .. $#types ) {
0.000006,2,0.000003,push @sub, sprintf( '(%s) ?', $types[$i]->inline_check( $varname ) );
0.000003,2,0.000002,push @sub,
0.000000,0,0.000000,( defined( $codes[$i] ) && ( $varname eq '$_' ) )
0.000000,0,0.000000,? sprintf( 'scalar(do { %s }) :', $codes[$i] )
0.000000,0,0.000000,: defined( $codes[$i] ) ? sprintf(
0.000000,0,0.000000,'scalar(do { local $_ = %s; %s }) :', $varname,
0.000000,0,0.000000,$codes[$i]
0.000000,0,0.000000,)
0.000000,0,0.000000,: sprintf( '%s :', $varname );
0.000000,0,0.000000,} #/ for my $i ( 0 .. $#types)
0.000000,0,0.000000,
0.000001,1,0.000001,push @sub, "$varname";
0.000000,0,0.000000,
0.000012,1,0.000012,"@sub";
0.000000,0,0.000000,} #/ sub inline_coercion
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_moose_coercion {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my %options = ();
0.000000,0,0.000000,$options{type_coercion_map} =
0.000000,0,0.000000,[ $self->freeze->_codelike_type_coercion_map( 'moose_type' ) ];
0.000000,0,0.000000,$options{type_constraint} = $self->type_constraint
0.000000,0,0.000000,if $self->has_type_constraint;
0.000000,0,0.000000,
0.000000,0,0.000000,require Moose::Meta::TypeCoercion;
0.000000,0,0.000000,my $r = "Moose::Meta::TypeCoercion"->new( %options );
0.000000,0,0.000000,
0.000000,0,0.000000,return $r;
0.000000,0,0.000000,} #/ sub _build_moose_coercion
0.000000,0,0.000000,
0.000000,0,0.000000,sub _codelike_type_coercion_map {
0.000000,0,0.000000,my $self     = shift;
0.000000,0,0.000000,my $modifier = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,my @orig = @{ $self->type_coercion_map };
0.000000,0,0.000000,my @new;
0.000000,0,0.000000,
0.000000,0,0.000000,while ( @orig ) {
0.000000,0,0.000000,my ( $type, $converter ) = splice( @orig, 0, 2 );
0.000000,0,0.000000,
0.000000,0,0.000000,push @new, $modifier ? $type->$modifier : $type;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( Types::TypeTiny::is_CodeLike( $converter ) ) {
0.000000,0,0.000000,push @new, $converter;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @new, Eval::TypeTiny::eval_closure(
0.000000,0,0.000000,source      => sprintf( 'sub { local $_ = $_[0]; %s }',           $converter ),
0.000000,0,0.000000,description => sprintf( "temporary compiled converter from '%s'", $type ),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ while ( @orig )
0.000000,0,0.000000,
0.000000,0,0.000000,return @new;
0.000000,0,0.000000,} #/ sub _codelike_type_coercion_map
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_parameterizable {
0.000006,3,0.000002,shift->has_coercion_generator;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_parameterized {
0.000000,0,0.000000,shift->has_parameters;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parameterize {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return $self unless @_;
0.000000,0,0.000000,$self->is_parameterizable
0.000000,0,0.000000,or _croak "Constraint '%s' does not accept parameters", "$self";
0.000000,0,0.000000,
0.000000,0,0.000000,@_ = map Types::TypeTiny::to_TypeTiny( $_ ), @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return ref( $self )->new(
0.000000,0,0.000000,type_constraint   => $self->type_constraint,
0.000000,0,0.000000,type_coercion_map =>
0.000000,0,0.000000,[ $self->coercion_generator->( $self, $self->type_constraint, @_ ) ],
0.000000,0,0.000000,parameters         => \@_,
0.000000,0,0.000000,frozen             => 1,
0.000000,0,0.000000,parameterized_from => $self,
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ sub parameterize
0.000000,0,0.000000,
0.000000,0,0.000000,sub _reparameterize {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $target_type ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->is_parameterized or return $self;
0.000000,0,0.000000,my $parent = $self->parameterized_from;
0.000000,0,0.000000,
0.000000,0,0.000000,return ref( $self )->new(
0.000000,0,0.000000,type_constraint   => $target_type,
0.000000,0,0.000000,type_coercion_map => [
0.000000,0,0.000000,$parent->coercion_generator->( $parent, $target_type, @{ $self->parameters } )
0.000000,0,0.000000,],
0.000000,0,0.000000,parameters         => \@_,
0.000000,0,0.000000,frozen             => 1,
0.000000,0,0.000000,parameterized_from => $parent,
0.000000,0,0.000000,);
0.000000,0,0.000000,} #/ sub _reparameterize
0.000000,0,0.000000,
0.000000,0,0.000000,sub isa {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $INC{"Moose.pm"}
0.000000,0,0.000000,and blessed( $self )
0.000000,0,0.000000,and $_[0] eq 'Moose::Meta::TypeCoercion' )
0.000000,0,0.000000,{
0.000000,0,0.000000,return !!1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $INC{"Moose.pm"}
0.000000,0,0.000000,and blessed( $self )
0.000000,0,0.000000,and $_[0] =~ /^(Class::MOP|MooseX?)::/ )
0.000000,0,0.000000,{
0.000000,0,0.000000,my $r = $self->moose_coercion->isa( @_ );
0.000000,0,0.000000,return $r if $r;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->SUPER::isa( @_ );
0.000000,0,0.000000,} #/ sub isa
0.000000,0,0.000000,
0.000000,0,0.000000,sub can {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $can = $self->SUPER::can( @_ );
0.000000,0,0.000000,return $can if $can;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $INC{"Moose.pm"}
0.000000,0,0.000000,and blessed( $self )
0.000000,0,0.000000,and my $method = $self->moose_coercion->can( @_ ) )
0.000000,0,0.000000,{
0.000000,0,0.000000,return sub { $method->( shift->moose_coercion, @_ ) };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,} #/ sub can
0.000000,0,0.000000,
0.000000,0,0.000000,sub AUTOLOAD {
0.000000,1,0.000000,my $self = shift;
0.000007,1,0.000007,my ( $m ) = ( our $AUTOLOAD =~ /::(\w+)$/ );
0.000003,1,0.000003,return if $m eq 'DESTROY';
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $INC{"Moose.pm"}
0.000000,0,0.000000,and blessed( $self )
0.000000,0,0.000000,and my $method = $self->moose_coercion->can( $m ) )
0.000000,0,0.000000,{
0.000000,0,0.000000,return $method->( $self->moose_coercion, @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,_croak q[Can't locate object method "%s" via package "%s"], $m,
0.000000,0,0.000000,ref( $self ) || $self;
0.000000,0,0.000000,} #/ sub AUTOLOAD
0.000000,0,0.000000,
0.000000,0,0.000000,# Private Moose method, but Moo uses this...
0.000000,0,0.000000,sub _compiled_type_coercion {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,if ( @_ ) {
0.000000,0,0.000000,my $thing = $_[0];
0.000000,0,0.000000,if ( blessed( $thing ) and $thing->isa( "Type::Coercion" ) ) {
0.000000,0,0.000000,$self->add_type_coercions( @{ $thing->type_coercion_map } );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( Types::TypeTiny::is_CodeLike( $thing ) ) {
0.000000,0,0.000000,require Types::Standard;
0.000000,0,0.000000,$self->add_type_coercions( Types::Standard::Any(), $thing );
0.000000,0,0.000000,}
0.000000,0,0.000000,} #/ if ( @_ )
0.000000,0,0.000000,$self->compiled_coercion;
0.000000,0,0.000000,} #/ sub _compiled_type_coercion
0.000000,0,0.000000,
0.000000,1,0.000000,*compile_type_coercion = \&compiled_coercion;
0.000000,0,0.000000,sub meta { _croak( "Not really a Moose::Meta::TypeCoercion. Sorry!" ) }
0.000000,0,0.000000,
0.000009,1,0.000009,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
