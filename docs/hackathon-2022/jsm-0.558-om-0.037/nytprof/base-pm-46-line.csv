# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000053,2,0.000027,use 5.008;
0.000000,0,0.000000,package base;
0.000000,0,0.000000,
0.000923,2,0.000461,use strict 'vars';
0.000001,1,0.000001,our $VERSION = '2.27';
0.000001,1,0.000001,$VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000000,0,0.000000,# simplest way to avoid indexing of the package: no package statement
0.000000,0,0.000000,sub base::__inc::unhook { @INC = grep !(ref eq 'CODE' && $_ == $_[0]), @INC }
0.000000,0,0.000000,# instance is blessed array of coderefs to be removed from @INC at scope exit
0.000000,0,0.000000,sub base::__inc::scope_guard::DESTROY { base::__inc::unhook $_ for @{$_[0]} }
0.000000,0,0.000000,
0.000000,0,0.000000,# constant.pm is slow
0.000000,0,0.000000,sub SUCCESS () { 1 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub PUBLIC     () { 2**0  }
0.000000,0,0.000000,sub PRIVATE    () { 2**1  }
0.000000,0,0.000000,sub INHERITED  () { 2**2  }
0.000000,0,0.000000,sub PROTECTED  () { 2**3  }
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000001,1,0.000001,my $Fattr = \%fields::attr;
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_fields {
0.000010,13,0.000001,my($base) = shift;
0.000016,13,0.000001,my $fglob = ${"$base\::"}{FIELDS};
0.000024,13,0.000002,return( ($fglob && 'GLOB' eq ref($fglob) && *$fglob{HASH}) ? 1 : 0 );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_attr {
0.000002,13,0.000000,my($proto) = shift;
0.000005,13,0.000000,my($class) = ref $proto || $proto;
0.000028,13,0.000002,return exists $Fattr->{$class};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_attr {
0.000000,0,0.000000,$Fattr->{$_[0]} = [1] unless $Fattr->{$_[0]};
0.000000,0,0.000000,return $Fattr->{$_[0]};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,if ($] < 5.009) {
0.000000,0,0.000000,*get_fields = sub {
0.000000,0,0.000000,# Shut up a possible typo warning.
0.000000,0,0.000000,() = \%{$_[0].'::FIELDS'};
0.000000,0,0.000000,my $f = \%{$_[0].'::FIELDS'};
0.000000,0,0.000000,
0.000000,0,0.000000,# should be centralized in fields? perhaps
0.000000,0,0.000000,# fields::mk_FIELDS_be_OK. Peh. As long as %{ $package . '::FIELDS' }
0.000000,0,0.000000,# is used here anyway, it doesn't matter.
0.000000,0,0.000000,bless $f, 'pseudohash' if (ref($f) ne 'pseudohash');
0.000000,0,0.000000,
0.000000,0,0.000000,return $f;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,*get_fields = sub {
0.000000,0,0.000000,# Shut up a possible typo warning.
0.000000,0,0.000000,() = \%{$_[0].'::FIELDS'};
0.000000,0,0.000000,return \%{$_[0].'::FIELDS'};
0.000000,0,0.000000,}
0.000003,1,0.000003,}
0.000000,0,0.000000,
0.000001,1,0.000001,if ($] < 5.008) {
0.000000,0,0.000000,*_module_to_filename = sub {
0.000000,0,0.000000,(my $fn = $_[0]) =~ s!::!/!g;
0.000000,0,0.000000,$fn .= '.pm';
0.000000,0,0.000000,return $fn;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,*_module_to_filename = sub {
0.000076,13,0.000006,(my $fn = $_[0]) =~ s!::!/!g;
0.000008,13,0.000001,$fn .= '.pm';
0.000051,13,0.000004,utf8::encode($fn);
0.000034,13,0.000003,return $fn;
0.000000,0,0.000000,}
0.000001,1,0.000001,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000007,13,0.000001,my $class = shift;
0.000000,0,0.000000,
0.000004,13,0.000000,return SUCCESS unless @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# List of base classes from which we will inherit %FIELDS.
0.000003,13,0.000000,my $fields_base;
0.000000,0,0.000000,
0.000010,13,0.000001,my $inheritor = caller(0);
0.000000,0,0.000000,
0.000002,13,0.000000,my @bases;
0.000011,13,0.000001,foreach my $base (@_) {
0.000009,13,0.000001,if ( $inheritor eq $base ) {
0.000000,0,0.000000,warn "Class '$inheritor' tried to inherit from itself\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000201,13,0.000015,next if grep $_->isa($base), ($inheritor, @bases);
0.000000,0,0.000000,
0.000000,0,0.000000,# Following blocks help isolate $SIG{__DIE__} and @INC changes
0.000000,0,0.000000,{
0.000009,26,0.000000,my $sigdie;
0.000000,0,0.000000,{
0.000038,26,0.000001,local $SIG{__DIE__};
0.000038,13,0.000003,my $fn = _module_to_filename($base);
0.000002,13,0.000000,my $dot_hidden;
0.000004,13,0.000000,eval {
0.000000,13,0.000000,my $guard;
0.000008,13,0.000001,if ($INC[-1] eq '.' && %{"$base\::"}) {
0.000000,0,0.000000,# So:  the package already exists   => this an optional load
0.000000,0,0.000000,# And: there is a dot at the end of @INC  => we want to hide it
0.000000,0,0.000000,# However: we only want to hide it during our *own* require()
0.000000,0,0.000000,# (i.e. without affecting nested require()s).
0.000000,0,0.000000,# So we add a hook to @INC whose job is to hide the dot, but which
0.000000,0,0.000000,# first checks checks the callstack depth, because within nested
0.000000,0,0.000000,# require()s the callstack is deeper.
0.000000,0,0.000000,# Since CORE::GLOBAL::require makes it unknowable in advance what
0.000000,0,0.000000,# the exact relevant callstack depth will be, we have to record it
0.000000,0,0.000000,# inside a hook. So we put another hook just for that at the front
0.000000,0,0.000000,# of @INC, where it's guaranteed to run -- immediately.
0.000000,0,0.000000,# The dot-hiding hook does its job by sitting directly in front of
0.000000,0,0.000000,# the dot and removing itself from @INC when reached. This causes
0.000000,0,0.000000,# the dot to move up one index in @INC, causing the loop inside
0.000000,0,0.000000,# pp_require() to skip it.
0.000000,0,0.000000,# Loaded coded may disturb this precise arrangement, but that's OK
0.000000,0,0.000000,# because the hook is inert by that time. It is only active during
0.000000,0,0.000000,# the top-level require(), when @INC is in our control. The only
0.000000,0,0.000000,# possible gotcha is if other hooks already in @INC modify @INC in
0.000000,0,0.000000,# some way during that initial require().
0.000000,0,0.000000,# Note that this jiggery hookery works just fine recursively: if
0.000000,0,0.000000,# a module loaded via base.pm uses base.pm itself, there will be
0.000000,0,0.000000,# one pair of hooks in @INC per base::import call frame, but the
0.000000,0,0.000000,# pairs from different nestings do not interfere with each other.
0.000000,0,0.000000,my $lvl;
0.000000,0,0.000000,unshift @INC,        sub { return if defined $lvl; 1 while defined caller ++$lvl; () };
0.000000,0,0.000000,splice  @INC, -1, 0, sub { return if defined caller $lvl; ++$dot_hidden, &base::__inc::unhook; () };
0.000000,0,0.000000,$guard = bless [ @INC[0,-2] ], 'base::__inc::scope_guard';
0.000000,0,0.000000,}
0.000203,13,0.000016,require $fn
0.000000,0,0.000000,};
0.000005,13,0.000000,if ($dot_hidden && (my @fn = grep -e && !( -d _ || -b _ ), $fn.'c', $fn)) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak(<<ERROR);
0.000000,0,0.000000,Base class package "$base" is not empty but "$fn[0]" exists in the current directory.
0.000000,0,0.000000,To help avoid security issues, base.pm now refuses to load optional modules
0.000000,0,0.000000,from the current working directory when it is the last entry in \@INC.
0.000000,0,0.000000,If your software worked on previous versions of Perl, the best solution
0.000000,0,0.000000,is to use FindBin to detect the path properly and to add that path to
0.000000,0,0.000000,\@INC.  As a last resort, you can re-enable looking in the current working
0.000000,0,0.000000,directory by adding "use lib '.'" to your code.
0.000000,0,0.000000,ERROR
0.000000,0,0.000000,}
0.000000,0,0.000000,# Only ignore "Can't locate" errors from our eval require.
0.000000,0,0.000000,# Other fatal errors (syntax etc) must be reported.
0.000000,0,0.000000,#
0.000000,0,0.000000,# changing the check here is fragile - if the check
0.000000,0,0.000000,# here isn't catching every error you want, you should
0.000000,0,0.000000,# probably be using parent.pm, which doesn't try to
0.000000,0,0.000000,# guess whether require is needed or failed,
0.000000,0,0.000000,# see [perl #118561]
0.000247,13,0.000019,die if $@ && $@ !~ /^Can't locate \Q$fn\E .*? at .* line [0-9]+(?:, <[^>]*> (?:line|chunk) [0-9]+)?\.\n\z/s
0.000000,0,0.000000,|| $@ =~ /Compilation failed in require at .* line [0-9]+(?:, <[^>]*> (?:line|chunk) [0-9]+)?\.\n\z/;
0.000023,13,0.000002,unless (%{"$base\::"}) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,local $" = " ";
0.000000,0,0.000000,Carp::croak(<<ERROR);
0.000000,0,0.000000,Base class package "$base" is empty.
0.000000,0,0.000000,(Perhaps you need to 'use' the module which defines that package first,
0.000000,0,0.000000,or make that module available in \@INC (\@INC contains: @INC).
0.000000,0,0.000000,ERROR
0.000000,0,0.000000,}
0.000042,13,0.000003,$sigdie = $SIG{__DIE__} || undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,# Make sure a global $SIG{__DIE__} makes it out of the localization.
0.000004,13,0.000000,$SIG{__DIE__} = $sigdie if defined $sigdie;
0.000000,0,0.000000,}
0.000005,13,0.000000,push @bases, $base;
0.000000,0,0.000000,
0.000041,13,0.000003,if ( has_fields($base) || has_attr($base) ) {
0.000000,0,0.000000,# No multiple fields inheritance *suck*
0.000000,0,0.000000,if ($fields_base) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Can't multiply inherit fields");
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$fields_base = $base;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,# Save this until the end so it's all or nothing if the above loop croaks.
0.000118,13,0.000009,push @{"$inheritor\::ISA"}, @bases;
0.000000,0,0.000000,
0.000053,13,0.000004,if( defined $fields_base ) {
0.000000,0,0.000000,inherit_fields($inheritor, $fields_base);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub inherit_fields {
0.000000,0,0.000000,my($derived, $base) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return SUCCESS unless $base;
0.000000,0,0.000000,
0.000000,0,0.000000,my $battr = get_attr($base);
0.000000,0,0.000000,my $dattr = get_attr($derived);
0.000000,0,0.000000,my $dfields = get_fields($derived);
0.000000,0,0.000000,my $bfields = get_fields($base);
0.000000,0,0.000000,
0.000000,0,0.000000,$dattr->[0] = @$battr;
0.000000,0,0.000000,
0.000000,0,0.000000,if( keys %$dfields ) {
0.000000,0,0.000000,warn <<"END";
0.000000,0,0.000000,$derived is inheriting from $base but already has its own fields!
0.000000,0,0.000000,This will cause problems.  Be sure you use base BEFORE declaring fields.
0.000000,0,0.000000,END
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Iterate through the base's fields adding all the non-private
0.000000,0,0.000000,# ones to the derived class.  Hang on to the original attribute
0.000000,0,0.000000,# (Public, Private, etc...) and add Inherited.
0.000000,0,0.000000,# This is all too complicated to do efficiently with add_fields().
0.000000,0,0.000000,while (my($k,$v) = each %$bfields) {
0.000000,0,0.000000,my $fno;
0.000000,0,0.000000,if ($fno = $dfields->{$k} and $fno != $v) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak ("Inherited fields can't override existing fields");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if( $battr->[$v] & PRIVATE ) {
0.000000,0,0.000000,$dattr->[$v] = PRIVATE | INHERITED;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$dattr->[$v] = INHERITED | $battr->[$v];
0.000000,0,0.000000,$dfields->{$k} = $v;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $idx (1..$#{$battr}) {
0.000000,0,0.000000,next if defined $dattr->[$idx];
0.000000,0,0.000000,$dattr->[$idx] = $battr->[$idx] & INHERITED;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
