# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Tie::Hash;
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '1.06';
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,Tie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,package NewHash;
0.000000,0,0.000000,require Tie::Hash;
0.000000,0,0.000000,
0.000000,0,0.000000,@ISA = qw(Tie::Hash);
0.000000,0,0.000000,
0.000000,0,0.000000,sub DELETE { ... }		# Provides needed method
0.000000,0,0.000000,sub CLEAR { ... }		# Overrides inherited method
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,package NewStdHash;
0.000000,0,0.000000,require Tie::Hash;
0.000000,0,0.000000,
0.000000,0,0.000000,@ISA = qw(Tie::StdHash);
0.000000,0,0.000000,
0.000000,0,0.000000,# All methods provided by default, define
0.000000,0,0.000000,# only those needing overrides
0.000000,0,0.000000,# Accessors access the storage in %{$_[0]};
0.000000,0,0.000000,# TIEHASH should return a reference to the actual storage
0.000000,0,0.000000,sub DELETE { ... }
0.000000,0,0.000000,
0.000000,0,0.000000,package NewExtraHash;
0.000000,0,0.000000,require Tie::Hash;
0.000000,0,0.000000,
0.000000,0,0.000000,@ISA = qw(Tie::ExtraHash);
0.000000,0,0.000000,
0.000000,0,0.000000,# All methods provided by default, define 
0.000000,0,0.000000,# only those needing overrides
0.000000,0,0.000000,# Accessors access the storage in %{$_[0][0]};
0.000000,0,0.000000,# TIEHASH should return an array reference with the first element
0.000000,0,0.000000,# being the reference to the actual storage 
0.000000,0,0.000000,sub DELETE { 
0.000000,0,0.000000,$_[0][1]->('del', $_[0][0], $_[1]); # Call the report writer
0.000000,0,0.000000,delete $_[0][0]->{$_[1]};		  #  $_[0]->SUPER::DELETE($_[1])
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,package main;
0.000000,0,0.000000,
0.000000,0,0.000000,tie %new_hash, 'NewHash';
0.000000,0,0.000000,tie %new_std_hash, 'NewStdHash';
0.000000,0,0.000000,tie %new_extra_hash, 'NewExtraHash',
0.000000,0,0.000000,sub {warn "Doing \U$_[1]\E of $_[2].\n"};
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,This module provides some skeletal methods for hash-tying classes. See
0.000000,0,0.000000,L<perltie> for a list of the functions required in order to tie a hash
0.000000,0,0.000000,to a package. The basic B<Tie::Hash> package provides a C<new> method, as well
0.000000,0,0.000000,as methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and
0.000000,0,0.000000,B<Tie::ExtraHash> packages
0.000000,0,0.000000,provide most methods for hashes described in L<perltie> (the exceptions
0.000000,0,0.000000,are C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,
0.000000,0,0.000000,and allow for selective overwriting of methods.  B<Tie::Hash> has legacy support for the
0.000000,0,0.000000,C<new> method: it is used if C<TIEHASH> is not defined
0.000000,0,0.000000,in the case a class forgets to include a C<TIEHASH> method.
0.000000,0,0.000000,
0.000000,0,0.000000,For developers wishing to write their own tied hashes, the required methods
0.000000,0,0.000000,are briefly defined below. See the L<perltie> section for more detailed
0.000000,0,0.000000,descriptive, as well as example code:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item TIEHASH classname, LIST
0.000000,0,0.000000,
0.000000,0,0.000000,The method invoked by the command C<tie %hash, classname>. Associates a new
0.000000,0,0.000000,hash instance with the specified class. C<LIST> would represent additional
0.000000,0,0.000000,arguments (along the lines of L<AnyDBM_File> and compatriots) needed to
0.000000,0,0.000000,complete the association.
0.000000,0,0.000000,
0.000000,0,0.000000,=item STORE this, key, value
0.000000,0,0.000000,
0.000000,0,0.000000,Store datum I<value> into I<key> for the tied hash I<this>.
0.000000,0,0.000000,
0.000000,0,0.000000,=item FETCH this, key
0.000000,0,0.000000,
0.000000,0,0.000000,Retrieve the datum in I<key> for the tied hash I<this>.
0.000000,0,0.000000,
0.000000,0,0.000000,=item FIRSTKEY this
0.000000,0,0.000000,
0.000000,0,0.000000,Return the first key in the hash.
0.000000,0,0.000000,
0.000000,0,0.000000,=item NEXTKEY this, lastkey
0.000000,0,0.000000,
0.000000,0,0.000000,Return the next key in the hash.
0.000000,0,0.000000,
0.000000,0,0.000000,=item EXISTS this, key
0.000000,0,0.000000,
0.000000,0,0.000000,Verify that I<key> exists with the tied hash I<this>.
0.000000,0,0.000000,
0.000000,0,0.000000,The B<Tie::Hash> implementation is a stub that simply croaks.
0.000000,0,0.000000,
0.000000,0,0.000000,=item DELETE this, key
0.000000,0,0.000000,
0.000000,0,0.000000,Delete the key I<key> from the tied hash I<this>.
0.000000,0,0.000000,
0.000000,0,0.000000,=item CLEAR this
0.000000,0,0.000000,
0.000000,0,0.000000,Clear all values from the tied hash I<this>.
0.000000,0,0.000000,
0.000000,0,0.000000,=item SCALAR this
0.000000,0,0.000000,
0.000000,0,0.000000,Returns what evaluating the hash in scalar context yields.
0.000000,0,0.000000,
0.000000,0,0.000000,B<Tie::Hash> does not implement this method (but B<Tie::StdHash>
0.000000,0,0.000000,and B<Tie::ExtraHash> do).
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 Inheriting from B<Tie::StdHash>
0.000000,0,0.000000,
0.000000,0,0.000000,The accessor methods assume that the actual storage for the data in the tied
0.000000,0,0.000000,hash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten
0.000000,0,0.000000,C<TIEHASH> method should return a hash reference, and the remaining methods
0.000000,0,0.000000,should operate on the hash referenced by the first argument:
0.000000,0,0.000000,
0.000000,0,0.000000,package ReportHash;
0.000000,0,0.000000,our @ISA = 'Tie::StdHash';
0.000000,0,0.000000,
0.000000,0,0.000000,sub TIEHASH  {
0.000000,0,0.000000,my $storage = bless {}, shift;
0.000000,0,0.000000,warn "New ReportHash created, stored in $storage.\n";
0.000000,0,0.000000,$storage
0.000000,0,0.000000,}
0.000000,0,0.000000,sub STORE    {
0.000000,0,0.000000,warn "Storing data with key $_[1] at $_[0].\n";
0.000000,0,0.000000,$_[0]{$_[1]} = $_[2]
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 Inheriting from B<Tie::ExtraHash>
0.000000,0,0.000000,
0.000000,0,0.000000,The accessor methods assume that the actual storage for the data in the tied
0.000000,0,0.000000,hash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten
0.000000,0,0.000000,C<TIEHASH> method should return an array reference with the first
0.000000,0,0.000000,element being a hash reference, and the remaining methods should operate on the
0.000000,0,0.000000,hash C<< %{ $_[0]->[0] } >>:
0.000000,0,0.000000,
0.000000,0,0.000000,package ReportHash;
0.000000,0,0.000000,our @ISA = 'Tie::ExtraHash';
0.000000,0,0.000000,
0.000000,0,0.000000,sub TIEHASH  {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $storage = bless [{}, @_], $class;
0.000000,0,0.000000,warn "New ReportHash created, stored in $storage.\n";
0.000000,0,0.000000,$storage;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub STORE    {
0.000000,0,0.000000,warn "Storing data with key $_[1] at $_[0].\n";
0.000000,0,0.000000,$_[0][0]{$_[1]} = $_[2]
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,The default C<TIEHASH> method stores "extra" arguments to tie() starting
0.000000,0,0.000000,from offset 1 in the array referenced by C<tied(%tiedhash)>; this is the
0.000000,0,0.000000,same storage algorithm as in TIEHASH subroutine above.  Hence, a typical
0.000000,0,0.000000,package inheriting from B<Tie::ExtraHash> does not need to overwrite this
0.000000,0,0.000000,method.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>
0.000000,0,0.000000,
0.000000,0,0.000000,The methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,
0.000000,0,0.000000,B<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require
0.000000,0,0.000000,presence of these methods, but if defined, the methods will be called in
0.000000,0,0.000000,proper time, see L<perltie>.
0.000000,0,0.000000,
0.000000,0,0.000000,C<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.
0.000000,0,0.000000,
0.000000,0,0.000000,If needed, these methods should be defined by the package inheriting from
0.000000,0,0.000000,B<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<perltie/"SCALAR">
0.000000,0,0.000000,to find out what happens when C<SCALAR> does not exist.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 MORE INFORMATION
0.000000,0,0.000000,
0.000000,0,0.000000,The packages relating to various DBM-related implementations (F<DB_File>,
0.000000,0,0.000000,F<NDBM_File>, etc.) show examples of general tied hashes, as does the
0.000000,0,0.000000,L<Config> module. While these do not utilize B<Tie::Hash>, they serve as
0.000000,0,0.000000,good working examples.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000046,2,0.000023,use Carp;
0.000821,2,0.000411,use warnings::register;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my $pkg = shift;
0.000000,0,0.000000,$pkg->TIEHASH(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Legacy support for new()
0.000000,0,0.000000,
0.000000,0,0.000000,sub TIEHASH {
0.000000,0,0.000000,my $pkg = shift;
0.000000,0,0.000000,my $pkg_new = $pkg -> can ('new');
0.000000,0,0.000000,
0.000000,0,0.000000,if ($pkg_new and $pkg ne __PACKAGE__) {
0.000000,0,0.000000,my $my_new = __PACKAGE__ -> can ('new');
0.000000,0,0.000000,if ($pkg_new == $my_new) {  
0.000000,0,0.000000,#
0.000000,0,0.000000,# Prevent recursion
0.000000,0,0.000000,#
0.000000,0,0.000000,croak "$pkg must define either a TIEHASH() or a new() method";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,warnings::warnif ("WARNING: calling ${pkg}->new since " .
0.000000,0,0.000000,"${pkg}->TIEHASH is missing");
0.000000,0,0.000000,$pkg -> new (@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,croak "$pkg doesn't define a TIEHASH method";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub EXISTS {
0.000000,0,0.000000,my $pkg = ref $_[0];
0.000000,0,0.000000,croak "$pkg doesn't define an EXISTS method";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub CLEAR {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $key = $self->FIRSTKEY(@_);
0.000000,0,0.000000,my @keys;
0.000000,0,0.000000,
0.000000,0,0.000000,while (defined $key) {
0.000000,0,0.000000,push @keys, $key;
0.000000,0,0.000000,$key = $self->NEXTKEY(@_, $key);
0.000000,0,0.000000,}
0.000000,0,0.000000,foreach $key (@keys) {
0.000000,0,0.000000,$self->DELETE(@_, $key);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# The Tie::StdHash package implements standard perl hash behaviour.
0.000000,0,0.000000,# It exists to act as a base class for classes which only wish to
0.000000,0,0.000000,# alter some parts of their behaviour.
0.000000,0,0.000000,
0.000000,0,0.000000,package Tie::StdHash;
0.000000,0,0.000000,# @ISA = qw(Tie::Hash);		# would inherit new() only
0.000000,0,0.000000,
0.000006,1,0.000006,sub TIEHASH  { bless {}, $_[0] }
0.000000,0,0.000000,sub STORE    { $_[0]->{$_[1]} = $_[2] }
0.000000,0,0.000000,sub FETCH    { $_[0]->{$_[1]} }
0.000000,0,0.000000,sub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }
0.000000,0,0.000000,sub NEXTKEY  { each %{$_[0]} }
0.000000,0,0.000000,sub EXISTS   { exists $_[0]->{$_[1]} }
0.000000,0,0.000000,sub DELETE   { delete $_[0]->{$_[1]} }
0.000000,0,0.000000,sub CLEAR    { %{$_[0]} = () }
0.000000,0,0.000000,sub SCALAR   { scalar %{$_[0]} }
0.000000,0,0.000000,
0.000000,0,0.000000,package Tie::ExtraHash;
0.000000,0,0.000000,
0.000000,0,0.000000,sub TIEHASH  { my $p = shift; bless [{}, @_], $p }
0.000000,0,0.000000,sub STORE    { $_[0][0]{$_[1]} = $_[2] }
0.000000,0,0.000000,sub FETCH    { $_[0][0]{$_[1]} }
0.000000,0,0.000000,sub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }
0.000000,0,0.000000,sub NEXTKEY  { each %{$_[0][0]} }
0.000000,0,0.000000,sub EXISTS   { exists $_[0][0]->{$_[1]} }
0.000000,0,0.000000,sub DELETE   { delete $_[0][0]->{$_[1]} }
0.000000,0,0.000000,sub CLEAR    { %{$_[0][0]} = () }
0.000000,0,0.000000,sub SCALAR   { scalar %{$_[0][0]} }
0.000000,0,0.000000,
0.000006,1,0.000006,1;
