# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Socket;
0.000000,0,0.000000,
0.000021,2,0.000011,use strict;
0.000229,2,0.000115,{ use v5.6.1; }
0.000000,0,0.000000,
0.000001,2,0.000000,our $VERSION = '2.033';
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,C<Socket> - networking constants and support functions
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,C<Socket> a low-level module used by, among other things, the L<IO::Socket>
0.000000,0,0.000000,family of modules. The following examples demonstrate some low-level uses but
0.000000,0,0.000000,a practical program would likely use the higher-level API provided by
0.000000,0,0.000000,C<IO::Socket> or similar instead.
0.000000,0,0.000000,
0.000000,0,0.000000,use Socket qw(PF_INET SOCK_STREAM pack_sockaddr_in inet_aton);
0.000000,0,0.000000,
0.000000,0,0.000000,socket(my $socket, PF_INET, SOCK_STREAM, 0)
0.000000,0,0.000000,or die "socket: $!";
0.000000,0,0.000000,
0.000000,0,0.000000,my $port = getservbyname "echo", "tcp";
0.000000,0,0.000000,connect($socket, pack_sockaddr_in($port, inet_aton("localhost")))
0.000000,0,0.000000,or die "connect: $!";
0.000000,0,0.000000,
0.000000,0,0.000000,print $socket "Hello, world!\n";
0.000000,0,0.000000,print <$socket>;
0.000000,0,0.000000,
0.000000,0,0.000000,See also the L</EXAMPLES> section.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,This module provides a variety of constants, structure manipulators and other
0.000000,0,0.000000,functions related to socket-based networking. The values and functions
0.000000,0,0.000000,provided are useful when used in conjunction with Perl core functions such as
0.000000,0,0.000000,socket(), setsockopt() and bind(). It also provides several other support
0.000000,0,0.000000,functions, mostly for dealing with conversions of network addresses between
0.000000,0,0.000000,human-readable and native binary forms, and for hostname resolver operations.
0.000000,0,0.000000,
0.000000,0,0.000000,Some constants and functions are exported by default by this module; but for
0.000000,0,0.000000,backward-compatibility any recently-added symbols are not exported by default
0.000000,0,0.000000,and must be requested explicitly. When an import list is provided to the
0.000000,0,0.000000,C<use Socket> line, the default exports are not automatically imported. It is
0.000000,0,0.000000,therefore best practice to always to explicitly list all the symbols required.
0.000000,0,0.000000,
0.000000,0,0.000000,Also, some common socket "newline" constants are provided: the constants
0.000000,0,0.000000,C<CR>, C<LF>, and C<CRLF>, as well as C<$CR>, C<$LF>, and C<$CRLF>, which map
0.000000,0,0.000000,to C<\015>, C<\012>, and C<\015\012>. If you do not want to use the literal
0.000000,0,0.000000,characters in your programs, then use the constants provided here. They are
0.000000,0,0.000000,not exported by default, but can be imported individually, and with the
0.000000,0,0.000000,C<:crlf> export tag:
0.000000,0,0.000000,
0.000000,0,0.000000,use Socket qw(:DEFAULT :crlf);
0.000000,0,0.000000,
0.000000,0,0.000000,$sock->print("GET / HTTP/1.0$CRLF");
0.000000,0,0.000000,
0.000000,0,0.000000,The entire getaddrinfo() subsystem can be exported using the tag C<:addrinfo>;
0.000000,0,0.000000,this exports the getaddrinfo() and getnameinfo() functions, and all the
0.000000,0,0.000000,C<AI_*>, C<NI_*>, C<NIx_*> and C<EAI_*> constants.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 CONSTANTS
0.000000,0,0.000000,
0.000000,0,0.000000,In each of the following groups, there may be many more constants provided
0.000000,0,0.000000,than just the ones given as examples in the section heading. If the heading
0.000000,0,0.000000,ends C<...> then this means there are likely more; the exact constants
0.000000,0,0.000000,provided will depend on the OS and headers found at compile-time.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 PF_INET, PF_INET6, PF_UNIX, ...
0.000000,0,0.000000,
0.000000,0,0.000000,Protocol family constants to use as the first argument to socket() or the
0.000000,0,0.000000,value of the C<SO_DOMAIN> or C<SO_FAMILY> socket option.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 AF_INET, AF_INET6, AF_UNIX, ...
0.000000,0,0.000000,
0.000000,0,0.000000,Address family constants used by the socket address structures, to pass to
0.000000,0,0.000000,such functions as inet_pton() or getaddrinfo(), or are returned by such
0.000000,0,0.000000,functions as sockaddr_family().
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, ...
0.000000,0,0.000000,
0.000000,0,0.000000,Socket type constants to use as the second argument to socket(), or the value
0.000000,0,0.000000,of the C<SO_TYPE> socket option.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 SOCK_NONBLOCK. SOCK_CLOEXEC
0.000000,0,0.000000,
0.000000,0,0.000000,Linux-specific shortcuts to specify the C<O_NONBLOCK> and C<FD_CLOEXEC> flags
0.000000,0,0.000000,during a C<socket(2)> call.
0.000000,0,0.000000,
0.000000,0,0.000000,socket( my $sockh, PF_INET, SOCK_DGRAM|SOCK_NONBLOCK, 0 )
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 SOL_SOCKET
0.000000,0,0.000000,
0.000000,0,0.000000,Socket option level constant for setsockopt() and getsockopt().
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 SO_ACCEPTCONN, SO_BROADCAST, SO_ERROR, ...
0.000000,0,0.000000,
0.000000,0,0.000000,Socket option name constants for setsockopt() and getsockopt() at the
0.000000,0,0.000000,C<SOL_SOCKET> level.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 IP_OPTIONS, IP_TOS, IP_TTL, ...
0.000000,0,0.000000,
0.000000,0,0.000000,Socket option name constants for IPv4 socket options at the C<IPPROTO_IP>
0.000000,0,0.000000,level.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 IP_PMTUDISC_WANT, IP_PMTUDISC_DONT, ...
0.000000,0,0.000000,
0.000000,0,0.000000,Socket option value constants for C<IP_MTU_DISCOVER> socket option.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 IPTOS_LOWDELAY, IPTOS_THROUGHPUT, IPTOS_RELIABILITY, ...
0.000000,0,0.000000,
0.000000,0,0.000000,Socket option value constants for C<IP_TOS> socket option.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 MSG_BCAST, MSG_OOB, MSG_TRUNC, ...
0.000000,0,0.000000,
0.000000,0,0.000000,Message flag constants for send() and recv().
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 SHUT_RD, SHUT_RDWR, SHUT_WR
0.000000,0,0.000000,
0.000000,0,0.000000,Direction constants for shutdown().
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 INADDR_ANY, INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE
0.000000,0,0.000000,
0.000000,0,0.000000,Constants giving the special C<AF_INET> addresses for wildcard, broadcast,
0.000000,0,0.000000,local loopback, and invalid addresses.
0.000000,0,0.000000,
0.000000,0,0.000000,Normally equivalent to inet_aton('0.0.0.0'), inet_aton('255.255.255.255'),
0.000000,0,0.000000,inet_aton('localhost') and inet_aton('255.255.255.255') respectively.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, ...
0.000000,0,0.000000,
0.000000,0,0.000000,IP protocol constants to use as the third argument to socket(), the level
0.000000,0,0.000000,argument to getsockopt() or setsockopt(), or the value of the C<SO_PROTOCOL>
0.000000,0,0.000000,socket option.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ...
0.000000,0,0.000000,
0.000000,0,0.000000,Socket option name constants for TCP socket options at the C<IPPROTO_TCP>
0.000000,0,0.000000,level.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 IN6ADDR_ANY, IN6ADDR_LOOPBACK
0.000000,0,0.000000,
0.000000,0,0.000000,Constants giving the special C<AF_INET6> addresses for wildcard and local
0.000000,0,0.000000,loopback.
0.000000,0,0.000000,
0.000000,0,0.000000,Normally equivalent to inet_pton(AF_INET6, "::") and
0.000000,0,0.000000,inet_pton(AF_INET6, "::1") respectively.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 IPV6_ADD_MEMBERSHIP, IPV6_MTU, IPV6_V6ONLY, ...
0.000000,0,0.000000,
0.000000,0,0.000000,Socket option name constants for IPv6 socket options at the C<IPPROTO_IPV6>
0.000000,0,0.000000,level.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,# Still undocumented: SCM_*, SOMAXCONN, IOV_MAX, UIO_MAXIOV
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 STRUCTURE MANIPULATORS
0.000000,0,0.000000,
0.000000,0,0.000000,The following functions convert between lists of Perl values and packed binary
0.000000,0,0.000000,strings representing structures.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 $family = sockaddr_family $sockaddr
0.000000,0,0.000000,
0.000000,0,0.000000,Takes a packed socket address (as returned by pack_sockaddr_in(),
0.000000,0,0.000000,pack_sockaddr_un() or the perl builtin functions getsockname() and
0.000000,0,0.000000,getpeername()). Returns the address family tag. This will be one of the
0.000000,0,0.000000,C<AF_*> constants, such as C<AF_INET> for a C<sockaddr_in> addresses or
0.000000,0,0.000000,C<AF_UNIX> for a C<sockaddr_un>. It can be used to figure out what unpack to
0.000000,0,0.000000,use for a sockaddr of unknown type.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 $sockaddr = pack_sockaddr_in $port, $ip_address
0.000000,0,0.000000,
0.000000,0,0.000000,Takes two arguments, a port number and an opaque string (as returned by
0.000000,0,0.000000,inet_aton(), or a v-string). Returns the C<sockaddr_in> structure with those
0.000000,0,0.000000,arguments packed in and C<AF_INET> filled in. For Internet domain sockets,
0.000000,0,0.000000,this structure is normally what you need for the arguments in bind(),
0.000000,0,0.000000,connect(), and send().
0.000000,0,0.000000,
0.000000,0,0.000000,An undefined $port argument is taken as zero; an undefined $ip_address is
0.000000,0,0.000000,considered a fatal error.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 ($port, $ip_address) = unpack_sockaddr_in $sockaddr
0.000000,0,0.000000,
0.000000,0,0.000000,Takes a C<sockaddr_in> structure (as returned by pack_sockaddr_in(),
0.000000,0,0.000000,getpeername() or recv()). Returns a list of two elements: the port and an
0.000000,0,0.000000,opaque string representing the IP address (you can use inet_ntoa() to convert
0.000000,0,0.000000,the address to the four-dotted numeric format). Will croak if the structure
0.000000,0,0.000000,does not represent an C<AF_INET> address.
0.000000,0,0.000000,
0.000000,0,0.000000,In scalar context will return just the IP address.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 $sockaddr = sockaddr_in $port, $ip_address
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 ($port, $ip_address) = sockaddr_in $sockaddr
0.000000,0,0.000000,
0.000000,0,0.000000,A wrapper of pack_sockaddr_in() or unpack_sockaddr_in(). In list context,
0.000000,0,0.000000,unpacks its argument and returns a list consisting of the port and IP address.
0.000000,0,0.000000,In scalar context, packs its port and IP address arguments as a C<sockaddr_in>
0.000000,0,0.000000,and returns it.
0.000000,0,0.000000,
0.000000,0,0.000000,Provided largely for legacy compatibility; it is better to use
0.000000,0,0.000000,pack_sockaddr_in() or unpack_sockaddr_in() explicitly.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 $sockaddr = pack_sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]
0.000000,0,0.000000,
0.000000,0,0.000000,Takes two to four arguments, a port number, an opaque string (as returned by
0.000000,0,0.000000,inet_pton()), optionally a scope ID number, and optionally a flow label
0.000000,0,0.000000,number. Returns the C<sockaddr_in6> structure with those arguments packed in
0.000000,0,0.000000,and C<AF_INET6> filled in. IPv6 equivalent of pack_sockaddr_in().
0.000000,0,0.000000,
0.000000,0,0.000000,An undefined $port argument is taken as zero; an undefined $ip6_address is
0.000000,0,0.000000,considered a fatal error.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 ($port, $ip6_address, $scope_id, $flowinfo) = unpack_sockaddr_in6 $sockaddr
0.000000,0,0.000000,
0.000000,0,0.000000,Takes a C<sockaddr_in6> structure. Returns a list of four elements: the port
0.000000,0,0.000000,number, an opaque string representing the IPv6 address, the scope ID, and the
0.000000,0,0.000000,flow label. (You can use inet_ntop() to convert the address to the usual
0.000000,0,0.000000,string format). Will croak if the structure does not represent an C<AF_INET6>
0.000000,0,0.000000,address.
0.000000,0,0.000000,
0.000000,0,0.000000,In scalar context will return just the IP address.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 $sockaddr = sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 ($port, $ip6_address, $scope_id, $flowinfo) = sockaddr_in6 $sockaddr
0.000000,0,0.000000,
0.000000,0,0.000000,A wrapper of pack_sockaddr_in6() or unpack_sockaddr_in6(). In list context,
0.000000,0,0.000000,unpacks its argument according to unpack_sockaddr_in6(). In scalar context,
0.000000,0,0.000000,packs its arguments according to pack_sockaddr_in6().
0.000000,0,0.000000,
0.000000,0,0.000000,Provided largely for legacy compatibility; it is better to use
0.000000,0,0.000000,pack_sockaddr_in6() or unpack_sockaddr_in6() explicitly.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 $sockaddr = pack_sockaddr_un $path
0.000000,0,0.000000,
0.000000,0,0.000000,Takes one argument, a pathname. Returns the C<sockaddr_un> structure with that
0.000000,0,0.000000,path packed in with C<AF_UNIX> filled in. For C<PF_UNIX> sockets, this
0.000000,0,0.000000,structure is normally what you need for the arguments in bind(), connect(),
0.000000,0,0.000000,and send().
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 ($path) = unpack_sockaddr_un $sockaddr
0.000000,0,0.000000,
0.000000,0,0.000000,Takes a C<sockaddr_un> structure (as returned by pack_sockaddr_un(),
0.000000,0,0.000000,getpeername() or recv()). Returns a list of one element: the pathname. Will
0.000000,0,0.000000,croak if the structure does not represent an C<AF_UNIX> address.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 $sockaddr = sockaddr_un $path
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 ($path) = sockaddr_un $sockaddr
0.000000,0,0.000000,
0.000000,0,0.000000,A wrapper of pack_sockaddr_un() or unpack_sockaddr_un(). In a list context,
0.000000,0,0.000000,unpacks its argument and returns a list consisting of the pathname. In a
0.000000,0,0.000000,scalar context, packs its pathname as a C<sockaddr_un> and returns it.
0.000000,0,0.000000,
0.000000,0,0.000000,Provided largely for legacy compatibility; it is better to use
0.000000,0,0.000000,pack_sockaddr_un() or unpack_sockaddr_un() explicitly.
0.000000,0,0.000000,
0.000000,0,0.000000,These are only supported if your system has E<lt>F<sys/un.h>E<gt>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 $ip_mreq = pack_ip_mreq $multiaddr, $interface
0.000000,0,0.000000,
0.000000,0,0.000000,Takes an IPv4 multicast address and optionally an interface address (or
0.000000,0,0.000000,C<INADDR_ANY>). Returns the C<ip_mreq> structure with those arguments packed
0.000000,0,0.000000,in. Suitable for use with the C<IP_ADD_MEMBERSHIP> and C<IP_DROP_MEMBERSHIP>
0.000000,0,0.000000,sockopts.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 ($multiaddr, $interface) = unpack_ip_mreq $ip_mreq
0.000000,0,0.000000,
0.000000,0,0.000000,Takes an C<ip_mreq> structure. Returns a list of two elements; the IPv4
0.000000,0,0.000000,multicast address and interface address.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 $ip_mreq_source = pack_ip_mreq_source $multiaddr, $source, $interface
0.000000,0,0.000000,
0.000000,0,0.000000,Takes an IPv4 multicast address, source address, and optionally an interface
0.000000,0,0.000000,address (or C<INADDR_ANY>). Returns the C<ip_mreq_source> structure with those
0.000000,0,0.000000,arguments packed in. Suitable for use with the C<IP_ADD_SOURCE_MEMBERSHIP>
0.000000,0,0.000000,and C<IP_DROP_SOURCE_MEMBERSHIP> sockopts.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 ($multiaddr, $source, $interface) = unpack_ip_mreq_source $ip_mreq
0.000000,0,0.000000,
0.000000,0,0.000000,Takes an C<ip_mreq_source> structure. Returns a list of three elements; the
0.000000,0,0.000000,IPv4 multicast address, source address and interface address.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 $ipv6_mreq = pack_ipv6_mreq $multiaddr6, $ifindex
0.000000,0,0.000000,
0.000000,0,0.000000,Takes an IPv6 multicast address and an interface number. Returns the
0.000000,0,0.000000,C<ipv6_mreq> structure with those arguments packed in. Suitable for use with
0.000000,0,0.000000,the C<IPV6_ADD_MEMBERSHIP> and C<IPV6_DROP_MEMBERSHIP> sockopts.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 ($multiaddr6, $ifindex) = unpack_ipv6_mreq $ipv6_mreq
0.000000,0,0.000000,
0.000000,0,0.000000,Takes an C<ipv6_mreq> structure. Returns a list of two elements; the IPv6
0.000000,0,0.000000,address and an interface number.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 FUNCTIONS
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 $ip_address = inet_aton $string
0.000000,0,0.000000,
0.000000,0,0.000000,Takes a string giving the name of a host, or a textual representation of an IP
0.000000,0,0.000000,address and translates that to an packed binary address structure suitable to
0.000000,0,0.000000,pass to pack_sockaddr_in(). If passed a hostname that cannot be resolved,
0.000000,0,0.000000,returns C<undef>. For multi-homed hosts (hosts with more than one address),
0.000000,0,0.000000,the first address found is returned.
0.000000,0,0.000000,
0.000000,0,0.000000,For portability do not assume that the result of inet_aton() is 32 bits wide,
0.000000,0,0.000000,in other words, that it would contain only the IPv4 address in network order.
0.000000,0,0.000000,
0.000000,0,0.000000,This IPv4-only function is provided largely for legacy reasons. Newly-written
0.000000,0,0.000000,code should use getaddrinfo() or inet_pton() instead for IPv6 support.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 $string = inet_ntoa $ip_address
0.000000,0,0.000000,
0.000000,0,0.000000,Takes a packed binary address structure such as returned by
0.000000,0,0.000000,unpack_sockaddr_in() (or a v-string representing the four octets of the IPv4
0.000000,0,0.000000,address in network order) and translates it into a string of the form
0.000000,0,0.000000,C<d.d.d.d> where the C<d>s are numbers less than 256 (the normal
0.000000,0,0.000000,human-readable four dotted number notation for Internet addresses).
0.000000,0,0.000000,
0.000000,0,0.000000,This IPv4-only function is provided largely for legacy reasons. Newly-written
0.000000,0,0.000000,code should use getnameinfo() or inet_ntop() instead for IPv6 support.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 $address = inet_pton $family, $string
0.000000,0,0.000000,
0.000000,0,0.000000,Takes an address family (such as C<AF_INET> or C<AF_INET6>) and a string
0.000000,0,0.000000,containing a textual representation of an address in that family and
0.000000,0,0.000000,translates that to an packed binary address structure.
0.000000,0,0.000000,
0.000000,0,0.000000,See also getaddrinfo() for a more powerful and flexible function to look up
0.000000,0,0.000000,socket addresses given hostnames or textual addresses.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 $string = inet_ntop $family, $address
0.000000,0,0.000000,
0.000000,0,0.000000,Takes an address family and a packed binary address structure and translates
0.000000,0,0.000000,it into a human-readable textual representation of the address; typically in
0.000000,0,0.000000,C<d.d.d.d> form for C<AF_INET> or C<hhhh:hhhh::hhhh> form for C<AF_INET6>.
0.000000,0,0.000000,
0.000000,0,0.000000,See also getnameinfo() for a more powerful and flexible function to turn
0.000000,0,0.000000,socket addresses into human-readable textual representations.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 ($err, @result) = getaddrinfo $host, $service, [$hints]
0.000000,0,0.000000,
0.000000,0,0.000000,Given both a hostname and service name, this function attempts to resolve the
0.000000,0,0.000000,host name into a list of network addresses, and the service name into a
0.000000,0,0.000000,protocol and port number, and then returns a list of address structures
0.000000,0,0.000000,suitable to connect() to it.
0.000000,0,0.000000,
0.000000,0,0.000000,Given just a host name, this function attempts to resolve it to a list of
0.000000,0,0.000000,network addresses, and then returns a list of address structures giving these
0.000000,0,0.000000,addresses.
0.000000,0,0.000000,
0.000000,0,0.000000,Given just a service name, this function attempts to resolve it to a protocol
0.000000,0,0.000000,and port number, and then returns a list of address structures that represent
0.000000,0,0.000000,it suitable to bind() to. This use should be combined with the C<AI_PASSIVE>
0.000000,0,0.000000,flag; see below.
0.000000,0,0.000000,
0.000000,0,0.000000,Given neither name, it generates an error.
0.000000,0,0.000000,
0.000000,0,0.000000,If present, $hints should be a reference to a hash, where the following keys
0.000000,0,0.000000,are recognised:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item flags => INT
0.000000,0,0.000000,
0.000000,0,0.000000,A bitfield containing C<AI_*> constants; see below.
0.000000,0,0.000000,
0.000000,0,0.000000,=item family => INT
0.000000,0,0.000000,
0.000000,0,0.000000,Restrict to only generating addresses in this address family
0.000000,0,0.000000,
0.000000,0,0.000000,=item socktype => INT
0.000000,0,0.000000,
0.000000,0,0.000000,Restrict to only generating addresses of this socket type
0.000000,0,0.000000,
0.000000,0,0.000000,=item protocol => INT
0.000000,0,0.000000,
0.000000,0,0.000000,Restrict to only generating addresses for this protocol
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,The return value will be a list; the first value being an error indication,
0.000000,0,0.000000,followed by a list of address structures (if no error occurred).
0.000000,0,0.000000,
0.000000,0,0.000000,The error value will be a dualvar; comparable to the C<EAI_*> error constants,
0.000000,0,0.000000,or printable as a human-readable error message string. If no error occurred it
0.000000,0,0.000000,will be zero numerically and an empty string.
0.000000,0,0.000000,
0.000000,0,0.000000,Each value in the results list will be a hash reference containing the following
0.000000,0,0.000000,fields:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item family => INT
0.000000,0,0.000000,
0.000000,0,0.000000,The address family (e.g. C<AF_INET>)
0.000000,0,0.000000,
0.000000,0,0.000000,=item socktype => INT
0.000000,0,0.000000,
0.000000,0,0.000000,The socket type (e.g. C<SOCK_STREAM>)
0.000000,0,0.000000,
0.000000,0,0.000000,=item protocol => INT
0.000000,0,0.000000,
0.000000,0,0.000000,The protocol (e.g. C<IPPROTO_TCP>)
0.000000,0,0.000000,
0.000000,0,0.000000,=item addr => STRING
0.000000,0,0.000000,
0.000000,0,0.000000,The address in a packed string (such as would be returned by
0.000000,0,0.000000,pack_sockaddr_in())
0.000000,0,0.000000,
0.000000,0,0.000000,=item canonname => STRING
0.000000,0,0.000000,
0.000000,0,0.000000,The canonical name for the host if the C<AI_CANONNAME> flag was provided, or
0.000000,0,0.000000,C<undef> otherwise. This field will only be present on the first returned
0.000000,0,0.000000,address.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,The following flag constants are recognised in the $hints hash. Other flag
0.000000,0,0.000000,constants may exist as provided by the OS.
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item AI_PASSIVE
0.000000,0,0.000000,
0.000000,0,0.000000,Indicates that this resolution is for a local bind() for a passive (i.e.
0.000000,0,0.000000,listening) socket, rather than an active (i.e. connecting) socket.
0.000000,0,0.000000,
0.000000,0,0.000000,=item AI_CANONNAME
0.000000,0,0.000000,
0.000000,0,0.000000,Indicates that the caller wishes the canonical hostname (C<canonname>) field
0.000000,0,0.000000,of the result to be filled in.
0.000000,0,0.000000,
0.000000,0,0.000000,=item AI_NUMERICHOST
0.000000,0,0.000000,
0.000000,0,0.000000,Indicates that the caller will pass a numeric address, rather than a hostname,
0.000000,0,0.000000,and that getaddrinfo() must not perform a resolve operation on this name. This
0.000000,0,0.000000,flag will prevent a possibly-slow network lookup operation, and instead return
0.000000,0,0.000000,an error if a hostname is passed.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 ($err, $hostname, $servicename) = getnameinfo $sockaddr, [$flags, [$xflags]]
0.000000,0,0.000000,
0.000000,0,0.000000,Given a packed socket address (such as from getsockname(), getpeername(), or
0.000000,0,0.000000,returned by getaddrinfo() in a C<addr> field), returns the hostname and
0.000000,0,0.000000,symbolic service name it represents. $flags may be a bitmask of C<NI_*>
0.000000,0,0.000000,constants, or defaults to 0 if unspecified.
0.000000,0,0.000000,
0.000000,0,0.000000,The return value will be a list; the first value being an error condition,
0.000000,0,0.000000,followed by the hostname and service name.
0.000000,0,0.000000,
0.000000,0,0.000000,The error value will be a dualvar; comparable to the C<EAI_*> error constants,
0.000000,0,0.000000,or printable as a human-readable error message string. The host and service
0.000000,0,0.000000,names will be plain strings.
0.000000,0,0.000000,
0.000000,0,0.000000,The following flag constants are recognised as $flags. Other flag constants may
0.000000,0,0.000000,exist as provided by the OS.
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item NI_NUMERICHOST
0.000000,0,0.000000,
0.000000,0,0.000000,Requests that a human-readable string representation of the numeric address be
0.000000,0,0.000000,returned directly, rather than performing a name resolve operation that may
0.000000,0,0.000000,convert it into a hostname. This will also avoid potentially-blocking network
0.000000,0,0.000000,IO.
0.000000,0,0.000000,
0.000000,0,0.000000,=item NI_NUMERICSERV
0.000000,0,0.000000,
0.000000,0,0.000000,Requests that the port number be returned directly as a number representation
0.000000,0,0.000000,rather than performing a name resolve operation that may convert it into a
0.000000,0,0.000000,service name.
0.000000,0,0.000000,
0.000000,0,0.000000,=item NI_NAMEREQD
0.000000,0,0.000000,
0.000000,0,0.000000,If a name resolve operation fails to provide a name, then this flag will cause
0.000000,0,0.000000,getnameinfo() to indicate an error, rather than returning the numeric
0.000000,0,0.000000,representation as a human-readable string.
0.000000,0,0.000000,
0.000000,0,0.000000,=item NI_DGRAM
0.000000,0,0.000000,
0.000000,0,0.000000,Indicates that the socket address relates to a C<SOCK_DGRAM> socket, for the
0.000000,0,0.000000,services whose name differs between TCP and UDP protocols.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,The following constants may be supplied as $xflags.
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item NIx_NOHOST
0.000000,0,0.000000,
0.000000,0,0.000000,Indicates that the caller is not interested in the hostname of the result, so
0.000000,0,0.000000,it does not have to be converted. C<undef> will be returned as the hostname.
0.000000,0,0.000000,
0.000000,0,0.000000,=item NIx_NOSERV
0.000000,0,0.000000,
0.000000,0,0.000000,Indicates that the caller is not interested in the service name of the result,
0.000000,0,0.000000,so it does not have to be converted. C<undef> will be returned as the service
0.000000,0,0.000000,name.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 getaddrinfo() / getnameinfo() ERROR CONSTANTS
0.000000,0,0.000000,
0.000000,0,0.000000,The following constants may be returned by getaddrinfo() or getnameinfo().
0.000000,0,0.000000,Others may be provided by the OS.
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item EAI_AGAIN
0.000000,0,0.000000,
0.000000,0,0.000000,A temporary failure occurred during name resolution. The operation may be
0.000000,0,0.000000,successful if it is retried later.
0.000000,0,0.000000,
0.000000,0,0.000000,=item EAI_BADFLAGS
0.000000,0,0.000000,
0.000000,0,0.000000,The value of the C<flags> hint to getaddrinfo(), or the $flags parameter to
0.000000,0,0.000000,getnameinfo() contains unrecognised flags.
0.000000,0,0.000000,
0.000000,0,0.000000,=item EAI_FAMILY
0.000000,0,0.000000,
0.000000,0,0.000000,The C<family> hint to getaddrinfo(), or the family of the socket address
0.000000,0,0.000000,passed to getnameinfo() is not supported.
0.000000,0,0.000000,
0.000000,0,0.000000,=item EAI_NODATA
0.000000,0,0.000000,
0.000000,0,0.000000,The host name supplied to getaddrinfo() did not provide any usable address
0.000000,0,0.000000,data.
0.000000,0,0.000000,
0.000000,0,0.000000,=item EAI_NONAME
0.000000,0,0.000000,
0.000000,0,0.000000,The host name supplied to getaddrinfo() does not exist, or the address
0.000000,0,0.000000,supplied to getnameinfo() is not associated with a host name and the
0.000000,0,0.000000,C<NI_NAMEREQD> flag was supplied.
0.000000,0,0.000000,
0.000000,0,0.000000,=item EAI_SERVICE
0.000000,0,0.000000,
0.000000,0,0.000000,The service name supplied to getaddrinfo() is not available for the socket
0.000000,0,0.000000,type given in the $hints.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 EXAMPLES
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Lookup for connect()
0.000000,0,0.000000,
0.000000,0,0.000000,The getaddrinfo() function converts a hostname and a service name into a list
0.000000,0,0.000000,of structures, each containing a potential way to connect() to the named
0.000000,0,0.000000,service on the named host.
0.000000,0,0.000000,
0.000000,0,0.000000,use IO::Socket;
0.000000,0,0.000000,use Socket qw(SOCK_STREAM getaddrinfo);
0.000000,0,0.000000,
0.000000,0,0.000000,my %hints = (socktype => SOCK_STREAM);
0.000000,0,0.000000,my ($err, @res) = getaddrinfo("localhost", "echo", \%hints);
0.000000,0,0.000000,die "Cannot getaddrinfo - $err" if $err;
0.000000,0,0.000000,
0.000000,0,0.000000,my $sock;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $ai (@res) {
0.000000,0,0.000000,my $candidate = IO::Socket->new();
0.000000,0,0.000000,
0.000000,0,0.000000,$candidate->socket($ai->{family}, $ai->{socktype}, $ai->{protocol})
0.000000,0,0.000000,or next;
0.000000,0,0.000000,
0.000000,0,0.000000,$candidate->connect($ai->{addr})
0.000000,0,0.000000,or next;
0.000000,0,0.000000,
0.000000,0,0.000000,$sock = $candidate;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,die "Cannot connect to localhost:echo" unless $sock;
0.000000,0,0.000000,
0.000000,0,0.000000,$sock->print("Hello, world!\n");
0.000000,0,0.000000,print <$sock>;
0.000000,0,0.000000,
0.000000,0,0.000000,Because a list of potential candidates is returned, the C<while> loop tries
0.000000,0,0.000000,each in turn until it finds one that succeeds both the socket() and connect()
0.000000,0,0.000000,calls.
0.000000,0,0.000000,
0.000000,0,0.000000,This function performs the work of the legacy functions gethostbyname(),
0.000000,0,0.000000,getservbyname(), inet_aton() and pack_sockaddr_in().
0.000000,0,0.000000,
0.000000,0,0.000000,In practice this logic is better performed by L<IO::Socket::IP>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Making a human-readable string out of an address
0.000000,0,0.000000,
0.000000,0,0.000000,The getnameinfo() function converts a socket address, such as returned by
0.000000,0,0.000000,getsockname() or getpeername(), into a pair of human-readable strings
0.000000,0,0.000000,representing the address and service name.
0.000000,0,0.000000,
0.000000,0,0.000000,use IO::Socket::IP;
0.000000,0,0.000000,use Socket qw(getnameinfo);
0.000000,0,0.000000,
0.000000,0,0.000000,my $server = IO::Socket::IP->new(LocalPort => 12345, Listen => 1) or
0.000000,0,0.000000,die "Cannot listen - $@";
0.000000,0,0.000000,
0.000000,0,0.000000,my $socket = $server->accept or die "accept: $!";
0.000000,0,0.000000,
0.000000,0,0.000000,my ($err, $hostname, $servicename) = getnameinfo($socket->peername);
0.000000,0,0.000000,die "Cannot getnameinfo - $err" if $err;
0.000000,0,0.000000,
0.000000,0,0.000000,print "The peer is connected from $hostname\n";
0.000000,0,0.000000,
0.000000,0,0.000000,Since in this example only the hostname was used, the redundant conversion of
0.000000,0,0.000000,the port number into a service name may be omitted by passing the
0.000000,0,0.000000,C<NIx_NOSERV> flag.
0.000000,0,0.000000,
0.000000,0,0.000000,use Socket qw(getnameinfo NIx_NOSERV);
0.000000,0,0.000000,
0.000000,0,0.000000,my ($err, $hostname) = getnameinfo($socket->peername, 0, NIx_NOSERV);
0.000000,0,0.000000,
0.000000,0,0.000000,This function performs the work of the legacy functions unpack_sockaddr_in(),
0.000000,0,0.000000,inet_ntoa(), gethostbyaddr() and getservbyport().
0.000000,0,0.000000,
0.000000,0,0.000000,In practice this logic is better performed by L<IO::Socket::IP>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Resolving hostnames into IP addresses
0.000000,0,0.000000,
0.000000,0,0.000000,To turn a hostname into a human-readable plain IP address use getaddrinfo()
0.000000,0,0.000000,to turn the hostname into a list of socket structures, then getnameinfo() on
0.000000,0,0.000000,each one to make it a readable IP address again.
0.000000,0,0.000000,
0.000000,0,0.000000,use Socket qw(:addrinfo SOCK_RAW);
0.000000,0,0.000000,
0.000000,0,0.000000,my ($err, @res) = getaddrinfo($hostname, "", {socktype => SOCK_RAW});
0.000000,0,0.000000,die "Cannot getaddrinfo - $err" if $err;
0.000000,0,0.000000,
0.000000,0,0.000000,while( my $ai = shift @res ) {
0.000000,0,0.000000,my ($err, $ipaddr) = getnameinfo($ai->{addr}, NI_NUMERICHOST, NIx_NOSERV);
0.000000,0,0.000000,die "Cannot getnameinfo - $err" if $err;
0.000000,0,0.000000,
0.000000,0,0.000000,print "$ipaddr\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,The C<socktype> hint to getaddrinfo() filters the results to only include one
0.000000,0,0.000000,socket type and protocol. Without this most OSes return three combinations,
0.000000,0,0.000000,for C<SOCK_STREAM>, C<SOCK_DGRAM> and C<SOCK_RAW>, resulting in triplicate
0.000000,0,0.000000,output of addresses. The C<NI_NUMERICHOST> flag to getnameinfo() causes it to
0.000000,0,0.000000,return a string-formatted plain IP address, rather than reverse resolving it
0.000000,0,0.000000,back into a hostname.
0.000000,0,0.000000,
0.000000,0,0.000000,This combination performs the work of the legacy functions gethostbyname()
0.000000,0,0.000000,and inet_ntoa().
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Accessing socket options
0.000000,0,0.000000,
0.000000,0,0.000000,The many C<SO_*> and other constants provide the socket option names for
0.000000,0,0.000000,getsockopt() and setsockopt().
0.000000,0,0.000000,
0.000000,0,0.000000,use IO::Socket::INET;
0.000000,0,0.000000,use Socket qw(SOL_SOCKET SO_RCVBUF IPPROTO_IP IP_TTL);
0.000000,0,0.000000,
0.000000,0,0.000000,my $socket = IO::Socket::INET->new(LocalPort => 0, Proto => 'udp')
0.000000,0,0.000000,or die "Cannot create socket: $@";
0.000000,0,0.000000,
0.000000,0,0.000000,$socket->setsockopt(SOL_SOCKET, SO_RCVBUF, 64*1024) or
0.000000,0,0.000000,die "setsockopt: $!";
0.000000,0,0.000000,
0.000000,0,0.000000,print "Receive buffer is ", $socket->getsockopt(SOL_SOCKET, SO_RCVBUF),
0.000000,0,0.000000," bytes\n";
0.000000,0,0.000000,
0.000000,0,0.000000,print "IP TTL is ", $socket->getsockopt(IPPROTO_IP, IP_TTL), "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,As a convenience, L<IO::Socket>'s setsockopt() method will convert a number
0.000000,0,0.000000,into a packed byte buffer, and getsockopt() will unpack a byte buffer of the
0.000000,0,0.000000,correct size back into a number.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHOR
0.000000,0,0.000000,
0.000000,0,0.000000,This module was originally maintained in Perl core by the Perl 5 Porters.
0.000000,0,0.000000,
0.000000,0,0.000000,It was extracted to dual-life on CPAN at version 1.95 by
0.000000,0,0.000000,Paul Evans <leonerd@leonerd.org.uk>
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000016,2,0.000008,use Carp;
0.000245,2,0.000122,use warnings::register;
0.000000,0,0.000000,
0.000000,1,0.000000,require Exporter;
0.000000,1,0.000000,require XSLoader;
0.000006,1,0.000006,our @ISA = qw(Exporter);
0.000000,0,0.000000,
0.000000,0,0.000000,# <@Nicholas> you can't change @EXPORT without breaking the implicit API
0.000000,0,0.000000,# Please put any new constants in @EXPORT_OK!
0.000000,0,0.000000,
0.000000,0,0.000000,# List re-ordered to match documentation above. Try to keep the ordering
0.000000,0,0.000000,# consistent so it's easier to see which ones are or aren't documented.
0.000023,1,0.000023,our @EXPORT = qw(
0.000000,0,0.000000,PF_802 PF_AAL PF_APPLETALK PF_CCITT PF_CHAOS PF_CTF PF_DATAKIT
0.000000,0,0.000000,PF_DECnet PF_DLI PF_ECMA PF_GOSIP PF_HYLINK PF_IMPLINK PF_INET PF_INET6
0.000000,0,0.000000,PF_ISO PF_KEY PF_LAST PF_LAT PF_LINK PF_MAX PF_NBS PF_NIT PF_NS PF_OSI
0.000000,0,0.000000,PF_OSINET PF_PUP PF_ROUTE PF_SNA PF_UNIX PF_UNSPEC PF_USER PF_WAN
0.000000,0,0.000000,PF_X25
0.000000,0,0.000000,
0.000000,0,0.000000,AF_802 AF_AAL AF_APPLETALK AF_CCITT AF_CHAOS AF_CTF AF_DATAKIT
0.000000,0,0.000000,AF_DECnet AF_DLI AF_ECMA AF_GOSIP AF_HYLINK AF_IMPLINK AF_INET AF_INET6
0.000000,0,0.000000,AF_ISO AF_KEY AF_LAST AF_LAT AF_LINK AF_MAX AF_NBS AF_NIT AF_NS AF_OSI
0.000000,0,0.000000,AF_OSINET AF_PUP AF_ROUTE AF_SNA AF_UNIX AF_UNSPEC AF_USER AF_WAN
0.000000,0,0.000000,AF_X25
0.000000,0,0.000000,
0.000000,0,0.000000,SOCK_DGRAM SOCK_RAW SOCK_RDM SOCK_SEQPACKET SOCK_STREAM
0.000000,0,0.000000,
0.000000,0,0.000000,SOL_SOCKET
0.000000,0,0.000000,
0.000000,0,0.000000,SO_ACCEPTCONN SO_ATTACH_FILTER SO_BACKLOG SO_BROADCAST SO_CHAMELEON
0.000000,0,0.000000,SO_DEBUG SO_DETACH_FILTER SO_DGRAM_ERRIND SO_DOMAIN SO_DONTLINGER
0.000000,0,0.000000,SO_DONTROUTE SO_ERROR SO_FAMILY SO_KEEPALIVE SO_LINGER SO_OOBINLINE
0.000000,0,0.000000,SO_PASSCRED SO_PASSIFNAME SO_PEERCRED SO_PROTOCOL SO_PROTOTYPE
0.000000,0,0.000000,SO_RCVBUF SO_RCVLOWAT SO_RCVTIMEO SO_REUSEADDR SO_REUSEPORT
0.000000,0,0.000000,SO_SECURITY_AUTHENTICATION SO_SECURITY_ENCRYPTION_NETWORK
0.000000,0,0.000000,SO_SECURITY_ENCRYPTION_TRANSPORT SO_SNDBUF SO_SNDLOWAT SO_SNDTIMEO
0.000000,0,0.000000,SO_STATE SO_TYPE SO_USELOOPBACK SO_XOPEN SO_XSE
0.000000,0,0.000000,
0.000000,0,0.000000,IP_HDRINCL IP_OPTIONS IP_RECVOPTS IP_RECVRETOPTS IP_RETOPTS IP_TOS
0.000000,0,0.000000,IP_TTL
0.000000,0,0.000000,
0.000000,0,0.000000,MSG_BCAST MSG_BTAG MSG_CTLFLAGS MSG_CTLIGNORE MSG_CTRUNC MSG_DONTROUTE
0.000000,0,0.000000,MSG_DONTWAIT MSG_EOF MSG_EOR MSG_ERRQUEUE MSG_ETAG MSG_FASTOPEN MSG_FIN
0.000000,0,0.000000,MSG_MAXIOVLEN MSG_MCAST MSG_NOSIGNAL MSG_OOB MSG_PEEK MSG_PROXY MSG_RST
0.000000,0,0.000000,MSG_SYN MSG_TRUNC MSG_URG MSG_WAITALL MSG_WIRE
0.000000,0,0.000000,
0.000000,0,0.000000,SHUT_RD SHUT_RDWR SHUT_WR
0.000000,0,0.000000,
0.000000,0,0.000000,INADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE
0.000000,0,0.000000,
0.000000,0,0.000000,SCM_CONNECT SCM_CREDENTIALS SCM_CREDS SCM_RIGHTS SCM_TIMESTAMP
0.000000,0,0.000000,
0.000000,0,0.000000,SOMAXCONN
0.000000,0,0.000000,
0.000000,0,0.000000,IOV_MAX
0.000000,0,0.000000,UIO_MAXIOV
0.000000,0,0.000000,
0.000000,0,0.000000,sockaddr_family
0.000000,0,0.000000,pack_sockaddr_in  unpack_sockaddr_in  sockaddr_in
0.000000,0,0.000000,pack_sockaddr_in6 unpack_sockaddr_in6 sockaddr_in6
0.000000,0,0.000000,pack_sockaddr_un  unpack_sockaddr_un  sockaddr_un 
0.000000,0,0.000000,
0.000000,0,0.000000,inet_aton inet_ntoa
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# List re-ordered to match documentation above. Try to keep the ordering
0.000000,0,0.000000,# consistent so it's easier to see which ones are or aren't documented.
0.000004,1,0.000004,our @EXPORT_OK = qw(
0.000000,0,0.000000,CR LF CRLF $CR $LF $CRLF
0.000000,0,0.000000,
0.000000,0,0.000000,SOCK_NONBLOCK SOCK_CLOEXEC
0.000000,0,0.000000,
0.000000,0,0.000000,IP_ADD_MEMBERSHIP IP_ADD_SOURCE_MEMBERSHIP IP_BIND_ADDRESS_NO_PORT
0.000000,0,0.000000,IP_DROP_MEMBERSHIP IP_DROP_SOURCE_MEMBERSHIP IP_FREEBIND
0.000000,0,0.000000,IP_MULTICAST_ALL IP_MULTICAST_IF IP_MULTICAST_LOOP IP_MULTICAST_TTL
0.000000,0,0.000000,IP_MTU IP_MTU_DISCOVER IP_NODEFRAG IP_RECVERR IP_TRANSPARENT
0.000000,0,0.000000,
0.000000,0,0.000000,IPPROTO_IP IPPROTO_IPV6 IPPROTO_RAW IPPROTO_ICMP IPPROTO_IGMP
0.000000,0,0.000000,IPPROTO_TCP IPPROTO_UDP IPPROTO_GRE IPPROTO_ESP IPPROTO_AH
0.000000,0,0.000000,IPPROTO_ICMPV6 IPPROTO_SCTP
0.000000,0,0.000000,
0.000000,0,0.000000,IP_PMTUDISC_DO IP_PMTUDISC_DONT IP_PMTUDISC_PROBE IP_PMTUDISC_WANT
0.000000,0,0.000000,
0.000000,0,0.000000,IPTOS_LOWDELAY IPTOS_THROUGHPUT IPTOS_RELIABILITY IPTOS_MINCOST
0.000000,0,0.000000,
0.000000,0,0.000000,TCP_CONGESTION TCP_CONNECTIONTIMEOUT TCP_CORK TCP_DEFER_ACCEPT
0.000000,0,0.000000,TCP_FASTOPEN TCP_INFO TCP_INIT_CWND TCP_KEEPALIVE TCP_KEEPCNT
0.000000,0,0.000000,TCP_KEEPIDLE TCP_KEEPINTVL TCP_LINGER2 TCP_MAXRT TCP_MAXSEG
0.000000,0,0.000000,TCP_MD5SIG TCP_NODELAY TCP_NOOPT TCP_NOPUSH TCP_QUICKACK
0.000000,0,0.000000,TCP_SACK_ENABLE TCP_STDURG TCP_SYNCNT TCP_USER_TIMEOUT
0.000000,0,0.000000,TCP_WINDOW_CLAMP
0.000000,0,0.000000,
0.000000,0,0.000000,IN6ADDR_ANY IN6ADDR_LOOPBACK
0.000000,0,0.000000,
0.000000,0,0.000000,IPV6_ADDRFROM IPV6_ADD_MEMBERSHIP IPV6_DROP_MEMBERSHIP IPV6_JOIN_GROUP
0.000000,0,0.000000,IPV6_LEAVE_GROUP IPV6_MTU IPV6_MTU_DISCOVER IPV6_MULTICAST_HOPS
0.000000,0,0.000000,IPV6_MULTICAST_IF IPV6_MULTICAST_LOOP IPV6_RECVERR IPV6_ROUTER_ALERT
0.000000,0,0.000000,IPV6_UNICAST_HOPS IPV6_V6ONLY
0.000000,0,0.000000,
0.000000,0,0.000000,SO_LOCK_FILTER SO_RCVBUFFORCE SO_SNDBUFFORCE
0.000000,0,0.000000,
0.000000,0,0.000000,pack_ip_mreq unpack_ip_mreq pack_ip_mreq_source unpack_ip_mreq_source
0.000000,0,0.000000,
0.000000,0,0.000000,pack_ipv6_mreq unpack_ipv6_mreq
0.000000,0,0.000000,
0.000000,0,0.000000,inet_pton inet_ntop
0.000000,0,0.000000,
0.000000,0,0.000000,getaddrinfo getnameinfo
0.000000,0,0.000000,
0.000000,0,0.000000,AI_ADDRCONFIG AI_ALL AI_CANONIDN AI_CANONNAME AI_IDN
0.000000,0,0.000000,AI_IDN_ALLOW_UNASSIGNED AI_IDN_USE_STD3_ASCII_RULES AI_NUMERICHOST
0.000000,0,0.000000,AI_NUMERICSERV AI_PASSIVE AI_V4MAPPED
0.000000,0,0.000000,
0.000000,0,0.000000,NI_DGRAM NI_IDN NI_IDN_ALLOW_UNASSIGNED NI_IDN_USE_STD3_ASCII_RULES
0.000000,0,0.000000,NI_NAMEREQD NI_NOFQDN NI_NUMERICHOST NI_NUMERICSERV
0.000000,0,0.000000,
0.000000,0,0.000000,NIx_NOHOST NIx_NOSERV
0.000000,0,0.000000,
0.000000,0,0.000000,EAI_ADDRFAMILY EAI_AGAIN EAI_BADFLAGS EAI_BADHINTS EAI_FAIL EAI_FAMILY
0.000000,0,0.000000,EAI_NODATA EAI_NONAME EAI_PROTOCOL EAI_SERVICE EAI_SOCKTYPE EAI_SYSTEM
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000216,1,0.000216,our %EXPORT_TAGS = (
0.000000,0,0.000000,crlf     => [qw(CR LF CRLF $CR $LF $CRLF)],
0.000000,0,0.000000,addrinfo => [qw(getaddrinfo getnameinfo), grep m/^(?:AI|NI|NIx|EAI)_/, @EXPORT_OK],
0.000000,0,0.000000,all      => [@EXPORT, @EXPORT_OK],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,sub CR   () {"\015"}
0.000000,0,0.000000,sub LF   () {"\012"}
0.000000,0,0.000000,sub CRLF () {"\015\012"}
0.000000,0,0.000000,
0.000000,0,0.000000,# These are not gni() constants; they're extensions for the perl API
0.000000,0,0.000000,# The definitions in Socket.pm and Socket.xs must match
0.000000,0,0.000000,sub NIx_NOHOST() {1 << 0}
0.000000,0,0.000000,sub NIx_NOSERV() {1 << 1}
0.000026,1,0.000026,}
0.000000,0,0.000000,
0.000001,1,0.000001,*CR   = \CR();
0.000000,1,0.000000,*LF   = \LF();
0.000000,1,0.000000,*CRLF = \CRLF();
0.000000,0,0.000000,
0.000000,0,0.000000,# The four deprecated addrinfo constants
0.000001,1,0.000001,foreach my $name (qw( AI_IDN_ALLOW_UNASSIGNED AI_IDN_USE_STD3_ASCII_RULES NI_IDN_ALLOW_UNASSIGNED NI_IDN_USE_STD3_ASCII_RULES )) {
0.000223,2,0.000111,no strict 'refs';
0.000000,0,0.000000,*$name = sub {
0.000000,0,0.000000,croak "The addrinfo constant $name is deprecated";
0.000011,4,0.000003,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sockaddr_in {
0.000000,0,0.000000,if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die
0.000000,0,0.000000,my($af, $port, @quad) = @_;
0.000000,0,0.000000,warnings::warn "6-ARG sockaddr_in call is deprecated" 
0.000000,0,0.000000,if warnings::enabled();
0.000000,0,0.000000,pack_sockaddr_in($port, inet_aton(join('.', @quad)));
0.000000,0,0.000000,} elsif (wantarray) {
0.000000,0,0.000000,croak "usage:   (port,iaddr) = sockaddr_in(sin_sv)" unless @_ == 1;
0.000000,0,0.000000,unpack_sockaddr_in(@_);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak "usage:   sin_sv = sockaddr_in(port,iaddr))" unless @_ == 2;
0.000000,0,0.000000,pack_sockaddr_in(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sockaddr_in6 {
0.000000,0,0.000000,if (wantarray) {
0.000000,0,0.000000,croak "usage:   (port,in6addr,scope_id,flowinfo) = sockaddr_in6(sin6_sv)" unless @_ == 1;
0.000000,0,0.000000,unpack_sockaddr_in6(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,croak "usage:   sin6_sv = sockaddr_in6(port,in6addr,[scope_id,[flowinfo]])" unless @_ >= 2 and @_ <= 4;
0.000000,0,0.000000,pack_sockaddr_in6(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub sockaddr_un {
0.000000,0,0.000000,if (wantarray) {
0.000000,0,0.000000,croak "usage:   (filename) = sockaddr_un(sun_sv)" unless @_ == 1;
0.000000,0,0.000000,unpack_sockaddr_un(@_);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak "usage:   sun_sv = sockaddr_un(filename)" unless @_ == 1;
0.000000,0,0.000000,pack_sockaddr_un(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001085,1,0.001085,XSLoader::load(__PACKAGE__, $VERSION);
0.000000,0,0.000000,
0.000001,1,0.000001,my %errstr;
0.000000,0,0.000000,
0.000002,1,0.000002,if( defined &getaddrinfo ) {
0.000000,0,0.000000,# These are not part of the API, nothing uses them, and deleting them
0.000000,0,0.000000,# reduces the size of %Socket:: by about 12K
0.000001,1,0.000001,delete $Socket::{fake_getaddrinfo};
0.000010,1,0.000010,delete $Socket::{fake_getnameinfo};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,require Scalar::Util;
0.000000,0,0.000000,
0.000000,0,0.000000,*getaddrinfo = \&fake_getaddrinfo;
0.000000,0,0.000000,*getnameinfo = \&fake_getnameinfo;
0.000000,0,0.000000,
0.000000,0,0.000000,# These numbers borrowed from GNU libc's implementation, but since
0.000000,0,0.000000,# they're only used by our emulation, it doesn't matter if the real
0.000000,0,0.000000,# platform's values differ
0.000000,0,0.000000,my %constants = (
0.000000,0,0.000000,AI_PASSIVE     => 1,
0.000000,0,0.000000,AI_CANONNAME   => 2,
0.000000,0,0.000000,AI_NUMERICHOST => 4,
0.000000,0,0.000000,AI_V4MAPPED    => 8,
0.000000,0,0.000000,AI_ALL         => 16,
0.000000,0,0.000000,AI_ADDRCONFIG  => 32,
0.000000,0,0.000000,# RFC 2553 doesn't define this but Linux does - lets be nice and
0.000000,0,0.000000,# provide it since we can
0.000000,0,0.000000,AI_NUMERICSERV => 1024,
0.000000,0,0.000000,
0.000000,0,0.000000,EAI_BADFLAGS   => -1,
0.000000,0,0.000000,EAI_NONAME     => -2,
0.000000,0,0.000000,EAI_NODATA     => -5,
0.000000,0,0.000000,EAI_FAMILY     => -6,
0.000000,0,0.000000,EAI_SERVICE    => -8,
0.000000,0,0.000000,
0.000000,0,0.000000,NI_NUMERICHOST => 1,
0.000000,0,0.000000,NI_NUMERICSERV => 2,
0.000000,0,0.000000,NI_NOFQDN      => 4,
0.000000,0,0.000000,NI_NAMEREQD    => 8,
0.000000,0,0.000000,NI_DGRAM       => 16,
0.000000,0,0.000000,
0.000000,0,0.000000,# Constants we don't support. Export them, but croak if anyone tries to
0.000000,0,0.000000,# use them
0.000000,0,0.000000,AI_IDN      => 64,
0.000000,0,0.000000,AI_CANONIDN => 128,
0.000000,0,0.000000,NI_IDN      => 32,
0.000000,0,0.000000,
0.000000,0,0.000000,# Error constants we'll never return, so it doesn't matter what value
0.000000,0,0.000000,# these have, nor that we don't provide strings for them
0.000000,0,0.000000,EAI_SYSTEM   => -11,
0.000000,0,0.000000,EAI_BADHINTS => -1000,
0.000000,0,0.000000,EAI_PROTOCOL => -1001
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $name ( keys %constants ) {
0.000000,0,0.000000,my $value = $constants{$name};
0.000000,0,0.000000,
0.000707,2,0.000353,no strict 'refs';
0.000000,0,0.000000,defined &$name or *$name = sub () { $value };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,%errstr = (
0.000000,0,0.000000,# These strings from RFC 2553
0.000000,0,0.000000,EAI_BADFLAGS()   => "invalid value for ai_flags",
0.000000,0,0.000000,EAI_NONAME()     => "nodename nor servname provided, or not known",
0.000000,0,0.000000,EAI_NODATA()     => "no address associated with nodename",
0.000000,0,0.000000,EAI_FAMILY()     => "ai_family not supported",
0.000000,0,0.000000,EAI_SERVICE()    => "servname not supported for ai_socktype",
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# The following functions are used if the system does not have a
0.000000,0,0.000000,# getaddrinfo(3) function in libc; and are used to emulate it for the AF_INET
0.000000,0,0.000000,# family
0.000000,0,0.000000,
0.000000,0,0.000000,# Borrowed from Regexp::Common::net
0.000017,1,0.000017,my $REGEXP_IPv4_DECIMAL = qr/25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}/;
0.000217,1,0.000217,my $REGEXP_IPv4_DOTTEDQUAD = qr/$REGEXP_IPv4_DECIMAL\.$REGEXP_IPv4_DECIMAL\.$REGEXP_IPv4_DECIMAL\.$REGEXP_IPv4_DECIMAL/;
0.000000,0,0.000000,
0.000000,0,0.000000,sub fake_makeerr
0.000000,0,0.000000,{
0.000000,0,0.000000,my ( $errno ) = @_;
0.000000,0,0.000000,my $errstr = $errno == 0 ? "" : ( $errstr{$errno} || $errno );
0.000000,0,0.000000,return Scalar::Util::dualvar( $errno, $errstr );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fake_getaddrinfo
0.000000,0,0.000000,{
0.000000,0,0.000000,my ( $node, $service, $hints ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$node = "" unless defined $node;
0.000000,0,0.000000,
0.000000,0,0.000000,$service = "" unless defined $service;
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $family, $socktype, $protocol, $flags ) = @$hints{qw( family socktype protocol flags )};
0.000000,0,0.000000,
0.000000,0,0.000000,$family ||= Socket::AF_INET(); # 0 == AF_UNSPEC, which we want too
0.000000,0,0.000000,$family == Socket::AF_INET() or return fake_makeerr( EAI_FAMILY() );
0.000000,0,0.000000,
0.000000,0,0.000000,$socktype ||= 0;
0.000000,0,0.000000,
0.000000,0,0.000000,$protocol ||= 0;
0.000000,0,0.000000,
0.000000,0,0.000000,$flags ||= 0;
0.000000,0,0.000000,
0.000000,0,0.000000,my $flag_passive     = $flags & AI_PASSIVE();     $flags &= ~AI_PASSIVE();
0.000000,0,0.000000,my $flag_canonname   = $flags & AI_CANONNAME();   $flags &= ~AI_CANONNAME();
0.000000,0,0.000000,my $flag_numerichost = $flags & AI_NUMERICHOST(); $flags &= ~AI_NUMERICHOST();
0.000000,0,0.000000,my $flag_numericserv = $flags & AI_NUMERICSERV(); $flags &= ~AI_NUMERICSERV();
0.000000,0,0.000000,
0.000000,0,0.000000,# These constants don't apply to AF_INET-only lookups, so we might as well
0.000000,0,0.000000,# just ignore them. For AI_ADDRCONFIG we just presume the host has ability
0.000000,0,0.000000,# to talk AF_INET. If not we'd have to return no addresses at all. :)
0.000000,0,0.000000,$flags &= ~(AI_V4MAPPED()|AI_ALL()|AI_ADDRCONFIG());
0.000000,0,0.000000,
0.000000,0,0.000000,$flags & (AI_IDN()|AI_CANONIDN()) and
0.000000,0,0.000000,croak "Socket::getaddrinfo() does not support IDN";
0.000000,0,0.000000,
0.000000,0,0.000000,$flags == 0 or return fake_makeerr( EAI_BADFLAGS() );
0.000000,0,0.000000,
0.000000,0,0.000000,$node eq "" and $service eq "" and return fake_makeerr( EAI_NONAME() );
0.000000,0,0.000000,
0.000000,0,0.000000,my $canonname;
0.000000,0,0.000000,my @addrs;
0.000000,0,0.000000,if( $node ne "" ) {
0.000000,0,0.000000,return fake_makeerr( EAI_NONAME() ) if( $flag_numerichost and $node !~ m/^$REGEXP_IPv4_DOTTEDQUAD$/ );
0.000000,0,0.000000,( $canonname, undef, undef, undef, @addrs ) = gethostbyname( $node );
0.000000,0,0.000000,defined $canonname or return fake_makeerr( EAI_NONAME() );
0.000000,0,0.000000,
0.000000,0,0.000000,undef $canonname unless $flag_canonname;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$addrs[0] = $flag_passive ? Socket::inet_aton( "0.0.0.0" )
0.000000,0,0.000000,: Socket::inet_aton( "127.0.0.1" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @ports; # Actually ARRAYrefs of [ socktype, protocol, port ]
0.000000,0,0.000000,my $protname = "";
0.000000,0,0.000000,if( $protocol ) {
0.000000,0,0.000000,$protname = eval { getprotobynumber( $protocol ) };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if( $service ne "" and $service !~ m/^\d+$/ ) {
0.000000,0,0.000000,return fake_makeerr( EAI_NONAME() ) if( $flag_numericserv );
0.000000,0,0.000000,getservbyname( $service, $protname ) or return fake_makeerr( EAI_SERVICE() );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $this_socktype ( Socket::SOCK_STREAM(), Socket::SOCK_DGRAM(), Socket::SOCK_RAW() ) {
0.000000,0,0.000000,next if $socktype and $this_socktype != $socktype;
0.000000,0,0.000000,
0.000000,0,0.000000,my $this_protname = "raw";
0.000000,0,0.000000,$this_socktype == Socket::SOCK_STREAM() and $this_protname = "tcp";
0.000000,0,0.000000,$this_socktype == Socket::SOCK_DGRAM()  and $this_protname = "udp";
0.000000,0,0.000000,
0.000000,0,0.000000,next if $protname and $this_protname ne $protname;
0.000000,0,0.000000,
0.000000,0,0.000000,my $port;
0.000000,0,0.000000,if( $service ne "" ) {
0.000000,0,0.000000,if( $service =~ m/^\d+$/ ) {
0.000000,0,0.000000,$port = "$service";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,( undef, undef, $port, $this_protname ) = getservbyname( $service, $this_protname );
0.000000,0,0.000000,next unless defined $port;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$port = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @ports, [ $this_socktype, eval { scalar getprotobyname( $this_protname ) } || 0, $port ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @ret;
0.000000,0,0.000000,foreach my $addr ( @addrs ) {
0.000000,0,0.000000,foreach my $portspec ( @ports ) {
0.000000,0,0.000000,my ( $socktype, $protocol, $port ) = @$portspec;
0.000000,0,0.000000,push @ret, {
0.000000,0,0.000000,family    => $family,
0.000000,0,0.000000,socktype  => $socktype,
0.000000,0,0.000000,protocol  => $protocol,
0.000000,0,0.000000,addr      => Socket::pack_sockaddr_in( $port, $addr ),
0.000000,0,0.000000,canonname => undef,
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Only supply canonname for the first result
0.000000,0,0.000000,if( defined $canonname ) {
0.000000,0,0.000000,$ret[0]->{canonname} = $canonname;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ( fake_makeerr( 0 ), @ret );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fake_getnameinfo
0.000000,0,0.000000,{
0.000000,0,0.000000,my ( $addr, $flags, $xflags ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $port, $inetaddr );
0.000000,0,0.000000,eval { ( $port, $inetaddr ) = Socket::unpack_sockaddr_in( $addr ) }
0.000000,0,0.000000,or return fake_makeerr( EAI_FAMILY() );
0.000000,0,0.000000,
0.000000,0,0.000000,my $family = Socket::AF_INET();
0.000000,0,0.000000,
0.000000,0,0.000000,$flags ||= 0;
0.000000,0,0.000000,
0.000000,0,0.000000,my $flag_numerichost = $flags & NI_NUMERICHOST(); $flags &= ~NI_NUMERICHOST();
0.000000,0,0.000000,my $flag_numericserv = $flags & NI_NUMERICSERV(); $flags &= ~NI_NUMERICSERV();
0.000000,0,0.000000,my $flag_nofqdn      = $flags & NI_NOFQDN();      $flags &= ~NI_NOFQDN();
0.000000,0,0.000000,my $flag_namereqd    = $flags & NI_NAMEREQD();    $flags &= ~NI_NAMEREQD();
0.000000,0,0.000000,my $flag_dgram       = $flags & NI_DGRAM()   ;    $flags &= ~NI_DGRAM();
0.000000,0,0.000000,
0.000000,0,0.000000,$flags & NI_IDN() and
0.000000,0,0.000000,croak "Socket::getnameinfo() does not support IDN";
0.000000,0,0.000000,
0.000000,0,0.000000,$flags == 0 or return fake_makeerr( EAI_BADFLAGS() );
0.000000,0,0.000000,
0.000000,0,0.000000,$xflags ||= 0;
0.000000,0,0.000000,
0.000000,0,0.000000,my $node;
0.000000,0,0.000000,if( $xflags & NIx_NOHOST ) {
0.000000,0,0.000000,$node = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif( $flag_numerichost ) {
0.000000,0,0.000000,$node = Socket::inet_ntoa( $inetaddr );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$node = gethostbyaddr( $inetaddr, $family );
0.000000,0,0.000000,if( !defined $node ) {
0.000000,0,0.000000,return fake_makeerr( EAI_NONAME() ) if $flag_namereqd;
0.000000,0,0.000000,$node = Socket::inet_ntoa( $inetaddr );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif( $flag_nofqdn ) {
0.000000,0,0.000000,my ( $shortname ) = split m/\./, $node;
0.000000,0,0.000000,my ( $fqdn ) = gethostbyname $shortname;
0.000000,0,0.000000,$node = $shortname if defined $fqdn and $fqdn eq $node;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $service;
0.000000,0,0.000000,if( $xflags & NIx_NOSERV ) {
0.000000,0,0.000000,$service = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif( $flag_numericserv ) {
0.000000,0,0.000000,$service = "$port";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $protname = $flag_dgram ? "udp" : "";
0.000000,0,0.000000,$service = getservbyport( $port, $protname );
0.000000,0,0.000000,if( !defined $service ) {
0.000000,0,0.000000,$service = "$port";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ( fake_makeerr( 0 ), $node, $service );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000040,1,0.000040,1;
