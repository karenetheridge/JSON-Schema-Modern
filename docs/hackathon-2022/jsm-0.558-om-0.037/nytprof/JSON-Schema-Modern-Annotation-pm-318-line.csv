# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000022,2,0.000011,use strict;
0.000035,2,0.000017,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Annotation;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Contains a single annotation from a JSON Schema evaluation
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.558';
0.000000,0,0.000000,
0.000031,2,0.000015,use 5.020;
0.000024,2,0.000012,use Moo;
0.000026,3,0.000009,use strictures 2;
0.000031,2,0.000015,use experimental qw(signatures postderef);
0.000026,2,0.000013,use if "$]" >= 5.022, experimental => 're_strict';
0.000018,2,0.000009,no if "$]" >= 5.031009, feature => 'indirect';
0.000016,2,0.000008,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000012,2,0.000006,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000016,2,0.000008,use Safe::Isa;
0.000021,2,0.000010,use MooX::TypeTiny;
0.000023,2,0.000012,use Types::Standard qw(Str InstanceOf Bool);
0.000621,2,0.000311,use namespace::clean;
0.000000,0,0.000000,
0.000004,1,0.000004,has [qw(
0.000000,0,0.000000,keyword
0.000000,0,0.000000,instance_location
0.000000,0,0.000000,keyword_location
0.000000,0,0.000000,)] => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Str,
0.000000,0,0.000000,required => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,has absolute_keyword_location => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => InstanceOf['Mojo::URL'],
0.000000,0,0.000000,coerce => sub { $_[0]->$_isa('Mojo::URL') ? $_[0] : Mojo::URL->new($_[0]) },
0.000005,1,0.000005,);
0.000000,0,0.000000,
0.000000,0,0.000000,# https://json-schema.org/draft/2019-09/json-schema-core.html#rfc.section.7.7.1
0.000002,1,0.000002,has annotation => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,required => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000003,1,0.000003,has unknown => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => Bool,
0.000000,0,0.000000,default => 0,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,around BUILDARGS => sub ($orig, $class, @args) {
0.000000,0,0.000000,my $args = $class->$orig(@args);
0.000000,0,0.000000,
0.000000,0,0.000000,if (my $uri = delete $args->{_uri}) {
0.000000,0,0.000000,# as if we did canonical_uri(..)->to_abs($state->{effective_base_uri} in A(..)
0.000000,0,0.000000,$uri = $uri->[0]->to_abs($uri->[1]);
0.000000,0,0.000000,undef $uri if $uri eq '' and $args->{keyword_location} eq ''
0.000000,0,0.000000,or ($uri->fragment // '') eq $args->{keyword_location} and $uri->clone->fragment(undef) eq '';
0.000000,0,0.000000,$args->{absolute_keyword_location} = $uri if defined $uri;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $args;
0.000004,1,0.000004,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub TO_JSON ($self) {
0.000000,0,0.000000,return +{
0.000000,0,0.000000,# note that locations are JSON pointers, not uri fragments!
0.000000,0,0.000000,instanceLocation => $self->instance_location,
0.000000,0,0.000000,keywordLocation => $self->keyword_location,
0.000000,0,0.000000,!defined($self->absolute_keyword_location) ? ()
0.000000,0,0.000000,: ( absoluteKeywordLocation => $self->absolute_keyword_location->to_string ),
0.000000,0,0.000000,annotation => $self->annotation,
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub dump ($self) {
0.000000,0,0.000000,my $encoder = JSON::MaybeXS->new(utf8 => 0, convert_blessed => 1, canonical => 1, pretty => 1);
0.000000,0,0.000000,$encoder->indent_length(2) if $encoder->can('indent_length');
0.000000,0,0.000000,$encoder->encode($self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000016,1,0.000016,1;
0.000000,0,0.000000,
0.000026,1,0.000026,__END__
