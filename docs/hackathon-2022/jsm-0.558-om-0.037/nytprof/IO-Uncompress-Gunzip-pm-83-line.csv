# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package IO::Uncompress::Gunzip ;
0.000000,0,0.000000,
0.000008,1,0.000008,require 5.006 ;
0.000000,0,0.000000,
0.000000,0,0.000000,# for RFC1952
0.000000,0,0.000000,
0.000026,2,0.000013,use strict ;
0.000014,2,0.000007,use warnings;
0.000015,2,0.000008,use bytes;
0.000000,0,0.000000,
0.000570,3,0.000190,use IO::Uncompress::RawInflate 2.106 ;
0.000000,0,0.000000,
0.000025,3,0.000008,use Compress::Raw::Zlib 2.103 () ;
0.000033,3,0.000011,use IO::Compress::Base::Common 2.106 qw(:Status );
0.000092,3,0.000031,use IO::Compress::Gzip::Constants 2.106 ;
0.001131,3,0.000377,use IO::Compress::Zlib::Extra 2.106 ;
0.000000,0,0.000000,
0.000001,1,0.000001,require Exporter ;
0.000000,0,0.000000,
0.000000,0,0.000000,our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, $GunzipError);
0.000000,0,0.000000,
0.000011,1,0.000011,@ISA = qw(IO::Uncompress::RawInflate Exporter);
0.000001,1,0.000001,@EXPORT_OK = qw( $GunzipError gunzip );
0.000000,1,0.000000,%EXPORT_TAGS = %IO::Uncompress::RawInflate::DEFLATE_CONSTANTS ;
0.000001,1,0.000001,push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;
0.000004,1,0.000004,Exporter::export_ok_tags('all');
0.000000,0,0.000000,
0.000001,1,0.000001,$GunzipError = '';
0.000000,0,0.000000,
0.000000,1,0.000000,$VERSION = '2.106';
0.000000,0,0.000000,
0.000000,0,0.000000,sub new
0.000000,0,0.000000,{
0.000000,0,0.000000,my $class = shift ;
0.000000,0,0.000000,$GunzipError = '';
0.000000,0,0.000000,my $obj = IO::Compress::Base::Common::createSelfTiedObject($class, \$GunzipError);
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->_create(undef, 0, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub gunzip
0.000000,0,0.000000,{
0.000000,0,0.000000,my $obj = IO::Compress::Base::Common::createSelfTiedObject(undef, \$GunzipError);
0.000000,0,0.000000,return $obj->_inf(@_) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getExtraParams
0.000000,0,0.000000,{
0.000000,0,0.000000,return ( 'parseextra' => [IO::Compress::Base::Common::Parse_boolean,  0] ) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ckParams
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $got = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,# gunzip always needs crc32
0.000000,0,0.000000,$got->setValue('crc32' => 1);
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ckMagic
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $magic ;
0.000000,0,0.000000,$self->smartReadExact(\$magic, GZIP_ID_SIZE);
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{HeaderPending} = $magic ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->HeaderError("Minimum header size is " .
0.000000,0,0.000000,GZIP_MIN_HEADER_SIZE . " bytes")
0.000000,0,0.000000,if length $magic != GZIP_ID_SIZE ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->HeaderError("Bad Magic")
0.000000,0,0.000000,if ! isGzipMagic($magic) ;
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{Type} = 'rfc1952';
0.000000,0,0.000000,
0.000000,0,0.000000,return $magic ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub readHeader
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $magic = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->_readGzipHeader($magic);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub chkTrailer
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $trailer = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Check CRC & ISIZE
0.000000,0,0.000000,my ($CRC32, $ISIZE) = unpack("V V", $trailer) ;
0.000000,0,0.000000,*$self->{Info}{CRC32} = $CRC32;
0.000000,0,0.000000,*$self->{Info}{ISIZE} = $ISIZE;
0.000000,0,0.000000,
0.000000,0,0.000000,if (*$self->{Strict}) {
0.000000,0,0.000000,return $self->TrailerError("CRC mismatch")
0.000000,0,0.000000,if $CRC32 != *$self->{Uncomp}->crc32() ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $exp_isize = *$self->{UnCompSize}->get32bit();
0.000000,0,0.000000,return $self->TrailerError("ISIZE mismatch. Got $ISIZE"
0.000000,0,0.000000,. ", expected $exp_isize")
0.000000,0,0.000000,if $ISIZE != $exp_isize ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return STATUS_OK;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub isGzipMagic
0.000000,0,0.000000,{
0.000000,0,0.000000,my $buffer = shift ;
0.000000,0,0.000000,return 0 if length $buffer < GZIP_ID_SIZE ;
0.000000,0,0.000000,my ($id1, $id2) = unpack("C C", $buffer) ;
0.000000,0,0.000000,return $id1 == GZIP_ID1 && $id2 == GZIP_ID2 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _readFullGzipHeader($)
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($self) = @_ ;
0.000000,0,0.000000,my $magic = '' ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->smartReadExact(\$magic, GZIP_ID_SIZE);
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{HeaderPending} = $magic ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->HeaderError("Minimum header size is " .
0.000000,0,0.000000,GZIP_MIN_HEADER_SIZE . " bytes")
0.000000,0,0.000000,if length $magic != GZIP_ID_SIZE ;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->HeaderError("Bad Magic")
0.000000,0,0.000000,if ! isGzipMagic($magic) ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $status = $self->_readGzipHeader($magic);
0.000000,0,0.000000,delete *$self->{Transparent} if ! defined $status ;
0.000000,0,0.000000,return $status ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _readGzipHeader($)
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($self, $magic) = @_ ;
0.000000,0,0.000000,my ($HeaderCRC) ;
0.000000,0,0.000000,my ($buffer) = '' ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->smartReadExact(\$buffer, GZIP_MIN_HEADER_SIZE - GZIP_ID_SIZE)
0.000000,0,0.000000,or return $self->HeaderError("Minimum header size is " .
0.000000,0,0.000000,GZIP_MIN_HEADER_SIZE . " bytes") ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $keep = $magic . $buffer ;
0.000000,0,0.000000,*$self->{HeaderPending} = $keep ;
0.000000,0,0.000000,
0.000000,0,0.000000,# now split out the various parts
0.000000,0,0.000000,my ($cm, $flag, $mtime, $xfl, $os) = unpack("C C V C C", $buffer) ;
0.000000,0,0.000000,
0.000000,0,0.000000,$cm == GZIP_CM_DEFLATED
0.000000,0,0.000000,or return $self->HeaderError("Not Deflate (CM is $cm)") ;
0.000000,0,0.000000,
0.000000,0,0.000000,# check for use of reserved bits
0.000000,0,0.000000,return $self->HeaderError("Use of Reserved Bits in FLG field.")
0.000000,0,0.000000,if $flag & GZIP_FLG_RESERVED ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $EXTRA ;
0.000000,0,0.000000,my @EXTRA = () ;
0.000000,0,0.000000,if ($flag & GZIP_FLG_FEXTRA) {
0.000000,0,0.000000,$EXTRA = "" ;
0.000000,0,0.000000,$self->smartReadExact(\$buffer, GZIP_FEXTRA_HEADER_SIZE)
0.000000,0,0.000000,or return $self->TruncatedHeader("FEXTRA Length") ;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($XLEN) = unpack("v", $buffer) ;
0.000000,0,0.000000,$self->smartReadExact(\$EXTRA, $XLEN)
0.000000,0,0.000000,or return $self->TruncatedHeader("FEXTRA Body");
0.000000,0,0.000000,$keep .= $buffer . $EXTRA ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($XLEN && *$self->{'ParseExtra'}) {
0.000000,0,0.000000,my $bad = IO::Compress::Zlib::Extra::parseRawExtra($EXTRA,
0.000000,0,0.000000,\@EXTRA, 1, 1);
0.000000,0,0.000000,return $self->HeaderError($bad)
0.000000,0,0.000000,if defined $bad;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $origname ;
0.000000,0,0.000000,if ($flag & GZIP_FLG_FNAME) {
0.000000,0,0.000000,$origname = "" ;
0.000000,0,0.000000,while (1) {
0.000000,0,0.000000,$self->smartReadExact(\$buffer, 1)
0.000000,0,0.000000,or return $self->TruncatedHeader("FNAME");
0.000000,0,0.000000,last if $buffer eq GZIP_NULL_BYTE ;
0.000000,0,0.000000,$origname .= $buffer
0.000000,0,0.000000,}
0.000000,0,0.000000,$keep .= $origname . GZIP_NULL_BYTE ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->HeaderError("Non ISO 8859-1 Character found in Name")
0.000000,0,0.000000,if *$self->{Strict} && $origname =~ /$GZIP_FNAME_INVALID_CHAR_RE/o ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $comment ;
0.000000,0,0.000000,if ($flag & GZIP_FLG_FCOMMENT) {
0.000000,0,0.000000,$comment = "";
0.000000,0,0.000000,while (1) {
0.000000,0,0.000000,$self->smartReadExact(\$buffer, 1)
0.000000,0,0.000000,or return $self->TruncatedHeader("FCOMMENT");
0.000000,0,0.000000,last if $buffer eq GZIP_NULL_BYTE ;
0.000000,0,0.000000,$comment .= $buffer
0.000000,0,0.000000,}
0.000000,0,0.000000,$keep .= $comment . GZIP_NULL_BYTE ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->HeaderError("Non ISO 8859-1 Character found in Comment")
0.000000,0,0.000000,if *$self->{Strict} && $comment =~ /$GZIP_FCOMMENT_INVALID_CHAR_RE/o ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($flag & GZIP_FLG_FHCRC) {
0.000000,0,0.000000,$self->smartReadExact(\$buffer, GZIP_FHCRC_SIZE)
0.000000,0,0.000000,or return $self->TruncatedHeader("FHCRC");
0.000000,0,0.000000,
0.000000,0,0.000000,$HeaderCRC = unpack("v", $buffer) ;
0.000000,0,0.000000,my $crc16 = Compress::Raw::Zlib::crc32($keep) & 0xFF ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->HeaderError("CRC16 mismatch.")
0.000000,0,0.000000,if *$self->{Strict} && $crc16 != $HeaderCRC;
0.000000,0,0.000000,
0.000000,0,0.000000,$keep .= $buffer ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Assume compression method is deflated for xfl tests
0.000000,0,0.000000,#if ($xfl) {
0.000000,0,0.000000,#}
0.000000,0,0.000000,
0.000000,0,0.000000,*$self->{Type} = 'rfc1952';
0.000000,0,0.000000,
0.000000,0,0.000000,return {
0.000000,0,0.000000,'Type'          => 'rfc1952',
0.000000,0,0.000000,'FingerprintLength'  => 2,
0.000000,0,0.000000,'HeaderLength'  => length $keep,
0.000000,0,0.000000,'TrailerLength' => GZIP_TRAILER_SIZE,
0.000000,0,0.000000,'Header'        => $keep,
0.000000,0,0.000000,'isMinimalHeader' => $keep eq GZIP_MINIMUM_HEADER ? 1 : 0,
0.000000,0,0.000000,
0.000000,0,0.000000,'MethodID'      => $cm,
0.000000,0,0.000000,'MethodName'    => $cm == GZIP_CM_DEFLATED ? "Deflated" : "Unknown" ,
0.000000,0,0.000000,'TextFlag'      => $flag & GZIP_FLG_FTEXT ? 1 : 0,
0.000000,0,0.000000,'HeaderCRCFlag' => $flag & GZIP_FLG_FHCRC ? 1 : 0,
0.000000,0,0.000000,'NameFlag'      => $flag & GZIP_FLG_FNAME ? 1 : 0,
0.000000,0,0.000000,'CommentFlag'   => $flag & GZIP_FLG_FCOMMENT ? 1 : 0,
0.000000,0,0.000000,'ExtraFlag'     => $flag & GZIP_FLG_FEXTRA ? 1 : 0,
0.000000,0,0.000000,'Name'          => $origname,
0.000000,0,0.000000,'Comment'       => $comment,
0.000000,0,0.000000,'Time'          => $mtime,
0.000000,0,0.000000,'OsID'          => $os,
0.000000,0,0.000000,'OsName'        => defined $GZIP_OS_Names{$os}
0.000000,0,0.000000,? $GZIP_OS_Names{$os} : "Unknown",
0.000000,0,0.000000,'HeaderCRC'     => $HeaderCRC,
0.000000,0,0.000000,'Flags'         => $flag,
0.000000,0,0.000000,'ExtraFlags'    => $xfl,
0.000000,0,0.000000,'ExtraFieldRaw' => $EXTRA,
0.000000,0,0.000000,'ExtraField'    => [ @EXTRA ],
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#'CompSize'=> $compsize,
0.000000,0,0.000000,#'CRC32'=> $CRC32,
0.000000,0,0.000000,#'OrigSize'=> $ISIZE,
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000008,1,0.000008,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
