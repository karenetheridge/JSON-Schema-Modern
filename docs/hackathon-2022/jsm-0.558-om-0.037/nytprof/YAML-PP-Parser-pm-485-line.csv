# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# ABSTRACT: YAML Parser
0.000020,2,0.000010,use strict;
0.000033,2,0.000017,use warnings;
0.000000,0,0.000000,package YAML::PP::Parser;
0.000000,0,0.000000,
0.000004,1,0.000004,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000027,2,0.000013,use constant TRACE => $ENV{YAML_PP_TRACE} ? 1 : 0;
0.000024,2,0.000012,use constant DEBUG => ($ENV{YAML_PP_DEBUG} || $ENV{YAML_PP_TRACE}) ? 1 : 0;
0.000000,0,0.000000,
0.000000,1,0.000000,use YAML::PP::Common qw/
0.000000,0,0.000000,YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,YAML_DOUBLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE
0.000000,0,0.000000,YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE
0.000017,1,0.000017,/;
0.000442,2,0.000221,use YAML::PP::Render;
0.000520,2,0.000260,use YAML::PP::Lexer;
0.000097,2,0.000048,use YAML::PP::Grammar qw/ $GRAMMAR /;
0.002590,2,0.001295,use YAML::PP::Exception;
0.000437,2,0.000218,use YAML::PP::Reader;
0.000737,2,0.000369,use Carp qw/ croak /;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000003,1,0.000003,my ($class, %args) = @_;
0.000004,1,0.000004,my $reader = delete $args{reader} || YAML::PP::Reader->new;
0.000001,1,0.000001,my $default_yaml_version = delete $args{default_yaml_version};
0.000005,1,0.000005,my $self = bless {
0.000000,0,0.000000,default_yaml_version => $default_yaml_version || '1.2',
0.000000,0,0.000000,lexer => YAML::PP::Lexer->new(
0.000000,0,0.000000,reader => $reader,
0.000000,0,0.000000,),
0.000000,0,0.000000,}, $class;
0.000001,1,0.000001,my $receiver = delete $args{receiver};
0.000000,1,0.000000,if ($receiver) {
0.000000,0,0.000000,$self->set_receiver($receiver);
0.000000,0,0.000000,}
0.000003,1,0.000003,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my $clone = {
0.000000,0,0.000000,default_yaml_version => $self->default_yaml_version,
0.000000,0,0.000000,lexer => YAML::PP::Lexer->new(),
0.000000,0,0.000000,};
0.000000,0,0.000000,return bless $clone, ref $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000009,1,0.000009,sub receiver { return $_[0]->{receiver} }
0.000000,0,0.000000,sub set_receiver {
0.000000,1,0.000000,my ($self, $receiver) = @_;
0.000001,1,0.000001,my $callback;
0.000002,1,0.000002,if (ref $receiver eq 'CODE') {
0.000000,0,0.000000,$callback = $receiver;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$callback = sub {
0.010232,36113,0.000000,my ($self, $event, $info) = @_;
0.102653,36113,0.000003,return $receiver->$event($info);
0.000008,1,0.000008,};
0.000000,0,0.000000,}
0.000000,1,0.000000,$self->{callback} = $callback;
0.000015,1,0.000015,$self->{receiver} = $receiver;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub reader { return $_[0]->lexer->{reader} }
0.000000,0,0.000000,sub set_reader {
0.000000,1,0.000000,my ($self, $reader) = @_;
0.000005,1,0.000005,$self->lexer->set_reader($reader);
0.000000,0,0.000000,}
0.077661,55337,0.000001,sub lexer { return $_[0]->{lexer} }
0.046656,36113,0.000001,sub callback { return $_[0]->{callback} }
0.000000,0,0.000000,sub set_callback { $_[0]->{callback} = $_[1] }
0.016115,6993,0.000002,sub level { return $#{ $_[0]->{offset} } }
0.046756,31969,0.000001,sub offset { return $_[0]->{offset} }
0.000003,1,0.000003,sub set_offset { $_[0]->{offset} = $_[1] }
0.090255,62745,0.000001,sub events { return $_[0]->{events} }
0.000002,1,0.000002,sub set_events { $_[0]->{events} = $_[1] }
0.038336,27450,0.000001,sub new_node { return $_[0]->{new_node} }
0.055458,36237,0.000002,sub set_new_node { $_[0]->{new_node} = $_[1] }
0.000000,0,0.000000,sub tagmap { return $_[0]->{tagmap} }
0.000006,2,0.000003,sub set_tagmap { $_[0]->{tagmap} = $_[1] }
0.021396,13450,0.000002,sub tokens { return $_[0]->{tokens} }
0.000002,1,0.000002,sub set_tokens { $_[0]->{tokens} = $_[1] }
0.105946,70379,0.000002,sub event_stack { return $_[0]->{event_stack} }
0.000002,1,0.000002,sub set_event_stack { $_[0]->{event_stack} = $_[1] }
0.000002,1,0.000002,sub default_yaml_version { return $_[0]->{default_yaml_version} }
0.000003,1,0.000003,sub yaml_version { return $_[0]->{yaml_version} }
0.000002,1,0.000002,sub set_yaml_version { $_[0]->{yaml_version} = $_[1] }
0.000003,1,0.000003,sub yaml_version_directive { return $_[0]->{yaml_version_directive} }
0.000005,2,0.000002,sub set_yaml_version_directive { $_[0]->{yaml_version_directive} = $_[1] }
0.000000,0,0.000000,
0.021088,13450,0.000002,sub rule { return $_[0]->{rule} }
0.000000,0,0.000000,sub set_rule {
0.015971,55080,0.000000,my ($self, $name) = @_;
0.009014,2,0.004507,no warnings 'uninitialized';
0.000000,0,0.000000,DEBUG and $self->info("set_rule($name)");
0.110285,55080,0.000002,$self->{rule} = $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub init {
0.000000,1,0.000000,my ($self) = @_;
0.000001,1,0.000001,$self->set_offset([]);
0.000014,1,0.000014,$self->set_events([]);
0.000002,1,0.000002,$self->set_new_node(0);
0.000001,1,0.000001,$self->set_tagmap({
0.000000,0,0.000000,'!!' => "tag:yaml.org,2002:",
0.000000,0,0.000000,});
0.000002,1,0.000002,$self->set_tokens([]);
0.000003,1,0.000003,$self->set_rule(undef);
0.000001,1,0.000001,$self->set_event_stack([]);
0.000003,1,0.000003,$self->set_yaml_version($self->default_yaml_version);
0.000001,1,0.000001,$self->set_yaml_version_directive(undef);
0.000004,1,0.000004,$self->lexer->init;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_string {
0.000000,0,0.000000,my ($self, $yaml) = @_;
0.000000,0,0.000000,$self->set_reader(YAML::PP::Reader->new( input => $yaml ));
0.000000,0,0.000000,$self->parse();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_file {
0.000000,0,0.000000,my ($self, $file) = @_;
0.000000,0,0.000000,$self->set_reader(YAML::PP::Reader::File->new( input => $file ));
0.000000,0,0.000000,$self->parse();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000013,1,0.000013,my %nodetypes = (
0.000000,0,0.000000,MAPVALUE     => 'NODETYPE_COMPLEX',
0.000000,0,0.000000,MAP          => 'NODETYPE_MAP',
0.000000,0,0.000000,#    IMAP         => 'NODETYPE_SEQ',
0.000000,0,0.000000,SEQ          => 'NODETYPE_SEQ',
0.000000,0,0.000000,SEQ0         => 'NODETYPE_SEQ',
0.000000,0,0.000000,FLOWMAP      => 'NODETYPE_FLOWMAP',
0.000000,0,0.000000,FLOWMAPVALUE => 'NODETYPE_FLOWMAPVALUE',
0.000000,0,0.000000,FLOWSEQ      => 'NODETYPE_FLOWSEQ',
0.000000,0,0.000000,FLOWSEQ_NEXT => 'FLOWSEQ_NEXT',
0.000000,0,0.000000,DOC          => 'FULLNODE',
0.000000,0,0.000000,DOC_END      => 'DOCUMENT_END',
0.000000,0,0.000000,STR          => 'STREAM',
0.000000,0,0.000000,END_FLOW     => 'END_FLOW',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse {
0.000000,1,0.000000,my ($self) = @_;
0.000000,0,0.000000,TRACE and warn "=== parse()\n";
0.000000,0,0.000000,TRACE and $self->debug_yaml;
0.000002,1,0.000002,$self->init;
0.000002,1,0.000002,$self->lexer->init;
0.000001,1,0.000001,eval {
0.000001,1,0.000001,$self->start_stream;
0.000001,1,0.000001,$self->set_rule( 'STREAM' );
0.000000,0,0.000000,
0.000002,1,0.000002,$self->parse_tokens();
0.000000,0,0.000000,
0.000003,1,0.000003,$self->end_stream;
0.000000,0,0.000000,};
0.000001,1,0.000001,if (my $error = $@) {
0.000000,0,0.000000,if (ref $error) {
0.000000,0,0.000000,croak "$error\n ";
0.000000,0,0.000000,}
0.000000,0,0.000000,croak $error;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and $self->highlight_yaml;
0.000004,1,0.000004,TRACE and $self->debug_tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub lex_next_tokens {
0.003481,13451,0.000000,my ($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and $self->info("----------------> lex_next_tokens");
0.000000,0,0.000000,TRACE and $self->debug_events;
0.000000,0,0.000000,
0.013289,13451,0.000001,my $indent = $self->offset->[-1];
0.008995,13451,0.000001,my $event_types = $self->events;
0.023836,13451,0.000002,my $next_tokens = $self->lexer->fetch_next_tokens($indent);
0.002148,13451,0.000000,return unless @$next_tokens;
0.000000,0,0.000000,
0.004947,13450,0.000000,my $next = $next_tokens->[0];
0.000000,0,0.000000,
0.005472,13450,0.000000,return 1 if ($next->{name} ne 'SPACE');
0.025625,13449,0.000002,my $flow = $event_types->[-1] =~ m/^FLOW/;
0.007397,13449,0.000001,my $space = length $next->{value};
0.012588,13449,0.000001,my $tokens = $self->tokens;
0.000000,0,0.000000,
0.005956,13449,0.000000,if (not $space) {
0.000000,0,0.000000,shift @$next_tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.004679,13444,0.000000,push @$tokens, shift @$next_tokens;
0.000000,0,0.000000,}
0.002233,13449,0.000000,if ($flow) {
0.000000,0,0.000000,if ($space >= $indent) {
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->exception("Bad indendation in " . $self->events->[-1]);
0.000000,0,0.000000,}
0.003940,13449,0.000000,$next = $next_tokens->[0];
0.004304,13449,0.000000,if ($space > $indent ) {
0.001323,6149,0.000000,return 1 if $indent < 0;
0.004818,6148,0.000001,unless ($self->new_node) {
0.000000,0,0.000000,$self->exception("Bad indendation in " . $self->events->[-1]);
0.000000,0,0.000000,}
0.012900,6148,0.000002,return 1;
0.000000,0,0.000000,}
0.008918,7300,0.000001,if ($self->new_node) {
0.000305,308,0.000001,if ($space < $indent) {
0.000000,0,0.000000,$self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
0.000000,0,0.000000,$self->remove_nodes($space);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# unindented sequence starts
0.000615,308,0.000002,my $exp = $self->events->[-1];
0.000211,308,0.000001,my $seq_start = $next->{name} eq 'DASH';
0.000363,308,0.000001,if ( $seq_start and ($exp eq 'MAPVALUE' or $exp eq 'MAP')) {
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.006166,6992,0.000001,if ($space < $indent) {
0.000000,0,0.000000,$self->remove_nodes($space);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.008301,7300,0.000001,my $exp = $self->events->[-1];
0.000000,0,0.000000,
0.002878,7300,0.000000,if ($exp eq 'SEQ0' and $next->{name} ne 'DASH') {
0.000000,0,0.000000,TRACE and $self->info("In unindented sequence");
0.000414,262,0.000002,$self->end_sequence;
0.000296,262,0.000001,$exp = $self->events->[-1];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.008304,7300,0.000001,if ($self->offset->[-1] != $space) {
0.000000,0,0.000000,$self->exception("Expected " . $self->events->[-1]);
0.000000,0,0.000000,}
0.016492,7300,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000012,1,0.000012,my %next_event = (
0.000000,0,0.000000,MAP => 'MAPVALUE',
0.000000,0,0.000000,IMAP => 'IMAPVALUE',
0.000000,0,0.000000,MAPVALUE => 'MAP',
0.000000,0,0.000000,IMAPVALUE => 'IMAP',
0.000000,0,0.000000,SEQ => 'SEQ',
0.000000,0,0.000000,SEQ0 => 'SEQ0',
0.000000,0,0.000000,DOC => 'DOC_END',
0.000000,0,0.000000,STR => 'STR',
0.000000,0,0.000000,FLOWSEQ => 'FLOWSEQ_NEXT',
0.000000,0,0.000000,FLOWSEQ_NEXT => 'FLOWSEQ',
0.000000,0,0.000000,FLOWMAP => 'FLOWMAPVALUE',
0.000000,0,0.000000,FLOWMAPVALUE => 'FLOWMAP',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000015,1,0.000015,my %event_to_method = (
0.000000,0,0.000000,MAP => 'mapping',
0.000000,0,0.000000,IMAP => 'mapping',
0.000000,0,0.000000,FLOWMAP => 'mapping',
0.000000,0,0.000000,SEQ => 'sequence',
0.000000,0,0.000000,SEQ0 => 'sequence',
0.000000,0,0.000000,FLOWSEQ => 'sequence',
0.000000,0,0.000000,DOC => 'document',
0.000000,0,0.000000,STR => 'stream',
0.000000,0,0.000000,VAL => 'scalar',
0.000000,0,0.000000,ALI => 'alias',
0.000000,0,0.000000,MAPVALUE => 'mapping',
0.000000,0,0.000000,IMAPVALUE => 'mapping',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,#sub process_events {
0.000000,0,0.000000,#    my ($self, $res) = @_;
0.000000,0,0.000000,#
0.000000,0,0.000000,#    my $event_stack = $self->event_stack;
0.000000,0,0.000000,#    return unless @$event_stack;
0.000000,0,0.000000,#
0.000000,0,0.000000,#    if (@$event_stack == 1 and $event_stack->[0]->[0] eq 'properties') {
0.000000,0,0.000000,#        return;
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#
0.000000,0,0.000000,#    my $event_types = $self->events;
0.000000,0,0.000000,#    my $properties;
0.000000,0,0.000000,#    my @send_events;
0.000000,0,0.000000,#    for my $event (@$event_stack) {
0.000000,0,0.000000,#        TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$event], ['event']);
0.000000,0,0.000000,#        my ($type, $info) = @$event;
0.000000,0,0.000000,#        if ($type eq 'properties') {
0.000000,0,0.000000,#            $properties = $info;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#        elsif ($type eq 'scalar') {
0.000000,0,0.000000,#            $info->{name} = 'scalar_event';
0.000000,0,0.000000,#            $event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,#            push @send_events, $info;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#        elsif ($type eq 'begin') {
0.000000,0,0.000000,#            my $name = $info->{name};
0.000000,0,0.000000,#            $info->{name} = $event_to_method{ $name } . '_start_event';
0.000000,0,0.000000,#            push @{ $event_types }, $name;
0.000000,0,0.000000,#            push @{ $self->offset }, $info->{offset};
0.000000,0,0.000000,#            push @send_events, $info;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#        elsif ($type eq 'end') {
0.000000,0,0.000000,#            my $name = $info->{name};
0.000000,0,0.000000,#            $info->{name} = $event_to_method{ $name } . '_end_event';
0.000000,0,0.000000,#            $self->$type($name, $info);
0.000000,0,0.000000,#            push @send_events, $info;
0.000000,0,0.000000,#            if (@$event_types) {
0.000000,0,0.000000,#                $event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,#            }
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#        elsif ($type eq 'alias') {
0.000000,0,0.000000,#            if ($properties) {
0.000000,0,0.000000,#                $self->exception("Parse error: Alias not allowed in this context");
0.000000,0,0.000000,#            }
0.000000,0,0.000000,#            $info->{name} = 'alias_event';
0.000000,0,0.000000,#            $event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,#            push @send_events, $info;
0.000000,0,0.000000,#        }
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#    @$event_stack = ();
0.000000,0,0.000000,#    for my $info (@send_events) {
0.000000,0,0.000000,#        DEBUG and $self->debug_event( $info );
0.000000,0,0.000000,#        $self->callback->($self, $info->{name}, $info);
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#}
0.000000,0,0.000000,
0.000003,1,0.000003,my %fetch_method = (
0.000000,0,0.000000,'"' => 'fetch_quoted',
0.000000,0,0.000000,"'" => 'fetch_quoted',
0.000000,0,0.000000,'|' => 'fetch_block',
0.000000,0,0.000000,'>' => 'fetch_block',
0.000000,0,0.000000,''  => 'fetch_plain',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_tokens {
0.000008,1,0.000008,my ($self) = @_;
0.000004,1,0.000004,my $event_types = $self->events;
0.000001,1,0.000001,my $offsets = $self->offset;
0.000002,1,0.000002,my $tokens = $self->tokens;
0.000003,1,0.000003,my $next_tokens = $self->lexer->next_tokens;
0.000000,0,0.000000,
0.000002,1,0.000002,unless ($self->lex_next_tokens) {
0.000000,0,0.000000,$self->end_document(1);
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000003,1,0.000003,unless ($self->new_node) {
0.000003,1,0.000003,if ($self->level > 0) {
0.000000,0,0.000000,my $new_rule = $nodetypes{ $event_types->[-1] }
0.000000,0,0.000000,or die "Did not find '$event_types->[-1]'";
0.000000,0,0.000000,$self->set_rule( $new_rule );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,my $rule_name = $self->rule;
0.000000,0,0.000000,DEBUG and $self->info("----------------> parse_tokens($rule_name)");
0.000002,1,0.000002,my $rule = $GRAMMAR->{ $rule_name }
0.000000,0,0.000000,or die "Could not find rule $rule_name";
0.000000,0,0.000000,
0.000000,0,0.000000,TRACE and $self->debug_rules($rule);
0.000000,0,0.000000,TRACE and $self->debug_yaml;
0.000000,0,0.000000,DEBUG and $self->debug_next_line;
0.000000,0,0.000000,
0.009748,1,0.009748,RULE: while ($rule_name) {
0.000000,0,0.000000,DEBUG and $self->info("RULE: $rule_name");
0.000000,0,0.000000,TRACE and $self->debug_tokens($next_tokens);
0.000000,0,0.000000,
0.014119,110985,0.000000,unless (@$next_tokens) {
0.000000,0,0.000000,$self->exception("No more tokens");
0.000000,0,0.000000,}
0.000000,0,0.000000,TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$next_tokens->[0]], ['next_token']);
0.033106,110985,0.000000,my $got = $next_tokens->[0]->{name};
0.016755,110985,0.000000,if ($got eq 'CONTEXT') {
0.004799,20941,0.000000,my $context = shift @$next_tokens;
0.004743,20941,0.000000,my $indent = $offsets->[-1];
0.031653,20941,0.000002,$indent++ unless $self->lexer->flowcontext;
0.012214,20941,0.000001,my $method = $fetch_method{ $context->{value} };
0.036487,20941,0.000002,my $partial = $self->lexer->$method($indent, $context->{value});
0.028965,20941,0.000001,next RULE;
0.000000,0,0.000000,}
0.042844,90044,0.000000,my $def = $rule->{ $got };
0.036873,90044,0.000000,if ($def) {
0.000000,0,0.000000,push @$tokens, shift @$next_tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($def = $rule->{DEFAULT}) {
0.000000,0,0.000000,$got = 'DEFAULT';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->expected(
0.000000,0,0.000000,expected => [keys %$rule],
0.000000,0,0.000000,got => $next_tokens->[0],
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and $self->got("---got $got");
0.040193,90044,0.000000,if (my $sub = $def->{match}) {
0.000000,0,0.000000,DEBUG and $self->info("CALLBACK $sub");
0.062424,43770,0.000001,$self->$sub(@$tokens ? $tokens->[-1] : ());
0.000000,0,0.000000,}
0.019544,90044,0.000000,my $eol = $got eq 'EOL';
0.024769,90044,0.000000,my $new = $def->{new};
0.025197,90044,0.000000,if ($new) {
0.000000,0,0.000000,DEBUG and $self->got("NEW: $new");
0.008477,46809,0.000000,$rule_name = $new;
0.036395,46809,0.000001,$self->set_rule($rule_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($eol) {
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($def->{return}) {
0.001029,1275,0.000001,$rule_name = $nodetypes{ $event_types->[-1] }
0.000000,0,0.000000,or die "Unexpected event type $event_types->[-1]";
0.000989,1275,0.000001,$self->set_rule($rule_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.020042,34967,0.000001,$rule_name .= " - $got"; # for debugging
0.004604,34967,0.000000,$rule = $def;
0.013176,34967,0.000000,next RULE;
0.000000,0,0.000000,}
0.009112,55077,0.000000,if ($eol) {
0.014550,13450,0.000001,unless ($self->lex_next_tokens) {
0.000001,1,0.000001,if ($rule_name eq 'DIRECTIVE') {
0.000000,0,0.000000,$self->exception("Directive needs document start");
0.000000,0,0.000000,}
0.000002,1,0.000002,$self->end_document(1);
0.000005,1,0.000005,return 0;
0.000000,0,0.000000,}
0.011875,13449,0.000001,unless ($self->new_node) {
0.010668,6992,0.000002,if ($self->level > 0) {
0.005613,6992,0.000001,$rule_name = $nodetypes{ $event_types->[-1] }
0.000000,0,0.000000,or die "Did not find '$event_types->[-1]'";
0.005407,6992,0.000001,$self->set_rule( $rule_name );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.015274,13449,0.000001,$rule_name = $self->rule;
0.000000,0,0.000000,}
0.089257,55076,0.000002,$rule = $GRAMMAR->{ $rule_name }
0.000000,0,0.000000,or die "Unexpected rule $rule_name";
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,die "Unexpected";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_sequence {
0.000124,262,0.000000,my ($self) = @_;
0.000214,262,0.000001,my $event_types = $self->events;
0.000109,262,0.000000,pop @{ $event_types };
0.000338,262,0.000001,pop @{ $self->offset };
0.000229,262,0.000001,my $info = { name => 'sequence_end_event' };
0.000501,262,0.000002,$self->callback->($self, $info->{name} => $info );
0.000952,262,0.000004,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove_nodes {
0.001248,2816,0.000000,my ($self, $space) = @_;
0.003161,2816,0.000001,my $offset = $self->offset;
0.002780,2816,0.000001,my $event_types = $self->events;
0.000000,0,0.000000,
0.001383,2816,0.000000,my $exp = $event_types->[-1];
0.001073,2816,0.000000,while (@$offset) {
0.003242,9587,0.000000,if ($offset->[ -1 ] <= $space) {
0.001364,2816,0.000000,last;
0.000000,0,0.000000,}
0.001703,6771,0.000000,if ($exp eq 'MAPVALUE') {
0.000000,0,0.000000,$self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
0.000000,0,0.000000,$exp = 'MAP';
0.000000,0,0.000000,}
0.004320,6771,0.000001,my $info = { name => $exp };
0.005099,6771,0.000001,$info->{name} = $event_to_method{ $exp } . '_end_event';
0.002041,6771,0.000000,pop @{ $event_types };
0.001182,6771,0.000000,pop @{ $offset };
0.010683,6771,0.000002,$self->callback->($self, $info->{name} => $info );
0.004838,6771,0.000001,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.006491,6771,0.000001,$exp = $event_types->[-1];
0.000000,0,0.000000,}
0.006509,2816,0.000002,return $exp;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_stream {
0.000001,1,0.000001,my ($self) = @_;
0.000001,1,0.000001,push @{ $self->events }, 'STR';
0.000003,1,0.000003,push @{ $self->offset }, -1;
0.000004,1,0.000004,$self->callback->($self, 'stream_start_event', {
0.000000,0,0.000000,name => 'stream_start_event',
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_document {
0.000000,1,0.000000,my ($self, $implicit) = @_;
0.000003,1,0.000003,push @{ $self->events }, 'DOC';
0.000002,1,0.000002,push @{ $self->offset }, -1;
0.000002,1,0.000002,my $directive = $self->yaml_version_directive;
0.000001,1,0.000001,my %directive;
0.000000,1,0.000000,if ($directive) {
0.000000,0,0.000000,my ($major, $minor) = split m/\./, $self->yaml_version;
0.000000,0,0.000000,%directive = ( version_directive => { major => $major, minor => $minor } );
0.000000,0,0.000000,}
0.000010,1,0.000010,$self->callback->($self, 'document_start_event', {
0.000000,0,0.000000,name => 'document_start_event',
0.000000,0,0.000000,implicit => $implicit,
0.000000,0,0.000000,%directive,
0.000000,0,0.000000,});
0.000002,1,0.000002,$self->set_yaml_version_directive(undef);
0.000001,1,0.000001,$self->set_rule( 'FULLNODE' );
0.000006,1,0.000006,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_sequence {
0.000139,308,0.000000,my ($self, $offset) = @_;
0.000271,308,0.000001,my $offsets = $self->offset;
0.000563,308,0.000002,if ($offsets->[-1] == $offset) {
0.000000,0,0.000000,push @{ $self->events }, 'SEQ0';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @{ $self->events }, 'SEQ';
0.000000,0,0.000000,}
0.000138,308,0.000000,push @{ $offsets }, $offset;
0.000350,308,0.000001,my $event_stack = $self->event_stack;
0.000330,308,0.000001,my $info = { name => 'sequence_start_event' };
0.000130,308,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,my $properties = pop @$event_stack;
0.000000,0,0.000000,$self->node_properties($properties->[1], $info);
0.000000,0,0.000000,}
0.001242,308,0.000004,$self->callback->($self, 'sequence_start_event', $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_flow_sequence {
0.000151,337,0.000000,my ($self, $offset) = @_;
0.000362,337,0.000001,my $offsets = $self->offset;
0.000183,337,0.000001,my $new_offset = $offsets->[-1];
0.000360,337,0.000001,my $event_types = $self->events;
0.000571,337,0.000002,if ($new_offset < 0) {
0.000000,0,0.000000,$new_offset = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->new_node) {
0.000901,337,0.000003,if ($event_types->[-1] !~ m/^FLOW/) {
0.000000,0,0.000000,$new_offset++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000397,337,0.000001,push @{ $self->events }, 'FLOWSEQ';
0.000144,337,0.000000,push @{ $offsets }, $new_offset;
0.000000,0,0.000000,
0.000340,337,0.000001,my $event_stack = $self->event_stack;
0.000395,337,0.000001,my $info = { style => YAML_FLOW_SEQUENCE_STYLE, name => 'sequence_start_event'  };
0.000102,337,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($event_stack, $info);
0.000000,0,0.000000,}
0.001295,337,0.000004,$self->callback->($self, 'sequence_start_event', $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_flow_mapping {
0.000087,214,0.000000,my ($self, $offset, $implicit_flowseq_map) = @_;
0.000193,214,0.000001,my $offsets = $self->offset;
0.000074,214,0.000000,my $new_offset = $offsets->[-1];
0.000205,214,0.000001,my $event_types = $self->events;
0.000302,214,0.000001,if ($new_offset < 0) {
0.000000,0,0.000000,$new_offset = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->new_node) {
0.000500,214,0.000002,if ($event_types->[-1] !~ m/^FLOW/) {
0.000000,0,0.000000,$new_offset++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000422,214,0.000002,push @{ $self->events }, $implicit_flowseq_map ? 'IMAP' : 'FLOWMAP';
0.000082,214,0.000000,push @{ $offsets }, $new_offset;
0.000000,0,0.000000,
0.000229,214,0.000001,my $event_stack = $self->event_stack;
0.000315,214,0.000001,my $info = { name => 'mapping_start_event', style => YAML_FLOW_MAPPING_STYLE };
0.000064,214,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($event_stack, $info);
0.000000,0,0.000000,}
0.000812,214,0.000004,$self->callback->($self, 'mapping_start_event', $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_flow_sequence {
0.000182,337,0.000001,my ($self) = @_;
0.000523,337,0.000002,my $event_types = $self->events;
0.000179,337,0.000001,pop @{ $event_types };
0.000423,337,0.000001,pop @{ $self->offset };
0.000266,337,0.000001,my $info = { name => 'sequence_end_event' };
0.000737,337,0.000002,$self->callback->($self, $info->{name}, $info);
0.002702,337,0.000008,if ($event_types->[-1] =~ m/^FLOW|^IMAP/) {
0.000000,0,0.000000,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000139,314,0.000000,push @$event_types, 'END_FLOW';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_flow_mapping {
0.000133,214,0.000001,my ($self) = @_;
0.000270,214,0.000001,my $event_types = $self->events;
0.000102,214,0.000000,pop @{ $event_types };
0.000245,214,0.000001,pop @{ $self->offset };
0.000170,214,0.000001,my $info = { name => 'mapping_end_event' };
0.000333,214,0.000002,$self->callback->($self, $info->{name}, $info);
0.001638,214,0.000008,if ($event_types->[-1] =~ m/^FLOW|^IMAP/) {
0.000000,0,0.000000,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000120,214,0.000001,push @$event_types, 'END_FLOW';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_outer_flow {
0.000279,528,0.000001,my ($self) = @_;
0.000479,528,0.000001,my $event_types = $self->events;
0.000334,528,0.000001,pop @$event_types;
0.001341,528,0.000003,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub start_mapping {
0.002031,6725,0.000000,my ($self, $offset) = @_;
0.007110,6725,0.000001,my $offsets = $self->offset;
0.007658,6725,0.000001,push @{ $self->events }, 'MAP';
0.002393,6725,0.000000,push @{ $offsets }, $offset;
0.004173,6725,0.000001,my $event_stack = $self->event_stack;
0.005903,6725,0.000001,my $info = { name => 'mapping_start_event' };
0.001431,6725,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,my $properties = pop @$event_stack;
0.000000,0,0.000000,$self->node_properties($properties->[1], $info);
0.000000,0,0.000000,}
0.021693,6725,0.000003,$self->callback->($self, 'mapping_start_event', $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_document {
0.000000,1,0.000000,my ($self, $implicit) = @_;
0.000000,0,0.000000,
0.000001,1,0.000001,my $event_types = $self->events;
0.000005,1,0.000005,if ($event_types->[-1] =~ m/FLOW/) {
0.000000,0,0.000000,die "Unexpected end of flow context";
0.000000,0,0.000000,}
0.000001,1,0.000001,if ($self->new_node) {
0.000000,0,0.000000,$self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
0.000000,0,0.000000,}
0.000002,1,0.000002,$self->remove_nodes(-1);
0.000000,0,0.000000,
0.000001,1,0.000001,if ($event_types->[-1] eq 'STR') {
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,1,0.000000,my $last = pop @{ $event_types };
0.000000,1,0.000000,if ($last ne 'DOC' and $last ne 'DOC_END') {
0.000000,0,0.000000,$self->exception("Unexpected event type $last");
0.000000,0,0.000000,}
0.000002,1,0.000002,pop @{ $self->offset };
0.000004,1,0.000004,$self->callback->($self, 'document_end_event', {
0.000000,0,0.000000,name => 'document_end_event',
0.000000,0,0.000000,implicit => $implicit,
0.000000,0,0.000000,});
0.000005,1,0.000005,if ($self->yaml_version eq '1.2') {
0.000000,0,0.000000,# In YAML 1.2, directives are only for the following
0.000000,0,0.000000,# document. In YAML 1.1, they are global
0.000000,0,0.000000,$self->set_tagmap({ '!!' => "tag:yaml.org,2002:" });
0.000000,0,0.000000,}
0.000001,1,0.000001,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000006,1,0.000006,$self->set_rule('STREAM');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_stream {
0.000000,1,0.000000,my ($self) = @_;
0.000002,1,0.000002,my $last = pop @{ $self->events };
0.000001,1,0.000001,$self->exception("Unexpected event type $last") unless $last eq 'STR';
0.000002,1,0.000002,pop @{ $self->offset };
0.000006,1,0.000006,$self->callback->($self, 'stream_end_event', {
0.000000,0,0.000000,name => 'stream_end_event',
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetch_inline_properties {
0.000000,0,0.000000,my ($self, $stack, $info) = @_;
0.000000,0,0.000000,my $properties = $stack->[-1];
0.000000,0,0.000000,
0.000000,0,0.000000,$properties = $properties->[1];
0.000000,0,0.000000,my $property_offset;
0.000000,0,0.000000,if ($properties) {
0.000000,0,0.000000,for my $p (@{ $properties->{inline} }) {
0.000000,0,0.000000,my $type = $p->{type};
0.000000,0,0.000000,if (exists $info->{ $type }) {
0.000000,0,0.000000,$self->exception("A node can only have one $type");
0.000000,0,0.000000,}
0.000000,0,0.000000,$info->{ $type } = $p->{value};
0.000000,0,0.000000,unless (defined $property_offset) {
0.000000,0,0.000000,$property_offset = $p->{offset};
0.000000,0,0.000000,$info->{offset} = $p->{offset};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,delete $properties->{inline};
0.000000,0,0.000000,undef $properties unless $properties->{newline};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless ($properties) {
0.000000,0,0.000000,pop @$stack;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub node_properties {
0.000000,0,0.000000,my ($self, $properties, $info) = @_;
0.000000,0,0.000000,if ($properties) {
0.000000,0,0.000000,for my $p (@{ $properties->{newline} }) {
0.000000,0,0.000000,my $type = $p->{type};
0.000000,0,0.000000,if (exists $info->{ $type }) {
0.000000,0,0.000000,$self->exception("A node can only have one $type");
0.000000,0,0.000000,}
0.000000,0,0.000000,$info->{ $type } = $p->{value};
0.000000,0,0.000000,}
0.000000,0,0.000000,undef $properties;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub scalar_event {
0.004289,20941,0.000000,my ($self, $info) = @_;
0.016863,20941,0.000001,my $event_types = $self->events;
0.012076,20941,0.000001,my $event_stack = $self->event_stack;
0.003967,20941,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,my $properties = pop @$event_stack;
0.000000,0,0.000000,$properties = $self->node_properties($properties->[1], $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.008974,20941,0.000000,$info->{name} = 'scalar_event';
0.030055,20941,0.000001,$self->callback->($self, 'scalar_event', $info);
0.019379,20941,0.000001,$self->set_new_node(0);
0.050289,20941,0.000002,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub alias_event {
0.000000,0,0.000000,my ($self, $info) = @_;
0.000000,0,0.000000,my $event_stack = $self->event_stack;
0.000000,0,0.000000,if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->exception("Parse error: Alias not allowed in this context");
0.000000,0,0.000000,}
0.000000,0,0.000000,my $event_types = $self->events;
0.000000,0,0.000000,$info->{name} = 'alias_event';
0.000000,0,0.000000,$self->callback->($self, 'alias_event', $info);
0.000000,0,0.000000,$self->set_new_node(0);
0.000000,0,0.000000,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub yaml_to_tokens {
0.000000,0,0.000000,my ($class, $type, $input) = @_;
0.000000,0,0.000000,my $yp = YAML::PP::Parser->new( receiver => sub {} );
0.000000,0,0.000000,my @docs = eval {
0.000000,0,0.000000,$type eq 'string' ? $yp->parse_string($input) : $yp->parse_file($input);
0.000000,0,0.000000,};
0.000000,0,0.000000,my $error = $@;
0.000000,0,0.000000,
0.000000,0,0.000000,my $tokens = $yp->tokens;
0.000000,0,0.000000,if ($error) {
0.000000,0,0.000000,my $remaining_tokens = $yp->_remaining_tokens;
0.000000,0,0.000000,push @$tokens, map { +{ %$_, name => 'ERROR' } } @$remaining_tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $error, $tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _remaining_tokens {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my @tokens;
0.000000,0,0.000000,my $next = $self->lexer->next_tokens;
0.000000,0,0.000000,push @tokens, @$next;
0.000000,0,0.000000,my $next_line = $self->lexer->next_line;
0.000000,0,0.000000,my $remaining = '';
0.000000,0,0.000000,if ($next_line) {
0.000000,0,0.000000,if ($self->lexer->offset > 0) {
0.000000,0,0.000000,$remaining = $next_line->[1] . $next_line->[2];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$remaining = join '', @$next_line;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$remaining .= $self->reader->read;
0.000000,0,0.000000,$remaining = '' unless defined $remaining;
0.000000,0,0.000000,push @tokens, { name => "ERROR", value => $remaining };
0.000000,0,0.000000,return \@tokens;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# deprecated
0.000000,0,0.000000,sub event_to_test_suite {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self, $event) = @_; # uncoverable statement
0.000000,0,0.000000,if (ref $event eq 'ARRAY') { # uncoverable statement
0.000000,0,0.000000,return YAML::PP::Common::event_to_test_suite($event->[1]); # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,return YAML::PP::Common::event_to_test_suite($event); # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_events {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self) = @_; # uncoverable statement
0.000000,0,0.000000,$self->note("EVENTS: (" # uncoverable statement
0.000000,0,0.000000,. join (' | ', @{ $_[0]->events }) . ')' # uncoverable statement
0.000000,0,0.000000,);
0.000000,0,0.000000,$self->debug_offset; # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_offset {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self) = @_; # uncoverable statement
0.000000,0,0.000000,$self->note(
0.000000,0,0.000000,qq{OFFSET: (}
0.000000,0,0.000000,# uncoverable statement count:1
0.000000,0,0.000000,# uncoverable statement count:2
0.000000,0,0.000000,# uncoverable statement count:3
0.000000,0,0.000000,. join (' | ', map { defined $_ ? sprintf "%-3d", $_ : '?' } @{ $_[0]->offset })
0.000000,0,0.000000,# uncoverable statement
0.000000,0,0.000000,. qq/) level=@{[ $_[0]->level ]}]}/
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_yaml {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self) = @_; # uncoverable statement
0.000000,0,0.000000,my $line = $self->lexer->line; # uncoverable statement
0.000000,0,0.000000,$self->note("LINE NUMBER: $line"); # uncoverable statement
0.000000,0,0.000000,my $next_tokens = $self->lexer->next_tokens; # uncoverable statement
0.000000,0,0.000000,if (@$next_tokens) { # uncoverable statement
0.000000,0,0.000000,$self->debug_tokens($next_tokens); # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_next_line {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,my $next_line = $self->lexer->next_line || [];
0.000000,0,0.000000,my $line = $next_line->[0];
0.000000,0,0.000000,$line = '' unless defined $line;
0.000000,0,0.000000,$line =~ s/( +)$/'Â·' x length $1/e;
0.000000,0,0.000000,$line =~ s/\t/â–¸/g;
0.000000,0,0.000000,$self->note("NEXT LINE: >>$line<<");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub note {
0.000000,0,0.000000,my ($self, $msg) = @_;
0.000000,0,0.000000,$self->_colorize_warn(["yellow"], "============ $msg");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub info {
0.000000,0,0.000000,my ($self, $msg) = @_;
0.000000,0,0.000000,$self->_colorize_warn(["cyan"], "============ $msg");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub got {
0.000000,0,0.000000,my ($self, $msg) = @_;
0.000000,0,0.000000,$self->_colorize_warn(["green"], "============ $msg");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _colorize_warn {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self, $colors, $text) = @_; # uncoverable statement
0.000000,0,0.000000,require Term::ANSIColor; # uncoverable statement
0.000000,0,0.000000,warn Term::ANSIColor::colored($colors, $text), "\n"; # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_event {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self, $event) = @_; # uncoverable statement
0.000000,0,0.000000,my $str = YAML::PP::Common::event_to_test_suite($event); # uncoverable statement
0.000000,0,0.000000,require Term::ANSIColor; # uncoverable statement
0.000000,0,0.000000,warn Term::ANSIColor::colored(["magenta"], "============ $str"), "\n"; # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_rules {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self, $rules) = @_; # uncoverable statement
0.000000,0,0.000000,local $Data::Dumper::Maxdepth = 2; # uncoverable statement
0.000000,0,0.000000,$self->note("RULES:"); # uncoverable statement
0.000000,0,0.000000,for my $rule ($rules) { # uncoverable statement
0.000000,0,0.000000,if (ref $rule eq 'ARRAY') { # uncoverable statement
0.000000,0,0.000000,my $first = $rule->[0]; # uncoverable statement
0.000000,0,0.000000,if (ref $first eq 'SCALAR') { # uncoverable statement
0.000000,0,0.000000,$self->info("-> $$first"); # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,else { # uncoverable statement
0.000000,0,0.000000,if (ref $first eq 'ARRAY') { # uncoverable statement
0.000000,0,0.000000,$first = $first->[0]; # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->info("TYPE $first"); # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else { # uncoverable statement
0.000000,0,0.000000,eval { # uncoverable statement
0.000000,0,0.000000,my @keys = sort keys %$rule; # uncoverable statement
0.000000,0,0.000000,$self->info("@keys"); # uncoverable statement
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug_tokens {
0.000000,0,0.000000,# uncoverable subroutine
0.000000,0,0.000000,my ($self, $tokens) = @_; # uncoverable statement
0.000000,0,0.000000,$tokens ||= $self->tokens; # uncoverable statement
0.000000,0,0.000000,require Term::ANSIColor; # uncoverable statement
0.000000,0,0.000000,for my $token (@$tokens) { # uncoverable statement
0.000000,0,0.000000,my $type = Term::ANSIColor::colored(["green"], # uncoverable statement
0.000000,0,0.000000,sprintf "%-22s L %2d C %2d ", # uncoverable statement
0.000000,0,0.000000,$token->{name}, $token->{line}, $token->{column} + 1 # uncoverable statement
0.000000,0,0.000000,);
0.000000,0,0.000000,local $Data::Dumper::Useqq = 1; # uncoverable statement
0.000000,0,0.000000,local $Data::Dumper::Terse = 1; # uncoverable statement
0.000000,0,0.000000,require Data::Dumper; # uncoverable statement
0.000000,0,0.000000,my $str = Data::Dumper->Dump([$token->{value}], ['str']); # uncoverable statement
0.000000,0,0.000000,chomp $str; # uncoverable statement
0.000000,0,0.000000,$str =~ s/(^.|.$)/Term::ANSIColor::colored(['blue'], $1)/ge; # uncoverable statement
0.000000,0,0.000000,warn "$type$str\n"; # uncoverable statement
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub highlight_yaml {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,require YAML::PP::Highlight;
0.000000,0,0.000000,my $tokens = $self->tokens;
0.000000,0,0.000000,my $highlighted = YAML::PP::Highlight->ansicolored($tokens);
0.000000,0,0.000000,warn $highlighted;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub exception {
0.000000,0,0.000000,my ($self, $msg, %args) = @_;
0.000000,0,0.000000,my $next = $self->lexer->next_tokens;
0.000000,0,0.000000,my $line = @$next ? $next->[0]->{line} : $self->lexer->line;
0.000000,0,0.000000,my $offset = @$next ? $next->[0]->{column} : $self->lexer->offset;
0.000000,0,0.000000,$offset++;
0.000000,0,0.000000,my $next_line = $self->lexer->next_line;
0.000000,0,0.000000,my $remaining = '';
0.000000,0,0.000000,if ($next_line) {
0.000000,0,0.000000,if ($self->lexer->offset > 0) {
0.000000,0,0.000000,$remaining = $next_line->[1] . $next_line->[2];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$remaining = join '', @$next_line;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my $caller = $args{caller} || [ caller(0) ];
0.000000,0,0.000000,my $e = YAML::PP::Exception->new(
0.000000,0,0.000000,got => $args{got},
0.000000,0,0.000000,expected => $args{expected},
0.000000,0,0.000000,line => $line,
0.000000,0,0.000000,column => $offset,
0.000000,0,0.000000,msg => $msg,
0.000000,0,0.000000,next => $next,
0.000000,0,0.000000,where => $caller->[1] . ' line ' . $caller->[2],
0.000000,0,0.000000,yaml => $remaining,
0.000000,0,0.000000,);
0.000000,0,0.000000,croak $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub expected {
0.000000,0,0.000000,my ($self, %args) = @_;
0.000000,0,0.000000,my $expected = $args{expected};
0.000000,0,0.000000,@$expected = sort grep { m/^[A-Z_]+$/ } @$expected;
0.000000,0,0.000000,my $got = $args{got}->{name};
0.000000,0,0.000000,my @caller = caller(0);
0.000000,0,0.000000,$self->exception("Expected (@$expected), but got $got",
0.000000,0,0.000000,caller => \@caller,
0.000000,0,0.000000,expected => $expected,
0.000000,0,0.000000,got => $args{got},
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_tag {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,if (! @$stack or $stack->[-1]->[0] ne 'properties') {
0.000000,0,0.000000,push @$stack, [ properties => {} ];
0.000000,0,0.000000,}
0.000000,0,0.000000,my $last = $stack->[-1]->[1];
0.000000,0,0.000000,my $tag = $self->_read_tag($token->{value}, $self->tagmap);
0.000000,0,0.000000,$last->{inline} ||= [];
0.000000,0,0.000000,push @{ $last->{inline} }, {
0.000000,0,0.000000,type => 'tag',
0.000000,0,0.000000,value => $tag,
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _read_tag {
0.000000,0,0.000000,my ($self, $tag, $map) = @_;
0.000000,0,0.000000,if ($tag eq '!') {
0.000000,0,0.000000,return "!";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($tag =~ m/^!<(.*)>/) {
0.000000,0,0.000000,return $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($tag =~ m/^(![^!]*!|!)(.+)/) {
0.000000,0,0.000000,my $alias = $1;
0.000000,0,0.000000,my $name = $2;
0.000000,0,0.000000,$name =~ s/%([0-9a-fA-F]{2})/chr hex $1/eg;
0.000000,0,0.000000,if (exists $map->{ $alias }) {
0.000000,0,0.000000,$tag = $map->{ $alias }. $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($alias ne '!' and $alias ne '!!') {
0.000000,0,0.000000,die "Found undefined tag handle '$alias'";
0.000000,0,0.000000,}
0.000000,0,0.000000,$tag = "!$name";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die "Invalid tag";
0.000000,0,0.000000,}
0.000000,0,0.000000,return $tag;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_anchor {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $anchor = $token->{value};
0.000000,0,0.000000,$anchor = substr($anchor, 1);
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,if (! @$stack or $stack->[-1]->[0] ne 'properties') {
0.000000,0,0.000000,push @$stack, [ properties => {} ];
0.000000,0,0.000000,}
0.000000,0,0.000000,my $last = $stack->[-1]->[1];
0.000000,0,0.000000,$last->{inline} ||= [];
0.000000,0,0.000000,push @{ $last->{inline} }, {
0.000000,0,0.000000,type => 'anchor',
0.000000,0,0.000000,value => $anchor,
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_property_eol {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $last = $stack->[-1]->[1];
0.000000,0,0.000000,my $inline = delete $last->{inline} or return;
0.000000,0,0.000000,my $newline = $last->{newline} ||= [];
0.000000,0,0.000000,push @$newline, @$inline;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_mapkey {
0.002079,6675,0.000000,my ($self, $token) = @_;
0.005749,6675,0.000001,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.010594,6675,0.000002,};
0.002251,6675,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.015343,6675,0.000002,push @{ $stack }, [ scalar => $info ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_mapkey {
0.001424,6690,0.000000,my ($self, $res) = @_;
0.006996,6690,0.000001,my $last = pop @{ $self->event_stack };
0.006855,6690,0.000001,$self->scalar_event($last->[1]);
0.020820,6690,0.000003,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_scalar {
0.002278,7497,0.000000,my ($self, $res) = @_;
0.007610,7497,0.000001,my $last = pop @{ $self->event_stack };
0.001269,7497,0.000000,return unless $last;
0.006925,7497,0.000001,$self->scalar_event($last->[1]);
0.006362,7497,0.000001,my $e = $self->events;
0.023433,7497,0.000003,if ($e->[-1] eq 'IMAP') {
0.000000,0,0.000000,$self->end_flow_mapping;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_mapkey {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => '',
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_flow_alias {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $alias = substr($token->{value}, 1);
0.000000,0,0.000000,$self->alias_event({ value => $alias });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_alias {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $alias = substr($token->{value}, 1);
0.000000,0,0.000000,$self->alias_event({ value => $alias });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_alias_key {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $alias = substr($token->{value}, 1);
0.000000,0,0.000000,$self->alias_event({ value => $alias });
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_alias_from_stack {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $last = pop @{ $self->event_stack };
0.000000,0,0.000000,$self->alias_event($last->[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_alias {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $alias = substr($token->{value}, 1);
0.000000,0,0.000000,push @{ $self->event_stack }, [ alias => {
0.000000,0,0.000000,value => $alias,
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,}];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_question {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_flow_question {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,$self->set_new_node(2);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_complexvalue {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,$self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_questionstart {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->start_mapping($token->{column});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_complexcolon {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_seqstart {
0.000200,308,0.000001,my ($self, $token) = @_;
0.000175,308,0.000001,my $column = $token->{column};
0.000604,308,0.000002,$self->start_sequence($column);
0.001000,308,0.000003,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_seqitem {
0.000123,302,0.000000,my ($self, $res) = @_;
0.000964,302,0.000003,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_take_quoted {
0.000806,2056,0.000000,my ($self, $token) = @_;
0.000791,2056,0.000000,my $subtokens = $token->{subtokens};
0.002407,2056,0.000001,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => $subtokens->[0]->{value} eq '"'
0.000000,0,0.000000,? YAML_DOUBLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,: YAML_SINGLE_QUOTED_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.004995,2056,0.000002,};
0.000625,2056,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.004919,2056,0.000002,push @{ $stack }, [ scalar => $info ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_quoted_multiline {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $subtokens = $token->{subtokens};
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => $subtokens->[0]->{value} eq '"'
0.000000,0,0.000000,? YAML_DOUBLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,: YAML_SINGLE_QUOTED_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,push @{ $stack }, [ scalar => $info ];
0.000000,0,0.000000,$self->cb_send_scalar;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_take_quoted_key {
0.000004,15,0.000000,my ($self, $token) = @_;
0.000028,15,0.000002,$self->cb_take_quoted($token);
0.000047,15,0.000003,$self->cb_send_mapkey;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_plain_multi {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,push @{ $stack }, [ scalar => $info ];
0.000000,0,0.000000,$self->cb_send_scalar;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_start_plain {
0.003369,12180,0.000000,my ($self, $token) = @_;
0.010507,12180,0.000001,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.019275,12180,0.000002,};
0.002444,12180,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.025721,12180,0.000002,push @{ $stack }, [ scalar => $info ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_start_flowseq {
0.000191,337,0.000001,my ($self, $token) = @_;
0.001277,337,0.000004,$self->start_flow_sequence($token->{column});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_start_flowmap {
0.000096,214,0.000000,my ($self, $token) = @_;
0.000658,214,0.000003,$self->start_flow_mapping($token->{column});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_flowseq {
0.000158,337,0.000000,my ($self, $res) = @_;
0.000456,337,0.000001,$self->cb_send_scalar;
0.000812,337,0.000002,$self->end_flow_sequence;
0.000914,337,0.000003,$self->set_new_node(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_flow_comma {
0.000191,689,0.000000,my ($self) = @_;
0.000735,689,0.000001,my $event_types = $self->events;
0.000643,689,0.000001,$self->set_new_node(0);
0.002769,689,0.000004,if ($event_types->[-1] =~ m/^FLOWSEQ/) {
0.000723,689,0.000001,$self->cb_send_scalar;
0.000431,689,0.000001,$event_types->[-1] = $next_event{ $event_types->[-1] };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_flow_colon {
0.000010,29,0.000000,my ($self) = @_;
0.000072,29,0.000002,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_flow_mapkey {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => '',
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_flowmap {
0.000089,214,0.000000,my ($self, $res) = @_;
0.000415,214,0.000002,$self->end_flow_mapping;
0.000604,214,0.000003,$self->set_new_node(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_flowmap_empty {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,$self->cb_empty_flowmap_value;
0.000000,0,0.000000,$self->end_flow_mapping;
0.000000,0,0.000000,$self->set_new_node(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_flowkey_plain {
0.000057,29,0.000002,my ($self, $token) = @_;
0.000038,29,0.000001,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.000061,29,0.000002,};
0.000009,29,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000107,29,0.000004,$self->scalar_event($info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_flowkey_quoted {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $subtokens = $token->{subtokens};
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => $subtokens->[0]->{value} eq '"'
0.000000,0,0.000000,? YAML_DOUBLE_QUOTED_SCALAR_STYLE
0.000000,0,0.000000,: YAML_SINGLE_QUOTED_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_flowmap_key_value {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->cb_empty_flow_mapkey($token);
0.000000,0,0.000000,$self->cb_empty_flowmap_value;
0.000000,0,0.000000,$self->cb_flow_comma;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_empty_flowmap_key_value {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->cb_empty_flow_mapkey($token);
0.000000,0,0.000000,$self->cb_empty_flowmap_value;
0.000000,0,0.000000,$self->cb_flow_comma;
0.000000,0,0.000000,$self->cb_end_flowmap;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_flowmap_value {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => '',
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_flowseq_comma {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->cb_empty_flowmap_value($token);
0.000000,0,0.000000,$self->cb_flow_comma;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_empty_flowseq_end {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->cb_empty_flowmap_value($token);
0.000000,0,0.000000,$self->cb_end_flowseq;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_insert_map_alias {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $scalar = pop @$stack;
0.000000,0,0.000000,my $info = $scalar->[1];
0.000000,0,0.000000,$self->start_mapping($info->{offset});
0.000000,0,0.000000,$self->alias_event($info);
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_insert_map {
0.001755,6725,0.000000,my ($self, $res) = @_;
0.005277,6725,0.000001,my $stack = $self->event_stack;
0.002647,6725,0.000000,my $scalar = pop @$stack;
0.001545,6725,0.000000,my $info = $scalar->[1];
0.009069,6725,0.000001,$self->start_mapping($info->{offset});
0.006845,6725,0.000001,$self->scalar_event($info);
0.022891,6725,0.000003,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_insert_implicit_flowseq_map {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $scalar = pop @$stack;
0.000000,0,0.000000,my $info = $scalar->[1];
0.000000,0,0.000000,$self->start_flow_mapping($info->{offset}, 1);
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_insert_empty_implicit_flowseq_map {
0.000000,0,0.000000,my ($self, $res) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $scalar = pop @$stack;
0.000000,0,0.000000,my $info = $scalar->[1];
0.000000,0,0.000000,$self->start_flow_mapping($info->{offset}, 1);
0.000000,0,0.000000,$self->cb_empty_flowmap_value;
0.000000,0,0.000000,$self->set_new_node(2);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_insert_empty_map {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => YAML_PLAIN_SCALAR_STYLE,
0.000000,0,0.000000,value => '',
0.000000,0,0.000000,offset => $token->{column},
0.000000,0,0.000000,};
0.000000,0,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->start_mapping($info->{offset});
0.000000,0,0.000000,$self->scalar_event($info);
0.000000,0,0.000000,$self->set_new_node(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_send_block_scalar {
0.000000,1,0.000000,my ($self, $token) = @_;
0.000001,1,0.000001,my $type = $token->{subtokens}->[0]->{value};
0.000001,1,0.000001,my $stack = $self->event_stack;
0.000000,0,0.000000,my $info = {
0.000000,0,0.000000,style => $type eq '|'
0.000000,0,0.000000,? YAML_LITERAL_SCALAR_STYLE
0.000000,0,0.000000,: YAML_FOLDED_SCALAR_STYLE,
0.000000,0,0.000000,value => $token->{value},
0.000000,0,0.000000,offset => $token->{column},
0.000003,1,0.000003,};
0.000000,1,0.000000,if (@$stack and $stack->[-1]->[0] eq 'properties') {
0.000000,0,0.000000,$self->fetch_inline_properties($stack, $info);
0.000000,0,0.000000,}
0.000001,1,0.000001,push @{ $self->event_stack }, [ scalar => $info ];
0.000004,1,0.000004,$self->cb_send_scalar;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_document {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->end_document(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_document_empty {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->end_document(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_doc_start_implicit {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->start_document(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_doc_start_explicit {
0.000000,1,0.000000,my ($self, $token) = @_;
0.000006,1,0.000006,$self->start_document(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_end_doc_start_document {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,$self->end_document(1);
0.000000,0,0.000000,$self->start_document(0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_tag_directive {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,my ($name, $tag_alias, $tag_url) = split ' ', $token->{value};
0.000000,0,0.000000,$self->tagmap->{ $tag_alias } = $tag_url;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_reserved_directive {
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub cb_set_yaml_version_directive {
0.000000,0,0.000000,my ($self, $token) = @_;
0.000000,0,0.000000,if ($self->yaml_version_directive) {
0.000000,0,0.000000,croak "Found duplicate YAML directive";
0.000000,0,0.000000,}
0.000000,0,0.000000,my ($version) = $token->{value} =~ m/^%YAML[ \t]+(1\.[12])/;
0.000000,0,0.000000,$self->set_yaml_version($version || '1.2');
0.000000,0,0.000000,$self->set_yaml_version_directive(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000027,1,0.000027,1;
