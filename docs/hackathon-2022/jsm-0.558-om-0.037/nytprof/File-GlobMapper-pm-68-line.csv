# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package File::GlobMapper;
0.000000,0,0.000000,
0.000025,2,0.000013,use strict;
0.000013,2,0.000007,use warnings;
0.000091,2,0.000046,use Carp;
0.000000,0,0.000000,
0.000000,0,0.000000,our ($CSH_GLOB);
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN
0.000000,0,0.000000,{
0.000004,1,0.000004,if ($] < 5.006)
0.000000,0,0.000000,{
0.000000,0,0.000000,require File::BSDGlob; import File::BSDGlob qw(:glob) ;
0.000000,0,0.000000,$CSH_GLOB = File::BSDGlob::GLOB_CSH() ;
0.000000,0,0.000000,*globber = \&File::BSDGlob::csh_glob;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000273,2,0.000137,require File::Glob; import File::Glob qw(:glob) ;
0.000002,1,0.000002,$CSH_GLOB = File::Glob::GLOB_CSH() ;
0.000000,0,0.000000,#*globber = \&File::Glob::bsd_glob;
0.000001,1,0.000001,*globber = \&File::Glob::csh_glob;
0.000000,0,0.000000,}
0.001152,1,0.001152,}
0.000000,0,0.000000,
0.000000,0,0.000000,our ($Error);
0.000000,0,0.000000,
0.000000,0,0.000000,our ($VERSION, @EXPORT_OK);
0.000000,1,0.000000,$VERSION = '1.001';
0.000001,1,0.000001,@EXPORT_OK = qw( globmap );
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,our ($noPreBS, $metachars, $matchMetaRE, %mapping, %wildCount);
0.000000,1,0.000000,$noPreBS = '(?<!\\\)' ; # no preceding backslash
0.000000,1,0.000000,$metachars = '.*?[](){}';
0.000001,1,0.000001,$matchMetaRE = '[' . quotemeta($metachars) . ']';
0.000000,0,0.000000,
0.000003,1,0.000003,%mapping = (
0.000000,0,0.000000,'*' => '([^/]*)',
0.000000,0,0.000000,'?' => '([^/])',
0.000000,0,0.000000,'.' => '\.',
0.000000,0,0.000000,'[' => '([',
0.000000,0,0.000000,'(' => '(',
0.000000,0,0.000000,')' => ')',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000003,1,0.000003,%wildCount = map { $_ => 1 } qw/ * ? . { ( [ /;
0.000000,0,0.000000,
0.000000,0,0.000000,sub globmap ($$;)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $inputGlob = shift ;
0.000000,0,0.000000,my $outputGlob = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $obj = File::GlobMapper->new($inputGlob, $outputGlob, @_)
0.000000,0,0.000000,or croak "globmap: $Error" ;
0.000000,0,0.000000,return $obj->getFileMap();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub new
0.000000,0,0.000000,{
0.000000,0,0.000000,my $class = shift ;
0.000000,0,0.000000,my $inputGlob = shift ;
0.000000,0,0.000000,my $outputGlob = shift ;
0.000000,0,0.000000,# TODO -- flags needs to default to whatever File::Glob does
0.000000,0,0.000000,my $flags = shift || $CSH_GLOB ;
0.000000,0,0.000000,#my $flags = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,$inputGlob =~ s/^\s*\<\s*//;
0.000000,0,0.000000,$inputGlob =~ s/\s*\>\s*$//;
0.000000,0,0.000000,
0.000000,0,0.000000,$outputGlob =~ s/^\s*\<\s*//;
0.000000,0,0.000000,$outputGlob =~ s/\s*\>\s*$//;
0.000000,0,0.000000,
0.000000,0,0.000000,my %object =
0.000000,0,0.000000,(   InputGlob   => $inputGlob,
0.000000,0,0.000000,OutputGlob  => $outputGlob,
0.000000,0,0.000000,GlobFlags   => $flags,
0.000000,0,0.000000,Braces      => 0,
0.000000,0,0.000000,WildCount   => 0,
0.000000,0,0.000000,Pairs       => [],
0.000000,0,0.000000,Sigil       => '#',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $self = bless \%object, ref($class) || $class ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_parseInputGlob()
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_parseOutputGlob()
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,my @inputFiles = globber($self->{InputGlob}, $flags) ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (GLOB_ERROR)
0.000000,0,0.000000,{
0.000000,0,0.000000,$Error = $!;
0.000000,0,0.000000,return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#if (whatever)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $missing = grep { ! -e $_ } @inputFiles ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($missing)
0.000000,0,0.000000,{
0.000000,0,0.000000,$Error = "$missing input files do not exist";
0.000000,0,0.000000,return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{InputFiles} = \@inputFiles ;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_getFiles()
0.000000,0,0.000000,or return undef ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _retError
0.000000,0,0.000000,{
0.000000,0,0.000000,my $string = shift ;
0.000000,0,0.000000,$Error = "$string in input fileglob" ;
0.000000,0,0.000000,return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _unmatched
0.000000,0,0.000000,{
0.000000,0,0.000000,my $delimeter = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,_retError("Unmatched $delimeter");
0.000000,0,0.000000,return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _parseBit
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $string = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $out = '';
0.000000,0,0.000000,my $depth = 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,while ($string =~ s/(.*?)$noPreBS(,|$matchMetaRE)//)
0.000000,0,0.000000,{
0.000000,0,0.000000,$out .= quotemeta($1) ;
0.000000,0,0.000000,$out .= $mapping{$2} if defined $mapping{$2};
0.000000,0,0.000000,
0.000000,0,0.000000,++ $self->{WildCount} if $wildCount{$2} ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($2 eq ',')
0.000000,0,0.000000,{
0.000000,0,0.000000,return _unmatched("(")
0.000000,0,0.000000,if $depth ;
0.000000,0,0.000000,
0.000000,0,0.000000,$out .= '|';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($2 eq '(')
0.000000,0,0.000000,{
0.000000,0,0.000000,++ $depth ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($2 eq ')')
0.000000,0,0.000000,{
0.000000,0,0.000000,return _unmatched(")")
0.000000,0,0.000000,if ! $depth ;
0.000000,0,0.000000,
0.000000,0,0.000000,-- $depth ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($2 eq '[')
0.000000,0,0.000000,{
0.000000,0,0.000000,# TODO -- quotemeta & check no '/'
0.000000,0,0.000000,# TODO -- check for \]  & other \ within the []
0.000000,0,0.000000,$string =~ s#(.*?\])##
0.000000,0,0.000000,or return _unmatched("[");
0.000000,0,0.000000,$out .= "$1)" ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($2 eq ']')
0.000000,0,0.000000,{
0.000000,0,0.000000,return _unmatched("]");
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($2 eq '{' || $2 eq '}')
0.000000,0,0.000000,{
0.000000,0,0.000000,return _retError("Nested {} not allowed");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$out .= quotemeta $string;
0.000000,0,0.000000,
0.000000,0,0.000000,return _unmatched("(")
0.000000,0,0.000000,if $depth ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $out ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _parseInputGlob
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $string = $self->{InputGlob} ;
0.000000,0,0.000000,my $inGlob = '';
0.000000,0,0.000000,
0.000000,0,0.000000,# Multiple concatenated *'s don't make sense
0.000000,0,0.000000,#$string =~ s#\*\*+#*# ;
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO -- Allow space to delimit patterns?
0.000000,0,0.000000,#my @strings = split /\s+/, $string ;
0.000000,0,0.000000,#for my $str (@strings)
0.000000,0,0.000000,my $out = '';
0.000000,0,0.000000,my $depth = 0 ;
0.000000,0,0.000000,
0.000000,0,0.000000,while ($string =~ s/(.*?)$noPreBS($matchMetaRE)//)
0.000000,0,0.000000,{
0.000000,0,0.000000,$out .= quotemeta($1) ;
0.000000,0,0.000000,$out .= $mapping{$2} if defined $mapping{$2};
0.000000,0,0.000000,++ $self->{WildCount} if $wildCount{$2} ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($2 eq '(')
0.000000,0,0.000000,{
0.000000,0,0.000000,++ $depth ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($2 eq ')')
0.000000,0,0.000000,{
0.000000,0,0.000000,return _unmatched(")")
0.000000,0,0.000000,if ! $depth ;
0.000000,0,0.000000,
0.000000,0,0.000000,-- $depth ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($2 eq '[')
0.000000,0,0.000000,{
0.000000,0,0.000000,# TODO -- quotemeta & check no '/' or '(' or ')'
0.000000,0,0.000000,# TODO -- check for \]  & other \ within the []
0.000000,0,0.000000,$string =~ s#(.*?\])##
0.000000,0,0.000000,or return _unmatched("[");
0.000000,0,0.000000,$out .= "$1)" ;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($2 eq ']')
0.000000,0,0.000000,{
0.000000,0,0.000000,return _unmatched("]");
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($2 eq '}')
0.000000,0,0.000000,{
0.000000,0,0.000000,return _unmatched("}");
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($2 eq '{')
0.000000,0,0.000000,{
0.000000,0,0.000000,# TODO -- check no '/' within the {}
0.000000,0,0.000000,# TODO -- check for \}  & other \ within the {}
0.000000,0,0.000000,
0.000000,0,0.000000,my $tmp ;
0.000000,0,0.000000,unless ( $string =~ s/(.*?)$noPreBS\}//)
0.000000,0,0.000000,{
0.000000,0,0.000000,return _unmatched("{");
0.000000,0,0.000000,}
0.000000,0,0.000000,#$string =~ s#(.*?)\}##;
0.000000,0,0.000000,
0.000000,0,0.000000,#my $alt = join '|',
0.000000,0,0.000000,#          map { quotemeta $_ }
0.000000,0,0.000000,#          split "$noPreBS,", $1 ;
0.000000,0,0.000000,my $alt = $self->_parseBit($1);
0.000000,0,0.000000,defined $alt or return 0 ;
0.000000,0,0.000000,$out .= "($alt)" ;
0.000000,0,0.000000,
0.000000,0,0.000000,++ $self->{Braces} ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return _unmatched("(")
0.000000,0,0.000000,if $depth ;
0.000000,0,0.000000,
0.000000,0,0.000000,$out .= quotemeta $string ;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{InputGlob} =~ s/$noPreBS[\(\)]//g;
0.000000,0,0.000000,$self->{InputPattern} = $out ;
0.000000,0,0.000000,
0.000000,0,0.000000,#print "# INPUT '$self->{InputGlob}' => '$out'\n";
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _parseOutputGlob
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $string = $self->{OutputGlob} ;
0.000000,0,0.000000,my $maxwild = $self->{WildCount};
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->{GlobFlags} & GLOB_TILDE)
0.000000,0,0.000000,#if (1)
0.000000,0,0.000000,{
0.000000,0,0.000000,$string =~ s{
0.000000,0,0.000000,$1
0.000000,0,0.000000,? (getpwnam($1))[7]
0.000000,0,0.000000,: ( $ENV{HOME} || $ENV{LOGDIR} )
0.000000,0,0.000000,}ex;
0.000000,0,0.000000,)
0.000000,0,0.000000,}{
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# max #1 must be == to max no of '*' in input
0.000000,0,0.000000,while ( $string =~ m/#(\d)/g )
0.000000,0,0.000000,{
0.000000,0,0.000000,croak "Max wild is #$maxwild, you tried #$1"
0.000000,0,0.000000,if $1 > $maxwild ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $noPreBS = '(?<!\\\)' ; # no preceding backslash
0.000000,0,0.000000,#warn "noPreBS = '$noPreBS'\n";
0.000000,0,0.000000,
0.000000,0,0.000000,#$string =~ s/${noPreBS}\$(\d)/\${$1}/g;
0.000000,0,0.000000,$string =~ s/${noPreBS}#(\d)/\${$1}/g;
0.000000,0,0.000000,$string =~ s#${noPreBS}\*#\${inFile}#g;
0.000000,0,0.000000,$string = '"' . $string . '"';
0.000000,0,0.000000,
0.000000,0,0.000000,#print "OUTPUT '$self->{OutputGlob}' => '$string'\n";
0.000000,0,0.000000,$self->{OutputPattern} = $string ;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _getFiles
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my %outInMapping = ();
0.000000,0,0.000000,my %inFiles = () ;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $inFile (@{ $self->{InputFiles} })
0.000000,0,0.000000,{
0.000000,0,0.000000,next if $inFiles{$inFile} ++ ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $outFile = $inFile ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $inFile =~ m/$self->{InputPattern}/ )
0.000000,0,0.000000,{
0.000168,2,0.000084,no warnings 'uninitialized';
0.000000,0,0.000000,eval "\$outFile = $self->{OutputPattern};" ;
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined $outInMapping{$outFile})
0.000000,0,0.000000,{
0.000000,0,0.000000,$Error =  "multiple input files map to one output file";
0.000000,0,0.000000,return undef ;
0.000000,0,0.000000,}
0.000000,0,0.000000,$outInMapping{$outFile} = $inFile;
0.000000,0,0.000000,push @{ $self->{Pairs} }, [$inFile, $outFile];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getFileMap
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{Pairs} ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getHash
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return { map { $_->[0] => $_->[1] } @{ $self->{Pairs} } } ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
