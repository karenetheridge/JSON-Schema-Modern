# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package IO::Compress::Gzip ;
0.000000,0,0.000000,
0.000006,1,0.000006,require 5.006 ;
0.000000,0,0.000000,
0.000035,2,0.000018,use strict ;
0.000015,2,0.000007,use warnings;
0.000022,2,0.000011,use bytes;
0.000000,0,0.000000,
0.000001,1,0.000001,require Exporter ;
0.000000,0,0.000000,
0.000578,3,0.000193,use IO::Compress::RawDeflate 2.106 () ;
0.000052,3,0.000017,use IO::Compress::Adapter::Deflate 2.106 ;
0.000000,0,0.000000,
0.000044,3,0.000015,use IO::Compress::Base::Common  2.106 qw(:Status );
0.000551,3,0.000184,use IO::Compress::Gzip::Constants 2.106 ;
0.000447,3,0.000149,use IO::Compress::Zlib::Extra 2.106 ;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN
0.000000,0,0.000000,{
0.000004,1,0.000004,if (defined &utf8::downgrade )
0.000000,0,0.000000,{ *noUTF8 = \&utf8::downgrade }
0.000000,0,0.000000,else
0.000000,0,0.000000,{ *noUTF8 = sub {} }
0.000420,1,0.000420,}
0.000000,0,0.000000,
0.000000,0,0.000000,our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, %DEFLATE_CONSTANTS, $GzipError);
0.000000,0,0.000000,
0.000001,1,0.000001,$VERSION = '2.106';
0.000000,1,0.000000,$GzipError = '' ;
0.000000,0,0.000000,
0.000011,1,0.000011,@ISA    = qw(IO::Compress::RawDeflate Exporter);
0.000000,1,0.000000,@EXPORT_OK = qw( $GzipError gzip ) ;
0.000003,1,0.000003,%EXPORT_TAGS = %IO::Compress::RawDeflate::DEFLATE_CONSTANTS ;
0.000000,0,0.000000,
0.000002,1,0.000002,push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;
0.000002,1,0.000002,Exporter::export_ok_tags('all');
0.000000,0,0.000000,
0.000000,0,0.000000,sub new
0.000000,0,0.000000,{
0.000000,0,0.000000,my $class = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $obj = IO::Compress::Base::Common::createSelfTiedObject($class, \$GzipError);
0.000000,0,0.000000,
0.000000,0,0.000000,$obj->_create(undef, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub gzip
0.000000,0,0.000000,{
0.000000,0,0.000000,my $obj = IO::Compress::Base::Common::createSelfTiedObject(undef, \$GzipError);
0.000000,0,0.000000,return $obj->_def(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#sub newHeader
0.000000,0,0.000000,#{
0.000000,0,0.000000,#    my $self = shift ;
0.000000,0,0.000000,#    #return GZIP_MINIMUM_HEADER ;
0.000000,0,0.000000,#    return $self->mkHeader(*$self->{Got});
0.000000,0,0.000000,#}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getExtraParams
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.000000,0,0.000000,# zlib behaviour
0.000000,0,0.000000,$self->getZlibParams(),
0.000000,0,0.000000,
0.000000,0,0.000000,# Gzip header fields
0.000000,0,0.000000,'minimal'   => [IO::Compress::Base::Common::Parse_boolean,   0],
0.000000,0,0.000000,'comment'   => [IO::Compress::Base::Common::Parse_any,       undef],
0.000000,0,0.000000,'name'      => [IO::Compress::Base::Common::Parse_any,       undef],
0.000000,0,0.000000,'time'      => [IO::Compress::Base::Common::Parse_any,       undef],
0.000000,0,0.000000,'textflag'  => [IO::Compress::Base::Common::Parse_boolean,   0],
0.000000,0,0.000000,'headercrc' => [IO::Compress::Base::Common::Parse_boolean,   0],
0.000000,0,0.000000,'os_code'   => [IO::Compress::Base::Common::Parse_unsigned,  $Compress::Raw::Zlib::gzip_os_code],
0.000000,0,0.000000,'extrafield'=> [IO::Compress::Base::Common::Parse_any,       undef],
0.000000,0,0.000000,'extraflags'=> [IO::Compress::Base::Common::Parse_any,       undef],
0.000000,0,0.000000,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub ckParams
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $got = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,# gzip always needs crc32
0.000000,0,0.000000,$got->setValue('crc32' => 1);
0.000000,0,0.000000,
0.000000,0,0.000000,return 1
0.000000,0,0.000000,if $got->getValue('merge') ;
0.000000,0,0.000000,
0.000000,0,0.000000,my $strict = $got->getValue('strict') ;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,if (! $got->parsed('time') ) {
0.000000,0,0.000000,# Modification time defaults to now.
0.000000,0,0.000000,$got->setValue(time => time) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Check that the Name & Comment don't have embedded NULLs
0.000000,0,0.000000,# Also check that they only contain ISO 8859-1 chars.
0.000000,0,0.000000,if ($got->parsed('name') && defined $got->getValue('name')) {
0.000000,0,0.000000,my $name = $got->getValue('name');
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->saveErrorString(undef, "Null Character found in Name",
0.000000,0,0.000000,Z_DATA_ERROR)
0.000000,0,0.000000,if $strict && $name =~ /\x00/ ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->saveErrorString(undef, "Non ISO 8859-1 Character found in Name",
0.000000,0,0.000000,Z_DATA_ERROR)
0.000000,0,0.000000,if $strict && $name =~ /$GZIP_FNAME_INVALID_CHAR_RE/o ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($got->parsed('comment') && defined $got->getValue('comment')) {
0.000000,0,0.000000,my $comment = $got->getValue('comment');
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->saveErrorString(undef, "Null Character found in Comment",
0.000000,0,0.000000,Z_DATA_ERROR)
0.000000,0,0.000000,if $strict && $comment =~ /\x00/ ;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->saveErrorString(undef, "Non ISO 8859-1 Character found in Comment",
0.000000,0,0.000000,Z_DATA_ERROR)
0.000000,0,0.000000,if $strict && $comment =~ /$GZIP_FCOMMENT_INVALID_CHAR_RE/o;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($got->parsed('os_code') ) {
0.000000,0,0.000000,my $value = $got->getValue('os_code');
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->saveErrorString(undef, "OS_Code must be between 0 and 255, got '$value'")
0.000000,0,0.000000,if $value < 0 || $value > 255 ;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# gzip only supports Deflate at present
0.000000,0,0.000000,$got->setValue('method' => Z_DEFLATED) ;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ! $got->parsed('extraflags')) {
0.000000,0,0.000000,$got->setValue('extraflags' => 2)
0.000000,0,0.000000,if $got->getValue('level') == Z_BEST_COMPRESSION ;
0.000000,0,0.000000,$got->setValue('extraflags' => 4)
0.000000,0,0.000000,if $got->getValue('level') == Z_BEST_SPEED ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $data = $got->getValue('extrafield') ;
0.000000,0,0.000000,if (defined $data) {
0.000000,0,0.000000,my $bad = IO::Compress::Zlib::Extra::parseExtraField($data, $strict, 1) ;
0.000000,0,0.000000,return $self->saveErrorString(undef, "Error with ExtraField Parameter: $bad", Z_DATA_ERROR)
0.000000,0,0.000000,if $bad ;
0.000000,0,0.000000,
0.000000,0,0.000000,$got->setValue('extrafield' => $data) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mkTrailer
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,return pack("V V", *$self->{Compress}->crc32(),
0.000000,0,0.000000,*$self->{UnCompSize}->get32bit());
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getInverseClass
0.000000,0,0.000000,{
0.000321,2,0.000160,no warnings 'once';
0.000000,0,0.000000,return ('IO::Uncompress::Gunzip',
0.000000,0,0.000000,\$IO::Uncompress::Gunzip::GunzipError);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getFileInfo
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $params = shift;
0.000000,0,0.000000,my $filename = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,return if IO::Compress::Base::Common::isaScalar($filename);
0.000000,0,0.000000,
0.000000,0,0.000000,my $defaultTime = (stat($filename))[9] ;
0.000000,0,0.000000,
0.000000,0,0.000000,$params->setValue('name' => $filename)
0.000000,0,0.000000,if ! $params->parsed('name') ;
0.000000,0,0.000000,
0.000000,0,0.000000,$params->setValue('time' => $defaultTime)
0.000000,0,0.000000,if ! $params->parsed('time') ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub mkHeader
0.000000,0,0.000000,{
0.000000,0,0.000000,my $self = shift ;
0.000000,0,0.000000,my $param = shift ;
0.000000,0,0.000000,
0.000000,0,0.000000,# short-circuit if a minimal header is requested.
0.000000,0,0.000000,return GZIP_MINIMUM_HEADER if $param->getValue('minimal') ;
0.000000,0,0.000000,
0.000000,0,0.000000,# METHOD
0.000000,0,0.000000,my $method = $param->valueOrDefault('method', GZIP_CM_DEFLATED) ;
0.000000,0,0.000000,
0.000000,0,0.000000,# FLAGS
0.000000,0,0.000000,my $flags       = GZIP_FLG_DEFAULT ;
0.000000,0,0.000000,$flags |= GZIP_FLG_FTEXT    if $param->getValue('textflag') ;
0.000000,0,0.000000,$flags |= GZIP_FLG_FHCRC    if $param->getValue('headercrc') ;
0.000000,0,0.000000,$flags |= GZIP_FLG_FEXTRA   if $param->wantValue('extrafield') ;
0.000000,0,0.000000,$flags |= GZIP_FLG_FNAME    if $param->wantValue('name') ;
0.000000,0,0.000000,$flags |= GZIP_FLG_FCOMMENT if $param->wantValue('comment') ;
0.000000,0,0.000000,
0.000000,0,0.000000,# MTIME
0.000000,0,0.000000,my $time = $param->valueOrDefault('time', GZIP_MTIME_DEFAULT) ;
0.000000,0,0.000000,
0.000000,0,0.000000,# EXTRA FLAGS
0.000000,0,0.000000,my $extra_flags = $param->valueOrDefault('extraflags', GZIP_XFL_DEFAULT);
0.000000,0,0.000000,
0.000000,0,0.000000,# OS CODE
0.000000,0,0.000000,my $os_code = $param->valueOrDefault('os_code', GZIP_OS_DEFAULT) ;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,my $out = pack("C4 V C C",
0.000000,0,0.000000,GZIP_ID1,   # ID1
0.000000,0,0.000000,GZIP_ID2,   # ID2
0.000000,0,0.000000,$method,    # Compression Method
0.000000,0,0.000000,$flags,     # Flags
0.000000,0,0.000000,$time,      # Modification Time
0.000000,0,0.000000,$extra_flags, # Extra Flags
0.000000,0,0.000000,$os_code,   # Operating System Code
0.000000,0,0.000000,) ;
0.000000,0,0.000000,
0.000000,0,0.000000,# EXTRA
0.000000,0,0.000000,if ($flags & GZIP_FLG_FEXTRA) {
0.000000,0,0.000000,my $extra = $param->getValue('extrafield') ;
0.000000,0,0.000000,$out .= pack("v", length $extra) . $extra ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# NAME
0.000000,0,0.000000,if ($flags & GZIP_FLG_FNAME) {
0.000000,0,0.000000,my $name .= $param->getValue('name') ;
0.000000,0,0.000000,$name =~ s/\x00.*$//;
0.000000,0,0.000000,$out .= $name ;
0.000000,0,0.000000,# Terminate the filename with NULL unless it already is
0.000000,0,0.000000,$out .= GZIP_NULL_BYTE
0.000000,0,0.000000,if !length $name or
0.000000,0,0.000000,substr($name, 1, -1) ne GZIP_NULL_BYTE ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# COMMENT
0.000000,0,0.000000,if ($flags & GZIP_FLG_FCOMMENT) {
0.000000,0,0.000000,my $comment .= $param->getValue('comment') ;
0.000000,0,0.000000,$comment =~ s/\x00.*$//;
0.000000,0,0.000000,$out .= $comment ;
0.000000,0,0.000000,# Terminate the comment with NULL unless it already is
0.000000,0,0.000000,$out .= GZIP_NULL_BYTE
0.000000,0,0.000000,if ! length $comment or
0.000000,0,0.000000,substr($comment, 1, -1) ne GZIP_NULL_BYTE;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# HEADER CRC
0.000000,0,0.000000,$out .= pack("v", Compress::Raw::Zlib::crc32($out) & 0x00FF )
0.000000,0,0.000000,if $param->getValue('headercrc') ;
0.000000,0,0.000000,
0.000000,0,0.000000,noUTF8($out);
0.000000,0,0.000000,
0.000000,0,0.000000,return $out ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mkFinalTrailer
0.000000,0,0.000000,{
0.000000,0,0.000000,return '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
