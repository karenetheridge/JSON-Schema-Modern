# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package File::ShareDir;
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,File::ShareDir - Locate per-dist and per-module shared files
0.000000,0,0.000000,
0.000000,0,0.000000,=begin html
0.000000,0,0.000000,
0.000000,0,0.000000,<a href="https://travis-ci.org/perl5-utils/File-ShareDir"><img src="https://travis-ci.org/perl5-utils/File-ShareDir.svg?branch=master" alt="Travis CI"/></a>
0.000000,0,0.000000,<a href='https://coveralls.io/github/perl5-utils/File-ShareDir?branch=master'><img src='https://coveralls.io/repos/github/perl5-utils/File-ShareDir/badge.svg?branch=master' alt='Coverage Status' /></a>
0.000000,0,0.000000,<a href="https://saythanks.io/to/rehsack"><img src="https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg" alt="Say Thanks" /></a>
0.000000,0,0.000000,
0.000000,0,0.000000,=end html
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use File::ShareDir ':ALL';
0.000000,0,0.000000,
0.000000,0,0.000000,# Where are distribution-level shared data files kept
0.000000,0,0.000000,$dir = dist_dir('File-ShareDir');
0.000000,0,0.000000,
0.000000,0,0.000000,# Where are module-level shared data files kept
0.000000,0,0.000000,$dir = module_dir('File::ShareDir');
0.000000,0,0.000000,
0.000000,0,0.000000,# Find a specific file in our dist/module shared dir
0.000000,0,0.000000,$file = dist_file(  'File-ShareDir',  'file/name.txt');
0.000000,0,0.000000,$file = module_file('File::ShareDir', 'file/name.txt');
0.000000,0,0.000000,
0.000000,0,0.000000,# Like module_file, but search up the inheritance tree
0.000000,0,0.000000,$file = class_file( 'Foo::Bar', 'file/name.txt' );
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,The intent of L<File::ShareDir> is to provide a companion to
0.000000,0,0.000000,L<Class::Inspector> and L<File::HomeDir>, modules that take a
0.000000,0,0.000000,process that is well-known by advanced Perl developers but gets a
0.000000,0,0.000000,little tricky, and make it more available to the larger Perl community.
0.000000,0,0.000000,
0.000000,0,0.000000,Quite often you want or need your Perl module (CPAN or otherwise)
0.000000,0,0.000000,to have access to a large amount of read-only data that is stored
0.000000,0,0.000000,on the file-system at run-time.
0.000000,0,0.000000,
0.000000,0,0.000000,On a linux-like system, this would be in a place such as /usr/share,
0.000000,0,0.000000,however Perl runs on a wide variety of different systems, and so
0.000000,0,0.000000,the use of any one location is unreliable.
0.000000,0,0.000000,
0.000000,0,0.000000,Perl provides a little-known method for doing this, but almost
0.000000,0,0.000000,nobody is aware that it exists. As a result, module authors often
0.000000,0,0.000000,go through some very strange ways to make the data available to
0.000000,0,0.000000,their code.
0.000000,0,0.000000,
0.000000,0,0.000000,The most common of these is to dump the data out to an enormous
0.000000,0,0.000000,Perl data structure and save it into the module itself. The
0.000000,0,0.000000,result are enormous multi-megabyte .pm files that chew up a
0.000000,0,0.000000,lot of memory needlessly.
0.000000,0,0.000000,
0.000000,0,0.000000,Another method is to put the data "file" after the __DATA__ compiler
0.000000,0,0.000000,tag and limit yourself to access as a filehandle.
0.000000,0,0.000000,
0.000000,0,0.000000,The problem to solve is really quite simple.
0.000000,0,0.000000,
0.000000,0,0.000000,1. Write the data files to the system at install time.
0.000000,0,0.000000,
0.000000,0,0.000000,2. Know where you put them at run-time.
0.000000,0,0.000000,
0.000000,0,0.000000,Perl's install system creates an "auto" directory for both
0.000000,0,0.000000,every distribution and for every module file.
0.000000,0,0.000000,
0.000000,0,0.000000,These are used by a couple of different auto-loading systems
0.000000,0,0.000000,to store code fragments generated at install time, and various
0.000000,0,0.000000,other modules written by the Perl "ancient masters".
0.000000,0,0.000000,
0.000000,0,0.000000,But the same mechanism is available to any dist or module to
0.000000,0,0.000000,store any sort of data.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Using Data in your Module
0.000000,0,0.000000,
0.000000,0,0.000000,C<File::ShareDir> forms one half of a two part solution.
0.000000,0,0.000000,
0.000000,0,0.000000,Once the files have been installed to the correct directory,
0.000000,0,0.000000,you can use C<File::ShareDir> to find your files again after
0.000000,0,0.000000,the installation.
0.000000,0,0.000000,
0.000000,0,0.000000,For the installation half of the solution, see L<File::ShareDir::Install>
0.000000,0,0.000000,and its C<install_share> directive.
0.000000,0,0.000000,
0.000000,0,0.000000,Using L<File::ShareDir::Install> together with L<File::ShareDir>
0.000000,0,0.000000,allows one to rely on the files in appropriate C<dist_dir()>
0.000000,0,0.000000,or C<module_dir()> in development phase, too.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 FUNCTIONS
0.000000,0,0.000000,
0.000000,0,0.000000,C<File::ShareDir> provides four functions for locating files and
0.000000,0,0.000000,directories.
0.000000,0,0.000000,
0.000000,0,0.000000,For greater maintainability, none of these are exported by default
0.000000,0,0.000000,and you are expected to name the ones you want at use-time, or provide
0.000000,0,0.000000,the C<':ALL'> tag. All of the following are equivalent.
0.000000,0,0.000000,
0.000000,0,0.000000,# Load but don't import, and then call directly
0.000000,0,0.000000,use File::ShareDir;
0.000000,0,0.000000,$dir = File::ShareDir::dist_dir('My-Dist');
0.000000,0,0.000000,
0.000000,0,0.000000,# Import a single function
0.000000,0,0.000000,use File::ShareDir 'dist_dir';
0.000000,0,0.000000,dist_dir('My-Dist');
0.000000,0,0.000000,
0.000000,0,0.000000,# Import all the functions
0.000000,0,0.000000,use File::ShareDir ':ALL';
0.000000,0,0.000000,dist_dir('My-Dist');
0.000000,0,0.000000,
0.000000,0,0.000000,All of the functions will check for you that the dir/file actually
0.000000,0,0.000000,exists, and that you have read permissions, or they will throw an
0.000000,0,0.000000,exception.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000036,2,0.000018,use 5.005;
0.000024,2,0.000012,use strict;
0.000048,2,0.000024,use warnings;
0.000000,0,0.000000,
0.000025,2,0.000013,use base ('Exporter');
0.000019,2,0.000010,use constant IS_MACOS => !!($^O eq 'MacOS');
0.000011,2,0.000005,use constant IS_WIN32 => !!($^O eq 'MSWin32');
0.000000,0,0.000000,
0.000009,2,0.000005,use Carp             ();
0.000007,2,0.000003,use Exporter         ();
0.000009,2,0.000005,use File::Spec       ();
0.001779,2,0.000890,use Class::Inspector ();
0.000000,0,0.000000,
0.000000,0,0.000000,our %DIST_SHARE;
0.000000,0,0.000000,our %MODULE_SHARE;
0.000000,0,0.000000,
0.000000,0,0.000000,our @CARP_NOT;
0.000001,1,0.000001,our @EXPORT_OK = qw{
0.000000,0,0.000000,dist_dir
0.000000,0,0.000000,dist_file
0.000000,0,0.000000,module_dir
0.000000,0,0.000000,module_file
0.000000,0,0.000000,class_dir
0.000000,0,0.000000,class_file
0.000000,0,0.000000,};
0.000002,1,0.000002,our %EXPORT_TAGS = (
0.000000,0,0.000000,ALL => [@EXPORT_OK],
0.000000,0,0.000000,);
0.000000,1,0.000000,our $VERSION = '1.118';
0.000000,0,0.000000,
0.000000,0,0.000000,#####################################################################
0.000000,0,0.000000,# Interface Functions
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 dist_dir
0.000000,0,0.000000,
0.000000,0,0.000000,# Get a distribution's shared files directory
0.000000,0,0.000000,my $dir = dist_dir('My-Distribution');
0.000000,0,0.000000,
0.000000,0,0.000000,The C<dist_dir> function takes a single parameter of the name of an
0.000000,0,0.000000,installed (CPAN or otherwise) distribution, and locates the shared
0.000000,0,0.000000,data directory created at install time for it.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the directory path as a string, or dies if it cannot be
0.000000,0,0.000000,located or is not readable.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub dist_dir
0.000000,0,0.000000,{
0.000031,14,0.000002,my $dist = _DIST(shift);
0.000003,14,0.000000,my $dir;
0.000000,0,0.000000,
0.000000,0,0.000000,# Try the new version, then fall back to the legacy version
0.000022,14,0.000002,$dir = _dist_dir_new($dist) || _dist_dir_old($dist);
0.000000,0,0.000000,
0.000049,14,0.000004,return $dir if defined $dir;
0.000000,0,0.000000,
0.000000,0,0.000000,# Ran out of options
0.000000,0,0.000000,Carp::croak("Failed to find share dir for dist '$dist'");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _dist_dir_new
0.000000,0,0.000000,{
0.000007,14,0.000000,my $dist = shift;
0.000000,0,0.000000,
0.000011,14,0.000001,return $DIST_SHARE{$dist} if exists $DIST_SHARE{$dist};
0.000000,0,0.000000,
0.000000,0,0.000000,# Create the subpath
0.000204,14,0.000015,my $path = File::Spec->catdir('auto', 'share', 'dist', $dist);
0.000000,0,0.000000,
0.000000,0,0.000000,# Find the full dir within @INC
0.000076,14,0.000005,return _search_inc_path($path);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _dist_dir_old
0.000000,0,0.000000,{
0.000000,0,0.000000,my $dist = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Create the subpath
0.000000,0,0.000000,my $path = File::Spec->catdir('auto', split(/-/, $dist),);
0.000000,0,0.000000,
0.000000,0,0.000000,# Find the full dir within @INC
0.000000,0,0.000000,return _search_inc_path($path);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 module_dir
0.000000,0,0.000000,
0.000000,0,0.000000,# Get a module's shared files directory
0.000000,0,0.000000,my $dir = module_dir('My::Module');
0.000000,0,0.000000,
0.000000,0,0.000000,The C<module_dir> function takes a single parameter of the name of an
0.000000,0,0.000000,installed (CPAN or otherwise) module, and locates the shared data
0.000000,0,0.000000,directory created at install time for it.
0.000000,0,0.000000,
0.000000,0,0.000000,In order to find the directory, the module B<must> be loaded when
0.000000,0,0.000000,calling this function.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the directory path as a string, or dies if it cannot be
0.000000,0,0.000000,located or is not readable.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub module_dir
0.000000,0,0.000000,{
0.000000,0,0.000000,my $module = _MODULE(shift);
0.000000,0,0.000000,
0.000000,0,0.000000,return $MODULE_SHARE{$module} if exists $MODULE_SHARE{$module};
0.000000,0,0.000000,
0.000000,0,0.000000,# Try the new version first, then fall back to the legacy version
0.000000,0,0.000000,return _module_dir_new($module) || _module_dir_old($module);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _module_dir_new
0.000000,0,0.000000,{
0.000000,0,0.000000,my $module = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Create the subpath
0.000000,0,0.000000,my $path = File::Spec->catdir('auto', 'share', 'module', _module_subdir($module),);
0.000000,0,0.000000,
0.000000,0,0.000000,# Find the full dir within @INC
0.000000,0,0.000000,return _search_inc_path($path);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _module_dir_old
0.000000,0,0.000000,{
0.000000,0,0.000000,my $module = shift;
0.000000,0,0.000000,my $short  = Class::Inspector->filename($module);
0.000000,0,0.000000,my $long   = Class::Inspector->loaded_filename($module);
0.000000,0,0.000000,$short =~ tr{/}{:}   if IS_MACOS;
0.000000,0,0.000000,$short =~ tr{\\} {/} if IS_WIN32;
0.000000,0,0.000000,$long  =~ tr{\\} {/} if IS_WIN32;
0.000000,0,0.000000,substr($short, -3, 3, '');
0.000000,0,0.000000,$long =~ m/^(.*)\Q$short\E\.pm\z/s or Carp::croak("Failed to find base dir");
0.000000,0,0.000000,my $dir = File::Spec->catdir("$1", 'auto', $short);
0.000000,0,0.000000,
0.000000,0,0.000000,-d $dir or Carp::croak("Directory '$dir': No such directory");
0.000000,0,0.000000,-r $dir or Carp::croak("Directory '$dir': No read permission");
0.000000,0,0.000000,
0.000000,0,0.000000,return $dir;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 dist_file
0.000000,0,0.000000,
0.000000,0,0.000000,# Find a file in our distribution shared dir
0.000000,0,0.000000,my $dir = dist_file('My-Distribution', 'file/name.txt');
0.000000,0,0.000000,
0.000000,0,0.000000,The C<dist_file> function takes two parameters of the distribution name
0.000000,0,0.000000,and file name, locates the dist directory, and then finds the file within
0.000000,0,0.000000,it, verifying that the file actually exists, and that it is readable.
0.000000,0,0.000000,
0.000000,0,0.000000,The filename should be a relative path in the format of your local
0.000000,0,0.000000,filesystem. It will simply added to the directory using L<File::Spec>'s
0.000000,0,0.000000,C<catfile> method.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the file path as a string, or dies if the file or the dist's
0.000000,0,0.000000,directory cannot be located, or the file is not readable.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub dist_file
0.000000,0,0.000000,{
0.000000,0,0.000000,my $dist = _DIST(shift);
0.000000,0,0.000000,my $file = _FILE(shift);
0.000000,0,0.000000,
0.000000,0,0.000000,# Try the new version first, in doubt hand off to the legacy version
0.000000,0,0.000000,my $path = _dist_file_new($dist, $file) || _dist_file_old($dist, $file);
0.000000,0,0.000000,$path or Carp::croak("Failed to find shared file '$file' for dist '$dist'");
0.000000,0,0.000000,
0.000000,0,0.000000,-f $path or Carp::croak("File '$path': No such file");
0.000000,0,0.000000,-r $path or Carp::croak("File '$path': No read permission");
0.000000,0,0.000000,
0.000000,0,0.000000,return $path;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _dist_file_new
0.000000,0,0.000000,{
0.000000,0,0.000000,my $dist = shift;
0.000000,0,0.000000,my $file = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# If it exists, what should the path be
0.000000,0,0.000000,my $dir = _dist_dir_new($dist);
0.000000,0,0.000000,return undef unless defined $dir;
0.000000,0,0.000000,my $path = File::Spec->catfile($dir, $file);
0.000000,0,0.000000,
0.000000,0,0.000000,# Does the file exist
0.000000,0,0.000000,return undef unless -e $path;
0.000000,0,0.000000,
0.000000,0,0.000000,return $path;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _dist_file_old
0.000000,0,0.000000,{
0.000000,0,0.000000,my $dist = shift;
0.000000,0,0.000000,my $file = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# If it exists, what should the path be
0.000000,0,0.000000,my $dir = _dist_dir_old($dist);
0.000000,0,0.000000,return undef unless defined $dir;
0.000000,0,0.000000,my $path = File::Spec->catfile($dir, $file);
0.000000,0,0.000000,
0.000000,0,0.000000,# Does the file exist
0.000000,0,0.000000,return undef unless -e $path;
0.000000,0,0.000000,
0.000000,0,0.000000,return $path;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 module_file
0.000000,0,0.000000,
0.000000,0,0.000000,# Find a file in our module shared dir
0.000000,0,0.000000,my $dir = module_file('My::Module', 'file/name.txt');
0.000000,0,0.000000,
0.000000,0,0.000000,The C<module_file> function takes two parameters of the module name
0.000000,0,0.000000,and file name. It locates the module directory, and then finds the file
0.000000,0,0.000000,within it, verifying that the file actually exists, and that it is readable.
0.000000,0,0.000000,
0.000000,0,0.000000,In order to find the directory, the module B<must> be loaded when
0.000000,0,0.000000,calling this function.
0.000000,0,0.000000,
0.000000,0,0.000000,The filename should be a relative path in the format of your local
0.000000,0,0.000000,filesystem. It will simply added to the directory using L<File::Spec>'s
0.000000,0,0.000000,C<catfile> method.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the file path as a string, or dies if the file or the dist's
0.000000,0,0.000000,directory cannot be located, or the file is not readable.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub module_file
0.000000,0,0.000000,{
0.000000,0,0.000000,my $module = _MODULE(shift);
0.000000,0,0.000000,my $file   = _FILE(shift);
0.000000,0,0.000000,my $dir    = module_dir($module);
0.000000,0,0.000000,my $path   = File::Spec->catfile($dir, $file);
0.000000,0,0.000000,
0.000000,0,0.000000,-e $path or Carp::croak("File '$path' does not exist in module dir");
0.000000,0,0.000000,-r $path or Carp::croak("File '$path': No read permission");
0.000000,0,0.000000,
0.000000,0,0.000000,return $path;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 class_file
0.000000,0,0.000000,
0.000000,0,0.000000,# Find a file in our module shared dir, or in our parent class
0.000000,0,0.000000,my $dir = class_file('My::Module', 'file/name.txt');
0.000000,0,0.000000,
0.000000,0,0.000000,The C<module_file> function takes two parameters of the module name
0.000000,0,0.000000,and file name. It locates the module directory, and then finds the file
0.000000,0,0.000000,within it, verifying that the file actually exists, and that it is readable.
0.000000,0,0.000000,
0.000000,0,0.000000,In order to find the directory, the module B<must> be loaded when
0.000000,0,0.000000,calling this function.
0.000000,0,0.000000,
0.000000,0,0.000000,The filename should be a relative path in the format of your local
0.000000,0,0.000000,filesystem. It will simply added to the directory using L<File::Spec>'s
0.000000,0,0.000000,C<catfile> method.
0.000000,0,0.000000,
0.000000,0,0.000000,If the file is NOT found for that module, C<class_file> will scan up
0.000000,0,0.000000,the module's @ISA tree, looking for the file in all of the parent
0.000000,0,0.000000,classes.
0.000000,0,0.000000,
0.000000,0,0.000000,This allows you to, in effect, "subclass" shared files.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the file path as a string, or dies if the file or the dist's
0.000000,0,0.000000,directory cannot be located, or the file is not readable.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub class_file
0.000000,0,0.000000,{
0.000000,0,0.000000,my $module = _MODULE(shift);
0.000000,0,0.000000,my $file   = _FILE(shift);
0.000000,0,0.000000,
0.000000,0,0.000000,# Get the super path ( not including UNIVERSAL )
0.000000,0,0.000000,# Rather than using Class::ISA, we'll use an inlined version
0.000000,0,0.000000,# that implements the same basic algorithm.
0.000000,0,0.000000,my @path  = ();
0.000000,0,0.000000,my @queue = ($module);
0.000000,0,0.000000,my %seen  = ($module => 1);
0.000000,0,0.000000,while (my $cl = shift @queue)
0.000000,0,0.000000,{
0.000000,0,0.000000,push @path, $cl;
0.000769,2,0.000385,no strict 'refs';    ## no critic (TestingAndDebugging::ProhibitNoStrict)
0.000000,0,0.000000,unshift @queue, grep { !$seen{$_}++ }
0.000000,0,0.000000,map { my $s = $_; $s =~ s/^::/main::/; $s =~ s/\'/::/g; $s } (@{"${cl}::ISA"});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Search up the path
0.000000,0,0.000000,foreach my $class (@path)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $dir = eval { module_dir($class); };
0.000000,0,0.000000,next if $@;
0.000000,0,0.000000,my $path = File::Spec->catfile($dir, $file);
0.000000,0,0.000000,-e $path or next;
0.000000,0,0.000000,-r $path or Carp::croak("File '$file' cannot be read, no read permissions");
0.000000,0,0.000000,return $path;
0.000000,0,0.000000,}
0.000000,0,0.000000,Carp::croak("File '$file' does not exist in class or parent shared files");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## no critic (BuiltinFunctions::ProhibitStringyEval)
0.000772,1,0.000772,if (eval "use List::MoreUtils 0.428; 1;")
0.000000,0,0.000000,{
0.000000,0,0.000000,List::MoreUtils->import("firstres");
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,## no critic (ErrorHandling::RequireCheckingReturnValueOfEval)
0.000000,0,0.000000,eval <<'END_OF_BORROWED_CODE';
0.000000,0,0.000000,sub firstres (&@)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,foreach (@_)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $testval = $test->();
0.000000,0,0.000000,$testval and return $testval;
0.000000,0,0.000000,}
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_OF_BORROWED_CODE
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#####################################################################
0.000000,0,0.000000,# Support Functions
0.000000,0,0.000000,
0.000000,0,0.000000,sub _search_inc_path
0.000000,0,0.000000,{
0.000006,14,0.000000,my $path = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Find the full dir within @INC
0.000000,0,0.000000,my $dir = firstres(
0.000000,0,0.000000,sub {
0.000006,28,0.000000,my $d;
0.000190,28,0.000007,$d = File::Spec->catdir($_, $path) if defined _STRING($_);
0.000806,28,0.000029,defined $d and -d $d ? $d : 0;
0.000000,0,0.000000,},
0.000000,0,0.000000,@INC
0.000086,14,0.000006,) or return;
0.000000,0,0.000000,
0.000126,14,0.000009,Carp::croak("Found directory '$dir', but no read permissions") unless -r $dir;
0.000000,0,0.000000,
0.000031,14,0.000002,return $dir;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _module_subdir
0.000000,0,0.000000,{
0.000000,0,0.000000,my $module = shift;
0.000000,0,0.000000,$module =~ s/::/-/g;
0.000000,0,0.000000,return $module;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## no critic (BuiltinFunctions::ProhibitStringyEval)
0.000399,1,0.000399,if (eval "use Params::Util 1.07; 1;")
0.000000,0,0.000000,{
0.000000,0,0.000000,Params::Util->import("_CLASS", "_STRING");
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,## no critic (ErrorHandling::RequireCheckingReturnValueOfEval)
0.000000,0,0.000000,eval <<'END_OF_BORROWED_CODE';
0.000000,0,0.000000,# Inlined from Params::Util pure perl version
0.000000,0,0.000000,sub _CLASS ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,return (defined $_[0] and !ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _STRING ($)
0.000000,0,0.000000,{
0.000000,0,0.000000,(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_OF_BORROWED_CODE
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Maintainer note: The following private functions are used by
0.000000,0,0.000000,#                  File::ShareDir::PAR. (It has to or else it would have to copy&fork)
0.000000,0,0.000000,#                  So if you significantly change or even remove them, please
0.000000,0,0.000000,#                  notify the File::ShareDir::PAR maintainer(s). Thank you!
0.000000,0,0.000000,
0.000000,0,0.000000,# Matches a valid distribution name
0.000000,0,0.000000,### This is a total guess at this point
0.000000,0,0.000000,sub _DIST    ## no critic (Subroutines::RequireArgUnpacking)
0.000000,0,0.000000,{
0.000123,14,0.000009,defined _STRING($_[0]) and $_[0] =~ /^[a-z0-9+_-]+$/is and return $_[0];
0.000000,0,0.000000,Carp::croak("Not a valid distribution name");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# A valid and loaded module name
0.000000,0,0.000000,sub _MODULE
0.000000,0,0.000000,{
0.000000,0,0.000000,my $module = _CLASS(shift) or Carp::croak("Not a valid module name");
0.000000,0,0.000000,Class::Inspector->loaded($module) and return $module;
0.000000,0,0.000000,Carp::croak("Module '$module' is not loaded");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# A valid file name
0.000000,0,0.000000,sub _FILE
0.000000,0,0.000000,{
0.000000,0,0.000000,my $file = shift;
0.000000,0,0.000000,_STRING($file) or Carp::croak("Did not pass a file name");
0.000000,0,0.000000,File::Spec->file_name_is_absolute($file) and Carp::croak("Cannot use absolute file name '$file'");
0.000000,0,0.000000,return $file;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000019,1,0.000019,1;
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 EXTENDING
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Overriding Directory Resolution
0.000000,0,0.000000,
0.000000,0,0.000000,C<File::ShareDir> has two convenience hashes for people who have advanced usage
0.000000,0,0.000000,requirements of C<File::ShareDir> such as using uninstalled C<share>
0.000000,0,0.000000,directories during development.
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# Dist-Name => /absolute/path/for/DistName/share/dir
0.000000,0,0.000000,#
0.000000,0,0.000000,%File::ShareDir::DIST_SHARE
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# Module::Name => /absolute/path/for/Module/Name/share/dir
0.000000,0,0.000000,#
0.000000,0,0.000000,%File::ShareDir::MODULE_SHARE
0.000000,0,0.000000,
0.000000,0,0.000000,Setting these values any time before the corresponding calls
0.000000,0,0.000000,
0.000000,0,0.000000,dist_dir('Dist-Name')
0.000000,0,0.000000,dist_file('Dist-Name','some/file');
0.000000,0,0.000000,
0.000000,0,0.000000,module_dir('Module::Name');
0.000000,0,0.000000,module_file('Module::Name','some/file');
0.000000,0,0.000000,
0.000000,0,0.000000,Will override the base directory for resolving those calls.
0.000000,0,0.000000,
0.000000,0,0.000000,An example of where this would be useful is in a test for a module that
0.000000,0,0.000000,depends on files installed into a share directory, to enable the tests
0.000000,0,0.000000,to use the development copy without needing to install them first.
0.000000,0,0.000000,
0.000000,0,0.000000,use File::ShareDir;
0.000000,0,0.000000,use Cwd qw( getcwd );
0.000000,0,0.000000,use File::Spec::Functions qw( rel2abs catdir );
0.000000,0,0.000000,
0.000000,0,0.000000,$File::ShareDir::MODULE_SHARE{'Foo::Module'} = rel2abs(catfile(getcwd,'share'));
0.000000,0,0.000000,
0.000000,0,0.000000,use Foo::Module;
0.000000,0,0.000000,
0.000000,0,0.000000,# internal calls in Foo::Module to module_file('Foo::Module','bar') now resolves to
0.000000,0,0.000000,# the source trees share/ directory instead of something in @INC
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SUPPORT
0.000000,0,0.000000,
0.000000,0,0.000000,Bugs should always be submitted via the CPAN request tracker, see below.
0.000000,0,0.000000,
0.000000,0,0.000000,You can find documentation for this module with the perldoc command.
0.000000,0,0.000000,
0.000000,0,0.000000,perldoc File::ShareDir
0.000000,0,0.000000,
0.000000,0,0.000000,You can also look for information at:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * RT: CPAN's request tracker
0.000000,0,0.000000,
0.000000,0,0.000000,L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=File-ShareDir>
0.000000,0,0.000000,
0.000000,0,0.000000,=item * AnnoCPAN: Annotated CPAN documentation
0.000000,0,0.000000,
0.000000,0,0.000000,L<http://annocpan.org/dist/File-ShareDir>
0.000000,0,0.000000,
0.000000,0,0.000000,=item * CPAN Ratings
0.000000,0,0.000000,
0.000000,0,0.000000,L<http://cpanratings.perl.org/s/File-ShareDir>
0.000000,0,0.000000,
0.000000,0,0.000000,=item * CPAN Search
0.000000,0,0.000000,
0.000000,0,0.000000,L<http://search.cpan.org/dist/File-ShareDir/>
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Where can I go for other help?
0.000000,0,0.000000,
0.000000,0,0.000000,If you have a bug report, a patch or a suggestion, please open a new
0.000000,0,0.000000,report ticket at CPAN (but please check previous reports first in case
0.000000,0,0.000000,your issue has already been addressed).
0.000000,0,0.000000,
0.000000,0,0.000000,Report tickets should contain a detailed description of the bug or
0.000000,0,0.000000,enhancement request and at least an easily verifiable way of
0.000000,0,0.000000,reproducing the issue or fix. Patches are always welcome, too.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Where can I go for help with a concrete version?
0.000000,0,0.000000,
0.000000,0,0.000000,Bugs and feature requests are accepted against the latest version
0.000000,0,0.000000,only. To get patches for earlier versions, you need to get an
0.000000,0,0.000000,agreement with a developer of your choice - who may or not report the
0.000000,0,0.000000,issue and a suggested fix upstream (depends on the license you have
0.000000,0,0.000000,chosen).
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Business support and maintenance
0.000000,0,0.000000,
0.000000,0,0.000000,For business support you can contact the maintainer via his CPAN
0.000000,0,0.000000,email address. Please keep in mind that business support is neither
0.000000,0,0.000000,available for free nor are you eligible to receive any support
0.000000,0,0.000000,based on the license distributed with this package.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHOR
0.000000,0,0.000000,
0.000000,0,0.000000,Adam Kennedy E<lt>adamk@cpan.orgE<gt>
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 MAINTAINER
0.000000,0,0.000000,
0.000000,0,0.000000,Jens Rehsack E<lt>rehsack@cpan.orgE<gt>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,L<File::ShareDir::Install>,
0.000000,0,0.000000,L<File::ConfigDir>, L<File::HomeDir>,
0.000000,0,0.000000,L<Module::Install>, L<Module::Install::Share>,
0.000000,0,0.000000,L<File::ShareDir::PAR>, L<Dist::Zilla::Plugin::ShareDir>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright 2005 - 2011 Adam Kennedy,
0.000000,0,0.000000,Copyright 2014 - 2018 Jens Rehsack.
0.000000,0,0.000000,
0.000000,0,0.000000,This program is free software; you can redistribute
0.000000,0,0.000000,it and/or modify it under the same terms as Perl itself.
0.000000,0,0.000000,
0.000000,0,0.000000,The full text of the license can be found in the
0.000000,0,0.000000,LICENSE file included with this module.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
