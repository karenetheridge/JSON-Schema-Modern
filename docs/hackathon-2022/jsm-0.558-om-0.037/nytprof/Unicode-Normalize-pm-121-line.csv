# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Unicode::Normalize;
0.000000,0,0.000000,
0.000066,2,0.000033,use 5.006;
0.000051,2,0.000025,use strict;
0.000015,2,0.000008,use warnings;
0.000018,2,0.000009,use Carp;
0.000000,0,0.000000,
0.000198,2,0.000099,no warnings 'utf8';
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '1.31';
0.000000,1,0.000000,our $PACKAGE = __PACKAGE__;
0.000000,0,0.000000,
0.000002,1,0.000002,our @EXPORT = qw( NFC NFD NFKC NFKD );
0.000001,1,0.000001,our @EXPORT_OK = qw(
0.000000,0,0.000000,normalize decompose reorder compose
0.000000,0,0.000000,checkNFD checkNFKD checkNFC checkNFKC check
0.000000,0,0.000000,getCanon getCompat getComposite getCombinClass
0.000000,0,0.000000,isExclusion isSingleton isNonStDecomp isComp2nd isComp_Ex
0.000000,0,0.000000,isNFD_NO isNFC_NO isNFC_MAYBE isNFKD_NO isNFKC_NO isNFKC_MAYBE
0.000000,0,0.000000,FCD checkFCD FCC checkFCC composeContiguous splitOnLastStarter
0.000000,0,0.000000,normalize_partial NFC_partial NFD_partial NFKC_partial NFKD_partial
0.000000,0,0.000000,);
0.000004,1,0.000004,our %EXPORT_TAGS = (
0.000000,0,0.000000,all       => [ @EXPORT, @EXPORT_OK ],
0.000000,0,0.000000,normalize => [ @EXPORT, qw/normalize decompose reorder compose/ ],
0.000000,0,0.000000,check     => [ qw/checkNFD checkNFKD checkNFC checkNFKC check/ ],
0.000000,0,0.000000,fast      => [ qw/FCD checkFCD FCC checkFCC composeContiguous/ ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,##
0.000000,0,0.000000,## utilities for tests
0.000000,0,0.000000,##
0.000000,0,0.000000,
0.000000,0,0.000000,# No EBCDIC support on early perls
0.000000,0,0.000000,*to_native = ($::IS_ASCII || $] < 5.008)
0.000000,0,0.000000,? sub { return shift }
0.000003,1,0.000003,: sub { utf8::unicode_to_native(shift) };
0.000000,0,0.000000,
0.000000,0,0.000000,*from_native = ($::IS_ASCII || $] < 5.008)
0.000000,0,0.000000,? sub { return shift }
0.000001,1,0.000001,: sub { utf8::native_to_unicode(shift) };
0.000000,0,0.000000,
0.000000,0,0.000000,# The .t files are all in terms of Unicode, so xlate to/from native
0.000000,0,0.000000,sub dot_t_pack_U {
0.000000,0,0.000000,return pack('U*', map { to_native($_) } @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub dot_t_unpack_U {
0.000000,0,0.000000,
0.000000,0,0.000000,# The empty pack returns an empty UTF-8 string, so the effect is to force
0.000000,0,0.000000,# the shifted parameter into being UTF-8.  This allows this to work on
0.000000,0,0.000000,# Perl 5.6, where there is no utf8::upgrade().
0.000000,0,0.000000,return map { from_native($_) } unpack('U*', shift(@_).pack('U*'));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_printable_string ($) {
0.000178,2,0.000089,use bytes;
0.000000,0,0.000000,my $s = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# DeMorgan's laws cause this to mean ascii printables
0.000000,0,0.000000,return $s if $s =~ /[^[:^ascii:][:^print:]]/;
0.000000,0,0.000000,
0.000000,0,0.000000,return join " ", map { sprintf "\\x%02x", ord $_ } split "", $s;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ok ($$;$) {
0.000000,0,0.000000,my $count_ref = shift;  # Test number in caller
0.000000,0,0.000000,my $p = my $r = shift;
0.000000,0,0.000000,my $x;
0.000000,0,0.000000,if (@_) {
0.000000,0,0.000000,$x = shift;
0.000000,0,0.000000,$p = !defined $x ? !defined $r : !defined $r ? 0 : $r eq $x;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,print $p ? "ok" : "not ok", ' ', ++$$count_ref, "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,return if $p;
0.000000,0,0.000000,
0.000000,0,0.000000,my (undef, $file, $line) = caller(1);
0.000000,0,0.000000,print STDERR "# Failed test $$count_ref at $file line $line\n";
0.000000,0,0.000000,
0.000000,0,0.000000,return unless defined $x;
0.000000,0,0.000000,
0.000000,0,0.000000,print STDERR "#      got ", get_printable_string($r), "\n";
0.000000,0,0.000000,print STDERR "# expected ", get_printable_string($x), "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,require Exporter;
0.000000,0,0.000000,
0.000000,0,0.000000,##### The above part is common to XS and PP #####
0.000000,0,0.000000,
0.000007,1,0.000007,our @ISA = qw(Exporter);
0.000487,2,0.000244,use XSLoader ();
0.001572,1,0.001572,XSLoader::load( 'Unicode::Normalize', $VERSION );
0.000000,0,0.000000,
0.000000,0,0.000000,##### The below part is common to XS and PP #####
0.000000,0,0.000000,
0.000000,0,0.000000,##
0.000000,0,0.000000,## normalize
0.000000,0,0.000000,##
0.000000,0,0.000000,
0.000000,0,0.000000,sub FCD ($) {
0.000000,0,0.000000,my $str = shift;
0.000000,0,0.000000,return checkFCD($str) ? $str : NFD($str);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,our %formNorm = (
0.000000,0,0.000000,NFC  => \&NFC,	C  => \&NFC,
0.000000,0,0.000000,NFD  => \&NFD,	D  => \&NFD,
0.000000,0,0.000000,NFKC => \&NFKC,	KC => \&NFKC,
0.000000,0,0.000000,NFKD => \&NFKD,	KD => \&NFKD,
0.000000,0,0.000000,FCD  => \&FCD,	FCC => \&FCC,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub normalize($$)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $form = shift;
0.000000,0,0.000000,my $str = shift;
0.000000,0,0.000000,if (exists $formNorm{$form}) {
0.000000,0,0.000000,return $formNorm{$form}->($str);
0.000000,0,0.000000,}
0.000000,0,0.000000,croak($PACKAGE."::normalize: invalid form name: $form");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##
0.000000,0,0.000000,## partial
0.000000,0,0.000000,##
0.000000,0,0.000000,
0.000000,0,0.000000,sub normalize_partial ($$) {
0.000000,0,0.000000,if (exists $formNorm{$_[0]}) {
0.000000,0,0.000000,my $n = normalize($_[0], $_[1]);
0.000000,0,0.000000,my($p, $u) = splitOnLastStarter($n);
0.000000,0,0.000000,$_[1] = $u;
0.000000,0,0.000000,return $p;
0.000000,0,0.000000,}
0.000000,0,0.000000,croak($PACKAGE."::normalize_partial: invalid form name: $_[0]");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub NFD_partial ($) { return normalize_partial('NFD', $_[0]) }
0.000000,0,0.000000,sub NFC_partial ($) { return normalize_partial('NFC', $_[0]) }
0.000000,0,0.000000,sub NFKD_partial($) { return normalize_partial('NFKD',$_[0]) }
0.000000,0,0.000000,sub NFKC_partial($) { return normalize_partial('NFKC',$_[0]) }
0.000000,0,0.000000,
0.000000,0,0.000000,##
0.000000,0,0.000000,## check
0.000000,0,0.000000,##
0.000000,0,0.000000,
0.000002,1,0.000002,our %formCheck = (
0.000000,0,0.000000,NFC  => \&checkNFC, 	C  => \&checkNFC,
0.000000,0,0.000000,NFD  => \&checkNFD, 	D  => \&checkNFD,
0.000000,0,0.000000,NFKC => \&checkNFKC,	KC => \&checkNFKC,
0.000000,0,0.000000,NFKD => \&checkNFKD,	KD => \&checkNFKD,
0.000000,0,0.000000,FCD  => \&checkFCD, 	FCC => \&checkFCC,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub check($$)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $form = shift;
0.000000,0,0.000000,my $str = shift;
0.000000,0,0.000000,if (exists $formCheck{$form}) {
0.000000,0,0.000000,return $formCheck{$form}->($str);
0.000000,0,0.000000,}
0.000000,0,0.000000,croak($PACKAGE."::check: invalid form name: $form");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000018,1,0.000018,1;
0.000000,0,0.000000,__END__
