# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Carp;
0.000000,0,0.000000,
0.000031,2,0.000016,{ use 5.006; }
0.000013,3,0.000004,use strict;
0.000038,2,0.000019,use warnings;
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,# Very old versions of warnings.pm load Carp.  This can go wrong due
0.000000,0,0.000000,# to the circular dependency.  If warnings is invoked before Carp,
0.000000,0,0.000000,# then warnings starts by loading Carp, then Carp (above) tries to
0.000000,0,0.000000,# invoke warnings, and gets nothing because warnings is in the process
0.000000,0,0.000000,# of loading and hasn't defined its import method yet.  If we were
0.000000,0,0.000000,# only turning on warnings ("use warnings" above) this wouldn't be too
0.000000,0,0.000000,# bad, because Carp would just gets the state of the -w switch and so
0.000000,0,0.000000,# might not get some warnings that it wanted.  The real problem is
0.000000,0,0.000000,# that we then want to turn off Unicode warnings, but "no warnings
0.000000,0,0.000000,# 'utf8'" won't be effective if we're in this circular-dependency
0.000000,0,0.000000,# situation.  So, if warnings.pm is an affected version, we turn
0.000000,0,0.000000,# off all warnings ourselves by directly setting ${^WARNING_BITS}.
0.000000,0,0.000000,# On unaffected versions, we turn off just Unicode warnings, via
0.000000,0,0.000000,# the proper API.
0.000014,1,0.000014,if(!defined($warnings::VERSION) || eval($warnings::VERSION) < 1.06) {
0.000000,0,0.000000,${^WARNING_BITS} = "";
0.000000,0,0.000000,} else {
0.000002,1,0.000002,"warnings"->unimport("utf8");
0.000000,0,0.000000,}
0.000101,1,0.000101,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fetch_sub { # fetch sub without autovivifying
0.000001,3,0.000000,my($pack, $sub) = @_;
0.000002,3,0.000001,$pack .= '::';
0.000000,0,0.000000,# only works with top-level packages
0.000001,3,0.000000,return unless exists($::{$pack});
0.000000,3,0.000000,for ($::{$pack}) {
0.000002,3,0.000001,return unless ref \$_ eq 'GLOB' && *$_{HASH} && exists $$_{$sub};
0.000001,3,0.000000,for ($$_{$sub}) {
0.000000,0,0.000000,return ref \$_ eq 'GLOB' ? *$_{CODE} : undef
0.000012,3,0.000004,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# UTF8_REGEXP_PROBLEM is a compile-time constant indicating whether Carp
0.000000,0,0.000000,# must avoid applying a regular expression to an upgraded (is_utf8)
0.000000,0,0.000000,# string.  There are multiple problems, on different Perl versions,
0.000000,0,0.000000,# that require this to be avoided.  All versions prior to 5.13.8 will
0.000000,0,0.000000,# load utf8_heavy.pl for the swash system, even if the regexp doesn't
0.000000,0,0.000000,# use character classes.  Perl 5.6 and Perls [5.11.2, 5.13.11) exhibit
0.000000,0,0.000000,# specific problems when Carp is being invoked in the aftermath of a
0.000000,0,0.000000,# syntax error.
0.000000,0,0.000000,BEGIN {
0.000004,1,0.000004,if("$]" < 5.013011) {
0.000000,0,0.000000,*UTF8_REGEXP_PROBLEM = sub () { 1 };
0.000000,0,0.000000,} else {
0.000000,1,0.000000,*UTF8_REGEXP_PROBLEM = sub () { 0 };
0.000000,0,0.000000,}
0.000047,1,0.000047,}
0.000000,0,0.000000,
0.000000,0,0.000000,# is_utf8() is essentially the utf8::is_utf8() function, which indicates
0.000000,0,0.000000,# whether a string is represented in the upgraded form (using UTF-8
0.000000,0,0.000000,# internally).  As utf8::is_utf8() is only available from Perl 5.8
0.000000,0,0.000000,# onwards, extra effort is required here to make it work on Perl 5.6.
0.000000,0,0.000000,BEGIN {
0.000003,1,0.000003,if(defined(my $sub = _fetch_sub utf8 => 'is_utf8')) {
0.000000,0,0.000000,*is_utf8 = $sub;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# black magic for perl 5.6
0.000000,0,0.000000,*is_utf8 = sub { unpack("C", "\xaa".$_[0]) != 170 };
0.000000,0,0.000000,}
0.000073,1,0.000073,}
0.000000,0,0.000000,
0.000000,0,0.000000,# The downgrade() function defined here is to be used for attempts to
0.000000,0,0.000000,# downgrade where it is acceptable to fail.  It must be called with a
0.000000,0,0.000000,# second argument that is a true value.
0.000000,0,0.000000,BEGIN {
0.000004,1,0.000004,if(defined(my $sub = _fetch_sub utf8 => 'downgrade')) {
0.000000,0,0.000000,*downgrade = \&{"utf8::downgrade"};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,*downgrade = sub {
0.000000,0,0.000000,my $r = "";
0.000000,0,0.000000,my $l = length($_[0]);
0.000000,0,0.000000,for(my $i = 0; $i != $l; $i++) {
0.000000,0,0.000000,my $o = ord(substr($_[0], $i, 1));
0.000000,0,0.000000,return if $o > 255;
0.000000,0,0.000000,$r .= chr($o);
0.000000,0,0.000000,}
0.000000,0,0.000000,$_[0] = $r;
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000070,1,0.000070,}
0.000000,0,0.000000,
0.000000,0,0.000000,# is_safe_printable_codepoint() indicates whether a character, specified
0.000000,0,0.000000,# by integer codepoint, is OK to output literally in a trace.  Generally
0.000000,0,0.000000,# this is if it is a printable character in the ancestral character set
0.000000,0,0.000000,# (ASCII or EBCDIC).  This is used on some Perls in situations where a
0.000000,0,0.000000,# regexp can't be used.
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,*is_safe_printable_codepoint =
0.000000,0,0.000000,"$]" >= 5.007_003 ?
0.000000,0,0.000000,eval(q(sub ($) {
0.000000,0,0.000000,my $u = utf8::native_to_unicode($_[0]);
0.000000,0,0.000000,$u >= 0x20 && $u <= 0x7e;
0.000000,0,0.000000,}))
0.000000,0,0.000000,: ord("A") == 65 ?
0.000000,0,0.000000,sub ($) { $_[0] >= 0x20 && $_[0] <= 0x7e }
0.000000,0,0.000000,:
0.000000,0,0.000000,sub ($) {
0.000000,0,0.000000,# Early EBCDIC
0.000000,0,0.000000,# 3 EBCDIC code pages supported then;  all controls but one
0.000000,0,0.000000,# are the code points below SPACE.  The other one is 0x5F on
0.000000,0,0.000000,# POSIX-BC; FF on the other two.
0.000000,0,0.000000,# FIXME: there are plenty of unprintable codepoints other
0.000000,0,0.000000,# than those that this code and the comment above identifies
0.000000,0,0.000000,# as "controls".
0.000000,0,0.000000,$_[0] >= ord(" ") && $_[0] <= 0xff &&
0.000000,0,0.000000,$_[0] != (ord ("^") == 106 ? 0x5f : 0xff);
0.000000,0,0.000000,}
0.000030,1,0.000030,;
0.000107,1,0.000107,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _univ_mod_loaded {
0.000001,1,0.000001,return 0 unless exists($::{"UNIVERSAL::"});
0.000000,1,0.000000,for ($::{"UNIVERSAL::"}) {
0.000008,1,0.000008,return 0 unless ref \$_ eq "GLOB" && *$_{HASH} && exists $$_{"$_[0]::"};
0.000000,0,0.000000,for ($$_{"$_[0]::"}) {
0.000000,0,0.000000,return 0 unless ref \$_ eq "GLOB" && *$_{HASH} && exists $$_{"VERSION"};
0.000000,0,0.000000,for ($$_{"VERSION"}) {
0.000000,0,0.000000,return 0 unless ref \$_ eq "GLOB";
0.000000,0,0.000000,return ${*$_{SCALAR}};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# _maybe_isa() is usually the UNIVERSAL::isa function.  We have to avoid
0.000000,0,0.000000,# the latter if the UNIVERSAL::isa module has been loaded, to avoid infi-
0.000000,0,0.000000,# nite recursion; in that case _maybe_isa simply returns true.
0.000001,1,0.000001,my $isa;
0.000000,0,0.000000,BEGIN {
0.000002,1,0.000002,if (_univ_mod_loaded('isa')) {
0.000000,0,0.000000,*_maybe_isa = sub { 1 }
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# Since we have already done the check, record $isa for use below
0.000000,0,0.000000,# when defining _StrVal.
0.000000,1,0.000000,*_maybe_isa = $isa = _fetch_sub(UNIVERSAL => "isa");
0.000000,0,0.000000,}
0.000069,1,0.000069,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# We need an overload::StrVal or equivalent function, but we must avoid
0.000000,0,0.000000,# loading any modules on demand, as Carp is used from __DIE__ handlers and
0.000000,0,0.000000,# may be invoked after a syntax error.
0.000000,0,0.000000,# We can copy recent implementations of overload::StrVal and use
0.000000,0,0.000000,# overloading.pm, which is the fastest implementation, so long as
0.000000,0,0.000000,# overloading is available.  If it is not available, we use our own pure-
0.000000,0,0.000000,# Perl StrVal.  We never actually use overload::StrVal, for various rea-
0.000000,0,0.000000,# sons described below.
0.000000,0,0.000000,# overload versions are as follows:
0.000000,0,0.000000,#     undef-1.00 (up to perl 5.8.0)   uses bless (avoid!)
0.000000,0,0.000000,#     1.01-1.17  (perl 5.8.1 to 5.14) uses Scalar::Util
0.000000,0,0.000000,#     1.18+      (perl 5.16+)         uses overloading
0.000000,0,0.000000,# The ancient 'bless' implementation (that inspires our pure-Perl version)
0.000000,0,0.000000,# blesses unblessed references and must be avoided.  Those using
0.000000,0,0.000000,# Scalar::Util use refaddr, possibly the pure-Perl implementation, which
0.000000,0,0.000000,# has the same blessing bug, and must be avoided.  Also, Scalar::Util is
0.000000,0,0.000000,# loaded on demand.  Since we avoid the Scalar::Util implementations, we
0.000000,0,0.000000,# end up having to implement our own overloading.pm-based version for perl
0.000000,0,0.000000,# 5.10.1 to 5.14.  Since it also works just as well in more recent ver-
0.000000,0,0.000000,# sions, we use it there, too.
0.000000,0,0.000000,BEGIN {
0.000133,2,0.000066,if (eval { require "overloading.pm" }) {
0.000047,1,0.000047,*_StrVal = eval 'sub { no overloading; "$_[0]" }'
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# Work around the UNIVERSAL::can/isa modules to avoid recursion.
0.000000,0,0.000000,
0.000000,0,0.000000,# _mycan is either UNIVERSAL::can, or, in the presence of an
0.000000,0,0.000000,# override, overload::mycan.
0.000000,0,0.000000,*_mycan = _univ_mod_loaded('can')
0.000000,0,0.000000,? do { require "overload.pm"; _fetch_sub overload => 'mycan' }
0.000000,0,0.000000,: \&UNIVERSAL::can;
0.000000,0,0.000000,
0.000000,0,0.000000,# _blessed is either UNIVERAL::isa(...), or, in the presence of an
0.000000,0,0.000000,# override, a hideous, but fairly reliable, workaround.
0.000000,0,0.000000,*_blessed = $isa
0.000000,0,0.000000,? sub { &$isa($_[0], "UNIVERSAL") }
0.000000,0,0.000000,: sub {
0.000000,0,0.000000,my $probe = "UNIVERSAL::Carp_probe_" . rand;
0.000119,2,0.000060,no strict 'refs';
0.000000,0,0.000000,local *$probe = sub { "unlikely string" };
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,local $SIG{__DIE__} = sub{};
0.000000,0,0.000000,(eval { $_[0]->$probe } || '') eq 'unlikely string'
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,*_StrVal = sub {
0.000000,0,0.000000,my $pack = ref $_[0];
0.000000,0,0.000000,# Perl's overload mechanism uses the presence of a special
0.000000,0,0.000000,# "method" named "((" or "()" to signal it is in effect.
0.000000,0,0.000000,# This test seeks to see if it has been set up.  "((" post-
0.000000,0,0.000000,# dates overloading.pm, so we can skip it.
0.000000,0,0.000000,return "$_[0]" unless _mycan($pack, "()");
0.000000,0,0.000000,# Even at this point, the invocant may not be blessed, so
0.000000,0,0.000000,# check for that.
0.000000,0,0.000000,return "$_[0]" if not _blessed($_[0]);
0.000000,0,0.000000,bless $_[0], "Carp";
0.000000,0,0.000000,my $str = "$_[0]";
0.000000,0,0.000000,bless $_[0], $pack;
0.000000,0,0.000000,$pack . substr $str, index $str, "=";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000115,1,0.000115,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '1.52';
0.000001,1,0.000001,$VERSION =~ tr/_//d;
0.000000,0,0.000000,
0.000000,1,0.000000,our $MaxEvalLen = 0;
0.000000,1,0.000000,our $Verbose    = 0;
0.000000,1,0.000000,our $CarpLevel  = 0;
0.000000,1,0.000000,our $MaxArgLen  = 64;    # How much of each argument to print. 0 = all.
0.000000,1,0.000000,our $MaxArgNums = 8;     # How many arguments to print. 0 = all.
0.000000,1,0.000000,our $RefArgFormatter = undef; # allow caller to format reference arguments
0.000000,0,0.000000,
0.000001,1,0.000001,require Exporter;
0.000007,1,0.000007,our @ISA       = ('Exporter');
0.000000,1,0.000000,our @EXPORT    = qw(confess croak carp);
0.000000,1,0.000000,our @EXPORT_OK = qw(cluck verbose longmess shortmess);
0.000000,1,0.000000,our @EXPORT_FAIL = qw(verbose);    # hook to enable verbose mode
0.000000,0,0.000000,
0.000000,0,0.000000,# The members of %Internal are packages that are internal to perl.
0.000000,0,0.000000,# Carp will not report errors from within these packages if it
0.000000,0,0.000000,# can.  The members of %CarpInternal are internal to Perl's warning
0.000000,0,0.000000,# system.  Carp will not report errors from within these packages
0.000000,0,0.000000,# either, and will not report calls *to* these packages for carp and
0.000000,0,0.000000,# croak.  They replace $CarpLevel, which is deprecated.    The
0.000000,0,0.000000,# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval
0.000000,0,0.000000,# text and function arguments should be formatted when printed.
0.000000,0,0.000000,
0.000000,0,0.000000,our %CarpInternal;
0.000000,0,0.000000,our %Internal;
0.000000,0,0.000000,
0.000000,0,0.000000,# disable these by default, so they can live w/o require Carp
0.000000,1,0.000000,$CarpInternal{Carp}++;
0.000001,1,0.000001,$CarpInternal{warnings}++;
0.000000,1,0.000000,$Internal{Exporter}++;
0.000000,1,0.000000,$Internal{'Exporter::Heavy'}++;
0.000000,0,0.000000,
0.000000,0,0.000000,# if the caller specifies verbose usage ("perl -MCarp=verbose script.pl")
0.000000,0,0.000000,# then the following method will be called by the Exporter which knows
0.000000,0,0.000000,# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word
0.000000,0,0.000000,# 'verbose'.
0.000000,0,0.000000,
0.000000,0,0.000000,sub export_fail { shift; $Verbose = shift if $_[0] eq 'verbose'; @_ }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _cgc {
0.000318,2,0.000159,no strict 'refs';
0.000030,16,0.000002,return \&{"CORE::GLOBAL::caller"} if defined &{"CORE::GLOBAL::caller"};
0.000026,16,0.000002,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub longmess {
0.000000,0,0.000000,local($!, $^E);
0.000000,0,0.000000,# Icky backwards compatibility wrapper. :-(
0.000000,0,0.000000,#
0.000000,0,0.000000,# The story is that the original implementation hard-coded the
0.000000,0,0.000000,# number of call levels to go back, so calls to longmess were off
0.000000,0,0.000000,# by one.  Other code began calling longmess and expecting this
0.000000,0,0.000000,# behaviour, so the replacement has to emulate that behaviour.
0.000000,0,0.000000,my $cgc = _cgc();
0.000000,0,0.000000,my $call_pack = $cgc ? $cgc->() : caller();
0.000000,0,0.000000,if ( $Internal{$call_pack} or $CarpInternal{$call_pack} ) {
0.000000,0,0.000000,return longmess_heavy(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,local $CarpLevel = $CarpLevel + 1;
0.000000,0,0.000000,return longmess_heavy(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,our @CARP_NOT;
0.000000,0,0.000000,
0.000000,0,0.000000,sub shortmess {
0.000000,0,0.000000,local($!, $^E);
0.000000,0,0.000000,my $cgc = _cgc();
0.000000,0,0.000000,
0.000000,0,0.000000,# Icky backwards compatibility wrapper. :-(
0.000000,0,0.000000,local @CARP_NOT = scalar( $cgc ? $cgc->() : caller() );
0.000000,0,0.000000,shortmess_heavy(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub croak   { die shortmess @_ }
0.000000,0,0.000000,sub confess { die longmess @_ }
0.000000,0,0.000000,sub carp    { warn shortmess @_ }
0.000000,0,0.000000,sub cluck   { warn longmess @_ }
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000005,1,0.000005,if("$]" >= 5.015002 || ("$]" >= 5.014002 && "$]" < 5.015) ||
0.000000,0,0.000000,("$]" >= 5.012005 && "$]" < 5.013)) {
0.000000,0,0.000000,*CALLER_OVERRIDE_CHECK_OK = sub () { 1 };
0.000000,0,0.000000,} else {
0.000000,0,0.000000,*CALLER_OVERRIDE_CHECK_OK = sub () { 0 };
0.000000,0,0.000000,}
0.000939,1,0.000939,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub caller_info {
0.000000,0,0.000000,my $i = shift(@_) + 1;
0.000000,0,0.000000,my %call_info;
0.000000,0,0.000000,my $cgc = _cgc();
0.000000,0,0.000000,{
0.000000,0,0.000000,# Some things override caller() but forget to implement the
0.000000,0,0.000000,# @DB::args part of it, which we need.  We check for this by
0.000000,0,0.000000,# pre-populating @DB::args with a sentinel which no-one else
0.000000,0,0.000000,# has the address of, so that we can detect whether @DB::args
0.000000,0,0.000000,# has been properly populated.  However, on earlier versions
0.000000,0,0.000000,# of perl this check tickles a bug in CORE::caller() which
0.000000,0,0.000000,# leaks memory.  So we only check on fixed perls.
0.000000,0,0.000000,@DB::args = \$i if CALLER_OVERRIDE_CHECK_OK;
0.000000,0,0.000000,package DB;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( defined $call_info{file} ) {
0.000000,0,0.000000,return ();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $sub_name = Carp::get_subname( \%call_info );
0.000000,0,0.000000,if ( $call_info{has_args} ) {
0.000000,0,0.000000,# Guard our serialization of the stack from stack refcounting bugs
0.000000,0,0.000000,# NOTE this is NOT a complete solution, we cannot 100% guard against
0.000000,0,0.000000,# these bugs.  However in many cases Perl *is* capable of detecting
0.000000,0,0.000000,# them and throws an error when it does.  Unfortunately serializing
0.000000,0,0.000000,# the arguments on the stack is a perfect way of finding these bugs,
0.000000,0,0.000000,# even when they would not affect normal program flow that did not
0.000000,0,0.000000,# poke around inside the stack.  Inside of Carp.pm it makes little
0.000000,0,0.000000,# sense reporting these bugs, as Carp's job is to report the callers
0.000000,0,0.000000,# errors, not the ones it might happen to tickle while doing so.
0.000000,0,0.000000,# See: https://rt.perl.org/Public/Bug/Display.html?id=131046
0.000000,0,0.000000,# and: https://rt.perl.org/Public/Bug/Display.html?id=52610
0.000000,0,0.000000,# for more details and discussion. - Yves
0.000000,0,0.000000,my @args = map {
0.000000,0,0.000000,my $arg;
0.000000,0,0.000000,local $@= $@;
0.000000,0,0.000000,eval {
0.000000,0,0.000000,$arg = $_;
0.000000,0,0.000000,1;
0.000000,0,0.000000,} or do {
0.000000,0,0.000000,$arg = '** argument not available anymore **';
0.000000,0,0.000000,};
0.000000,0,0.000000,$arg;
0.000000,0,0.000000,} @DB::args;
0.000000,0,0.000000,if (CALLER_OVERRIDE_CHECK_OK && @args == 1
0.000000,0,0.000000,&& ref $args[0] eq ref \$i
0.000000,0,0.000000,&& $args[0] == \$i ) {
0.000000,0,0.000000,@args = ();    # Don't let anyone see the address of $i
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,my $where = eval {
0.000000,0,0.000000,my $func    = $cgc or return '';
0.000000,0,0.000000,my $gv      =
0.000000,0,0.000000,(_fetch_sub B => 'svref_2object' or return '')
0.000000,0,0.000000,->($func)->GV;
0.000000,0,0.000000,my $package = $gv->STASH->NAME;
0.000000,0,0.000000,my $subname = $gv->NAME;
0.000000,0,0.000000,return unless defined $package && defined $subname;
0.000000,0,0.000000,
0.000000,0,0.000000,# returning CORE::GLOBAL::caller isn't useful for tracing the cause:
0.000000,0,0.000000,return if $package eq 'CORE::GLOBAL' && $subname eq 'caller';
0.000000,0,0.000000," in &${package}::$subname";
0.000000,0,0.000000,} || '';
0.000000,0,0.000000,@args
0.000000,0,0.000000,= "** Incomplete caller override detected$where; \@DB::args were not set **";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $overflow;
0.000000,0,0.000000,if ( $MaxArgNums and @args > $MaxArgNums )
0.000000,0,0.000000,{    # More than we want to show?
0.000000,0,0.000000,$#args = $MaxArgNums - 1;
0.000000,0,0.000000,$overflow = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,@args = map { Carp::format_arg($_) } @args;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($overflow) {
0.000000,0,0.000000,push @args, '...';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Push the args onto the subroutine
0.000000,0,0.000000,$sub_name .= '(' . join( ', ', @args ) . ')';
0.000000,0,0.000000,}
0.000000,0,0.000000,$call_info{sub_name} = $sub_name;
0.000000,0,0.000000,return wantarray() ? %call_info : \%call_info;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Transform an argument to a function into a string.
0.000000,0,0.000000,our $in_recurse;
0.000000,0,0.000000,sub format_arg {
0.000000,0,0.000000,my $arg = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( my $pack= ref($arg) ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# legitimate, let's not leak it.
0.000000,0,0.000000,if (!$in_recurse && _maybe_isa( $arg, 'UNIVERSAL' ) &&
0.000000,0,0.000000,do {
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,local $in_recurse = 1;
0.000000,0,0.000000,local $SIG{__DIE__} = sub{};
0.000000,0,0.000000,eval {$arg->can('CARP_TRACE') }
0.000000,0,0.000000,})
0.000000,0,0.000000,{
0.000000,0,0.000000,return $arg->CARP_TRACE();
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (!$in_recurse &&
0.000000,0,0.000000,defined($RefArgFormatter) &&
0.000000,0,0.000000,do {
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,local $in_recurse = 1;
0.000000,0,0.000000,local $SIG{__DIE__} = sub{};
0.000000,0,0.000000,eval {$arg = $RefArgFormatter->($arg); 1}
0.000000,0,0.000000,})
0.000000,0,0.000000,{
0.000000,0,0.000000,return $arg;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{
0.000000,0,0.000000,# Argument may be blessed into a class with overloading, and so
0.000000,0,0.000000,# might have an overloaded stringification.  We don't want to
0.000000,0,0.000000,# risk getting the overloaded stringification, so we need to
0.000000,0,0.000000,# use _StrVal, our overload::StrVal()-equivalent.
0.000000,0,0.000000,return _StrVal $arg;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return "undef" if !defined($arg);
0.000000,0,0.000000,downgrade($arg, 1);
0.000000,0,0.000000,return $arg if !(UTF8_REGEXP_PROBLEM && is_utf8($arg)) &&
0.000000,0,0.000000,$arg =~ /\A-?[0-9]+(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?\z/;
0.000000,0,0.000000,my $suffix = "";
0.000000,0,0.000000,if ( 2 < $MaxArgLen and $MaxArgLen < length($arg) ) {
0.000000,0,0.000000,substr ( $arg, $MaxArgLen - 3 ) = "";
0.000000,0,0.000000,$suffix = "...";
0.000000,0,0.000000,}
0.000000,0,0.000000,if(UTF8_REGEXP_PROBLEM && is_utf8($arg)) {
0.000000,0,0.000000,for(my $i = length($arg); $i--; ) {
0.000000,0,0.000000,my $c = substr($arg, $i, 1);
0.000000,0,0.000000,my $x = substr($arg, 0, 0);   # work around bug on Perl 5.8.{1,2}
0.000000,0,0.000000,if($c eq "\"" || $c eq "\\" || $c eq "\$" || $c eq "\@") {
0.000000,0,0.000000,substr $arg, $i, 0, "\\";
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $o = ord($c);
0.000000,0,0.000000,substr $arg, $i, 1, sprintf("\\x{%x}", $o)
0.000000,0,0.000000,unless is_safe_printable_codepoint($o);
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$arg =~ s/([\"\\\$\@])/\\$1/g;
0.000000,0,0.000000,# This is all the ASCII printables spelled-out.  It is portable to all
0.000000,0,0.000000,# Perl versions and platforms (such as EBCDIC).  There are other more
0.000000,0,0.000000,# compact ways to do this, but may not work everywhere every version.
0.000000,0,0.000000,$arg =~ s/([^ !"#\$\%\&'()*+,\-.\/0123456789:;<=>?\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\\\]^_`abcdefghijklmnopqrstuvwxyz\{|}~])/sprintf("\\x{%x}",ord($1))/eg;
0.000000,0,0.000000,}
0.000000,0,0.000000,downgrade($arg, 1);
0.000000,0,0.000000,return "\"".$arg."\"".$suffix;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Regexp::CARP_TRACE {
0.000000,0,0.000000,my $arg = "$_[0]";
0.000000,0,0.000000,downgrade($arg, 1);
0.000000,0,0.000000,if(UTF8_REGEXP_PROBLEM && is_utf8($arg)) {
0.000000,0,0.000000,for(my $i = length($arg); $i--; ) {
0.000000,0,0.000000,my $o = ord(substr($arg, $i, 1));
0.000000,0,0.000000,my $x = substr($arg, 0, 0);   # work around bug on Perl 5.8.{1,2}
0.000000,0,0.000000,substr $arg, $i, 1, sprintf("\\x{%x}", $o)
0.000000,0,0.000000,unless is_safe_printable_codepoint($o);
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# See comment in format_arg() about this same regex.
0.000000,0,0.000000,$arg =~ s/([^ !"#\$\%\&'()*+,\-.\/0123456789:;<=>?\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\\\]^_`abcdefghijklmnopqrstuvwxyz\{|}~])/sprintf("\\x{%x}",ord($1))/eg;
0.000000,0,0.000000,}
0.000000,0,0.000000,downgrade($arg, 1);
0.000000,0,0.000000,my $suffix = "";
0.000000,0,0.000000,if($arg =~ /\A\(\?\^?([a-z]*)(?:-[a-z]*)?:(.*)\)\z/s) {
0.000000,0,0.000000,($suffix, $arg) = ($1, $2);
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( 2 < $MaxArgLen and $MaxArgLen < length($arg) ) {
0.000000,0,0.000000,substr ( $arg, $MaxArgLen - 3 ) = "";
0.000000,0,0.000000,$suffix = "...".$suffix;
0.000000,0,0.000000,}
0.000000,0,0.000000,return "qr($arg)$suffix";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Takes an inheritance cache and a package and returns
0.000000,0,0.000000,# an anon hash of known inheritances and anon array of
0.000000,0,0.000000,# inheritances which consequences have not been figured
0.000000,0,0.000000,# for.
0.000000,0,0.000000,sub get_status {
0.000019,123,0.000000,my $cache = shift;
0.000011,123,0.000000,my $pkg   = shift;
0.000223,123,0.000002,$cache->{$pkg} ||= [ { $pkg => $pkg }, [ trusts_directly($pkg) ] ];
0.000169,123,0.000001,return @{ $cache->{$pkg} };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Takes the info from caller() and figures out the name of
0.000000,0,0.000000,# the sub/require/eval
0.000000,0,0.000000,sub get_subname {
0.000000,0,0.000000,my $info = shift;
0.000000,0,0.000000,if ( defined( $info->{evaltext} ) ) {
0.000000,0,0.000000,my $eval = $info->{evaltext};
0.000000,0,0.000000,if ( $info->{is_require} ) {
0.000000,0,0.000000,return "require $eval";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$eval =~ s/([\\\'])/\\$1/g;
0.000000,0,0.000000,return "eval '" . str_len_trim( $eval, $MaxEvalLen ) . "'";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# this can happen on older perls when the sub (or the stash containing it)
0.000000,0,0.000000,# has been deleted
0.000000,0,0.000000,if ( !defined( $info->{sub} ) ) {
0.000000,0,0.000000,return '__ANON__::__ANON__';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ( $info->{sub} eq '(eval)' ) ? 'eval {...}' : $info->{sub};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Figures out what call (from the point of view of the caller)
0.000000,0,0.000000,# the long error backtrace should start at.
0.000000,0,0.000000,sub long_error_loc {
0.000000,0,0.000000,my $i;
0.000000,0,0.000000,my $lvl = $CarpLevel;
0.000000,0,0.000000,{
0.000000,0,0.000000,++$i;
0.000000,0,0.000000,my $cgc = _cgc();
0.000000,0,0.000000,my @caller = $cgc ? $cgc->($i) : caller($i);
0.000000,0,0.000000,my $pkg = $caller[0];
0.000000,0,0.000000,unless ( defined($pkg) ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# This *shouldn't* happen.
0.000000,0,0.000000,if (%Internal) {
0.000000,0,0.000000,local %Internal;
0.000000,0,0.000000,$i = long_error_loc();
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (defined $caller[2]) {
0.000000,0,0.000000,# this can happen when the stash has been deleted
0.000000,0,0.000000,# in that case, just assume that it's a reasonable place to
0.000000,0,0.000000,# stop (the file and line data will still be intact in any
0.000000,0,0.000000,# case) - the only issue is that we can't detect if the
0.000000,0,0.000000,# deleted package was internal (so don't do that then)
0.000000,0,0.000000,# -doy
0.000000,0,0.000000,redo unless 0 > --$lvl;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return 2;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,redo if $CarpInternal{$pkg};
0.000000,0,0.000000,redo unless 0 > --$lvl;
0.000000,0,0.000000,redo if $Internal{$pkg};
0.000000,0,0.000000,}
0.000000,0,0.000000,return $i - 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub longmess_heavy {
0.000000,0,0.000000,if ( ref( $_[0] ) ) {   # don't break references as exceptions
0.000000,0,0.000000,return wantarray ? @_ : $_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,my $i = long_error_loc();
0.000000,0,0.000000,return ret_backtrace( $i, @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000005,1,0.000005,if("$]" >= 5.017004) {
0.000000,0,0.000000,# The LAST_FH constant is a reference to the variable.
0.000015,1,0.000015,$Carp::{LAST_FH} = \eval '\${^LAST_FH}';
0.000000,0,0.000000,} else {
0.000000,0,0.000000,eval '*LAST_FH = sub () { 0 }';
0.000000,0,0.000000,}
0.000472,1,0.000472,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Returns a full stack backtrace starting from where it is
0.000000,0,0.000000,# told.
0.000000,0,0.000000,sub ret_backtrace {
0.000000,0,0.000000,my ( $i, @error ) = @_;
0.000000,0,0.000000,my $mess;
0.000000,0,0.000000,my $err = join '', @error;
0.000000,0,0.000000,$i++;
0.000000,0,0.000000,
0.000000,0,0.000000,my $tid_msg = '';
0.000000,0,0.000000,if ( defined &threads::tid ) {
0.000000,0,0.000000,my $tid = threads->tid;
0.000000,0,0.000000,$tid_msg = " thread $tid" if $tid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %i = caller_info($i);
0.000000,0,0.000000,$mess = "$err at $i{file} line $i{line}$tid_msg";
0.000000,0,0.000000,if( $. ) {
0.000000,0,0.000000,# Use ${^LAST_FH} if available.
0.000000,0,0.000000,if (LAST_FH) {
0.000000,0,0.000000,if (${+LAST_FH}) {
0.000000,0,0.000000,$mess .= sprintf ", <%s> %s %d",
0.000000,0,0.000000,*${+LAST_FH}{NAME},
0.000000,0,0.000000,($/ eq "\n" ? "line" : "chunk"), $.
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,local $@ = '';
0.000000,0,0.000000,local $SIG{__DIE__};
0.000000,0,0.000000,eval {
0.000000,0,0.000000,CORE::die;
0.000000,0,0.000000,};
0.000000,0,0.000000,if($@ =~ /^Died at .*(, <.*?> (?:line|chunk) \d+).$/ ) {
0.000000,0,0.000000,$mess .= $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$mess .= "\.\n";
0.000000,0,0.000000,
0.000000,0,0.000000,while ( my %i = caller_info( ++$i ) ) {
0.000000,0,0.000000,$mess .= "\t$i{sub_name} called at $i{file} line $i{line}$tid_msg\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $mess;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ret_summary {
0.000000,0,0.000000,my ( $i, @error ) = @_;
0.000000,0,0.000000,my $err = join '', @error;
0.000000,0,0.000000,$i++;
0.000000,0,0.000000,
0.000000,0,0.000000,my $tid_msg = '';
0.000000,0,0.000000,if ( defined &threads::tid ) {
0.000000,0,0.000000,my $tid = threads->tid;
0.000000,0,0.000000,$tid_msg = " thread $tid" if $tid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %i = caller_info($i);
0.000000,0,0.000000,return "$err at $i{file} line $i{line}$tid_msg\.\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub short_error_loc {
0.000000,0,0.000000,# You have to create your (hash)ref out here, rather than defaulting it
0.000000,0,0.000000,# inside trusts *on a lexical*, as you want it to persist across calls.
0.000000,0,0.000000,# (You can default it on $_[2], but that gets messy)
0.000003,10,0.000000,my $cache = {};
0.000005,10,0.000000,my $i     = 1;
0.000003,10,0.000000,my $lvl   = $CarpLevel;
0.000000,0,0.000000,{
0.000021,26,0.000001,my $cgc = _cgc();
0.000009,16,0.000001,my $called = $cgc ? $cgc->($i) : caller($i);
0.000002,16,0.000000,$i++;
0.000012,16,0.000001,my $caller = $cgc ? $cgc->($i) : caller($i);
0.000000,0,0.000000,
0.000003,16,0.000000,if (!defined($caller)) {
0.000000,0,0.000000,my @caller = $cgc ? $cgc->($i) : caller($i);
0.000000,0,0.000000,if (@caller) {
0.000000,0,0.000000,# if there's no package but there is other caller info, then
0.000000,0,0.000000,# the package has been deleted - treat this as a valid package
0.000000,0,0.000000,# in this case
0.000000,0,0.000000,redo if defined($called) && $CarpInternal{$called};
0.000000,0,0.000000,redo unless 0 > --$lvl;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000009,16,0.000001,redo if $Internal{$caller};
0.000004,16,0.000000,redo if $CarpInternal{$caller};
0.000008,16,0.000000,redo if $CarpInternal{$called};
0.000028,16,0.000002,redo if trusts( $called, $caller, $cache );
0.000012,11,0.000001,redo if trusts( $caller, $called, $cache );
0.000007,10,0.000001,redo unless 0 > --$lvl;
0.000000,0,0.000000,}
0.000134,10,0.000013,return $i - 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub shortmess_heavy {
0.000000,0,0.000000,return longmess_heavy(@_) if $Verbose;
0.000000,0,0.000000,return @_ if ref( $_[0] );    # don't break references as exceptions
0.000000,0,0.000000,my $i = short_error_loc();
0.000000,0,0.000000,if ($i) {
0.000000,0,0.000000,ret_summary( $i, @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,longmess_heavy(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# If a string is too long, trims it with ...
0.000000,0,0.000000,sub str_len_trim {
0.000000,0,0.000000,my $str = shift;
0.000000,0,0.000000,my $max = shift || 0;
0.000000,0,0.000000,if ( 2 < $max and $max < length($str) ) {
0.000000,0,0.000000,substr( $str, $max - 3 ) = '...';
0.000000,0,0.000000,}
0.000000,0,0.000000,return $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Takes two packages and an optional cache.  Says whether the
0.000000,0,0.000000,# first inherits from the second.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Recursive versions of this have to work to avoid certain
0.000000,0,0.000000,# possible endless loops, and when following long chains of
0.000000,0,0.000000,# inheritance are less efficient.
0.000000,0,0.000000,sub trusts {
0.000004,27,0.000000,my $child  = shift;
0.000006,27,0.000000,my $parent = shift;
0.000004,27,0.000000,my $cache  = shift;
0.000029,27,0.000001,my ( $known, $partial ) = get_status( $cache, $child );
0.000000,0,0.000000,
0.000000,0,0.000000,# Figure out consequences until we have an answer
0.000032,27,0.000001,while ( @$partial and not exists $known->{$parent} ) {
0.000039,156,0.000000,my $anc = shift @$partial;
0.000031,156,0.000000,next if exists $known->{$anc};
0.000074,96,0.000001,$known->{$anc}++;
0.000059,96,0.000001,my ( $anc_knows, $anc_partial ) = get_status( $cache, $anc );
0.000038,96,0.000000,my @found = keys %$anc_knows;
0.000027,96,0.000000,@$known{@found} = ();
0.000077,96,0.000001,push @$partial, @$anc_partial;
0.000000,0,0.000000,}
0.000046,27,0.000002,return exists $known->{$parent};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Takes a package and gives a list of those trusted directly
0.000000,0,0.000000,sub trusts_directly {
0.000016,115,0.000000,my $class = shift;
0.000084,2,0.000042,no strict 'refs';
0.000103,115,0.000001,my $stash = \%{"$class\::"};
0.000028,115,0.000000,for my $var (qw/ CARP_NOT ISA /) {
0.000000,0,0.000000,# Don't try using the variable until we know it exists,
0.000000,0,0.000000,# to avoid polluting the caller's namespace.
0.000308,180,0.000002,if ( $stash->{$var} && ref \$stash->{$var} eq 'GLOB'
0.000000,0,0.000000,&& *{$stash->{$var}}{ARRAY} && @{$stash->{$var}} ) {
0.000000,0,0.000000,return @{$stash->{$var}}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000081,60,0.000001,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,if(!defined($warnings::VERSION) ||
0.000022,3,0.000007,do { no warnings "numeric"; $warnings::VERSION < 1.03 }) {
0.000000,0,0.000000,# Very old versions of warnings.pm import from Carp.  This can go
0.000000,0,0.000000,# wrong due to the circular dependency.  If Carp is invoked before
0.000000,0,0.000000,# warnings, then Carp starts by loading warnings, then warnings
0.000000,0,0.000000,# tries to import from Carp, and gets nothing because Carp is in
0.000000,0,0.000000,# the process of loading and hasn't defined its import method yet.
0.000000,0,0.000000,# So we work around that by manually exporting to warnings here.
0.000107,2,0.000053,no strict "refs";
0.000000,0,0.000000,*{"warnings::$_"} = \&$_ foreach @EXPORT;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000009,1,0.000009,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
