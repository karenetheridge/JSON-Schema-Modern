# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Digest::base;
0.000000,0,0.000000,
0.000033,2,0.000017,use strict;
0.000343,2,0.000171,use warnings;
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = "1.20";
0.000000,0,0.000000,
0.000000,0,0.000000,# subclass is supposed to implement at least these
0.000000,0,0.000000,sub new;
0.000000,0,0.000000,sub clone;
0.000000,0,0.000000,sub add;
0.000000,0,0.000000,sub digest;
0.000000,0,0.000000,
0.000000,0,0.000000,sub reset {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->new(@_);    # ugly
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub addfile {
0.000000,0,0.000000,my ( $self, $handle ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $n;
0.000000,0,0.000000,my $buf = "";
0.000000,0,0.000000,
0.000000,0,0.000000,while ( ( $n = read( $handle, $buf, 4 * 1024 ) ) ) {
0.000000,0,0.000000,$self->add($buf);
0.000000,0,0.000000,}
0.000000,0,0.000000,unless ( defined $n ) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Read failed: $!");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_bits {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $bits;
0.000000,0,0.000000,my $nbits;
0.000000,0,0.000000,if ( @_ == 1 ) {
0.000000,0,0.000000,my $arg = shift;
0.000000,0,0.000000,$bits  = pack( "B*", $arg );
0.000000,0,0.000000,$nbits = length($arg);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,( $bits, $nbits ) = @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( ( $nbits % 8 ) != 0 ) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Number of bits must be multiple of 8 for this algorithm");
0.000000,0,0.000000,}
0.000000,0,0.000000,return $self->add( substr( $bits, 0, $nbits / 8 ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub hexdigest {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return unpack( "H*", $self->digest(@_) );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub b64digest {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $b64  = $self->base64_padded_digest;
0.000000,0,0.000000,$b64 =~ s/=+$//;
0.000000,0,0.000000,return $b64;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub base64_padded_digest {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,require MIME::Base64;
0.000000,0,0.000000,return MIME::Base64::encode( $self->digest(@_), "" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
