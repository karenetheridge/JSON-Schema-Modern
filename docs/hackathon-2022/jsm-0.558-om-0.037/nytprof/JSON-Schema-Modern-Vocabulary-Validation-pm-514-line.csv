# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000040,2,0.000020,use strict;
0.000064,2,0.000032,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Vocabulary::Validation;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Implementation of the JSON Schema Validation vocabulary
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.558';
0.000000,0,0.000000,
0.000041,2,0.000021,use 5.020;
0.000039,2,0.000019,use Moo;
0.000102,3,0.000034,use strictures 2;
0.000053,2,0.000027,use experimental qw(signatures postderef);
0.000037,2,0.000018,use if "$]" >= 5.022, experimental => 're_strict';
0.000035,2,0.000017,no if "$]" >= 5.031009, feature => 'indirect';
0.000025,2,0.000012,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000035,2,0.000017,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000027,2,0.000013,use List::Util 'any';
0.000045,3,0.000015,use Ref::Util 0.100 'is_plain_arrayref';
0.000066,2,0.000033,use if "$]" >= 5.022, POSIX => 'isinf';
0.000029,2,0.000015,use JSON::Schema::Modern::Utilities qw(is_type get_type is_equal is_elements_unique E assert_keyword_type assert_pattern jsonp sprintf_num);
0.002591,2,0.001295,use namespace::clean;
0.000000,0,0.000000,
0.000006,1,0.000006,with 'JSON::Schema::Modern::Vocabulary';
0.000000,0,0.000000,
0.000000,0,0.000000,sub vocabulary {
0.000003,1,0.000003,'https://json-schema.org/draft/2019-09/vocab/validation' => 'draft2019-09',
0.000000,0,0.000000,'https://json-schema.org/draft/2020-12/vocab/validation' => 'draft2020-12';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,5,0.000001,sub evaluation_order { 2 }
0.000000,0,0.000000,
0.000004,6,0.000001,sub keywords ($self, $spec_version) {
0.000000,0,0.000000,return (
0.000012,2,0.000006,qw(type enum const
0.000000,0,0.000000,multipleOf maximum exclusiveMaximum minimum exclusiveMinimum
0.000000,0,0.000000,maxLength minLength pattern
0.000000,0,0.000000,maxItems minItems uniqueItems),
0.000000,0,0.000000,$spec_version ne 'draft7' ? qw(maxContains minContains) : (),
0.000000,0,0.000000,qw(maxProperties minProperties required),
0.000000,0,0.000000,$spec_version ne 'draft7' ? 'dependentRequired' : (),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000866,5528,0.000000,sub _traverse_keyword_type ($self, $schema, $state) {
0.002836,1382,0.000002,if (is_plain_arrayref($schema->{type})) {
0.000036,76,0.000000,return E($state, 'type array is empty') if not $schema->{type}->@*;
0.000121,76,0.000002,foreach my $type ($schema->{type}->@*) {
0.000000,0,0.000000,return E($state, 'unrecognized type "%s"', $type//'<null>')
0.000802,692,0.000001,if not any { ($type//'') eq $_ } qw(null boolean object array string number integer);
0.000000,0,0.000000,}
0.000119,76,0.000002,return E($state, '"type" values are not unique') if not is_elements_unique($schema->{type});
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.001512,1306,0.000001,return if not assert_keyword_type($state, $schema, 'string');
0.000000,0,0.000000,return E($state, 'unrecognized type "%s"', $schema->{type}//'<null>')
0.008949,6440,0.000001,if not any { ($schema->{type}//'') eq $_ } qw(null boolean object array string number integer);
0.000000,0,0.000000,}
0.002524,1382,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.039120,178240,0.000000,sub _eval_keyword_type ($self, $data, $schema, $state) {
0.057516,35648,0.000002,my $type = get_type($data);
0.024116,35648,0.000001,if (is_plain_arrayref($schema->{type})) {
0.000000,0,0.000000,return 1 if any {
0.000000,0,0.000000,$type eq $_ or ($_ eq 'number' and $type eq 'integer')
0.186051,26766,0.000007,or ($_ eq 'boolean' and $state->{scalarref_booleans} and $type eq 'reference to SCALAR')
0.104506,23274,0.000004,} $schema->{type}->@*;
0.000000,0,0.000000,return E($state, 'got %s, not one of %s', $type, join(', ', $schema->{type}->@*));
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return 1 if $type eq $schema->{type} or ($schema->{type} eq 'number' and $type eq 'integer')
0.031496,12374,0.000003,or ($schema->{type} eq 'boolean' and $state->{scalarref_booleans} and $type eq 'reference to SCALAR');
0.005659,1115,0.000005,return E($state, 'got %s, not %s', $type, $schema->{type});
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000058,240,0.000000,sub _traverse_keyword_enum ($self, $schema, $state) {
0.000079,60,0.000001,return if not assert_keyword_type($state, $schema, 'array');
0.000099,60,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002490,7690,0.000000,sub _eval_keyword_enum ($self, $data, $schema, $state) {
0.001029,3076,0.000000,my @s; my $idx = 0;
0.002919,1538,0.000002,my %s = ( scalarref_booleans => $state->{scalarref_booleans} );
0.035310,9032,0.000004,return 1 if any { is_equal($data, $_, $s[$idx++] = {%s}) } $schema->{enum}->@*;
0.000000,0,0.000000,return E($state, 'value does not match'
0.000000,0,0.000000,.(!(grep $_->{path}, @s) ? ''
0.000673,66,0.000010,: ' (differences start '.join(', ', map 'from item #'.$_.' at "'.$s[$_]->{path}.'"', 0..$#s).')'));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000213,95,0.000002,sub _traverse_keyword_const { 1 }
0.000000,0,0.000000,
0.001903,6040,0.000000,sub _eval_keyword_const ($self, $data, $schema, $state) {
0.001937,1208,0.000002,my %s = ( scalarref_booleans => $state->{scalarref_booleans} );
0.005225,1208,0.000004,return 1 if is_equal($data, $schema->{const}, my $s = { scalarref_booleans => $state->{scalarref_booleans} });
0.000000,0,0.000000,return E($state, 'value does not match'
0.004757,799,0.000006,.($s->{path} ? ' (differences start at "'.$s->{path}.'")' : ''));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_multipleOf ($self, $schema, $state) {
0.000000,0,0.000000,return if not assert_keyword_type($state, $schema, 'number');
0.000000,0,0.000000,return E($state, 'multipleOf value is not a positive number') if $schema->{multipleOf} <= 0;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_multipleOf ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not is_type('number', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,# if either value is a float, use the bignum library for the calculation for an accurate remainder
0.000000,0,0.000000,if (ref($data) =~ /^Math::Big(?:Int|Float)$/ or ref($schema->{multipleOf}) =~ /^Math::Big(?:Int|Float)$/) {
0.000000,0,0.000000,$data = ref($data) =~ /^Math::Big(?:Int|Float)$/ ? $data->copy : Math::BigFloat->new($data);
0.000000,0,0.000000,my $divisor = ref($schema->{multipleOf}) =~ /^Math::Big(?:Int|Float)$/ ? $schema->{multipleOf} : Math::BigFloat->new($schema->{multipleOf});
0.000000,0,0.000000,my ($quotient, $remainder) = $data->bdiv($divisor);
0.000000,0,0.000000,return E($state, 'overflow while calculating quotient') if $quotient->is_inf;
0.000000,0,0.000000,return 1 if $remainder == 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $quotient = $data / $schema->{multipleOf};
0.000000,0,0.000000,return E($state, 'overflow while calculating quotient')
0.000000,0,0.000000,if "$]" >= 5.022 ? isinf($quotient) : $quotient =~ /^-?Inf$/i;
0.000000,0,0.000000,return 1 if int($quotient) == $quotient;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return E($state, 'value is not a multiple of %s', sprintf_num($schema->{multipleOf}));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000068,8,0.000008,sub _traverse_keyword_maximum { shift->_assert_number(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_maximum ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not is_type('number', $data);
0.000000,0,0.000000,return 1 if $data <= $schema->{maximum};
0.000000,0,0.000000,return E($state, 'value is larger than %s', sprintf_num($schema->{maximum}));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_keyword_exclusiveMaximum { shift->_assert_number(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_exclusiveMaximum ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not is_type('number', $data);
0.000000,0,0.000000,return 1 if $data < $schema->{exclusiveMaximum};
0.000000,0,0.000000,return E($state, 'value is equal to or larger than %s', sprintf_num($schema->{exclusiveMaximum}));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000096,21,0.000005,sub _traverse_keyword_minimum { shift->_assert_number(@_) }
0.000000,0,0.000000,
0.000084,395,0.000000,sub _eval_keyword_minimum ($self, $data, $schema, $state) {
0.000184,79,0.000002,return 1 if not is_type('number', $data);
0.000254,79,0.000003,return 1 if $data >= $schema->{minimum};
0.000000,0,0.000000,return E($state, 'value is smaller than %s', sprintf_num($schema->{minimum}));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,sub _traverse_keyword_exclusiveMinimum { shift->_assert_number(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_exclusiveMinimum ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not is_type('number', $data);
0.000000,0,0.000000,return 1 if $data > $schema->{exclusiveMinimum};
0.000000,0,0.000000,return E($state, 'value is equal to or smaller than %s', sprintf_num($schema->{exclusiveMinimum}));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000033,8,0.000004,sub _traverse_keyword_maxLength { shift->_assert_non_negative_integer(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_maxLength ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not is_type('string', $data);
0.000000,0,0.000000,return 1 if length($data) <= $schema->{maxLength};
0.000000,0,0.000000,return E($state, 'length is greater than %d', $schema->{maxLength});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000053,8,0.000007,sub _traverse_keyword_minLength { shift->_assert_non_negative_integer(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_minLength ($self, $data, $schema, $state) {
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if not is_type('string', $data);
0.000000,0,0.000000,return 1 if length($data) >= $schema->{minLength};
0.000000,0,0.000000,return E($state, 'length is less than %d', $schema->{minLength});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000042,276,0.000000,sub _traverse_keyword_pattern ($self, $schema, $state) {
0.000000,0,0.000000,return if not assert_keyword_type($state, $schema, 'string')
0.000250,69,0.000004,or not assert_pattern($state, $schema->{pattern});
0.000107,69,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000353,1310,0.000000,sub _eval_keyword_pattern ($self, $data, $schema, $state) {
0.000424,262,0.000002,return 1 if not is_type('string', $data);
0.000000,0,0.000000,
0.002907,262,0.000011,return 1 if $data =~ m/$schema->{pattern}/;
0.000000,0,0.000000,return E($state, 'pattern does not match');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,sub _traverse_keyword_maxItems { shift->_assert_non_negative_integer(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_maxItems ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not is_type('array', $data);
0.000000,0,0.000000,return 1 if @$data <= $schema->{maxItems};
0.000000,0,0.000000,return E($state, 'more than %d item%s', $schema->{maxItems}, $schema->{maxItems} > 1 ? 's' : '');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000053,14,0.000004,sub _traverse_keyword_minItems { shift->_assert_non_negative_integer(@_) }
0.000000,0,0.000000,
0.002083,6220,0.000000,sub _eval_keyword_minItems ($self, $data, $schema, $state) {
0.004715,1244,0.000004,return 1 if not is_type('array', $data);
0.000301,129,0.000002,return 1 if @$data >= $schema->{minItems};
0.000000,0,0.000000,return E($state, 'fewer than %d item%s', $schema->{minItems}, $schema->{minItems} > 1 ? 's' : '');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,12,0.000000,sub _traverse_keyword_uniqueItems ($self, $schema, $state) {
0.000003,3,0.000001,return if not assert_keyword_type($state, $schema, 'boolean');
0.000007,3,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001905,7015,0.000000,sub _eval_keyword_uniqueItems ($self, $data, $schema, $state) {
0.004029,1403,0.000003,return 1 if not is_type('array', $data);
0.001243,288,0.000004,return 1 if not $schema->{uniqueItems};
0.001433,288,0.000005,return 1 if is_elements_unique($data, my $equal_indices = []);
0.000000,0,0.000000,return E($state, 'items at indices %d and %d are not unique', @$equal_indices);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Note: no effort is made to check if the 'contains' keyword has been disabled via its vocabulary.
0.000013,2,0.000006,sub _traverse_keyword_maxContains { shift->_assert_non_negative_integer(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_maxContains ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not exists $state->{_num_contains};
0.000000,0,0.000000,return 1 if not is_type('array', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,return E($state, 'contains too many matching items')
0.000000,0,0.000000,if $state->{_num_contains} > $schema->{maxContains};
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,sub _traverse_keyword_minContains { shift->_assert_non_negative_integer(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_minContains ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not exists $state->{_num_contains};
0.000000,0,0.000000,return 1 if not is_type('array', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,return E($state, 'contains too few matching items')
0.000000,0,0.000000,if $state->{_num_contains} < $schema->{minContains};
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000012,3,0.000004,sub _traverse_keyword_maxProperties { shift->_assert_non_negative_integer(@_) }
0.000000,0,0.000000,
0.000018,75,0.000000,sub _eval_keyword_maxProperties ($self, $data, $schema, $state) {
0.000023,15,0.000002,return 1 if not is_type('object', $data);
0.000071,15,0.000005,return 1 if keys %$data <= $schema->{maxProperties};
0.000000,0,0.000000,return E($state, 'more than %d propert%s', $schema->{maxProperties},
0.000000,0,0.000000,$schema->{maxProperties} > 1 ? 'ies' : 'y');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000296,50,0.000006,sub _traverse_keyword_minProperties { shift->_assert_non_negative_integer(@_) }
0.000000,0,0.000000,
0.000670,2425,0.000000,sub _eval_keyword_minProperties ($self, $data, $schema, $state) {
0.000687,485,0.000001,return 1 if not is_type('object', $data);
0.001663,485,0.000003,return 1 if keys %$data >= $schema->{minProperties};
0.000000,0,0.000000,return E($state, 'fewer than %d propert%s', $schema->{minProperties},
0.000000,0,0.000000,$schema->{minProperties} > 1 ? 'ies' : 'y');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000199,1100,0.000000,sub _traverse_keyword_required ($self, $schema, $state) {
0.000358,275,0.000001,return if not assert_keyword_type($state, $schema, 'array');
0.000000,0,0.000000,return E($state, '"required" element is not a string')
0.002405,1049,0.000002,if any { !is_type('string', $_) } $schema->{required}->@*;
0.000470,275,0.000002,return E($state, '"required" values are not unique') if not is_elements_unique($schema->{required});
0.000551,275,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.006251,23975,0.000000,sub _eval_keyword_required ($self, $data, $schema, $state) {
0.009682,4795,0.000002,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.017770,4795,0.000004,my @missing = grep !exists $data->{$_}, $schema->{required}->@*;
0.007802,4795,0.000002,return 1 if not @missing;
0.009026,1438,0.000006,return E($state, 'missing propert%s: %s', @missing > 1 ? 'ies' : 'y', join(', ', @missing));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,4,0.000000,sub _traverse_keyword_dependentRequired ($self, $schema, $state) {
0.000000,1,0.000000,return if not assert_keyword_type($state, $schema, 'object');
0.000000,0,0.000000,
0.000013,1,0.000013,my $valid = 1;
0.000014,1,0.000014,foreach my $property (sort keys $schema->{dependentRequired}->%*) {
0.000000,0,0.000000,$valid = E({ %$state, _schema_path_suffix => $property }, 'value is not an array'), next
0.000001,1,0.000001,if not is_type('array', $schema->{dependentRequired}{$property});
0.000000,0,0.000000,
0.000002,1,0.000002,foreach my $index (0..$schema->{dependentRequired}{$property}->$#*) {
0.000000,0,0.000000,$valid = E({ %$state, _schema_path_suffix => [ $property, $index ] }, 'element #%d is not a string', $index)
0.000000,1,0.000000,if not is_type('string', $schema->{dependentRequired}{$property}[$index]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$valid = E({ %$state, _schema_path_suffix => $property }, 'elements are not unique')
0.000001,1,0.000001,if not is_elements_unique($schema->{dependentRequired}{$property});
0.000000,0,0.000000,}
0.000004,1,0.000004,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_keyword_dependentRequired ($self, $data, $schema, $state) {
0.000000,0,0.000000,return 1 if not is_type('object', $data);
0.000000,0,0.000000,
0.000000,0,0.000000,my $valid = 1;
0.000000,0,0.000000,foreach my $property (sort keys $schema->{dependentRequired}->%*) {
0.000000,0,0.000000,next if not exists $data->{$property};
0.000000,0,0.000000,
0.000000,0,0.000000,if (my @missing = grep !exists($data->{$_}), $schema->{dependentRequired}{$property}->@*) {
0.000000,0,0.000000,$valid = E({ %$state, _schema_path_suffix => $property },
0.000000,0,0.000000,'missing propert%s: %s', @missing > 1 ? 'ies' : 'y', join(', ', @missing));
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if $valid;
0.000000,0,0.000000,return E($state, 'not all dependencies are satisfied');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000031,120,0.000000,sub _assert_number ($self, $schema, $state) {
0.000017,30,0.000001,return if not assert_keyword_type($state, $schema, 'number');
0.000078,30,0.000003,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000050,348,0.000000,sub _assert_non_negative_integer ($self, $schema, $state) {
0.000114,87,0.000001,return if not assert_keyword_type($state, $schema, 'integer');
0.000000,0,0.000000,return E($state, '%s value is not a non-negative integer', $state->{keyword})
0.000085,87,0.000001,if $schema->{$state->{keyword}} < 0;
0.000209,87,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,1;
0.000000,0,0.000000,
0.000041,1,0.000041,__END__
