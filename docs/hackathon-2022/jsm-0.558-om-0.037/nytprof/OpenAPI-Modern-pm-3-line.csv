# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000022,2,0.000011,use strict;
0.000031,2,0.000016,use warnings;
0.000000,0,0.000000,package OpenAPI::Modern; # git description: v0.036-2-g96d001a
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Validate HTTP requests and responses against an OpenAPI document
0.000000,0,0.000000,# KEYWORDS: validation evaluation JSON Schema OpenAPI Swagger HTTP request response
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.037';
0.000000,0,0.000000,
0.000040,2,0.000020,use 5.020;
0.000474,2,0.000237,use Moo;
0.000615,3,0.000205,use strictures 2;
0.000628,2,0.000314,use experimental qw(signatures postderef);
0.000304,2,0.000152,use if "$]" >= 5.022, experimental => 're_strict';
0.000048,2,0.000024,no if "$]" >= 5.031009, feature => 'indirect';
0.000029,2,0.000015,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000031,2,0.000016,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000024,2,0.000012,use Carp 'croak';
0.000547,2,0.000274,use Safe::Isa;
0.000646,2,0.000323,use Ref::Util qw(is_plain_hashref is_plain_arrayref is_ref);
0.000024,2,0.000012,use List::Util 'first';
0.000018,2,0.000009,use Scalar::Util 'looks_like_number';
0.000579,2,0.000290,use Feature::Compat::Try;
0.000373,3,0.000124,use Encode 2.89;
0.000190,2,0.000095,use URI::Escape ();
0.000538,3,0.000179,use JSON::Schema::Modern 0.557;
0.000042,3,0.000014,use JSON::Schema::Modern::Utilities 0.531 qw(jsonp unjsonp canonical_uri E abort is_equal is_elements_unique);
0.000289,2,0.000145,use JSON::Schema::Modern::Document::OpenAPI;
0.000020,2,0.000010,use MooX::HandlesVia;
0.000032,3,0.000011,use MooX::TypeTiny 0.002002;
0.000047,2,0.000023,use Types::Standard 'InstanceOf';
0.000025,2,0.000012,use constant { true => JSON::PP::true, false => JSON::PP::false };
0.004151,2,0.002076,use namespace::clean;
0.000000,0,0.000000,
0.000008,1,0.000008,has openapi_document => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => InstanceOf['JSON::Schema::Modern::Document::OpenAPI'],
0.000000,0,0.000000,required => 1,
0.000000,0,0.000000,handles => {
0.000000,0,0.000000,openapi_uri => 'canonical_uri', # Mojo::URL
0.000000,0,0.000000,openapi_schema => 'schema',     # hashref
0.000000,0,0.000000,document_get => 'get',          # data access using a json pointer
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# held separately because $document->evaluator is a weak ref
0.000005,1,0.000005,has evaluator => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => InstanceOf['JSON::Schema::Modern'],
0.000000,0,0.000000,required => 1,
0.000000,0,0.000000,handles => [ qw(get_media_type add_media_type) ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000007,4,0.000002,around BUILDARGS => sub ($orig, $class, @args) {
0.000003,1,0.000003,my $args = $class->$orig(@args);
0.000000,0,0.000000,
0.000002,1,0.000002,if (exists $args->{openapi_document}) {
0.000000,0,0.000000,$args->{evaluator} = $args->{openapi_document}->evaluator;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# construct document out of openapi_uri, openapi_schema, evaluator, if provided.
0.000000,0,0.000000,croak 'missing required constructor arguments: either openapi_document, or openapi_uri'
0.000001,1,0.000001,if not exists $args->{openapi_uri};
0.000000,0,0.000000,croak 'missing required constructor arguments: either openapi_document, or openapi_schema'
0.000000,1,0.000000,if not exists $args->{openapi_schema};
0.000000,0,0.000000,
0.000013,1,0.000013,$args->{evaluator} //= JSON::Schema::Modern->new(validate_formats => 1, max_traversal_depth => 80);
0.000000,0,0.000000,$args->{openapi_document} = JSON::Schema::Modern::Document::OpenAPI->new(
0.000000,0,0.000000,canonical_uri => $args->{openapi_uri},
0.000000,0,0.000000,schema => $args->{openapi_schema},
0.000000,0,0.000000,evaluator => $args->{evaluator},
0.000008,1,0.000008,);
0.000000,0,0.000000,
0.000000,0,0.000000,# if there were errors, this will die with a JSON::Schema::Modern::Result object
0.000005,1,0.000005,$args->{evaluator}->add_schema($args->{openapi_document});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000043,1,0.000043,return $args;
0.000005,1,0.000005,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub validate_request ($self, $request, $options = {}) {
0.000000,0,0.000000,my $state = {
0.000000,0,0.000000,data_path => '/request',
0.000000,0,0.000000,initial_schema_uri => $self->openapi_uri,   # the canonical URI as of the start or last $id, or the last traversed $ref
0.000000,0,0.000000,traversed_schema_path => '',    # the accumulated traversal path as of the start, or last $id, or up to the last traversed $ref
0.000000,0,0.000000,schema_path => '',              # the rest of the path, since the last $id or the last traversed $ref
0.000000,0,0.000000,effective_base_uri => Mojo::URL->new->host(scalar _header($request, 'Host'))->scheme('https'),
0.000000,0,0.000000,annotations => [],
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,try {
0.000000,0,0.000000,my $path_ok = $self->find_path($request, $options);
0.000000,0,0.000000,$state->{errors} = delete $options->{errors};
0.000000,0,0.000000,return $self->_result($state, 1) if not $path_ok;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($path_template, $path_captures) = $options->@{qw(path_template path_captures)};
0.000000,0,0.000000,my $path_item = $self->openapi_document->schema->{paths}{$path_template};
0.000000,0,0.000000,my $method = lc $request->method;
0.000000,0,0.000000,my $operation = $path_item->{$method};
0.000000,0,0.000000,
0.000000,0,0.000000,$state->{schema_path} = jsonp('/paths', $path_template);
0.000000,0,0.000000,
0.000000,0,0.000000,# PARAMETERS
0.000000,0,0.000000,# { $in => { $name => 'path-item'|$method } }  as we process each one.
0.000000,0,0.000000,my $request_parameters_processed;
0.000000,0,0.000000,
0.000000,0,0.000000,# first, consider parameters at the operation level.
0.000000,0,0.000000,# parameters at the path-item level are also considered, if not already seen at the operation level
0.000000,0,0.000000,foreach my $section ($method, 'path-item') {
0.000000,0,0.000000,foreach my $idx (0 .. (($section eq $method ? $operation : $path_item)->{parameters}//[])->$#*) {
0.000000,0,0.000000,my $state = { %$state, schema_path => jsonp($state->{schema_path},
0.000000,0,0.000000,($section eq $method ? $method : ()), 'parameters', $idx) };
0.000000,0,0.000000,my $param_obj = ($section eq $method ? $operation : $path_item)->{parameters}[$idx];
0.000000,0,0.000000,while (my $ref = $param_obj->{'$ref'}) {
0.000000,0,0.000000,$param_obj = $self->_resolve_ref($ref, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $fc_name = $param_obj->{in} eq 'header' ? fc($param_obj->{name}) : $param_obj->{name};
0.000000,0,0.000000,
0.000000,0,0.000000,abort($state, 'duplicate %s parameter "%s"', $param_obj->{in}, $param_obj->{name})
0.000000,0,0.000000,if ($request_parameters_processed->{$param_obj->{in}}{$fc_name} // '') eq $section;
0.000000,0,0.000000,next if exists $request_parameters_processed->{$param_obj->{in}}{$fc_name};
0.000000,0,0.000000,$request_parameters_processed->{$param_obj->{in}}{$fc_name} = $section;
0.000000,0,0.000000,
0.000000,0,0.000000,$state->{data_path} = jsonp($state->{data_path},
0.000000,0,0.000000,((grep $param_obj->{in} eq $_, qw(path query)) ? 'uri' : ()), $param_obj->{in},
0.000000,0,0.000000,$param_obj->{name});
0.000000,0,0.000000,my $valid =
0.000000,0,0.000000,$param_obj->{in} eq 'path' ? $self->_validate_path_parameter($state, $param_obj, $path_captures)
0.000000,0,0.000000,: $param_obj->{in} eq 'query' ? $self->_validate_query_parameter($state, $param_obj, _request_uri($request))
0.000000,0,0.000000,: $param_obj->{in} eq 'header' ? $self->_validate_header_parameter($state, $param_obj->{name}, $param_obj, [ _header($request, $param_obj->{name}) ])
0.000000,0,0.000000,: $param_obj->{in} eq 'cookie' ? $self->_validate_cookie_parameter($state, $param_obj, $request)
0.000000,0,0.000000,: abort($state, 'unrecognized "in" value "%s"', $param_obj->{in});
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# 3.2 "Each template expression in the path MUST correspond to a path parameter that is included in
0.000000,0,0.000000,# the Path Item itself and/or in each of the Path Item’s Operations."
0.000000,0,0.000000,foreach my $path_name (sort keys $path_captures->%*) {
0.000000,0,0.000000,abort({ %$state, data_path => jsonp($state->{data_path}, qw(uri path), $path_name) },
0.000000,0,0.000000,'missing path parameter specification for "%s"', $path_name)
0.000000,0,0.000000,if not exists $request_parameters_processed->{path}{$path_name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$state->{data_path} = jsonp($state->{data_path}, 'body');
0.000000,0,0.000000,$state->{schema_path} = jsonp($state->{schema_path}, $method);
0.000000,0,0.000000,
0.000000,0,0.000000,if (my $body_obj = $operation->{requestBody}) {
0.000000,0,0.000000,$state->{schema_path} = jsonp($state->{schema_path}, 'requestBody');
0.000000,0,0.000000,
0.000000,0,0.000000,while (my $ref = $body_obj->{'$ref'}) {
0.000000,0,0.000000,$body_obj = $self->_resolve_ref($ref, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (_body_size($request)) {
0.000000,0,0.000000,$self->_validate_body_content($state, $body_obj->{content}, $request);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($body_obj->{required}) {
0.000000,0,0.000000,()= E({ %$state, keyword => 'required' }, 'request body is required but missing');
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,()= E($state, 'unspecified body is present in %s request', uc $method)
0.000000,0,0.000000,if ($method eq 'get' or $method eq 'head') and _body_size($request);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,if ($e->$_isa('JSON::Schema::Modern::Result')) {
0.000000,0,0.000000,return $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($e->$_isa('JSON::Schema::Modern::Error')) {
0.000000,0,0.000000,push @{$state->{errors}}, $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,()= E($state, 'EXCEPTION: '.$e);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->_result($state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub validate_response ($self, $response, $options = {}) {
0.000000,0,0.000000,my $state = {
0.000000,0,0.000000,data_path => '/response',
0.000000,0,0.000000,initial_schema_uri => $self->openapi_uri,   # the canonical URI as of the start or last $id, or the last traversed $ref
0.000000,0,0.000000,traversed_schema_path => '',    # the accumulated traversal path as of the start, or last $id, or up to the last traversed $ref
0.000000,0,0.000000,schema_path => '',              # the rest of the path, since the last $id or the last traversed $ref
0.000000,0,0.000000,annotations => [],
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,try {
0.000000,0,0.000000,my $path_ok = $self->find_path($response->$_call_if_can('request') // $options->{request}, $options);
0.000000,0,0.000000,$state->{errors} = delete $options->{errors};
0.000000,0,0.000000,return $self->_result($state, 1) if not $path_ok;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($path_template, $path_captures) = $options->@{qw(path_template path_captures)};
0.000000,0,0.000000,my $method = lc $options->{method};
0.000000,0,0.000000,my $operation = $self->openapi_document->schema->{paths}{$path_template}{$method};
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->_result($state) if not exists $operation->{responses};
0.000000,0,0.000000,
0.000000,0,0.000000,$state->{effective_base_uri} = Mojo::URL->new->host(scalar _header($options->{request}, 'Host'))->scheme('https')
0.000000,0,0.000000,if $options->{request};
0.000000,0,0.000000,$state->{schema_path} = jsonp('/paths', $path_template, $method);
0.000000,0,0.000000,
0.000000,0,0.000000,my $response_name = first { exists $operation->{responses}{$_} }
0.000000,0,0.000000,$response->code, substr(sprintf('%03s', $response->code), 0, -2).'XX', 'default';
0.000000,0,0.000000,
0.000000,0,0.000000,if (not $response_name) {
0.000000,0,0.000000,()= E({ %$state, keyword => 'responses' }, 'no response object found for code %s', $response->code);
0.000000,0,0.000000,return $self->_result($state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $response_obj = $operation->{responses}{$response_name};
0.000000,0,0.000000,$state->{schema_path} = jsonp($state->{schema_path}, 'responses', $response_name);
0.000000,0,0.000000,while (my $ref = $response_obj->{'$ref'}) {
0.000000,0,0.000000,$response_obj = $self->_resolve_ref($ref, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $header_name (sort keys(($response_obj->{headers}//{})->%*)) {
0.000000,0,0.000000,next if fc $header_name eq fc 'Content-Type';
0.000000,0,0.000000,my $state = { %$state, schema_path => jsonp($state->{schema_path}, 'headers', $header_name) };
0.000000,0,0.000000,my $header_obj = $response_obj->{headers}{$header_name};
0.000000,0,0.000000,while (my $ref = $header_obj->{'$ref'}) {
0.000000,0,0.000000,$header_obj = $self->_resolve_ref($ref, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,()= $self->_validate_header_parameter({ %$state,
0.000000,0,0.000000,data_path => jsonp($state->{data_path}, 'header', $header_name) },
0.000000,0,0.000000,$header_name, $header_obj, [ _header($response, $header_name) ]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_validate_body_content({ %$state, data_path => jsonp($state->{data_path}, 'body') },
0.000000,0,0.000000,$response_obj->{content}, $response)
0.000000,0,0.000000,if exists $response_obj->{content} and _body_size($response);
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,if ($e->$_isa('JSON::Schema::Modern::Result')) {
0.000000,0,0.000000,return $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($e->$_isa('JSON::Schema::Modern::Error')) {
0.000000,0,0.000000,push @{$state->{errors}}, $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,()= E($state, 'EXCEPTION: '.$e);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->_result($state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_path ($self, $request, $options) {
0.000000,0,0.000000,my $state = {
0.000000,0,0.000000,data_path => '/request/uri/path',
0.000000,0,0.000000,initial_schema_uri => $self->openapi_uri,   # the canonical URI as of the start or last $id, or the last traversed $ref
0.000000,0,0.000000,traversed_schema_path => '',    # the accumulated traversal path as of the start, or last $id, or up to the last traversed $ref
0.000000,0,0.000000,schema_path => '',              # the rest of the path, since the last $id or the last traversed $ref
0.000000,0,0.000000,errors => $options->{errors} //= [],
0.000000,0,0.000000,$request ? ( effective_base_uri => Mojo::URL->new->host(scalar _header($request, 'Host'))->scheme('https') ) : (),
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,my ($method, $path_template);
0.000000,0,0.000000,
0.000000,0,0.000000,# method from options
0.000000,0,0.000000,if (exists $options->{method}) {
0.000000,0,0.000000,$method = lc $options->{method};
0.000000,0,0.000000,return E({ %$state, data_path => '/request/method' }, 'wrong HTTP method %s', $request->method)
0.000000,0,0.000000,if $request and lc $request->method ne $method;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($request) {
0.000000,0,0.000000,$method = $options->{method} = lc $request->method;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# path_template and method from operation_id from options
0.000000,0,0.000000,if (exists $options->{operation_id}) {
0.000000,0,0.000000,my $operation_path = $self->openapi_document->get_operationId_path($options->{operation_id});
0.000000,0,0.000000,return E({ %$state, keyword => 'paths' }, 'unknown operation_id "%s"', $options->{operation_id})
0.000000,0,0.000000,if not $operation_path;
0.000000,0,0.000000,return E({ %$state, schema_path => $operation_path, keyword => 'operationId' },
0.000000,0,0.000000,'operation id does not have an associated path') if $operation_path !~ m{^/paths/};
0.000000,0,0.000000,(undef, undef, $path_template, $method) = unjsonp($operation_path);
0.000000,0,0.000000,
0.000000,0,0.000000,return E({ %$state, schema_path => jsonp('/paths', $path_template) },
0.000000,0,0.000000,'operation does not match provided path_template')
0.000000,0,0.000000,if exists $options->{path_template} and $options->{path_template} ne $path_template;
0.000000,0,0.000000,
0.000000,0,0.000000,return E({ %$state, data_path => '/request/method', schema_path => $operation_path },
0.000000,0,0.000000,'wrong HTTP method %s', $options->{method})
0.000000,0,0.000000,if $options->{method} and lc $options->{method} ne $method;
0.000000,0,0.000000,
0.000000,0,0.000000,$options->{operation_path} = $operation_path;
0.000000,0,0.000000,$options->{method} = lc $method;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,croak 'at least one of request, $options->{method} and $options->{operation_id} must be provided'
0.000000,0,0.000000,if not $method;
0.000000,0,0.000000,
0.000000,0,0.000000,# path_template from options
0.000000,0,0.000000,if (exists $options->{path_template}) {
0.000000,0,0.000000,$path_template = $options->{path_template};
0.000000,0,0.000000,
0.000000,0,0.000000,my $path_item = $self->openapi_document->schema->{paths}{$path_template};
0.000000,0,0.000000,return E({ %$state, keyword => 'paths' }, 'missing path-item "%s"', $path_template) if not $path_item;
0.000000,0,0.000000,
0.000000,0,0.000000,return E({ %$state, data_path => '/request/method', schema_path => jsonp('/paths', $path_template), keyword => $method },
0.000000,0,0.000000,'missing operation for HTTP method "%s"', $method)
0.000000,0,0.000000,if not $path_item->{$method};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# path_template from request URI
0.000000,0,0.000000,if (not $path_template and $request and my $uri_path = _request_uri($request)->path) {
0.000000,0,0.000000,my $schema = $self->openapi_document->schema;
0.000000,0,0.000000,croak 'servers not yet supported when matching request URIs'
0.000000,0,0.000000,if exists $schema->{servers} and $schema->{servers}->@*;
0.000000,0,0.000000,
0.000000,0,0.000000,# sorting (ascii-wise) gives us the desired results that concrete path components sort ahead of
0.000000,0,0.000000,# templated components, except when the concrete component is a non-ascii character or matches [|}~].
0.000000,0,0.000000,foreach $path_template (sort keys $schema->{paths}->%*) {
0.000000,0,0.000000,my $path_pattern = $path_template =~ s!\{[^/}]+\}!([^/?#]*)!gr;
0.000000,0,0.000000,next if $uri_path !~ m/^$path_pattern$/;
0.000000,0,0.000000,
0.000000,0,0.000000,$options->{path_template} = $path_template;
0.000000,0,0.000000,
0.000000,0,0.000000,# perldoc perlvar, @-: $n coincides with "substr $_, $-[n], $+[n] - $-[n]" if "$-[n]" is defined
0.000000,0,0.000000,my @capture_values = map
0.000000,0,0.000000,Encode::decode('UTF-8', URI::Escape::uri_unescape(substr($uri_path, $-[$_], $+[$_]-$-[$_]))), 1 .. $#-;
0.000000,0,0.000000,my @capture_names = ($path_template =~ m!\{([^/?#}]+)\}!g);
0.000000,0,0.000000,my %path_captures; @path_captures{@capture_names} = @capture_values;
0.000000,0,0.000000,
0.000000,0,0.000000,my $indexes = [];
0.000000,0,0.000000,return E({ %$state, keyword => 'paths' }, 'duplicate path capture name %s', $capture_names[$indexes->[0]])
0.000000,0,0.000000,if not is_elements_unique(\@capture_names, $indexes);
0.000000,0,0.000000,
0.000000,0,0.000000,return E({ %$state, keyword => 'paths' }, 'provided path_captures values do not match request URI')
0.000000,0,0.000000,if $options->{path_captures} and not is_equal($options->{path_captures}, \%path_captures);
0.000000,0,0.000000,
0.000000,0,0.000000,$options->{path_captures} = \%path_captures;
0.000000,0,0.000000,return E({ %$state, data_path => '/request/method', schema_path => jsonp('/paths', $path_template), keyword => $method },
0.000000,0,0.000000,'missing operation for HTTP method "%s"', $method)
0.000000,0,0.000000,if not exists $schema->{paths}{$path_template}{$method};
0.000000,0,0.000000,
0.000000,0,0.000000,$options->{operation_id} = $self->openapi_document->schema->{paths}{$path_template}{$method}{operationId};
0.000000,0,0.000000,delete $options->{operation_id} if not defined $options->{operation_id};
0.000000,0,0.000000,$options->{operation_path} = jsonp('/paths', $path_template, $method);
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return E({ %$state, keyword => 'paths' }, 'no match found for URI path "%s"', $uri_path);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,croak 'at least one of request, $options->{path_template} and $options->{operation_id} must be provided'
0.000000,0,0.000000,if not $path_template;
0.000000,0,0.000000,
0.000000,0,0.000000,$options->{operation_path} = jsonp('/paths', $path_template, $method);
0.000000,0,0.000000,
0.000000,0,0.000000,# note: we aren't doing anything special with escaped slashes. this bit of the spec is hazy.
0.000000,0,0.000000,my @capture_names = ($path_template =~ m!\{([^/}]+)\}!g);
0.000000,0,0.000000,return E({ %$state, keyword => 'paths', _schema_path_suffix => $path_template },
0.000000,0,0.000000,'provided path_captures names do not match path template "%s"', $path_template)
0.000000,0,0.000000,if exists $options->{path_captures}
0.000000,0,0.000000,and not is_equal([ sort keys $options->{path_captures}->%* ], [ sort @capture_names ]);
0.000000,0,0.000000,
0.000000,0,0.000000,if (not $request) {
0.000000,0,0.000000,$options->@{qw(path_template operation_id)} =
0.000000,0,0.000000,($path_template, $self->openapi_document->schema->{paths}{$path_template}{$method}{operationId});
0.000000,0,0.000000,delete $options->{operation_id} if not defined $options->{operation_id};
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# if we're still here, we were passed path_template in options or we calculated it from
0.000000,0,0.000000,# operation_id, and now we verify it against path_captures and the request URI.
0.000000,0,0.000000,my $uri_path = _request_uri($request)->path;
0.000000,0,0.000000,
0.000000,0,0.000000,# 3.2: "The value for these path parameters MUST NOT contain any unescaped “generic syntax”
0.000000,0,0.000000,# characters described by [RFC3986]: forward slashes (/), question marks (?), or hashes (#)."
0.000000,0,0.000000,my $path_pattern = $path_template =~ s!\{[^/}]+\}!([^/?#]*)!gr;
0.000000,0,0.000000,return E({ %$state, keyword => 'paths', _schema_path_suffix => $path_template },
0.000000,0,0.000000,'provided %s does not match request URI', exists $options->{path_template} ? 'path_template' : 'operation_id')
0.000000,0,0.000000,if $uri_path !~ m/^$path_pattern$/;
0.000000,0,0.000000,
0.000000,0,0.000000,# perldoc perlvar, @-: $n coincides with "substr $_, $-[n], $+[n] - $-[n]" if "$-[n]" is defined
0.000000,0,0.000000,my @capture_values = map
0.000000,0,0.000000,Encode::decode('UTF-8', URI::Escape::uri_unescape(substr($uri_path, $-[$_], $+[$_]-$-[$_]))), 1 .. $#-;
0.000000,0,0.000000,return E({ %$state, keyword => 'paths', _schema_path_suffix => $path_template },
0.000000,0,0.000000,'provided path_captures values do not match request URI')
0.000000,0,0.000000,if exists $options->{path_captures}
0.000000,0,0.000000,and not is_equal([ map $_.'', $options->{path_captures}->@{@capture_names} ], \@capture_values);
0.000000,0,0.000000,
0.000000,0,0.000000,my %path_captures; @path_captures{@capture_names} = @capture_values;
0.000000,0,0.000000,$options->@{qw(path_template path_captures operation_id)} =
0.000000,0,0.000000,($path_template, \%path_captures, $self->openapi_document->schema->{paths}{$path_template}{$method}{operationId});
0.000000,0,0.000000,delete $options->{operation_id} if not defined $options->{operation_id};
0.000000,0,0.000000,$options->{operation_path} = jsonp('/paths', $path_template, $method);
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,######## NO PUBLIC INTERFACES FOLLOW THIS POINT ########
0.000000,0,0.000000,
0.000000,0,0.000000,sub _validate_path_parameter ($self, $state, $param_obj, $path_captures) {
0.000000,0,0.000000,# 'required' is always true for path parameters
0.000000,0,0.000000,return E({ %$state, keyword => 'required' }, 'missing path parameter: %s', $param_obj->{name})
0.000000,0,0.000000,if not exists $path_captures->{$param_obj->{name}};
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_validate_parameter_content($state, $param_obj, \ $path_captures->{$param_obj->{name}});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _validate_query_parameter ($self, $state, $param_obj, $uri) {
0.000000,0,0.000000,# parse the query parameters out of uri
0.000000,0,0.000000,my $query_params = { _query_pairs($uri) };
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: support different styles.
0.000000,0,0.000000,# for now, we only support style=form and do not allow for multiple values per
0.000000,0,0.000000,# property (i.e. 'explode' is not checked at all.)
0.000000,0,0.000000,# (other possible style values: spaceDelimited, pipeDelimited, deepObject)
0.000000,0,0.000000,
0.000000,0,0.000000,if (not exists $query_params->{$param_obj->{name}}) {
0.000000,0,0.000000,return E({ %$state, keyword => 'required' }, 'missing query parameter: %s', $param_obj->{name})
0.000000,0,0.000000,if $param_obj->{required};
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: check 'allowReserved': if true, do not use percent-decoding
0.000000,0,0.000000,return E({ %$state, keyword => 'allowReserved' }, 'allowReserved: true is not yet supported')
0.000000,0,0.000000,if $param_obj->{allowReserved} // 0;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_validate_parameter_content($state, $param_obj, \ $query_params->{$param_obj->{name}});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# validates a header, from either the request or the response
0.000000,0,0.000000,sub _validate_header_parameter ($self, $state, $header_name, $header_obj, $headers) {
0.000000,0,0.000000,return 1 if grep fc $header_name eq fc $_, qw(Accept Content-Type Authorization);
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE: for now, we will only support a single header value.
0.000000,0,0.000000,@$headers = map s/^\s*//r =~ s/\s*$//r, @$headers;
0.000000,0,0.000000,
0.000000,0,0.000000,if (not @$headers) {
0.000000,0,0.000000,return E({ %$state, keyword => 'required' }, 'missing header: %s', $header_name)
0.000000,0,0.000000,if $header_obj->{required};
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_validate_parameter_content($state, $header_obj, \ $headers->[0]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _validate_cookie_parameter ($self, $state, $param_obj, $request) {
0.000000,0,0.000000,return E($state, 'cookie parameters not yet supported');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _validate_parameter_content ($self, $state, $param_obj, $content_ref) {
0.000000,0,0.000000,if (exists $param_obj->{content}) {
0.000000,0,0.000000,abort({ %$state, keyword => 'content' }, 'more than one media type entry present')
0.000000,0,0.000000,if keys $param_obj->{content}->%* > 1;  # TODO: remove, when the spec schema is updated
0.000000,0,0.000000,my ($media_type) = keys $param_obj->{content}->%*;  # there can only be one key
0.000000,0,0.000000,my $schema = $param_obj->{content}{$media_type}{schema};
0.000000,0,0.000000,
0.000000,0,0.000000,my $media_type_decoder = $self->get_media_type($media_type);  # case-insensitive, wildcard lookup
0.000000,0,0.000000,if (not $media_type_decoder) {
0.000000,0,0.000000,# don't fail if the schema would pass on any input
0.000000,0,0.000000,return if is_plain_hashref($schema) ? !keys %$schema : $schema;
0.000000,0,0.000000,
0.000000,0,0.000000,abort({ %$state, keyword => 'content', _schema_path_suffix => $media_type},
0.000000,0,0.000000,'EXCEPTION: unsupported media type "%s": add support with $openapi->add_media_type(...)', $media_type)
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,try {
0.000000,0,0.000000,$content_ref = $media_type_decoder->($content_ref);
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,return E({ %$state, keyword => 'content', _schema_path_suffix => $media_type },
0.000000,0,0.000000,'could not decode content as %s: %s', $media_type, $e =~ s/^(.*)\n/$1/r);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$state = { %$state, schema_path => jsonp($state->{schema_path}, 'content', $media_type, 'schema') };
0.000000,0,0.000000,return $self->_evaluate_subschema($content_ref->$*, $schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$state = { %$state, schema_path => jsonp($state->{schema_path}, 'schema') };
0.000000,0,0.000000,$self->_evaluate_subschema($content_ref->$*, $param_obj->{schema}, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _validate_body_content ($self, $state, $content_obj, $message) {
0.000000,0,0.000000,my $content_type = _content_type($message); # does not include charset
0.000000,0,0.000000,
0.000000,0,0.000000,return E({ %$state, data_path => $state->{data_path} =~ s{body}{header/Content-Type}r, keyword => 'content' },
0.000000,0,0.000000,'missing header: Content-Type')
0.000000,0,0.000000,if not length $content_type;
0.000000,0,0.000000,
0.000000,0,0.000000,my $media_type = (first { $content_type eq fc } keys $content_obj->%*)
0.000000,0,0.000000,// (first { m{([^/]+)/\*$} && fc($content_type) =~ m{^\F\Q$1\E/[^/]+$} } keys $content_obj->%*);
0.000000,0,0.000000,$media_type = '*/*' if not defined $media_type and exists $content_obj->{'*/*'};
0.000000,0,0.000000,return E({ %$state, keyword => 'content' }, 'incorrect Content-Type "%s"', $content_type)
0.000000,0,0.000000,if not defined $media_type;
0.000000,0,0.000000,
0.000000,0,0.000000,if (exists $content_obj->{$media_type}{encoding}) {
0.000000,0,0.000000,my $state = { %$state, schema_path => jsonp($state->{schema_path}, 'content', $media_type) };
0.000000,0,0.000000,# 4.8.14.1 "The key, being the property name, MUST exist in the schema as a property."
0.000000,0,0.000000,foreach my $property (sort keys $content_obj->{$media_type}{encoding}->%*) {
0.000000,0,0.000000,()= E({ $state, schema_path => jsonp($state->{schema_path}, 'schema', 'properties', $property) },
0.000000,0,0.000000,'encoding property "%s" requires a matching property definition in the schema')
0.000000,0,0.000000,if not exists(($content_obj->{$media_type}{schema}{properties}//{})->{$property});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# 4.8.14.1 "The encoding object SHALL only apply to requestBody objects when the media type is
0.000000,0,0.000000,# multipart or application/x-www-form-urlencoded."
0.000000,0,0.000000,return E({ %$state, keyword => 'encoding' }, 'encoding not yet supported')
0.000000,0,0.000000,if $content_type =~ m{^multipart/} or $content_type eq 'application/x-www-form-urlencoded';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: handle Content-Encoding header; https://github.com/OAI/OpenAPI-Specification/issues/2868
0.000000,0,0.000000,my $content_ref = _content_ref($message);
0.000000,0,0.000000,
0.000000,0,0.000000,# decode the charset, for text content
0.000000,0,0.000000,if ($content_type =~ m{^text/} and my $charset = _content_charset($message)) {
0.000000,0,0.000000,try {
0.000000,0,0.000000,$content_ref = \ Encode::decode($charset, $content_ref->$*, Encode::FB_CROAK | Encode::LEAVE_SRC);
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,return E({ %$state, keyword => 'content', _schema_path_suffix => $media_type },
0.000000,0,0.000000,'could not decode content as %s: %s', $charset, $e =~ s/^(.*)\n/$1/r);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $schema = $content_obj->{$media_type}{schema};
0.000000,0,0.000000,
0.000000,0,0.000000,# use the original Content-Type, NOT the possibly wildcard media type from the openapi document
0.000000,0,0.000000,# lookup is case-insensitive and falls back to wildcard definitions
0.000000,0,0.000000,my $media_type_decoder = $self->get_media_type($content_type);
0.000000,0,0.000000,$media_type_decoder = sub ($content_ref) { $content_ref } if $media_type eq '*/*';
0.000000,0,0.000000,if (not $media_type_decoder) {
0.000000,0,0.000000,# don't fail if the schema would pass on any input
0.000000,0,0.000000,return if not defined $schema or is_plain_hashref($schema) ? !keys %$schema : $schema;
0.000000,0,0.000000,
0.000000,0,0.000000,abort({ %$state, keyword => 'content', _schema_path_suffix => $media_type },
0.000000,0,0.000000,'EXCEPTION: unsupported Content-Type "%s": add support with $openapi->add_media_type(...)', $content_type)
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,try {
0.000000,0,0.000000,$content_ref = $media_type_decoder->($content_ref);
0.000000,0,0.000000,}
0.000000,0,0.000000,catch ($e) {
0.000000,0,0.000000,return E({ %$state, keyword => 'content', _schema_path_suffix => $media_type },
0.000000,0,0.000000,'could not decode content as %s: %s', $media_type, $e =~ s/^(.*)\n/$1/r);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return if not defined $schema;
0.000000,0,0.000000,
0.000000,0,0.000000,$state = { %$state, schema_path => jsonp($state->{schema_path}, 'content', $media_type, 'schema') };
0.000000,0,0.000000,$self->_evaluate_subschema($content_ref->$*, $schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# wrap a result object around the errors
0.000000,0,0.000000,sub _result ($self, $state, $exception = 0) {
0.000000,0,0.000000,return JSON::Schema::Modern::Result->new(
0.000000,0,0.000000,output_format => $self->evaluator->output_format,
0.000000,0,0.000000,formatted_annotations => 0,
0.000000,0,0.000000,valid => !$state->{errors}->@*,
0.000000,0,0.000000,$exception ? ( exception => 1 ) : (),
0.000000,0,0.000000,!$state->{errors}->@*
0.000000,0,0.000000,? (annotations => $state->{annotations}//[])
0.000000,0,0.000000,: (errors => $state->{errors}),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _resolve_ref ($self, $ref, $state) {
0.000000,0,0.000000,my $uri = Mojo::URL->new($ref)->to_abs($state->{initial_schema_uri});
0.000000,0,0.000000,my $schema_info = $self->evaluator->_fetch_from_uri($uri);
0.000000,0,0.000000,abort({ %$state, keyword => '$ref' }, 'EXCEPTION: unable to find resource %s', $uri)
0.000000,0,0.000000,if not $schema_info;
0.000000,0,0.000000,
0.000000,0,0.000000,abort($state, 'EXCEPTION: maximum evaluation depth exceeded')
0.000000,0,0.000000,if $state->{depth}++ > $self->evaluator->max_traversal_depth;
0.000000,0,0.000000,
0.000000,0,0.000000,$state->{initial_schema_uri} = $schema_info->{canonical_uri};
0.000000,0,0.000000,$state->{traversed_schema_path} = $state->{traversed_schema_path}.$state->{schema_path}.jsonp('/$ref');
0.000000,0,0.000000,$state->{schema_path} = '';
0.000000,0,0.000000,
0.000000,0,0.000000,return $schema_info->{schema};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# evaluates data against the subschema at the current state location
0.000000,0,0.000000,sub _evaluate_subschema ($self, $data, $schema, $state) {
0.000000,0,0.000000,# boolean schema
0.000000,0,0.000000,if (not is_plain_hashref($schema)) {
0.000000,0,0.000000,return 1 if $schema;
0.000000,0,0.000000,
0.000000,0,0.000000,my @location = unjsonp($state->{data_path});
0.000000,0,0.000000,my $location =
0.000000,0,0.000000,$location[-1] eq 'body' ? join(' ', @location[-2..-1])
0.000000,0,0.000000,: $location[-2] eq 'query' ? 'query parameter'
0.000000,0,0.000000,: $location[-2] eq 'path' ? 'path parameter'  # this should never happen
0.000000,0,0.000000,: $location[-2] eq 'header' ? join(' ', @location[-3..-2])
0.000000,0,0.000000,: $location[-2];  # cookie
0.000000,0,0.000000,return E($state, '%s not permitted', $location);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if !keys(%$schema);  # schema is {}
0.000000,0,0.000000,
0.000000,0,0.000000,# treat numeric-looking data as a string, unless "type" explicitly requests number or integer.
0.000000,0,0.000000,if (is_plain_hashref($schema) and exists $schema->{type} and not is_plain_arrayref($schema->{type})
0.000000,0,0.000000,and grep $schema->{type} eq $_, qw(number integer) and looks_like_number($data)) {
0.000000,0,0.000000,$data = $data+0;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (defined $data and not is_ref($data)) {
0.000000,0,0.000000,$data = $data.'';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: also handle multi-valued elements like headers and query parameters, when type=array requested
0.000000,0,0.000000,# (and possibly coerce their numeric-looking elements as well)
0.000000,0,0.000000,
0.000000,0,0.000000,my $result = $self->evaluator->evaluate(
0.000000,0,0.000000,$data, canonical_uri($state),
0.000000,0,0.000000,{
0.000000,0,0.000000,data_path => $state->{data_path},
0.000000,0,0.000000,traversed_schema_path => $state->{traversed_schema_path}.$state->{schema_path},
0.000000,0,0.000000,effective_base_uri => $state->{effective_base_uri},
0.000000,0,0.000000,collect_annotations => 1,
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,push $state->{errors}->@*, $result->errors;
0.000000,0,0.000000,push $state->{annotations}->@*, $result->annotations;
0.000000,0,0.000000,
0.000000,0,0.000000,return $result;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# returned object supports ->path
0.000000,0,0.000000,sub _request_uri ($request) {
0.000000,0,0.000000,$request->isa('HTTP::Request') ? $request->uri
0.000000,0,0.000000,: $request->isa('Mojo::Message::Request') ? $request->url
0.000000,0,0.000000,: croak 'unknown type '.ref($request);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# returns a list of key-value pairs (beware of treating as a hash!)
0.000000,0,0.000000,sub _query_pairs ($uri) {
0.000000,0,0.000000,$uri->isa('URI') ? $uri->query_form
0.000000,0,0.000000,: $uri->isa('Mojo::URL') ? $uri->query->pairs->@*
0.000000,0,0.000000,: croak 'unknown type '.ref($uri);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# note: this assumes that the header values were already normalized on creation,
0.000000,0,0.000000,# as sanitizing on read is bypassed
0.000000,0,0.000000,# beware: the lwp version is list/scalar-context-sensitive
0.000000,0,0.000000,sub _header ($message, $header_name) {
0.000000,0,0.000000,$message->isa('HTTP::Message') ? $message->headers->header($header_name)
0.000000,0,0.000000,: $message->isa('Mojo::Message') ? $message->content->headers->header($header_name) // ()
0.000000,0,0.000000,: croak 'unknown type '.ref($message);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# normalized, with extensions stripped
0.000000,0,0.000000,sub _content_type ($message) {
0.000000,0,0.000000,$message->isa('HTTP::Message') ? fc $message->headers->content_type
0.000000,0,0.000000,: $message->isa('Mojo::Message') ? fc((split(/;/, $message->headers->content_type//'', 2))[0] // '')
0.000000,0,0.000000,: croak 'unknown type '.ref($message);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _content_charset ($message) {
0.000000,0,0.000000,$message->isa('HTTP::Message') ? $message->headers->content_type_charset
0.000000,0,0.000000,: $message->isa('Mojo::Message') ? $message->content->charset
0.000000,0,0.000000,: croak 'unknown type '.ref($message);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _body_size ($message) {
0.000000,0,0.000000,$message->isa('HTTP::Message') ? $message->headers->content_length // length $message->content_ref->$*
0.000000,0,0.000000,: $message->isa('Mojo::Message') ? $message->headers->content_length // $message->body_size
0.000000,0,0.000000,: croak 'unknown type '.ref($message);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _content_ref ($message) {
0.000000,0,0.000000,$message->isa('HTTP::Message') ? $message->content_ref
0.000000,0,0.000000,: $message->isa('Mojo::Message') ? \$message->body
0.000000,0,0.000000,: croak 'unknown type '.ref($message);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# wrappers that aren't needed (yet), because they are the same across all supported classes:
0.000000,0,0.000000,# $request->method
0.000000,0,0.000000,# $response->code
0.000000,0,0.000000,# $uri->path
0.000000,0,0.000000,
0.000046,1,0.000046,1;
0.000000,0,0.000000,
0.000044,1,0.000044,__END__
