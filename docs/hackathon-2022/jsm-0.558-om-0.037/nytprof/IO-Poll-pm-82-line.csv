# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,# IO::Poll.pm
0.000000,0,0.000000,#
0.000000,0,0.000000,# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
0.000000,0,0.000000,# This program is free software; you can redistribute it and/or
0.000000,0,0.000000,# modify it under the same terms as Perl itself.
0.000000,0,0.000000,
0.000000,0,0.000000,package IO::Poll;
0.000000,0,0.000000,
0.000033,2,0.000017,use strict;
0.000023,2,0.000012,use IO::Handle;
0.000436,2,0.000218,use Exporter ();
0.000000,0,0.000000,
0.000008,1,0.000008,our @ISA = qw(Exporter);
0.000000,1,0.000000,our $VERSION = "1.49";
0.000000,0,0.000000,
0.000000,1,0.000000,our @EXPORT = qw( POLLIN
0.000000,0,0.000000,POLLOUT
0.000000,0,0.000000,POLLERR
0.000000,0,0.000000,POLLHUP
0.000000,0,0.000000,POLLNVAL
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000001,1,0.000001,our @EXPORT_OK = qw(
0.000000,0,0.000000,POLLPRI
0.000000,0,0.000000,POLLRDNORM
0.000000,0,0.000000,POLLWRNORM
0.000000,0,0.000000,POLLRDBAND
0.000000,0,0.000000,POLLWRBAND
0.000000,0,0.000000,POLLNORM
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# [0] maps fd's to requested masks
0.000000,0,0.000000,# [1] maps fd's to returned  masks
0.000000,0,0.000000,# [2] maps fd's to handles
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $self = bless [{},{},{}], $class;
0.000000,0,0.000000,
0.000000,0,0.000000,$self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mask {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $io = shift;
0.000000,0,0.000000,my $fd = fileno($io);
0.000000,0,0.000000,return unless defined $fd;
0.000000,0,0.000000,if (@_) {
0.000000,0,0.000000,my $mask = shift;
0.000000,0,0.000000,if($mask) {
0.000000,0,0.000000,$self->[0]{$fd}{$io} = $mask; # the error events are always returned
0.000000,0,0.000000,$self->[1]{$fd}      = 0;     # output mask
0.000000,0,0.000000,$self->[2]{$io}      = $io;   # remember handle
0.000000,0,0.000000,} else {
0.000000,0,0.000000,delete $self->[0]{$fd}{$io};
0.000000,0,0.000000,unless(%{$self->[0]{$fd}}) {
0.000000,0,0.000000,# We no longer have any handles for this FD
0.000000,0,0.000000,delete $self->[1]{$fd};
0.000000,0,0.000000,delete $self->[0]{$fd};
0.000000,0,0.000000,}
0.000000,0,0.000000,delete $self->[2]{$io};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return unless exists $self->[0]{$fd} and exists $self->[0]{$fd}{$io};
0.000000,0,0.000000,return $self->[0]{$fd}{$io};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub poll {
0.000000,0,0.000000,my($self,$timeout) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->[1] = {};
0.000000,0,0.000000,
0.000000,0,0.000000,my($fd,$mask,$iom);
0.000000,0,0.000000,my @poll = ();
0.000000,0,0.000000,
0.000000,0,0.000000,while(($fd,$iom) = each %{$self->[0]}) {
0.000000,0,0.000000,$mask   = 0;
0.000000,0,0.000000,$mask  |= $_ for values(%$iom);
0.000000,0,0.000000,push(@poll,$fd => $mask);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $ret = _poll(defined($timeout) ? $timeout * 1000 : -1,@poll);
0.000000,0,0.000000,
0.000000,0,0.000000,return $ret
0.000000,0,0.000000,unless $ret > 0;
0.000000,0,0.000000,
0.000000,0,0.000000,while(@poll) {
0.000000,0,0.000000,my($fd,$got) = splice(@poll,0,2);
0.000000,0,0.000000,$self->[1]{$fd} = $got if $got;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $ret;  
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub events {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $io = shift;
0.000000,0,0.000000,my $fd = fileno($io);
0.000000,0,0.000000,exists $self->[1]{$fd} and exists $self->[0]{$fd}{$io} 
0.000000,0,0.000000,? $self->[1]{$fd} & ($self->[0]{$fd}{$io}|POLLHUP|POLLERR|POLLNVAL)
0.000000,0,0.000000,: 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $io = shift;
0.000000,0,0.000000,$self->mask($io,0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub handles {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return values %{$self->[2]} unless @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $events = shift || 0;
0.000000,0,0.000000,my($fd,$ev,$io,$mask);
0.000000,0,0.000000,my @handles = ();
0.000000,0,0.000000,
0.000000,0,0.000000,while(($fd,$ev) = each %{$self->[1]}) {
0.000000,0,0.000000,while (($io,$mask) = each %{$self->[0]{$fd}}) {
0.000000,0,0.000000,$mask |= POLLHUP|POLLERR|POLLNVAL;  # must allow these
0.000000,0,0.000000,push @handles,$self->[2]{$io} if ($ev & $mask) & $events;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return @handles;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
