# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000040,2,0.000020,use strict;
0.000050,2,0.000025,use warnings;
0.000000,0,0.000000,package YAML::PP::Lexer;
0.000000,0,0.000000,
0.000001,1,0.000001,our $VERSION = '0.035'; # VERSION
0.000000,0,0.000000,
0.000033,2,0.000017,use constant TRACE => $ENV{YAML_PP_TRACE} ? 1 : 0;
0.000020,2,0.000010,use constant DEBUG => ($ENV{YAML_PP_DEBUG} || $ENV{YAML_PP_TRACE}) ? 1 : 0;
0.000000,0,0.000000,
0.000541,2,0.000270,use YAML::PP::Grammar qw/ $GRAMMAR /;
0.017079,2,0.008540,use Carp qw/ croak /;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000006,1,0.000006,my ($class, %args) = @_;
0.000000,0,0.000000,my $self = bless {
0.000000,0,0.000000,reader => $args{reader},
0.000001,1,0.000001,}, $class;
0.000003,1,0.000003,$self->init;
0.000004,1,0.000004,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub init {
0.000001,3,0.000000,my ($self) = @_;
0.000006,3,0.000002,$self->{next_tokens} = [];
0.000003,3,0.000001,$self->{next_line} = undef;
0.000001,3,0.000000,$self->{line} = 0;
0.000002,3,0.000001,$self->{offset} = 0;
0.000008,3,0.000003,$self->{flowcontext} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.056352,39438,0.000001,sub next_line { return $_[0]->{next_line} }
0.048107,26911,0.000002,sub set_next_line { $_[0]->{next_line} = $_[1] }
0.019447,13456,0.000001,sub reader { return $_[0]->{reader} }
0.000007,1,0.000007,sub set_reader { $_[0]->{reader} = $_[1] }
0.106083,77194,0.000001,sub next_tokens { return $_[0]->{next_tokens} }
0.217156,160784,0.000001,sub line { return $_[0]->{line} }
0.000000,0,0.000000,sub set_line { $_[0]->{line} = $_[1] }
0.186866,63742,0.000003,sub offset { return $_[0]->{offset} }
0.097854,63742,0.000002,sub set_offset { $_[0]->{offset} = $_[1] }
0.019470,13455,0.000001,sub inc_line { return $_[0]->{line}++ }
0.060727,37475,0.000002,sub context { return $_[0]->{context} }
0.000262,176,0.000001,sub set_context { $_[0]->{context} = $_[1] }
0.111002,76215,0.000001,sub flowcontext { return $_[0]->{flowcontext} }
0.002512,1102,0.000002,sub set_flowcontext { $_[0]->{flowcontext} = $_[1] }
0.019333,14025,0.000001,sub block { return $_[0]->{block} }
0.020769,13455,0.000002,sub set_block { $_[0]->{block} = $_[1] }
0.000000,0,0.000000,
0.000001,1,0.000001,my $RE_WS = '[\t ]';
0.000000,1,0.000000,my $RE_LB = '[\r\n]';
0.000118,1,0.000118,my $RE_DOC_END = qr/\A(\.\.\.)(?=$RE_WS|$)/m;
0.000022,1,0.000022,my $RE_DOC_START = qr/\A(---)(?=$RE_WS|$)/m;
0.000032,1,0.000032,my $RE_EOL = qr/\A($RE_WS+#.*|$RE_WS+)\z/;
0.000000,0,0.000000,#my $RE_COMMENT_EOL = qr/\A(#.*)?(?:$RE_LB|\z)/;
0.000000,0,0.000000,
0.000000,0,0.000000,#ns-word-char    ::= ns-dec-digit | ns-ascii-letter | “-”
0.000000,1,0.000000,my $RE_NS_WORD_CHAR = '[0-9A-Za-z-]';
0.000001,1,0.000001,my $RE_URI_CHAR = '(?:' . '%[0-9a-fA-F]{2}' .'|'.  q{[0-9A-Za-z#;/?:@&=+$,_.!*'\(\)\[\]-]} . ')';
0.000001,1,0.000001,my $RE_NS_TAG_CHAR = '(?:' . '%[0-9a-fA-F]{2}' .'|'.  q{[0-9A-Za-z#;/?:@&=+$_.~*'\(\)-]} . ')';
0.000000,0,0.000000,
0.000000,0,0.000000,#  [#x21-#x7E]          /* 8 bit */
0.000000,0,0.000000,# | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD] /* 16 bit */
0.000000,0,0.000000,# | [#x10000-#x10FFFF]                     /* 32 bit */
0.000000,0,0.000000,
0.000000,0,0.000000,#nb-char ::= c-printable - b-char - c-byte-order-mark
0.000000,0,0.000000,#my $RE_NB_CHAR = '[\x21-\x7E]';
0.000000,1,0.000000,my $RE_ANCHOR_CAR = '[\x21-\x2B\x2D-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
0.000000,0,0.000000,
0.000001,1,0.000001,my $RE_PLAIN_START = '[\x21\x22\x24-\x39\x3B-\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
0.000000,1,0.000000,my $RE_PLAIN_END = '[\x21-\x39\x3B-\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';
0.000000,1,0.000000,my $RE_PLAIN_FIRST = '[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
0.000000,0,0.000000,
0.000000,1,0.000000,my $RE_PLAIN_START_FLOW = '[\x21\x22\x24-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
0.000001,1,0.000001,my $RE_PLAIN_END_FLOW = '[\x21-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';
0.000000,1,0.000000,my $RE_PLAIN_FIRST_FLOW = '[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
0.000000,0,0.000000,# c-indicators
0.000000,0,0.000000,#! 21
0.000000,0,0.000000,#" 22
0.000000,0,0.000000,## 23
0.000000,0,0.000000,#% 25
0.000000,0,0.000000,#& 26
0.000000,0,0.000000,#' 27
0.000000,0,0.000000,#* 2A
0.000000,0,0.000000,#, 2C FLOW
0.000000,0,0.000000,#- 2D XX
0.000000,0,0.000000,#: 3A XX
0.000000,0,0.000000,#> 3E
0.000000,0,0.000000,#? 3F XX
0.000000,0,0.000000,#@ 40
0.000000,0,0.000000,#[ 5B FLOW
0.000000,0,0.000000,#] 5D FLOW
0.000000,0,0.000000,#` 60
0.000000,0,0.000000,#{ 7B FLOW
0.000000,0,0.000000,#| 7C
0.000000,0,0.000000,#} 7D FLOW
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000002,1,0.000002,my $RE_PLAIN_WORD = "(?::+$RE_PLAIN_END|$RE_PLAIN_START)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";
0.000000,1,0.000000,my $RE_PLAIN_FIRST_WORD = "(?:[:?-]+$RE_PLAIN_END|$RE_PLAIN_FIRST)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";
0.000003,1,0.000003,my $RE_PLAIN_WORDS = "(?:$RE_PLAIN_FIRST_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";
0.000001,1,0.000001,my $RE_PLAIN_WORDS2 = "(?:$RE_PLAIN_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";
0.000000,0,0.000000,
0.000001,1,0.000001,my $RE_PLAIN_WORD_FLOW = "(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_START_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";
0.000001,1,0.000001,my $RE_PLAIN_FIRST_WORD_FLOW = "(?:[:?-]+$RE_PLAIN_END_FLOW|$RE_PLAIN_FIRST_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";
0.000000,1,0.000000,my $RE_PLAIN_WORDS_FLOW = "(?:$RE_PLAIN_FIRST_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";
0.000002,1,0.000002,my $RE_PLAIN_WORDS_FLOW2 = "(?:$RE_PLAIN_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#c-secondary-tag-handle  ::= “!” “!”
0.000000,0,0.000000,#c-named-tag-handle  ::= “!” ns-word-char+ “!”
0.000000,0,0.000000,#ns-tag-char ::= ns-uri-char - “!” - c-flow-indicator
0.000000,0,0.000000,#ns-global-tag-prefix    ::= ns-tag-char ns-uri-char*
0.000000,0,0.000000,#c-ns-local-tag-prefix   ::= “!” ns-uri-char*
0.000001,1,0.000001,my $RE_TAG = "!(?:$RE_NS_WORD_CHAR*!$RE_NS_TAG_CHAR+|$RE_NS_TAG_CHAR+|<$RE_URI_CHAR+>|)";
0.000000,0,0.000000,
0.000000,0,0.000000,#c-ns-anchor-property    ::= “&” ns-anchor-name
0.000000,0,0.000000,#ns-char ::= nb-char - s-white
0.000000,0,0.000000,#ns-anchor-char  ::= ns-char - c-flow-indicator
0.000000,0,0.000000,#ns-anchor-name  ::= ns-anchor-char+
0.000000,0,0.000000,
0.000019,1,0.000019,my $RE_SEQSTART = qr/\A(-)(?=$RE_WS|$)/m;
0.000017,1,0.000017,my $RE_COMPLEX = qr/(\?)(?=$RE_WS|$)/m;
0.000013,1,0.000013,my $RE_COMPLEXCOLON = qr/\A(:)(?=$RE_WS|$)/m;
0.000001,1,0.000001,my $RE_ANCHOR = "&$RE_ANCHOR_CAR+";
0.000001,1,0.000001,my $RE_ALIAS = "\\*$RE_ANCHOR_CAR+";
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000238,1,0.000238,my %REGEXES = (
0.000000,0,0.000000,ANCHOR => qr{($RE_ANCHOR)},
0.000000,0,0.000000,TAG => qr{($RE_TAG)},
0.000000,0,0.000000,ALIAS => qr{($RE_ALIAS)},
0.000000,0,0.000000,SINGLEQUOTED => qr{(?:''|[^'\r\n]+)*},
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fetch_next_line {
0.004078,18497,0.000000,my ($self) = @_;
0.013512,18497,0.000001,my $next_line = $self->next_line;
0.011681,18497,0.000001,if (defined $next_line ) {
0.000000,0,0.000000,return $next_line;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.027699,13456,0.000002,my $line = $self->reader->readline;
0.003308,13456,0.000000,unless (defined $line) {
0.000001,1,0.000001,$self->set_next_line(undef);
0.000002,1,0.000002,return;
0.000000,0,0.000000,}
0.011875,13455,0.000001,$self->set_block(1);
0.011436,13455,0.000001,$self->inc_line;
0.048341,13455,0.000004,$line =~ m/\A( *)([^\r\n]*)([\r\n]|\z)/ or die "Unexpected";
0.024808,13455,0.000002,$next_line = [ $1,  $2, $3 ];
0.010982,13455,0.000001,$self->set_next_line($next_line);
0.000000,0,0.000000,# $ESCAPE_CHAR from YAML.pm
0.008377,13455,0.000001,if ($line =~ tr/\x00-\x08\x0b-\x0c\x0e-\x1f//) {
0.000000,0,0.000000,$self->exception("Control characters are not allowed");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.027929,13455,0.000002,return $next_line;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000014,1,0.000014,my %TOKEN_NAMES = (
0.000000,0,0.000000,'"' => 'DOUBLEQUOTE',
0.000000,0,0.000000,"'" => 'SINGLEQUOTE',
0.000000,0,0.000000,'|' => 'LITERAL',
0.000000,0,0.000000,'>' => 'FOLDED',
0.000000,0,0.000000,'!' => 'TAG',
0.000000,0,0.000000,'*' => 'ALIAS',
0.000000,0,0.000000,'&' => 'ANCHOR',
0.000000,0,0.000000,':' => 'COLON',
0.000000,0,0.000000,'-' => 'DASH',
0.000000,0,0.000000,'?' => 'QUESTION',
0.000000,0,0.000000,'[' => 'FLOWSEQ_START',
0.000000,0,0.000000,']' => 'FLOWSEQ_END',
0.000000,0,0.000000,'{' => 'FLOWMAP_START',
0.000000,0,0.000000,'}' => 'FLOWMAP_END',
0.000000,0,0.000000,',' => 'FLOW_COMMA',
0.000000,0,0.000000,'---' => 'DOC_START',
0.000000,0,0.000000,'...' => 'DOC_END',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetch_next_tokens {
0.003781,13451,0.000000,my ($self) = @_;
0.011319,13451,0.000001,my $next = $self->next_tokens;
0.003363,13451,0.000000,return $next if @$next;
0.000000,0,0.000000,
0.014454,13451,0.000001,my $next_line = $self->_fetch_next_line;
0.002829,13451,0.000000,if (not $next_line) {
0.000000,0,0.000000,return [];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.004976,13450,0.000000,my $spaces = $next_line->[0];
0.004631,13450,0.000000,my $yaml = \$next_line->[1];
0.004247,13450,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,$self->_push_tokens([ EOL => join('', @$next_line), $self->line ]);
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,return $next;
0.000000,0,0.000000,}
0.014150,13450,0.000001,if (substr($$yaml, 0, 1) eq '#') {
0.000000,0,0.000000,$self->_push_tokens([ EOL => join('', @$next_line), $self->line ]);
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,return $next;
0.000000,0,0.000000,}
0.003203,13450,0.000000,if (not $spaces and substr($$yaml, 0, 1) eq "%") {
0.000000,0,0.000000,$self->_fetch_next_tokens_directive($yaml, $next_line->[2]);
0.000000,0,0.000000,$self->set_context(0);
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,return $next;
0.000000,0,0.000000,}
0.021896,13450,0.000002,if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//) {
0.000000,0,0.000000,$self->_push_tokens([ $TOKEN_NAMES{ $1 } => $1, $self->line ]);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->flowcontext and $$yaml =~ m/\A[ \t]+(#.*)?\z/) {
0.000000,0,0.000000,$self->_push_tokens([ EOL => join('', @$next_line), $self->line ]);
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,return $next;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.025465,13449,0.000002,$self->_push_tokens([ SPACE => $spaces, $self->line ]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.013285,13450,0.000001,my $partial = $self->_fetch_next_tokens($next_line);
0.002081,13450,0.000000,unless ($partial) {
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,}
0.024413,13450,0.000002,return $next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,my %ANCHOR_ALIAS_TAG =    ( '&' => 1, '*' => 1, '!' => 1 );
0.000000,1,0.000000,my %BLOCK_SCALAR =        ( '|' => 1, '>' => 1 );
0.000001,1,0.000001,my %COLON_DASH_QUESTION = ( ':' => 1, '-' => 1, '?' => 1 );
0.000001,1,0.000001,my %QUOTED =              ( '"' => 1, "'" => 1 );
0.000001,1,0.000001,my %FLOW =                ( '{' => 1, '[' => 1, '}' => 1, ']' => 1, ',' => 1 );
0.000001,1,0.000001,my %CONTEXT =             ( '"' => 1, "'" => 1, '>' => 1, '|' => 1 );
0.000000,0,0.000000,
0.000009,1,0.000009,my $RE_ESCAPES = qr{(?:
0.000000,0,0.000000,\\([ \\\/_0abefnrtvLNP\t"]) | \\x([0-9a-fA-F]{2})
0.000000,0,0.000000,| \\u([A-Fa-f0-9]{4}) | \\U([A-Fa-f0-9]{4,8})
0.000000,0,0.000000,)}x;
0.000016,1,0.000016,my %CONTROL = (
0.000000,0,0.000000,'\\' => '\\', '/' => '/', n => "\n", t => "\t", r => "\r", b => "\b",
0.000000,0,0.000000,'a' => "\a", 'b' => "\b", 'e' => "\e", 'f' => "\f", 'v' => "\x0b", "\t" => "\t",
0.000000,0,0.000000,'P' => "\x{2029}", L => "\x{2028}", 'N' => "\x85",
0.000000,0,0.000000,'0' => "\0", '_' => "\xa0", ' ' => ' ', q/"/ => q/"/,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fetch_next_tokens {
0.000000,0,0.000000,TRACE and warn __PACKAGE__.':'.__LINE__.": _fetch_next_tokens\n";
0.005839,27926,0.000000,my ($self, $next_line) = @_;
0.000000,0,0.000000,
0.008338,27926,0.000000,my $yaml = \$next_line->[1];
0.005857,27926,0.000000,my $eol = $next_line->[2];
0.000000,0,0.000000,
0.003211,27926,0.000000,my @tokens;
0.000000,0,0.000000,
0.003917,27926,0.000000,while (1) {
0.007832,38004,0.000000,unless (length $$yaml) {
0.000582,529,0.000001,push @tokens, ( EOL => $eol, $self->line );
0.000439,529,0.000001,$self->_push_tokens(\@tokens);
0.001330,529,0.000003,return;
0.000000,0,0.000000,}
0.016095,37475,0.000000,my $first = substr($$yaml, 0, 1);
0.004758,37475,0.000000,my $plain = 0;
0.000000,0,0.000000,
0.026840,37475,0.000001,if ($self->context) {
0.000351,88,0.000004,if ($$yaml =~ s/\A($RE_WS*)://) {
0.000000,0,0.000000,push @tokens, ( WS => $1, $self->line ) if $1;
0.000000,0,0.000000,push @tokens, ( COLON => ':', $self->line );
0.000000,0,0.000000,$self->set_context(0);
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000377,88,0.000004,if ($$yaml =~ s/\A($RE_WS*(?: #.*))\z//) {
0.000000,0,0.000000,push @tokens, ( EOL => $1 . $eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000093,88,0.000001,$self->set_context(0);
0.000000,0,0.000000,}
0.033121,37475,0.000001,if ($CONTEXT{ $first }) {
0.003210,2057,0.000002,push @tokens, ( CONTEXT => $first, $self->line );
0.002205,2057,0.000001,$self->_push_tokens(\@tokens);
0.004965,2057,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($COLON_DASH_QUESTION{ $first }) {
0.005653,14054,0.000000,my $token_name = $TOKEN_NAMES{ $first };
0.111122,14054,0.000008,if ($$yaml =~ s/\A\Q$first\E($RE_WS+|\z)//) {
0.005924,14054,0.000000,my $after = $1;
0.022689,14054,0.000002,if (not $self->flowcontext and not $self->block) {
0.000000,0,0.000000,push @tokens, ERROR => $first . $after, $self->line;
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Tabs can not be used for indentation");
0.000000,0,0.000000,}
0.006203,14054,0.000000,if ($after =~ tr/\t//) {
0.000000,0,0.000000,$self->set_block(0);
0.000000,0,0.000000,}
0.004306,14054,0.000000,my $token_name = $TOKEN_NAMES{ $first };
0.017860,14054,0.000001,push @tokens, ( $token_name => $first, $self->line );
0.005011,14054,0.000000,if (not defined $1) {
0.000000,0,0.000000,push @tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.004464,14054,0.000000,my $ws = $1;
0.041484,14054,0.000003,if ($$yaml =~ s/\A(#.*|)\z//) {
0.013332,6456,0.000002,push @tokens, ( EOL => $ws . $1 . $eol, $self->line );
0.005179,6456,0.000001,$self->_push_tokens(\@tokens);
0.021347,6456,0.000003,return;
0.000000,0,0.000000,}
0.009993,7598,0.000001,push @tokens, ( WS => $ws, $self->line );
0.008615,7598,0.000001,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->flowcontext and $$yaml =~ s/\A:(?=[,\{\}\[\]])//) {
0.000000,0,0.000000,push @tokens, ( $token_name => $first, $self->line );
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,$plain = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($ANCHOR_ALIAS_TAG{ $first }) {
0.000000,0,0.000000,my $token_name = $TOKEN_NAMES{ $first };
0.000000,0,0.000000,my $REGEX = $REGEXES{ $token_name };
0.000000,0,0.000000,if ($$yaml =~ s/\A$REGEX//) {
0.000000,0,0.000000,push @tokens, ( $token_name => $1, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, ( "Invalid $token_name" => $$yaml, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($first eq ' ' or $first eq "\t") {
0.004713,689,0.000007,if ($$yaml =~ s/\A($RE_WS+)//) {
0.000462,689,0.000001,my $ws = $1;
0.001770,689,0.000003,if ($$yaml =~ s/\A((?:#.*)?\z)//) {
0.000000,0,0.000000,push @tokens, ( EOL => $ws . $1 . $eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.001180,689,0.000002,push @tokens, ( WS => $ws, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($FLOW{ $first }) {
0.002402,1791,0.000001,push @tokens, ( $TOKEN_NAMES{ $first } => $first, $self->line );
0.001924,1791,0.000001,substr($$yaml, 0, 1, '');
0.001313,1791,0.000001,my $flowcontext = $self->flowcontext;
0.002485,1791,0.000001,if ($first eq '{' or $first eq '[') {
0.000000,0,0.000000,$self->set_flowcontext(++$flowcontext);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($first eq '}' or $first eq ']') {
0.000000,0,0.000000,$self->set_flowcontext(--$flowcontext);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.002995,18884,0.000000,$plain = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.003920,21364,0.000000,if ($plain) {
0.017567,18884,0.000001,push @tokens, ( CONTEXT => '', $self->line );
0.013362,18884,0.000001,$self->_push_tokens(\@tokens);
0.041847,18884,0.000002,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetch_plain {
0.007503,18884,0.000000,my ($self, $indent, $context) = @_;
0.015792,18884,0.000001,my $next_line = $self->next_line;
0.007201,18884,0.000000,my $yaml = \$next_line->[1];
0.004513,18884,0.000000,my $eol = $next_line->[2];
0.004122,18884,0.000000,my $REGEX = $RE_PLAIN_WORDS;
0.011316,18884,0.000001,if ($self->flowcontext) {
0.000000,0,0.000000,$REGEX = $RE_PLAIN_WORDS_FLOW;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.003315,18884,0.000000,my @tokens;
0.307238,18884,0.000016,unless ($$yaml =~ s/\A($REGEX)//) {
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Invalid plain scalar");
0.000000,0,0.000000,}
0.012429,18884,0.000001,my $plain = $1;
0.023328,18884,0.000001,push @tokens, ( PLAIN => $plain, $self->line );
0.000000,0,0.000000,
0.100254,18884,0.000005,if ($$yaml =~ s/\A(?:($RE_WS+#.*)|($RE_WS*))\z//) {
0.003208,5040,0.000001,if (defined $1) {
0.000000,0,0.000000,push @tokens, ( EOL => $1 . $eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.008547,5040,0.000002,push @tokens, ( EOL => $2. $eol, $self->line );
0.005395,5040,0.000001,$self->set_next_line(undef);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.011703,13844,0.000001,$self->_push_tokens(\@tokens);
0.013206,13844,0.000001,my $partial = $self->_fetch_next_tokens($next_line);
0.007809,13844,0.000001,if (not $partial) {
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,}
0.044885,13844,0.000003,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001726,5040,0.000000,my $RE2 = $RE_PLAIN_WORDS2;
0.003644,5040,0.000001,if ($self->flowcontext) {
0.000000,0,0.000000,$RE2 = $RE_PLAIN_WORDS_FLOW2;
0.000000,0,0.000000,}
0.000808,5040,0.000000,my $fetch_next = 0;
0.002992,5040,0.000001,my @lines = ($plain);
0.000838,5040,0.000000,my @next;
0.000881,5040,0.000000,LOOP: while (1) {
0.008693,5040,0.000002,$next_line = $self->_fetch_next_line;
0.001105,5040,0.000000,if (not $next_line) {
0.000000,0,0.000000,last LOOP;
0.000000,0,0.000000,}
0.002419,5040,0.000000,my $spaces = $next_line->[0];
0.001993,5040,0.000000,my $yaml = \$next_line->[1];
0.001700,5040,0.000000,my $eol = $next_line->[2];
0.000000,0,0.000000,
0.001837,5040,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, ( EOL => $spaces . $eol, $self->line );
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,push @lines, '';
0.000000,0,0.000000,next LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001680,5040,0.000000,if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//) {
0.000000,0,0.000000,push @next, $TOKEN_NAMES{ $1 } => $1, $self->line;
0.000000,0,0.000000,$fetch_next = 1;
0.000000,0,0.000000,last LOOP;
0.000000,0,0.000000,}
0.003560,5040,0.000001,if ((length $spaces) < $indent) {
0.004529,5040,0.000001,last LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $ws = '';
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE_WS+)//) {
0.000000,0,0.000000,$ws = $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, ( EOL => $spaces . $ws . $eol, $self->line );
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,push @lines, '';
0.000000,0,0.000000,next LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($$yaml =~ s/\A(#.*)\z//) {
0.000000,0,0.000000,push @tokens, ( EOL => $spaces . $ws . $1 . $eol, $self->line );
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,last LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE2)//) {
0.000000,0,0.000000,push @tokens, INDENT => $spaces, $self->line;
0.000000,0,0.000000,push @tokens, WS => $ws, $self->line;
0.000000,0,0.000000,push @tokens, PLAIN => $1, $self->line;
0.000000,0,0.000000,push @lines, $1;
0.000000,0,0.000000,my $ws = '';
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE_WS+)//) {
0.000000,0,0.000000,$ws = $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, EOL => $ws . $eol, $self->line;
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,next LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($$yaml =~ s/\A(#.*)\z//) {
0.000000,0,0.000000,push @tokens, EOL => $ws . $1 . $eol, $self->line;
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,last LOOP;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, WS => $ws, $self->line if $ws;
0.000000,0,0.000000,$fetch_next = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, SPACE => $spaces, $self->line;
0.000000,0,0.000000,push @tokens, WS => $ws, $self->line;
0.000000,0,0.000000,if ($self->flowcontext) {
0.000000,0,0.000000,$fetch_next = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, ERROR => $$yaml, $self->line;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,last LOOP;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,# remove empty lines at the end
0.003553,5040,0.000001,while (@lines > 1 and $lines[-1] eq '') {
0.000000,0,0.000000,pop @lines;
0.000000,0,0.000000,}
0.005567,5040,0.000001,if (@lines > 1) {
0.000000,0,0.000000,my $value = YAML::PP::Render->render_multi_val(\@lines);
0.000000,0,0.000000,my @eol;
0.000000,0,0.000000,if ($tokens[-3] eq 'EOL') {
0.000000,0,0.000000,@eol = splice @tokens, -3;
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->push_subtokens( { name => 'PLAIN_MULTI', value => $value }, \@tokens);
0.000000,0,0.000000,$self->_push_tokens([ @eol, @next ]);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.009133,5040,0.000002,$self->_push_tokens([ @tokens, @next ]);
0.000000,0,0.000000,}
0.003982,5040,0.000001,@tokens = ();
0.001301,5040,0.000000,if ($fetch_next) {
0.000000,0,0.000000,my $partial = $self->_fetch_next_tokens($next_line);
0.000000,0,0.000000,if (not $partial) {
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.015648,5040,0.000003,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetch_block {
0.000001,1,0.000001,my ($self, $indent, $context) = @_;
0.000001,1,0.000001,my $next_line = $self->next_line;
0.000001,1,0.000001,my $yaml = \$next_line->[1];
0.000001,1,0.000001,my $eol = $next_line->[2];
0.000000,0,0.000000,
0.000000,1,0.000000,my @tokens;
0.000001,1,0.000001,my $token_name = $TOKEN_NAMES{ $context };
0.000018,1,0.000018,$$yaml =~ s/\A\Q$context\E// or die "Unexpected";
0.000001,1,0.000001,push @tokens, ( $token_name => $context, $self->line );
0.000000,1,0.000000,my $current_indent = $indent;
0.000001,1,0.000001,my $started = 0;
0.000000,1,0.000000,my $set_indent = 0;
0.000000,1,0.000000,my $chomp = '';
0.000005,1,0.000005,if ($$yaml =~ s/\A([1-9])([+-]?)//) {
0.000000,0,0.000000,push @tokens, ( BLOCK_SCALAR_INDENT => $1, $self->line );
0.000000,0,0.000000,$set_indent = $1;
0.000000,0,0.000000,$chomp = $2 if $2;
0.000000,0,0.000000,push @tokens, ( BLOCK_SCALAR_CHOMP => $2, $self->line ) if $2;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($$yaml =~ s/\A([+-])([1-9])?//) {
0.000002,1,0.000002,push @tokens, ( BLOCK_SCALAR_CHOMP => $1, $self->line );
0.000000,1,0.000000,$chomp = $1;
0.000000,1,0.000000,push @tokens, ( BLOCK_SCALAR_INDENT => $2, $self->line ) if $2;
0.000000,1,0.000000,$set_indent = $2 if $2;
0.000000,0,0.000000,}
0.000001,1,0.000001,if ($set_indent) {
0.000000,0,0.000000,$started = 1;
0.000000,0,0.000000,$indent-- if $indent > 0;
0.000000,0,0.000000,$current_indent = $indent + $set_indent;
0.000000,0,0.000000,}
0.000002,1,0.000002,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($$yaml =~ s/\A($RE_WS*(?:$RE_WS#.*|))\z//) {
0.000000,0,0.000000,push @tokens, ( EOL => $1 . $eol, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Invalid block scalar");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,1,0.000000,my @lines;
0.000000,1,0.000000,while (1) {
0.000002,6,0.000000,$self->set_next_line(undef);
0.000004,6,0.000001,$next_line = $self->_fetch_next_line;
0.000001,6,0.000000,if (not $next_line) {
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,6,0.000000,my $spaces = $next_line->[0];
0.000002,6,0.000000,my $content = $next_line->[1];
0.000001,6,0.000000,my $eol = $next_line->[2];
0.000001,6,0.000000,if (not $spaces and $content =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/) {
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000002,6,0.000000,if ((length $spaces) < $current_indent) {
0.000000,1,0.000000,if (length $content) {
0.000003,1,0.000003,if ($content =~ m/\A\t/) {
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Invalid block scalar");
0.000000,0,0.000000,}
0.000001,1,0.000001,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @lines, '';
0.000000,0,0.000000,push @tokens, ( EOL => $spaces . $eol, $self->line );
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000001,5,0.000000,if ((length $spaces) > $current_indent) {
0.000000,1,0.000000,if ($started) {
0.000000,0,0.000000,($spaces, my $more_spaces) = unpack "a${current_indent}a*", $spaces;
0.000000,0,0.000000,$content = $more_spaces . $content;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000001,5,0.000000,unless (length $content) {
0.000000,0,0.000000,push @lines, '';
0.000000,0,0.000000,push @tokens, ( INDENT => $spaces, $self->line, EOL => $eol, $self->line );
0.000000,0,0.000000,unless ($started) {
0.000000,0,0.000000,$current_indent = length $spaces;
0.000000,0,0.000000,}
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,5,0.000000,unless ($started) {
0.000000,1,0.000000,$started = 1;
0.000000,1,0.000000,$current_indent = length $spaces;
0.000000,0,0.000000,}
0.000026,5,0.000005,push @lines, $content;
0.000013,5,0.000003,push @tokens, (
0.000000,0,0.000000,INDENT => $spaces, $self->line,
0.000000,0,0.000000,BLOCK_SCALAR_CONTENT => $content, $self->line,
0.000000,0,0.000000,EOL => $eol, $self->line,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000006,1,0.000006,my $value = YAML::PP::Render->render_block_scalar($context, $chomp, \@lines);
0.000001,1,0.000001,my @eol = splice @tokens, -3;
0.000001,1,0.000001,$self->push_subtokens( { name => 'BLOCK_SCALAR', value => $value }, \@tokens );
0.000002,1,0.000002,$self->_push_tokens([ @eol ]);
0.000005,1,0.000005,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetch_quoted {
0.001261,2056,0.000001,my ($self, $indent, $context) = @_;
0.002406,2056,0.000001,my $next_line = $self->next_line;
0.001286,2056,0.000001,my $yaml = \$next_line->[1];
0.001322,2056,0.000001,my $spaces = $next_line->[0];
0.000000,0,0.000000,
0.001307,2056,0.000001,my $token_name = $TOKEN_NAMES{ $context };
0.015116,2056,0.000007,$$yaml =~ s/\A\Q$context// or die "Unexpected";;
0.004015,2056,0.000002,my @tokens = ( $token_name => $context, $self->line );
0.000000,0,0.000000,
0.000535,2056,0.000000,my $start = 1;
0.000530,2056,0.000000,my @values;
0.000471,2056,0.000000,while (1) {
0.000000,0,0.000000,
0.000530,2056,0.000000,unless ($start) {
0.000000,0,0.000000,$next_line = $self->_fetch_next_line or do {
0.000000,0,0.000000,for (my $i = 0; $i < @tokens; $i+= 3) {
0.000000,0,0.000000,my $token = $tokens[ $i + 1 ];
0.000000,0,0.000000,if (ref $token) {
0.000000,0,0.000000,$tokens[ $i + 1 ] = $token->{orig};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Missing closing quote <$context> at EOF");
0.000000,0,0.000000,};
0.000000,0,0.000000,$start = 0;
0.000000,0,0.000000,$spaces = $next_line->[0];
0.000000,0,0.000000,$yaml = \$next_line->[1];
0.000000,0,0.000000,
0.000000,0,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, ( EOL => $spaces . $next_line->[2], $self->line );
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,push @values, { value => '', orig => '' };
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (not $spaces and $$yaml =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/) {
0.000000,0,0.000000,for (my $i = 0; $i < @tokens; $i+= 3) {
0.000000,0,0.000000,my $token = $tokens[ $i + 1 ];
0.000000,0,0.000000,if (ref $token) {
0.000000,0,0.000000,$tokens[ $i + 1 ] = $token->{orig};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Missing closing quote <$context> or invalid document marker");
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ((length $spaces) < $indent) {
0.000000,0,0.000000,for (my $i = 0; $i < @tokens; $i+= 3) {
0.000000,0,0.000000,my $token = $tokens[ $i + 1 ];
0.000000,0,0.000000,if (ref $token) {
0.000000,0,0.000000,$tokens[ $i + 1 ] = $token->{orig};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,$self->exception("Wrong indendation or missing closing quote <$context>");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE_WS+)//) {
0.000000,0,0.000000,$spaces .= $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,push @tokens, ( WS => $spaces, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.004718,2056,0.000002,my $v = $self->_read_quoted_tokens($start, $context, $yaml, \@tokens);
0.000589,2056,0.000000,push @values, $v;
0.000992,2056,0.000000,if ($tokens[-3] eq $token_name) {
0.007028,2056,0.000003,if ($start) {
0.000000,0,0.000000,$self->push_subtokens(
0.000000,0,0.000000,{ name => 'QUOTED', value => $v->{value} }, \@tokens
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $value = YAML::PP::Render->render_quoted($context, \@values);
0.000000,0,0.000000,$self->push_subtokens(
0.000000,0,0.000000,{ name => 'QUOTED_MULTILINE', value => $value }, \@tokens
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.002042,2056,0.000001,$self->set_context(1) if $self->flowcontext;
0.000701,2056,0.000000,if (length $$yaml) {
0.000740,632,0.000001,my $partial = $self->_fetch_next_tokens($next_line);
0.000694,632,0.000001,if (not $partial) {
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,}
0.003496,632,0.000006,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.001417,1424,0.000001,@tokens = ();
0.002069,1424,0.000001,push @tokens, ( EOL => $next_line->[2], $self->line );
0.001239,1424,0.000001,$self->_push_tokens(\@tokens);
0.001387,1424,0.000001,$self->set_next_line(undef);
0.006800,1424,0.000005,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$tokens[-2] .= $next_line->[2];
0.000000,0,0.000000,$self->set_next_line(undef);
0.000000,0,0.000000,$start = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _read_quoted_tokens {
0.001142,2056,0.000001,my ($self, $start, $first, $yaml, $tokens) = @_;
0.000955,2056,0.000000,my $quoted = '';
0.000746,2056,0.000000,my $decoded = '';
0.001024,2056,0.000000,my $token_name = $TOKEN_NAMES{ $first };
0.000563,2056,0.000000,my $eol = '';
0.001503,2056,0.000001,if ($first eq "'") {
0.001244,2056,0.000001,my $regex = $REGEXES{SINGLEQUOTED};
0.015665,2056,0.000008,if ($$yaml =~ s/\A($regex)//) {
0.003100,2056,0.000002,$quoted .= $1;
0.001137,2056,0.000001,$decoded .= $1;
0.004104,2056,0.000002,$decoded =~ s/''/'/g;
0.000000,0,0.000000,}
0.001605,2056,0.000001,unless (length $$yaml) {
0.000000,0,0.000000,if ($quoted =~ s/($RE_WS+)\z//) {
0.000000,0,0.000000,$eol = $1;
0.000000,0,0.000000,$decoded =~ s/($eol)\z//;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,($quoted, $decoded, $eol) = $self->_read_doublequoted($yaml);
0.000000,0,0.000000,}
0.003853,2056,0.000002,my $value = { value => $decoded, orig => $quoted };
0.000000,0,0.000000,
0.008997,2056,0.000004,if ($$yaml =~ s/\A$first//) {
0.003878,2056,0.000002,if ($start) {
0.000000,0,0.000000,push @$tokens, ( $token_name . 'D' => $value, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @$tokens, ( $token_name . 'D_LINE' => $value, $self->line );
0.000000,0,0.000000,}
0.002433,2056,0.000001,push @$tokens, ( $token_name => $first, $self->line );
0.006025,2056,0.000003,return $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (length $$yaml) {
0.000000,0,0.000000,push @$tokens, ( $token_name . 'D' => $value->{orig}, $self->line );
0.000000,0,0.000000,$self->_push_tokens($tokens);
0.000000,0,0.000000,$self->exception("Invalid quoted <$first> string");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @$tokens, ( $token_name . 'D_LINE' => $value, $self->line );
0.000000,0,0.000000,push @$tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,
0.000000,0,0.000000,return $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _read_doublequoted {
0.000000,0,0.000000,my ($self, $yaml) = @_;
0.000000,0,0.000000,my $quoted = '';
0.000000,0,0.000000,my $decoded = '';
0.000000,0,0.000000,my $eol = '';
0.000000,0,0.000000,while (1) {
0.000000,0,0.000000,my $last = 1;
0.000000,0,0.000000,if ($$yaml =~ s/\A([^"\\ \t]+)//) {
0.000000,0,0.000000,$quoted .= $1;
0.000000,0,0.000000,$decoded .= $1;
0.000000,0,0.000000,$last = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE_ESCAPES)//) {
0.000000,0,0.000000,$quoted .= $1;
0.000000,0,0.000000,my $dec = defined $2 ? $CONTROL{ $2 }
0.000000,0,0.000000,: defined $3 ? chr hex $3
0.000000,0,0.000000,: defined $4 ? chr hex $4
0.000000,0,0.000000,: chr hex $5;
0.000000,0,0.000000,$decoded .= $dec;
0.000000,0,0.000000,$last = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($$yaml =~ s/\A([ \t]+)//) {
0.000000,0,0.000000,my $spaces = $1;
0.000000,0,0.000000,if (length $$yaml) {
0.000000,0,0.000000,$quoted .= $spaces;
0.000000,0,0.000000,$decoded .= $spaces;
0.000000,0,0.000000,$last = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$eol = $spaces;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($$yaml =~ s/\A(\\)\z//) {
0.000000,0,0.000000,$quoted .= $1;
0.000000,0,0.000000,$decoded .= $1;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if $last;
0.000000,0,0.000000,}
0.000000,0,0.000000,return ($quoted, $decoded, $eol);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fetch_next_tokens_directive {
0.000000,0,0.000000,my ($self, $yaml, $eol) = @_;
0.000000,0,0.000000,my @tokens;
0.000000,0,0.000000,
0.000000,0,0.000000,my $trailing_ws = '';
0.000000,0,0.000000,my $warn = $ENV{YAML_PP_RESERVED_DIRECTIVE} || 'warn';
0.000000,0,0.000000,if ($$yaml =~ s/\A(\s*%YAML[ \t]+([0-9]+\.[0-9]+))//) {
0.000000,0,0.000000,my $dir = $1;
0.000000,0,0.000000,my $version = $2;
0.000000,0,0.000000,if ($$yaml =~ s/\A($RE_WS+)//) {
0.000000,0,0.000000,$trailing_ws = $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (length $$yaml) {
0.000000,0,0.000000,push @tokens, ( 'Invalid directive' => $dir.$$yaml.$eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($version !~ m/^1\.[12]$/) {
0.000000,0,0.000000,if ($warn eq 'warn') {
0.000000,0,0.000000,warn "Unsupported YAML version '$dir'";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($warn eq 'fatal') {
0.000000,0,0.000000,push @tokens, ( 'Unsupported YAML version' => $dir, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,push @tokens, ( YAML_DIRECTIVE => $dir, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($$yaml =~ s/\A(\s*%TAG[ \t]+(!$RE_NS_WORD_CHAR*!|!)[ \t]+(tag:\S+|!$RE_URI_CHAR+))($RE_WS*)//) {
0.000000,0,0.000000,push @tokens, ( TAG_DIRECTIVE => $1, $self->line );
0.000000,0,0.000000,# TODO
0.000000,0,0.000000,my $tag_alias = $2;
0.000000,0,0.000000,my $tag_url = $3;
0.000000,0,0.000000,$trailing_ws = $4;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($$yaml =~ s/\A(\s*\A%(?:\w+).*)//) {
0.000000,0,0.000000,push @tokens, ( RESERVED_DIRECTIVE => $1, $self->line );
0.000000,0,0.000000,if ($warn eq 'warn') {
0.000000,0,0.000000,warn "Found reserved directive '$1'";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($warn eq 'fatal') {
0.000000,0,0.000000,die "Found reserved directive '$1'";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, ( 'Invalid directive' => $$yaml, $self->line );
0.000000,0,0.000000,push @tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (not length $$yaml) {
0.000000,0,0.000000,push @tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($trailing_ws and $$yaml =~ s/\A(#.*)?\z//) {
0.000000,0,0.000000,push @tokens, ( EOL => "$trailing_ws$1$eol", $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($$yaml =~ s/\A([ \t]+#.*)?\z//) {
0.000000,0,0.000000,push @tokens, ( EOL => "$1$eol", $self->line );
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @tokens, ( 'Invalid directive' => $trailing_ws.$$yaml, $self->line );
0.000000,0,0.000000,push @tokens, ( EOL => $eol, $self->line );
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->_push_tokens(\@tokens);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _push_tokens {
0.012947,61685,0.000000,my ($self, $new_tokens) = @_;
0.042206,61685,0.000001,my $next = $self->next_tokens;
0.035835,61685,0.000001,my $line = $self->line;
0.038115,61685,0.000001,my $column = $self->offset;
0.000000,0,0.000000,
0.067536,61685,0.000001,for (my $i = 0; $i < @$new_tokens; $i += 3) {
0.036066,90857,0.000000,my $value = $new_tokens->[ $i + 1 ];
0.021356,90857,0.000000,my $name = $new_tokens->[ $i ];
0.016350,90857,0.000000,my $line = $new_tokens->[ $i + 2 ];
0.115077,90857,0.000001,my $push = {
0.000000,0,0.000000,name => $name,
0.000000,0,0.000000,line => $line,
0.000000,0,0.000000,column => $column,
0.000000,0,0.000000,value => $value,
0.000000,0,0.000000,};
0.031709,90857,0.000000,$column += length $value unless $name eq 'CONTEXT';
0.015633,90857,0.000000,push @$next, $push;
0.034408,90857,0.000000,if ($name eq 'EOL') {
0.000000,0,0.000000,$column = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.043782,61685,0.000001,$self->set_offset($column);
0.105073,61685,0.000002,return $next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub push_subtokens {
0.000634,2057,0.000000,my ($self, $token, $subtokens) = @_;
0.002132,2057,0.000001,my $next = $self->next_tokens;
0.001418,2057,0.000001,my $line = $self->line;
0.001772,2057,0.000001,my $column = $self->offset;
0.001029,2057,0.000001,$token->{column} = $column;
0.001484,2057,0.000001,$token->{subtokens} = \my @sub;
0.000000,0,0.000000,
0.004431,2057,0.000002,for (my $i = 0; $i < @$subtokens; $i+=3) {
0.001572,6185,0.000000,my $name = $subtokens->[ $i ];
0.003466,6185,0.000001,my $value = $subtokens->[ $i + 1 ];
0.001599,6185,0.000000,my $line = $subtokens->[ $i + 2 ];
0.006739,6185,0.000001,my $push = {
0.000000,0,0.000000,name => $subtokens->[ $i ],
0.000000,0,0.000000,line => $line,
0.000000,0,0.000000,column => $column,
0.000000,0,0.000000,};
0.002603,6185,0.000000,if (ref $value eq 'HASH') {
0.007368,2056,0.000004,%$push = ( %$push, %$value );
0.001639,2056,0.000001,$column += length $value->{orig};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.002308,4129,0.000001,$push->{value} = $value;
0.000887,4129,0.000000,$column += length $value;
0.000000,0,0.000000,}
0.002083,6185,0.000000,if ($push->{name} eq 'EOL') {
0.000000,0,0.000000,$column = 0;
0.000000,0,0.000000,}
0.002276,6185,0.000000,push @sub, $push;
0.000000,0,0.000000,}
0.001037,2057,0.000001,$token->{line} = $sub[0]->{line};
0.000795,2057,0.000000,push @$next, $token;
0.002470,2057,0.000001,$self->set_offset($column);
0.003983,2057,0.000002,return $next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub exception {
0.000000,0,0.000000,my ($self, $msg) = @_;
0.000000,0,0.000000,my $next = $self->next_tokens;
0.000000,0,0.000000,$next = [];
0.000000,0,0.000000,my $line = @$next ? $next->[0]->{line} : $self->line;
0.000000,0,0.000000,my @caller = caller(0);
0.000000,0,0.000000,my $yaml = '';
0.000000,0,0.000000,if (my $nl = $self->next_line) {
0.000000,0,0.000000,$yaml = join '', @$nl;
0.000000,0,0.000000,$yaml = $nl->[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,my $e = YAML::PP::Exception->new(
0.000000,0,0.000000,line => $line,
0.000000,0,0.000000,column => $self->offset + 1,
0.000000,0,0.000000,msg => $msg,
0.000000,0,0.000000,next => $next,
0.000000,0,0.000000,where => $caller[1] . ' line ' . $caller[2],
0.000000,0,0.000000,yaml => $yaml,
0.000000,0,0.000000,);
0.000000,0,0.000000,croak $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000109,1,0.000109,1;
