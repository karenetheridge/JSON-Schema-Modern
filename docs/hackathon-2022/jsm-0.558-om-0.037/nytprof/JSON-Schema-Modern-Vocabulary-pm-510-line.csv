# Profile data generated by Devel::NYTProf::Reader
# Version: v6.12
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000039,2,0.000019,use strict;
0.000055,2,0.000028,use warnings;
0.000000,0,0.000000,package JSON::Schema::Modern::Vocabulary;
0.000000,0,0.000000,# vim: set ts=8 sts=2 sw=2 tw=100 et :
0.000000,0,0.000000,# ABSTRACT: Base role for JSON Schema vocabulary classes
0.000000,0,0.000000,
0.000000,1,0.000000,our $VERSION = '0.558';
0.000000,0,0.000000,
0.000041,2,0.000021,use 5.020;
0.000389,2,0.000194,use Moo::Role;
0.000129,3,0.000043,use strictures 2;
0.000054,2,0.000027,use experimental qw(signatures postderef);
0.000040,2,0.000020,use if "$]" >= 5.022, experimental => 're_strict';
0.000041,2,0.000021,no if "$]" >= 5.031009, feature => 'indirect';
0.000021,2,0.000011,no if "$]" >= 5.033001, feature => 'multidimensional';
0.000051,2,0.000025,no if "$]" >= 5.033006, feature => 'bareword_filehandles';
0.000036,3,0.000012,use Ref::Util 0.100 'is_plain_arrayref';
0.000014,2,0.000007,use JSON::Schema::Modern::Utilities qw(jsonp assert_keyword_type abort);
0.000045,2,0.000022,use Carp ();
0.000847,2,0.000423,use namespace::clean;
0.000000,0,0.000000,
0.000001,1,0.000001,our @CARP_NOT = qw(JSON::Schema::Modern);
0.000000,0,0.000000,
0.000001,1,0.000001,requires qw(vocabulary keywords);
0.000000,0,0.000000,
0.000004,3,0.000001,sub evaluation_order { 999 }  # override, if needed
0.000000,0,0.000000,
0.000000,0,0.000000,sub traverse ($self, $schema, $state) {
0.000000,0,0.000000,$state->{evaluator}->_traverse_subschema($schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000337,2248,0.000000,sub traverse_subschema ($self, $schema, $state) {
0.000000,0,0.000000,$state->{evaluator}->_traverse_subschema($schema->{$state->{keyword}},
0.004164,562,0.000007,+{ %$state, schema_path => $state->{schema_path}.'/'.$state->{keyword} });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000112,304,0.000000,sub traverse_array_schemas ($self, $schema, $state) {
0.000082,76,0.000001,return if not assert_keyword_type($state, $schema, 'array');
0.000081,76,0.000001,return E($state, '%s array is empty', $state->{keyword}) if not $schema->{$state->{keyword}}->@*;
0.000000,0,0.000000,
0.000011,76,0.000000,my $valid = 1;
0.000194,76,0.000003,foreach my $idx (0 .. $schema->{$state->{keyword}}->$#*) {
0.000000,0,0.000000,$valid = 0 if not $state->{evaluator}->_traverse_subschema($schema->{$state->{keyword}}[$idx],
0.001399,203,0.000007,+{ %$state, schema_path => $state->{schema_path}.'/'.$state->{keyword}.'/'.$idx });
0.000000,0,0.000000,}
0.000159,76,0.000002,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000280,1608,0.000000,sub traverse_object_schemas ($self, $schema, $state) {
0.000511,402,0.000001,return if not assert_keyword_type($state, $schema, 'object');
0.000000,0,0.000000,
0.000121,402,0.000000,my $valid = 1;
0.002953,402,0.000007,foreach my $property (sort keys $schema->{$state->{keyword}}->%*) {
0.000000,0,0.000000,$valid = 0 if not $state->{evaluator}->_traverse_subschema($schema->{$state->{keyword}}{$property},
0.011207,1349,0.000008,+{ %$state, schema_path => jsonp($state->{schema_path}, $state->{keyword}, $property) });
0.000000,0,0.000000,}
0.000932,402,0.000002,return $valid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,30,0.000000,sub traverse_property_schema ($self, $schema, $state, $property) {
0.000007,6,0.000001,return if not assert_keyword_type($state, $schema, 'object');
0.000000,0,0.000000,
0.000000,0,0.000000,$state->{evaluator}->_traverse_subschema($schema->{$state->{keyword}}{$property},
0.000042,6,0.000007,+{ %$state, schema_path => jsonp($state->{schema_path}, $state->{keyword}, $property) });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.082954,249435,0.000000,sub eval ($self, $data, $schema, $state) {
0.234636,49887,0.000005,$state->{evaluator}->_eval_subschema($data, $schema, $state);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.052949,250242,0.000000,sub eval_subschema_at_uri ($self, $data, $schema, $state, $uri) {
0.113522,41707,0.000003,my $schema_info = $state->{evaluator}->_fetch_from_uri($uri);
0.012833,41707,0.000000,abort($state, 'EXCEPTION: unable to find resource %s', $uri) if not $schema_info;
0.000000,0,0.000000,
0.000000,0,0.000000,return $state->{evaluator}->_eval_subschema($data, $schema_info->{schema},
0.000000,0,0.000000,+{
0.000000,0,0.000000,$schema_info->{configs}->%*,
0.000000,0,0.000000,%$state,
0.000000,0,0.000000,traversed_schema_path => $state->{traversed_schema_path}.$state->{schema_path}
0.000000,0,0.000000,.jsonp('', $state->{keyword}, exists $state->{_schema_path_suffix}
0.000000,0,0.000000,? (is_plain_arrayref($state->{_schema_path_suffix}) ? $state->{_schema_path_suffix}->@* : $state->{_schema_path_suffix})
0.000000,0,0.000000,: ()),
0.000000,0,0.000000,initial_schema_uri => $schema_info->{canonical_uri},
0.000000,0,0.000000,document => $schema_info->{document},
0.000000,0,0.000000,document_path => $schema_info->{document_path},
0.000000,0,0.000000,spec_version => $schema_info->{specification_version},
0.000000,0,0.000000,schema_path => '',
0.000000,0,0.000000,vocabularies => $schema_info->{vocabularies}, # reference, not copy
0.947951,41707,0.000023,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,
0.000021,1,0.000021,__END__
